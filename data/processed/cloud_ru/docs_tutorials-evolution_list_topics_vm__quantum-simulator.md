---
source_image: docs_tutorials-evolution_list_topics_vm__quantum-simulator.jpg
page_number: 0
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 230.91
tokens: 12442
characters: 7987
timestamp: 2025-12-24T06:35:18.488776
finish_reason: stop
---

### Решение задач с помощью квантового симулятора

С помощью этого руководства вы научитесь решать задачу с применением алгоритма имитации отжига, получите результаты решений и интерпретируйте их. Для решения используется образ виртуальной машины «Квантовый симулятор» на мощностях CPU и предустановленный в образе сэмплер D-Wave.

«Квантовый симулятор» — это усовершенствованная реализация алгоритма имитации отжига. Симулятор предназначен для решения задач в постановке матрицы Quadratic Unconstrained Binary Optimization (QUBO). С его помощью вы можете решать сложные оптимизационные задачи, например: оптимизировать маршруты, логистические процессы, энергопотребление, планирование производственных процессов.

Вы будете использовать следующие сервисы:

• Виртуальные машины — сервис, в рамках которого предоставляется виртуальная машина для развертывания симулятора.
• Публичный IP-адрес для доступа к виртуальной машине через интернет.
• Jupyter Server — серверное приложение, позволяющее запускать командные графические оболочки для интерактивных вычислений Jupyter Notebook и JupyterLab.

Шаги:

1. Разверните ресурсы в облаке.
2. Подключитесь к Jupyter Server.
3. Создайте матрицу.
4. Запустите сэмплер.
5. Выберите решение.

Перед началом работы

1. Зарегистрируйтесь в личном кабинете Cloud.ru.
   Если вы уже зарегистрированы, войдите под своей учетной записью.
2. Убедитесь, что для вашей учетной записи достаточно прав на проект. При необходимости настройте права или запросите их у администратора.
3. Запросите в технической поддержке пароль для квантового симулятора.

1. Разверните ресурсы в облаке

1. Создайте виртуальную машину со следующими параметрами:
   • Название — quantum-server .
   • Зона доступности — ru.AZ-1 .
   • Образ — на вкладке Маркетплейс выберите «Квантовый симулятор».
   • Гарантированная доля vCPU — 30%.
   • vCPU, шт — 2.
   • RAM, ГБ: — 4.
   • Сетевой интерфейс — выберите тип Подсеть с публичным IP .
   • Публичный IP — оставьте Арендовать новый или выберите IP-адрес из списка арендованных.
   • Имя пользователя — cloud-user .
   • Метод аутентификации — Пароль .
   • Пароль — задайте пароль пользователя.
   На виртуальной машине будет развернут Jupyter Server для работы с jupyter-ноутбуками.
2. В строке созданной ВМ скопируйте и сохраните адрес из столбца Публичный IP: он потребуется для дальнейшей настройки.
3. Добавьте правило входящего трафика в группу безопасности SSH-access_ru.AZ-1 :

<table>
  <tr>
    <th>Протокол</th>
    <th>Порт</th>
    <th>Тип источника</th>
    <th>Источник</th>
  </tr>
  <tr>
    <td>TCP</td>
    <td>8888</td>
    <td>IP-адрес</td>
    <td>0.0.0.0/0</td>
  </tr>
</table>

2. Подключитесь к Jupyter Server

Jupyter Server станет доступен через 5–7 минут после запуска виртуальной машины.

1. В браузере перейдите по адресу https://<public_ip>:8888 , где <public_ip> — публичный IP-адрес ВМ quantum-server .
   Если появится предупреждение о том, что подключение не защищено, добавьте сертификат сайта в доверенные по инструкции для вашего браузера.
2. В поле Password введите пароль, полученный в технической поддержке Cloud.ru.
3. Нажмите Log in.
   Откроется страница с файлами симулятора.
4. Смените пароль Jupyter Server:
   a. Откройте терминал: на верхней панели нажмите File → New → Terminal.
   b. В терминале введите команду:
      jupyter notebook password
   c. Дважды введите новый пароль.
5. Создайте новый ноутбук:
   a. На верхней панели нажмите File → New → Notebook.
   b. В открывшемся окне выберите ядро Python 3.

3. Создайте матрицу

1. Импортируйте в проект библиотеки. Вставьте в ячейку ноутбука указанный ниже код и нажмите Shift + Enter .

import numpy as np
from dwave.samplers import SimulatedAnnealingSampler
import matplotlib.pyplot as plt

Где:
• numpy — библиотека для работы с массивами данных.
• dwave.samplers — пакет с сэмплером D-Wave, в котором доступно несколько алгоритмов решения.
• SimulatedAnnealingSampler — алгоритм имитации отжига из пакета D-Wave.
• matplotlib — библиотека для визуализации.

2. Создайте матрицу со случайными значениями:

N = 10
M = 10
Q = np.random.uniform(low=-M, high=M, size=(N, N))

Где:
• N — размер матрицы;
• M — диапазон значений;
• Q — объект матрицы.

3. Чтобы убедиться, что матрица случайная, получите ее изображение:

plt.matshow(Q)

![Матрица случайных чисел](https://example.com/matrix.png)

4. Запустите сэмплер

1. Запустите сэмплер D-Wave:

sampler = SimulatedAnnealingSampler()
num_reads = 10
num_sweeps = 10**3
beta_range = [0.1, 4.2]
beta_schedule_type = 'geometric'
sample_set = sampler.sample_qubo(Q, num_reads=num_reads, num_sweeps=num_sweeps, beta_range=beta_range)

Где:
• sampler — объект решателя.
• num_reads — количество запусков алгоритма.
• num_sweeps — максимальное количество итераций алгоритма.
• beta_range — расписание отжига, последовательность обратных температуры величин.
• beta_schedule_type — тип интерполяции между точками.

2. Получите результаты:

print(sample_set)

В результате отобразится таблица:

<table>
  <tr>
    <th>n</th>
    <th>E</th>
    <th>x</th>
    <th>energy</th>
    <th>num_oc.</th>
  </tr>
  <tr>
    <td>0</td>
    <td>1</td>
    <td>1</td>
    <td>0</td>
    <td>0</td>
    <td>-50.046614</td>
    <td>1</td>
  </tr>
  <tr>
    <td>1</td>
    <td>1</td>
    <td>1</td>
    <td>0</td>
    <td>0</td>
    <td>-50.046614</td>
    <td>1</td>
  </tr>
  <tr>
    <td>2</td>
    <td>1</td>
    <td>1</td>
    <td>0</td>
    <td>0</td>
    <td>-50.046614</td>
    <td>1</td>
  </tr>
  <tr>
    <td>3</td>
    <td>1</td>
    <td>1</td>
    <td>0</td>
    <td>0</td>
    <td>-50.046614</td>
    <td>1</td>
  </tr>
  <tr>
    <td>4</td>
    <td>1</td>
    <td>1</td>
    <td>0</td>
    <td>0</td>
    <td>-50.046614</td>
    <td>1</td>
  </tr>
  <tr>
    <td>5</td>
    <td>1</td>
    <td>1</td>
    <td>0</td>
    <td>0</td>
    <td>-50.046614</td>
    <td>1</td>
  </tr>
  <tr>
    <td>6</td>
    <td>1</td>
    <td>1</td>
    <td>0</td>
    <td>0</td>
    <td>-50.046614</td>
    <td>1</td>
  </tr>
  <tr>
    <td>7</td>
    <td>1</td>
    <td>1</td>
    <td>0</td>
    <td>0</td>
    <td>-50.046614</td>
    <td>1</td>
  </tr>
  <tr>
    <td>8</td>
    <td>1</td>
    <td>1</td>
    <td>0</td>
    <td>0</td>
    <td>-50.046614</td>
    <td>1</td>
  </tr>
  <tr>
    <td>9</td>
    <td>1</td>
    <td>1</td>
    <td>0</td>
    <td>0</td>
    <td>-50.046614</td>
    <td>1</td>
  </tr>
  <tr>
    <td>10</td>
    <td>1</td>
    <td>1</td>
    <td>0</td>
    <td>0</td>
    <td>-50.046614</td>
    <td>1</td>
  </tr>
</table>

Где:
• Столбцы от 0 до 9 показывают полученные решения. Каждое число в строке, 0 или 1, соответствует одной из переменных в векторе решения.
• Столбец energy показывает значение функции \( E(x) \). Это число указывает, насколько эффективно решение с точки зрения достижения минимального значения функции — чем меньше число, тем лучше.
• Столбец num_oc показывает, сколько раз конкретное решение было найдено.

Каждая строка в таблице представляет одну попытку решения задачи.

5. Выберите решение

Выберите решение одним из двух методов:

• Чтобы получить конкретное решение, используйте метод record , отправив команду:

n = 9
E = sample_set.record[n][1]
x = sample_set.record[n][0]
print("Energy is ",E)
print("Solution is ",x)

Где:
• n — номер решения.
• E — значение энергии, связанное с решением.
• x — бинарный вектор, представляющий решение.

В результате отобразятся значения выбранного решения:

Energy is -50.046614387554584
Solution is [1 1 1 0 1 0 0 0 0]

• Чтобы получить эффективное решение, используйте метод first , отправив команду:

x = sample_set.first()
print("Energy is ",E)
print("Solution is ",x)

В результате отобразятся значения эффективного решения с точки зрения достижения минимального значения функции:

Energy is -50.046614387554584
Solution is [0: 1; 1: 1; 2: 1; 3: 0; 4: 1; 5: 0; 6: 0; 7: 0; 8: 0; 9: 1]

Результат

Вы научились применять алгоритм имитации отжига для решения задач в постановке матрицы QUBO.