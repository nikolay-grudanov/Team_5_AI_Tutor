---
source_image: page_293.png
page_number: 293
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 31.00
tokens: 7586
characters: 2120
timestamp: 2025-12-24T03:08:37.149459
finish_reason: stop
---

<table>
  <tr>
    <th colspan="2">Облако</th>
  </tr>
  <tr>
    <th>Операционная система</th>
    <th>Операционная система</th>
  </tr>
  <tr>
    <td>Многопроцессная обработка</td>
    <td>Контейнер</td>
    <td>Многопроцессная обработка</td>
    <td>Контейнер</td>
  </tr>
  <tr>
    <th colspan="4">Ядра</th>
  </tr>
</table>

Рис. 9.9. Параллельное выполнение кода на Python

Аналогично у контейнера также много преимуществ по сравнению с ветвлением процессов вручную. Определения контейнеров представляют собой код. Можно выбирать объемы используемых контейнерами ресурсов в разрезе оперативной памяти, CPU и дисковых операций ввода/вывода. Они представляют собой прямую альтернативу и зачастую лучшую замену ветвлению процессов вручную. Кроме того, на практике они гораздо легче укладываются в мировоззрение DevOps.

С точки зрения DevOps, если вы осознали, что конкурентности в Python желательно избегать при малейшей возможности, даже сценарии использования модуля multiprocessing довольно ограничены. Возможно, лучше задействовать библиотеку multiprocessing только для разработки и проведения экспериментов, поскольку существуют значительно лучшие варианты на уровне как контейнеров, так и облачных сервисов.

Можно сформулировать это и по-другому. Просто задумайтесь, кому вы доверяете создавать ветви процессов: написанному вами на Python многопроцессному коду, Kubernetes, созданному разработчиками Google, или AWS Lambda, созданному разработчиками Amazon? По нашему опыту, лучше всего стоять на плечах гигантов. Разобравшись с этим философским вопросом, обсудим несколько способов эффективной мультипроцессной обработки.

Ветвление процессов с помощью Pool()

Простейший способ проверить возможности ветвления процессов и выполнения в них функции — расчет кластеризации методом k-средних с помощью библиотеки машинного обучения sklearn. Кластеризация методом k-средних требует большого объема вычислений и характеризуется временной сложностью алгоритма \( O(n^{**2}) \), то есть объем вычислений растет экспоненциально быстрее при росте объемов данных. Этот пример прекрасно подходит для распараллеливания