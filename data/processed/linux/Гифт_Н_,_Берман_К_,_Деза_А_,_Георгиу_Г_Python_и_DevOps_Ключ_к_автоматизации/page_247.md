---
source_image: page_247.png
page_number: 247
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 26.54
tokens: 7495
characters: 2304
timestamp: 2025-12-24T03:07:22.314145
finish_reason: stop
---

и вспомогательные функции можно описать в том же файле, что и тест, они будут вести себя точно так же.

Единственное условие для загрузки файла conftest.py: он должен находиться в каталоге tests и называться именно так. Кроме того, хотя название можно менять в настройках, мы не рекомендуем это делать и советуем вам во избежание возможных проблем придерживаться принятых по умолчанию соглашений о наименованиях.

Этот замечательный оператор assert

Когда мы хотим рассказать о том, насколько замечателен инструментарий pytest, то начинаем с важнейших вариантов использования оператора assert. «За кулисами» фреймворк pytest просматривает объекты и предоставляет механизм сравнения, чтобы лучше описать ошибки. Разработчики обычно не хотят задействовать эти возможности, поскольку простой оператор assert в Python очень плохо описывает ошибки. Сравним для примера две длинные строки:

>>> assert "using assert for errors" == "using asert for errors"
Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
AssertionError

Чем они различаются? Трудно ответить на этот вопрос, если долго в них не всматриваться. Поэтому многие и не рекомендуют его использовать. Маленький тест демонстрирует, насколько иначе сообщает об ошибках pytest:

$ (testing) pytest test_long_lines.py
============================= test session starts ==============================
platform linux -- Python 3.6.8, pytest-4.4.1, py-1.8.0, pluggy-0.9.0
collected 1 item
test_long_lines.py F                                                                 [100%]
============================= FAILURES ================================
_________________________ test_long_lines ___________________________
    def test_long_lines():
>         assert "using assert for errors" == "using asert for errors"
E     AssertionError: assert '...rt for errors' == '...rt for errors'
E         - using assert for errors
E         ?                -
E         + using asert for errors
test_long_lines.py:2: AssertionError
============================= 1 failed in 0.04 seconds =====================

Можете ли вы теперь сказать, в чем различие? Намного легче. pytest не только сообщает, что контроль не пройден, но и указывает точно, где найдено расхождение. Этот пример — всего лишь простой оператор контроля для длинных строк,