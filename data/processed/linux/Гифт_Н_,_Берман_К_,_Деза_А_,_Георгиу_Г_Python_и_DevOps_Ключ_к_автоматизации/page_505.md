---
source_image: page_505.png
page_number: 505
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 32.75
tokens: 7650
characters: 2433
timestamp: 2025-12-24T03:14:07.821660
finish_reason: stop
---

Сценарии Python, запуск которых требует 60 секунд

Работа в одной из крупнейших кинокомпаний мира с мощнейшими в мире суперкомпьютерами — прекрасный способ посмотреть на происходящее в больших масштабах. Одна из самых острых проблем программного обеспечения с открытым исходным кодом — то, что его сборка возможна на ноутбуке в отрыве от нужд крупной компании. Разработчик при этом пытается решить конкретную задачу. С одной стороны, его решение изящно, с другой же — приводит к возникновению проблемы.

Одна из таких проблем Python и проявилась в этой кинокомпании, поскольку им приходилось обрабатывать петабайты данных на централизованном файловом сервере. Сценарии Python были своего рода валютой этой компании и работали практически повсюду. К сожалению, запуск их занимал около 60 секунд. Для решения этой проблемы мы собрались небольшой командой и воспользовались одной из наших любимых утилит, strace:

root@f1bfc615a58e:/app# strace -c -e stat64,open python -c 'import click'
% time seconds usecs/call calls errors syscall
------ ---------- ---------- ---------- ---------- --------------
0.00 0.000000 0 97 4 open
------ ---------- ---------- ---------- ---------- --------------
100.00 0.000000 97 4 total

Python 2 выполняет поиск модулей за время порядка O(nlogn) (сверхлинейное время). Время, требующееся для запуска сценария, растет как минимум линейно по мере роста количества каталогов в пути. Подобное снижение быстродействия превратилось в нашей кинокомпании в настоящую проблему, поскольку во многих случаях означало необходимость выполнять более сотни тысяч обращений к файловой системе для запуска сценария. А такой процесс не только медленный, но и отрицательно сказывается на производительности файлового сервера. В конце концов это начало приводить к сбоям в работе файлового сервера стоимостью многие миллионы долларов.

Решение состояло в сочетании анализа ситуации с помощью strace, то есть использовании подходящего инструмента, с внесением изменений в работу Python, чтобы он перестал выполнять поиск импортируемых модулей на основе путей. В последующих версиях Python эта проблема была решена благодаря кэшированию операций поиска, но изучение утилит, с помощью которых можно детально проанализировать быстродействие системы, никогда лишним не бывает. И последний штрих — в процессе непрерывной интеграции всегда следует выполнять профилирование, чтобы отловить подобные проблемы с производительностью.