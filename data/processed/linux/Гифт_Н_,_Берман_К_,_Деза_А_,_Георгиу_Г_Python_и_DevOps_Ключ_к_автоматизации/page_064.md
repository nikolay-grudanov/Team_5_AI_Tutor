---
source_image: page_064.png
page_number: 64
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 23.69
tokens: 7342
characters: 1507
timestamp: 2025-12-24T03:02:33.406667
finish_reason: stop
---

Отложенное вычисление

Идея отложенного вычисления (lazy evaluation) заключается в том, что иногда, особенно работая с большими объемами данных, не имеет смысла обрабатывать все данные перед использованием результатов. Вы уже наблюдали это на примере типа range, где объем занимаемой памяти не менялся даже в случае диапазонов, соответствующих большим группам чисел.

Генераторы

Генераторы можно использовать подобно объектам range. Они выполняют операции над данными по частям, по мере требования, замораживая состояние до следующего вызова. Это значит, что можно хранить данные, необходимые для вычисления результатов, обращаясь к ним при каждом вызове генератора.

При написании функции-генератора необходимо использовать ключевое слово yield вместо оператора return. При каждом вызове генератор возвращает указанное в yield значение, после чего замораживает состояние до следующего вызова. Напишем генератор-счетчик, просто возвращающий последовательные числа:

>>> def count():
...     n = 0
...     while True:
...         n += 1
...         yield n
...
...
>>> counter = count()
>>> counter
<generator object count at 0x10e8509a8>
>>> next(counter)
1
>>> next(counter)
2
>>> next(counter)
3

Обратите внимание на то, что генератор сохраняет состояние, а поэтому переменная n при каждом вызове генератора отражает установленное ранее значение. Реализуем генератор для чисел Фибоначчи:

>>> def fib():
...     first = 0
...     last = 1
...     while True:
...         first, last = last, first + last