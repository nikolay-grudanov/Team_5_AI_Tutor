---
source_image: page_290.png
page_number: 290
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 25.03
tokens: 7468
characters: 1925
timestamp: 2025-12-24T03:08:27.725914
finish_reason: stop
---

Python 3.7 или выше, а дальше можно начать с нее и упростить свой код. Простейший пример состоит всего из одной строки кода:

out = subprocess.run(["ls", "-l"], capture_output=True)

Она способна выполнить практически все что угодно. Строка вызывает инструкцию командной оболочки в дочернем процессе Python и захватывает выводимые результаты. Возвращаемое значение — объект типа CompletedProcess. Для запуска процесса используются args: returncode, stdout, stderr и check_returncode.

Этот одноручный сценарий замещает и упрощает недостаточно лаконичные и слишком сложные методы вызовов инструкций командной оболочки, что просто замечательно для разработчиков, часто пишущих код на языке Python, смешанный с инструкциями командной оболочки. Вот еще несколько полезных советов.

Избегайте shell=True

С точки зрения безопасности лучше вызывать команды в виде элементов списка:

subprocess.run["ls", "-la"]

И избегать использования строк следующего вида:

#Избегайте подобного
subprocess.run("ls -la", shell=True)

Причина этого очевидна. Если принимать на входе произвольную строку и выполнять ее, очень легко случайно нарушить безопасность программы. Допустим, вы написали простую программу, с помощью которой пользователь может выводить список файлов в каталоге. Он может воспользоваться вашей программой для выполнения произвольной команды. Случайно создать брешь в защите очень опасно, надеемся, это хорошо иллюстрирует, насколько плохой идеей будет использовать shell=True!

# Вводимые злоумышленником команды, приводящие к необратимой утере данных
user_input = 'some_dir && rm -rf /some/important/directory'
my_command = "ls -l " + user_input
subprocess.run(my_command, shell=True)

Можно полностью предотвратить подобное, запретив использование строк:

# Вводимые злоумышленником команды ни к чему плохому не приводят
user_input = 'some_dir && rm -rf /some/important/directory'
subprocess.run(["ls", "-l", user_input])