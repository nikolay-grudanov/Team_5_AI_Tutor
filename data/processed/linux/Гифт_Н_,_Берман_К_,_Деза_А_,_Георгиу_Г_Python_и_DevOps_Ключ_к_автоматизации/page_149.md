---
source_image: page_149.png
page_number: 149
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 32.89
tokens: 7642
characters: 2175
timestamp: 2025-12-24T03:04:52.900243
finish_reason: stop
---

У всех есть свои любимые утилиты отладки. pdb представляется нам не слишком удобным (нет автодополнения и подсветки синтаксиса), ipdb нравится больше. Не удивляйтесь, если кто-то работает с другим отладчиком! В конце концов, полезно знать, как работает pdb, он представляет собой фундамент, который следует освоить в совершенстве вне зависимости от используемого вами отладчика. В системах, которые вы не можете контролировать, вам придется применять непосредственно pdb, поскольку прав на установку зависимостей у вас нет, и хотя вам это вряд ли понравится, но позволит обойти ограничения.

Быстро ли работает конкретный фрагмент кода?

В Python есть модуль, позволяющий выполнить какой-либо фрагмент кода несколько раз подряд и вычислить для него показатели производительности. Многие пользователи любят спрашивать, как эффективнее написать цикл или обновить ассоциативный массив, так что специалисты обожают модуль timeit, с помощью которого можно проверить быстродействие.

Как вы уже, наверное, заметили, мы большие поклонники IPython (https://ipython.org), а его интерактивная командная оболочка включает специальную «магическую» функцию для модуля timeit. «Магические» функции предназначены для выполнения какой-либо конкретной операции в командной оболочке, перед их названием указывается символ %. Во все времена излюбленный вопрос, связанный с быстродействием, звучит так: что выполняется быстрее — списковое включение или добавление элементов в конец списка? В приведенных далее двух примерах мы отвечаем на него с помощью модуля timeit:

In [1]: def f(x):
   ...:     return x*x
   ...:
In [2]: %timeit for x in range(100): f(x)
100000 loops, best of 3: 20.3 us per loop

В стандартной командной оболочке (или интерпретаторе) Python мы импортируем модуль timeit и обращаемся к нему напрямую. В этом случае вызов выглядит немного иначе:

>>> array = []
>>> def appending():
...     for i in range(100):
...         array.append(i)
...
>>> timeit.repeat("appending()", "from __main__ import appending")
[5.298534262983594, 5.32031941099558, 5.359099322988186]
>>> timeit.repeat("[i for i in range(100)]")
[2.2052824340062216, 2.1648171059787273, 2.1733458579983562]