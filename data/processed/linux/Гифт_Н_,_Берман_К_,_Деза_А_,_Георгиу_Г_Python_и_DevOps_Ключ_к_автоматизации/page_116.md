---
source_image: page_116.png
page_number: 116
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 24.44
tokens: 7292
characters: 1398
timestamp: 2025-12-24T03:03:52.054497
finish_reason: stop
---

print(f"Running plugin {name}")
module.run() ④

if __name__ == '__main__':
    fire.Fire()

① pkgutil.iter_modules возвращает все доступные для текущего sys.path модули.

② Проверяем, начинается ли название модуля с интересующего нас префикса.

③ Используем importlib для загрузки модуля, сохраняя его в объекте dict для дальнейшего использования.

④ Вызываем метод run плагина.

Подключение дополнительных плагинов для примера 3.7 требует от пользовательских модулей всего лишь указания префикса в названии и доступа к их функциональности с помощью метода run. Если написать два файла с префиксом foo_plugin со своими методами run:

def run():
    print("Running plugin A")

def run():
    print("Running plugin B")

можно будет обнаружить и запустить их с помощью нашей системы работы с плагинами:

$ ./simple_plugins.py find_and_run_plugins foo_plugin
Running plugin foo_plugin_a
Running plugin A
Running plugin foo_plugin_b
Running plugin B

Этот простой пример можно легко расширить, создавая в своих приложениях системы плагинов.

Ситуационный анализ: разгоняем Python с помощью утилит командной строки

Писать код сейчас удобно как никогда: всего несколько строк кода способны очень на многое. Одной-единственной функции достаточно для удивительных вещей. Благодаря GPU, машинному обучению, облачным сервисам и Python можно легко создавать разогнанные утилиты командной строки. Это все равно