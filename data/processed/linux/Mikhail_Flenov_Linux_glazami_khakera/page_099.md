---
source_image: page_099.png
page_number: 99
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 48.25
tokens: 8344
characters: 3078
timestamp: 2025-12-24T04:21:52.514009
finish_reason: stop
---

Из личного опыта очень часто возникают проблемы с программой rsync. Она синхронизирует файлы между двумя хранилищами, которые могут находиться на разных компьютерах. С помощью rsync достаточно просто реализовать синхронизацию кода на серверах для веб-серверов. Это одна из задач, которую регулярно для меня решает Linux. Но rsync постоянно виснет. Решение — запускать его в виде демона. Под демоном он работает отлично и пока у меня ни разу не зависал, но это уже отдельная тема.

Сейчас мы поговорим о процессах зомби. Итак, у меня скрипты работают в постоянном режиме и создают новые процессы (дочерние), которые выполняют какие-то работы. Иногда бывает так, что дочерний процесс завершил свою работу, а родительский не видит этого и считает, что дочерний все еще работает. Получается, как бы зомби в системе, который вроде бы и умер, но другие не видят этого.

У меня все родительские процессы записывают себя в журнал в основном скрипте. Я знаю их ID, но не знаю, какой именно из дочерних завис или превратился в зомби. Команда ps далеко не всегда показывает правильно такие проблемы.

В таких случаях я выполняю команду:

ps -al

Эта команда выводит подробную информацию о выполняющихся сейчас процессах.

<table>
  <tr>
    <th>UID</th>
    <th>PID</th>
    <th>PPID</th>
    <th>F</th>
    <th>CPU</th>
    <th>PRI</th>
    <th>NI</th>
    <th>TTY</th>
    <th>TIME</th>
    <th>CMD</th>
  </tr>
  <tr>
    <td>0</td>
    <td>702</td>
    <td>339</td>
    <td>4106</td>
    <td>0</td>
    <td>33</td>
    <td>0</td>
    <td>ttys000</td>
    <td>0:00.05</td>
    <td>login -</td>
  </tr>
  <tr>
    <td>501</td>
    <td>703</td>
    <td>702</td>
    <td>4006</td>
    <td>0</td>
    <td>31</td>
    <td>0</td>
    <td>ttys000</td>
    <td>0:00.08</td>
    <td>-bash</td>
  </tr>
  <tr>
    <td>0</td>
    <td>8510</td>
    <td>703</td>
    <td>4106</td>
    <td>0</td>
    <td>31</td>
    <td>0</td>
    <td>ttys000</td>
    <td>0:00.01</td>
    <td>ps -al</td>
  </tr>
</table>

Самыми важными здесь являются вторая и третья колонки: PID (process ID) и PPID (parent process ID). Во второй строке в колонке PPID записано 702. Это значит, что процесс в этой строке является дочерним для процесса с PID равным 702. Этот процесс можно увидеть в первой строке. Третья строка является дочерней для второй. То есть третий процесс самый низший в иерархии.

Когда процессов много, то сразу так иерархию построить не получится. В этом случае можно фильтровать вывод с помощью следующей команды:

ps -al | grep XXX

Здесь вы видите две команды, разделенные вертикальной чертой. Первая команда слева: ps -al показывает подробную информацию о всех процессах. Вторая — grep фильтрует вывод. Команда grep показывает на экране только те строки, в которых есть текст XXX. В качестве этого XXX нужно указать ID родительского процесса.

3.5. Планирование задач

Очень часто возникает необходимость выполнить какую-либо операцию в определенное время. Раньше я надеялся на свою память и вручную выполнял команды. Но когда несколько раз произошла осечка — просто был слишком занят, чтобы обра-