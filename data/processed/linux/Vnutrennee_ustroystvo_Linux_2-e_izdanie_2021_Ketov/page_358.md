---
source_image: page_358.png
page_number: 358
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 27.98
tokens: 7624
characters: 2545
timestamp: 2025-12-24T04:42:34.856769
finish_reason: stop
---

процессов и был разработан механизм групп управления (control groups, они же cgroups, см. cgroups(7)), который нашел применение как для ограничения в ресурсах группы процессов, выполняющихся в контейнере, так и для ограничения других групп, например групп процессов, принадлежащих тому или иному сервису или пользовательскому сеансу (см. разд. 10.3).

По умолчанию все процессы находятся в одной, так называемой «корневой» группе, но механизм позволяет произвольно создавать подгруппы в любых группах, образуя иерархию групп и перемещать туда индивидуальные процессы (на самом деле задачи, т. е. ядерные нити процессов, см. разд. 4.2). Затем на группы этой иерархии накладываются ресурсные ограничения, зависящие от так называемого «контроллера» (controller), назначенного этой иерархии¹.

На текущий момент различают чёртову дюжину различных контроллеров: cpi, накладывающий ограничения на справедливую долю (cpi share) процессорного времени; cpuacct, просто подсчитывающий потребленные ресурсы ЦП; cpuset, привязывающий процессы к конкретным процессорам; memory, ограничивающий потребление памяти; devices, ограничивающий доступ к файлам устройств; freezer, позволяющий приостанавливать и возобновлять работу групп процессов; net_cls и net_prio, назначающий сетевому трафику процессов класс и приоритет обработки для использования сетевыми фильтрами и планировщиками; blkio, ограничивающий количество запросов к блочным (дисковым) устройствам при помощи планировщика CFQ (см. разд. 4.6.2); pids, накладывающий ограничение на количество процессов в группе. Кроме вышеперечисленных контроллеров, имеется еще несколько экзотических и наименее распространенных на практике: perf_event, huge_tlb и rdma (см. cgroups(7)).

Интерфейс, при помощи которого иерархию групп управления можно создавать, модифицировать и накладывать конкретные значения ограничений, выполнен при помощи очередной псевдофайловой системы cgroup, подобной proc и sysfs, а ее анализ использования системой контейнеризации Docker показан в листинге 9.12.

Листинг 9.12. Использование групп управления службой Docker

rick@ubuntu:~ $ mount -t cgroup

cgroup on /sys/fs/cgroup/cpu,cpuacct type cgroup (rw,nosuid,nodev,noexec,relatime,cpu,cpuacct)

¹ Различают две версии механизма cgroups(7): v1, в которой создаются независимые иерархии групп задач (процессов и нитей) по каждому из контроллеров в отдельности, и v2, где гораздо более удобным образом (но менее гибким) создается одна иерархия групп процессов (но не нитей), а затем уже каждой группе назначают набор контроллеров.