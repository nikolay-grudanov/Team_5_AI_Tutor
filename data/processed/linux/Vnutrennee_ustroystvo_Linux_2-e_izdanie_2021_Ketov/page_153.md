---
source_image: page_153.png
page_number: 153
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 37.63
tokens: 7708
characters: 2966
timestamp: 2025-12-24T04:36:24.848708
finish_reason: stop
---

начавший движение лифт всегда едет в одном направлении, подбирая новых пассажиров, только направляющихся в сторону его движения, после чего, достигнув точки назначения, ждет нового вызова.

Планировщики ввода-вывода аналогично пытаются обслуживать поступающие запросы к накопителю не в порядке их поступления, а в порядке их номеров блоков (в порядке номеров этажей, лифт всегда едет снизу вверх), что естественно уменьшает суммарное время поиска и, как следствие, увеличивает общую пропускную способность. Кроме этого, планировщики пытаются укрупнять мелкие запросы на доступ к единичным, расположенным последовательно дисковым блокам, объединяя их в меньшее количество крупных запросов на доступ к «несколькоблочным» дисковым областям. Это опять позволяет экономить время при обращении к диску, что тоже увеличивает количество данных, обрабатываемых в единицу времени. Две такие применяемые планировщиками операции принято называть сортировкой (sorting) и слиянием (merging) соответственно.

Простейший планировщик в ядрах версии 2.4 организовывал общую очередь запросов к накопителю, отсортированную в порядке их номеров блоков, помещая новые запросы в нужное место в середине очереди, а обслуживал запросы всегда из головы очереди, отправляя их на обработку драйверу контроллера накопителя. Организованная таким образом обработка, однако, должна страдать от эффекта голодаания (starvation) запросов со старшими номерами, т. к. если представить, что новые запросы будут непрерывно и достаточно интенсивно поступать с младшими номерами блоков, то запросы со старшими номерами вообще никогда не будут обработаны. Для решения проблемы голодаания этот классический планировщик использовал возрастные отметки запросов, заставляя новые запросы размещаться всегда в конце очереди, если в ней был найден хотя бы один запрос старше определенного возраста. Такая эвристика уменьшала проблему, но в принципе не избавляла от нее, т. к. запросы, конечно, не застревали в очереди «навсегда», но задержка их обработки была непредсказуемой и ожидала желать лучшего.

Более того, она никак не касалась особенного случая эффекта голодаания — так называемого голодаания запросов на чтение, вызываемого запросами на запись (writes starving reads). Этот эффект основывается на том, что при чтении в подавляющем большинстве случаев по тем или иным причинам программы ждут реального завершения одного запроса, прежде чем отправят другой. При записи, наоборот, они практически всегда генерируют кучу запросов пачкой, отчасти и потому, что ядро воображаемо «завершает» для процесса операцию записи немедленно после копирования данных запроса в свои внутренние структуры (например, в страничный кэш). Таким образом, в очереди запросов оказывается куча запросов на запись, обработка которых неминуемо ведет к задержкам обработки немногих запросов на чтение. Ситуация еще больше усугубляется тем, что подобные пачки запросов на запись обычно адресуют последовательные блоки, что, к сожалению