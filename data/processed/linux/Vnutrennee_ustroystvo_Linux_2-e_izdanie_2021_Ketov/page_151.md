---
source_image: page_151.png
page_number: 151
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 32.35
tokens: 7740
characters: 2357
timestamp: 2025-12-24T04:36:15.912053
finish_reason: stop
---

fitz@ubuntu:~$ top -b -n1 -p 15572,15573,15628

top - 14:44:01 up 4:27, 2 users, load average: 5.07, 3.42, 2.50
Tasks: 3 total, 3 running, 0 sleeping, 0 stopped, 0 zombie
Cpu(s): 18.5%us, 3.4%sy, 0.6%ni, 76.0%id, 1.4%wa, 0.0%hi, 0.1%si, 0.0%st
MiБ Mem : 3935,6 total, 2629,5 free, 425,1 used, 880,9 buff/cache
MiБ Swap: 448,5 total, 448,5 free, 0,0 used. 3265,3 avail Mem

PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND
15628 fitz -3 0 9536 7880 468 R 100 0.1 1:14.96 bzip2
15572 fitz -2 0 9536 7880 460 R 0 0.1 1:30.95 bzip2
15573 fitz -2 0 9536 7884 464 R 0 0.1 1:30.01 bzip2

Добывление третьего процесса упаковщика со статическим приоритетом 2 приводит к резкому перекосу выделяемой доли процессорного времени в его пользу. Это объясняется тем, что алгоритм планирования RR (равно как и FIFO) всегда выбирает процесс с самым высоким статическим приоритетом из множества готовых, поэтому процессам с более низкими приоритетами процессорное время будет выделено только при засыпании всех процессов с большими приоритетами.

Странный результат ★, изображаемый командой ps(1), объясняется «несовершенством» ее способа расчета доли процессорного времени %CPU, выделяемой процессу. Расчет производится как отношение чистого потребленного процессорного времени (за все время существования процесса) к промежутку реального времени, прошедшему с момента порождения процесса, что соответствует среднему, но не мгновенному значению потребляемой доли. Гораздо более ожидаемый результат получает команда top(1), выполняющая расчет мгновенной доли процессорного времени как отношение чистого потребленного процессорного времени (за небольшой промежуток наблюдения) к реальному времени наблюдения.

4.6.2. Распределение устройств ввода-вывода между процессами

В любой многозадачной операционной системе кроме вопроса распределения (между ее задачами) центрального процессора, рассмотренного выше, неизбежно возникают вопросы распределения и других устройств, например памяти (см. разд. 4.7) и устройств ввода-вывода. В Linux все устройства ввода-вывода принято подразделять на «поблочные» устройства (block devices), которые зачастую являются накопителями, «посимвольные» устройства (character devices), — как правило, устрой-

1 А упаковщик, хоть и выполняет операции ввода-вывода, в реальности практически не засыпает в связи с использованием дискового кэша.