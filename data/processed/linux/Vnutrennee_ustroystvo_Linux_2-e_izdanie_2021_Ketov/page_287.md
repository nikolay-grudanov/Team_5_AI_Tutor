---
source_image: page_287.png
page_number: 287
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 36.33
tokens: 7784
characters: 2689
timestamp: 2025-12-24T04:40:29.021714
finish_reason: stop
---

Системный вызов socket(2) создает потоковый сокет семейства ip(7), которому назначается первый свободный файловый дескриптор FD = 3, после чего системный вызов connect(2) инициирует установку соединения этого сокета с портом 80 узла 209.51.188.148. После установки соединения системный вызов sendto(2) отсылает Web-серверу команду W:[HTTP] протокола GET на получение запрашиваемого ресурса, а несколько системных вызовов recvfrom(2) получают запрошенный ресурс.

Листинг 6.39. Сетевой клиент. Системные вызовы socket(2), connect(2), sendto(2) и recvfrom(2)

```
lspry@ubuntu:~$ strace -fe trace=network curl http://www.gnu.org/graphics/agnuheadterm-xterm.txt

socket(AF_INET, SOCK_STREAM, IPPROTO_TCP) = 3
setsockopt(3, SOL_TCP, TCP_NODELAY, [1], 4) = 0
connect(3, {sa_family=AF_INET, sin_port=htons(80), sin_addr=inet_addr("209.51.188.148")}, 16) = -1 EINPROGRESS (Операция выполняется в данный момент)
sendto(3, "GET /graphics/agnuheadterm-xterm"..., 106, MSG_NOSIGNAL, NULL, 0) = 106
recvfrom(3, "HTTP/1.1 200 OK\r\nDate: Sun, 24 N"... , 102400, 0, NULL, NULL) = 1382
recvfrom(3, "249m\342\226\204\33[38;5;246m\342\226"... , 17588, 0, NULL, NULL) = 12438
```

Жизненный цикл «серверных» сокетов чуть более сложен и предполагает использование одного «слушающего» сокета для клиентских подключений и по одному «обслуживающему» сокету на каждого подключенного клиента.

В примере из листинга 6.40 показана трассировка простейшего Web-сервера, реализованного модулем SimpleHTTPServer языка программирования W:[python]. Web-сервер запускается из «рабочего» каталога /usr/share/doc и предоставляет Web-доступ ко всем файлам этого каталога, используя «нестандартный» порт 8000.

Для начала при помощи socket(2) создается потоковый сокет семейства ip(7), которому назначается первый свободный файловый дескриптор FD = 3. Этот сокет и будет выступать в роли «слушающего», т. е. принимающего клиентские соединения, поэтому ему «привязывается» адрес 0.0.0.0 и порт 8000 (куда и будут поступать клиентские соединения) при помощи системного вызова bind(2), а сам сокет переводится в слушающее состояние системным вызовом listen(2). Все входящие клиентские соединения ставятся в очередь «слушающего» сокета и изымаются из нее системным вызовом accept(2), который создает для каждого клиентского соединения собственный сокет (клонируя слушающий). При поступлении клиентского соединения был создан новый «обслуживающий» сокет с файловым дескриптором FD = 4, используя который при помощи recv(2) была получена W:[HTTP]-команда GET на доступ к «корневому» ресурсу сервера, а с помощью нескольких системных вызовов send(2) в ответ был направлен сформированный HTML-список файлов в каталоге /usr/share/doc.