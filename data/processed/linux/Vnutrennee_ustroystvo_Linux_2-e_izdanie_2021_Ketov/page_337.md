---
source_image: page_337.png
page_number: 337
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 30.01
tokens: 7697
characters: 2701
timestamp: 2025-12-24T04:41:54.676907
finish_reason: stop
---

При получении события «возможности» (capabilities) ④ интерфейса wl_seat, при помощи его методов get_pointer() и get_keyboard() извлекаются интерфейсы wl_pointer и wl_keyboard, на события которых производится подписка (на трассе не показано) для получения информации о движении указателя мыши и нажатия клавиш на поверхностях (surface), созданных приложением.

По окончании «синхронизации» ⑤ производится подписка ③ еще на один глобальный интерфейс xdg_wm_base, предназначенный для базового управления окнами (window management), а затем создается объект «поверхности» приложения ① методом create_surface() интерфейса wl_compositor. Эта поверхность «превращается» в «xdg-окно» ⑥ при помощи метода get_xdg_surface() интерфейса xdg_wm_base, т. е. пользователь сможет изменять ее размер или местоположение на экране. Последним шагом все сделанные изменения применяются ⑦ при помощи метода commit() интерфейса wl_surface. Надо заметить, что все вышеперечисленные интерфейсы на самом деле реализуются объектами, начиная с объектов «дисплея» и реестра глобальных объектов и заканчивая объектами поверхностей. И вообще, Wayland-протокол и его программный интерфейс спроектированы в объектно-ориентированном стиле, несмотря на то что их базовая реализация выполнена для необъектно-ориентированного языка C.

Последняя часть трассы листинга показывает, как на самом деле растровые изображения из клиента доставляются в композитор. При получении события конфигурирования xdg-окна ⑧ приложение посредством wl_shm интерфейса создает пул ⑨ разделяемой (между процессами клиента и композитора) памяти на основе отображения файла с файловым дескриптором fd = 13 и размером 272 800 байт. Такой дескриптор зачастую получают либо¹ при помощи shm_open(3) в семантике разделяемой памяти POSIX (см. разд. 4.9.5 и листинг 4.58), либо при помощи Linux-специфичного системного вызова memfd_create(2). Затем в пуле создается wl_buffer буфер ⑩ размером 245×278 пиксела (по 4 байта каждый), который присоединяется к «поверхности» ⑪ в качестве «заднего» (back buffer), а затем все сделанные изменения приводятся к исполнению ⑫, т. е. буфер становится передним (front buffer) и начинает изображаться на экране композитором. Между шагами ⑨ и ⑪ производится отображение файла с fd = 13 в память клиента и наверняка производится рендеринг изображения окна приложения, что заметно по задержке между ними.

При анализе файлов, отображенных в память процесса, видно, что libgdk действительно использует memfd_create(2) для создания временного файла в оперативной памяти, который затем разделяемым образом отображается в память процессов клиента и композитора (листинг 8.6).

¹ Так и поступит libgdk на другой платформе, например FreeBSD.