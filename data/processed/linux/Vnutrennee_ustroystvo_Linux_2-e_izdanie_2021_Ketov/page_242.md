---
source_image: page_242.png
page_number: 242
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 23.29
tokens: 7313
characters: 1470
timestamp: 2025-12-24T04:38:47.890356
finish_reason: stop
---

выделения строк, подлежащих обработке, и подстановочные выражения $1, $2, ..., $N для выделения столбцов. Каждая инструкция языка AWK записывается как /RE/{ ACTION $i ... } и заставляет процессор выполнить действие ACTION со столбцами $i каждой строки, соответствующей регулярному выражению RE.

![Рис. 5.7. Процессор текстовых таблиц awk(1)](https://i.imgur.com/3Q5z5QG.png)

Так, например, в листинге 5.61 при помощи awk(1) вместо grep(1) и cut(1) выделяются имена классифицированных командой file(1) файлов, являющихся сценариями командного интерпретатора.

Листинг 5.61. Выборка строк и полей с помощью awk: список имен сценариев интерпретатора

bender@ubuntu:~$ file -Li /*bin/* /usr/*bin/* | awk -F: '/shellscript/ { print $1 }'
/bin/bzcmp
/bin/setupcon
/sbin/dkms

В примере из листинга 5.62 при помощи awk(1) подсчитывается суммарное потребление RSS-памяти процессами chromium при помощи простейшей AWK-программы с тремя инструкциями. Инструкция BEGIN { sum = 0 } выполняется до анализа строк, инструкция END { print sum } — после анализа всех строк, а инструкция /chromium/ { sum += $1 } выполняется при анализе строк и прибавляет к значению переменной sum целочисленное значение первого столбца $1 тех строк, в содержимом которых будет найдена строка chromium.

Листинг 5.62. Суммирование по строкам и полям: суммарная RSS-память процессов браузера chromium

bender@ubuntu:~$ ps axo rss,comm |
> awk 'BEGIN { sum = 0 } /chrome/ { sum += $1 } END { print sum }'