---
source_image: page_145.png
page_number: 145
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 33.91
tokens: 7772
characters: 2889
timestamp: 2025-12-24T04:36:06.310825
finish_reason: stop
---

выбирает из множества неспящих, готовых к выполнению (runable) задач одну, которую переводит в состояние выполнения (gupping). Процедуры, определяющие способ выбора и моменты выполнения выбора, называются алгоритмами планирования. Выбор задачи, подлежащей выполнению, естественным образом происходит в моменты времени, когда текущая выполнявшаяся задача переходит в состояние сна (sleep) в результате выполнения операции ввода-вывода. Вытесняющие алгоритмы планирования, кроме всего прочего, ограничивают непрерывное время выполнения задачи, принудительно прерывая ее выполнение по исчерпанию выданного ей кванта времени (timeslice) и вытесняя ее во множество готовых, после чего производят выбор новой задачи, подлежащей выполнению.

По умолчанию для пользовательских задач используется вытесняющий алгоритм CFS (completely fair scheduler), согласно которому процессорное время распределяется между неспящими задачами справедливым (fair) образом. Для каждой задачи определяется выделяемая справедливая (в соответствии с ее относительным «приоритетом») доля процессорного времени, которую она должна получить при конкуренции за процессор. Для двух задач с любыми одинаковыми приоритетами должны быть выделены равные доли (в 50% процессорного времени), а при различии в приоритетах на одну ступень разница между выделяемыми долями должна составить \( \approx 10\% \) процессорного времени (т. е. 55 и 45% соответственно). Для удовлетворения этого требования алгоритм планирования CFS назначает каждой ступени приоритета соответствующий вес задачи, а процессорное время делит между всеми неспящими задачами пропорционально их весам. Таким образом, две задачи с любыми одинаковыми приоритетами будут иметь равные веса \( w_i = w_j = w \), а доли процессорного времени составят \( \mu_i = w_i/(w_i + w_j) = 1/2 \) и \( \mu_j = w_j/(w_i + w_j) = 1/2 \). Для двух задач с приоритетами, отличающимися на одну ступень, \( w_i \neq w_j \), а \( \mu_i - \mu_j = 1/10 \), откуда несложно получить, что \( w_i/w_j = 11/9 \) — правило построения шкалы весов, а \( \mu_1 = 11/20 = 0,55 \) и \( \mu_2 = 9/20 = 0,45 \), что и требовалось получить.

Для дифференциации задач используют 40 относительных POSIX-приоритетов на шкале от -20 до +19, называемых «любезностью» задачи NICE. Относительный приоритет буквально определяет, насколько «любезна» будет задача по отношению к остальным готовым к выполнению задачам при конкуренции за процессорное время освободившегося процессора. Наименее «любезным», с относительным приоритетом -20 (наивысшим) планировщик выделит большую долю процессорного времени, а наиболее «любезным», с приоритетом +19 (наинизшим) — меньшую.

1 Шкала весов учитывает только требование 10% разницы в выделении времени CPU для задач с различием в их относительных приоритетах на одну ступень.
2 Только \( w_i/w_j = 11/9 = 1,2(2) \), тогда как в ядре Linux взято \( w_i/w_j = 1,25 \).