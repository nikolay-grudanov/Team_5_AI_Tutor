---
source_image: page_126.png
page_number: 126
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 16.77
tokens: 7316
characters: 1500
timestamp: 2025-12-24T04:35:13.937797
finish_reason: stop
---

ше своих дочерних процессов, тогда логично предположить, что все «осиротевшие» процессы окажутся зомби по завершении, потому как просто некому будет востребовать их статус завершения. На самом деле этого не происходит, потому что «осиротевшим» процессам назначается приемный родитель, в качестве которого выступает прародитель всех процессов init(1) с идентификатором PID = 1.

![Рис. 4.1. Порождение процессов (а) и запуск программ (б)](https://i.imgur.com/3Q5z5QG.png)

Рис. 4.1. Порождение процессов (а) и запуск программ (б)

Запуск новой программы (см. рис. 4.1, б) реализуется при помощи системного вызова exec(3), в результате которого содержимое процесса PID₁ полностью замещается запускаемой программой и библиотеками, от которых она зависит, а свойства и атрибуты (включая идентификатор PID) остаются неизменными. Такое замещение обычно используется программами, устанавливающими нужные значения свойств и атрибутов процесса и подготавливающими ресурсы процесса к выполнению запускаемой программы. Например, обработчик терминального доступа getty(8) (см. главу 2) открывает заданный терминал, устанавливает режимы работы порта терминала, перенаправляет на терминал стандартные потоки ввода-вывода, а затем замещает себя программой аутентификации login(1).

Для запуска новой программы в новом процессе используются оба системных вызова fork(2) и exec(3) согласно принципу fork-and-exec «раздвоиться и запустить», показанного на рис. 4.2. В примере из листинга 4.8 дерево процессов сформиро-