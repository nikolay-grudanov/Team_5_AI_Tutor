---
source_image: page_125.png
page_number: 125
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 32.33
tokens: 7640
characters: 2385
timestamp: 2025-12-24T04:35:29.458665
finish_reason: stop
---

30315 30328 ? 00:00:00 Socket Thread
30315 30332 ? 00:00:00 Cache2 I/O
30315 30333 ? 00:00:00 Cookie
30315 30371 ? 00:00:00 HTML5 Parser
30315 30373 ? 00:00:00 DNS Resolver #3

4.3. Порождение процессов и нитей, запуск программ

Несмотря на очевидные различия, историю возникновения и развития, нити и процессы объединяет общее назначение — они являются примитивами выполнения некоторого набора последовательных инструкций.

Процессы выполняют или разные последовательные программы целиком, или ветви одной параллельной программы, но в изолированном окружении со своим «частным» (private) набором ресурсов. Нити, наоборот, выполняют ветви одной параллельной программы в одном окружении с «общим» (shared) набором ресурсов. В многозадачном ядре Linux вообще используется универсальное понятие «задача», которая может иметь как общие ресурсы (память, открытые файлы и т. д.) с другими задачами, так и частные ресурсы для своего собственного использования.

Порождение нового процесса (рис. 4.1, а) реализуется при помощи системного вызова fork(2), в результате которого ядро операционной системы создает новый дочерний (child) процесс PID_2 — полную копию (COPY) процесса-родителя (parent PID_1. Вся (за небольшими исключениями) память процесса — состояние, свойства атрибуты (кроме идентификатора PID) и даже содержимое (программа с ее библиотеками) — наследуется дочерним процессом. Даже выполнение порожденного и порождающего процесса продолжится с одной и той же инструкции их одинаковой программы. Такое клонирование обычно используют параллельные программы с ветвями (см. разд. 4.3.1), выполняющимися в дочерних процессах.

Уничтожение процесса (например, при штатном окончании программы) производится с помощью системного вызова exit(3). При этом родительскому процессу доставляется сигнал SIGCHILD, оповещающий о завершении дочернего процесса (см. разд. 4.8). Статус завершения status, переданный дочерним процессом через аргументы exit(3), будет сохраняться ядром до момента его востребования родительским процессом при помощи системного вызова wait(2), а весь этот промежуток времени дочерний процесс будет находиться в состоянии Z (zombie² (см. столбец STAT в листинге 4.8). Родительский процесс может завершиться рань-

¹ Откровенно говоря, нити, в общем, появились в операционных системах раньше, чем изолированные UNIX-процессы, в которые со временем вернулись UNIX-нити...