---
source_image: page_155.png
page_number: 155
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 38.87
tokens: 7723
characters: 2861
timestamp: 2025-12-24T04:36:30.434212
finish_reason: stop
---

Впоследствии anticipatory-планировщик был удален из ядра в пользу планировщика CFQ (Completely Fair Queuing, совершенно справедливая очередь), который позволяет получать результаты сравнимые (и даже лучше) с anticipatory-планировщиком, но обладает еще и массой других полезных свойств. В основе CFQ-планировщика лежит желание обеспечить справедливое распределение пропускной способности накопителя между процессами, вне зависимости от их поведения. Для этого планировщик организует для запросов на чтение по одной очереди на процесс, плюс общую очередь для запросов на запись, а сами запросы во всех очередях, как и всегда, сортируются в порядке номеров их дисковых блоков. Кроме этого, подобно deadline-планировщику, CFQ определяет максимальные « сроки» обработки запросов, а подобно anticipatory-планировщику, после обработки запроса на чтение выжидает некоторое время, предвосхищая появление еще одного запроса с номером блока, следующего за только что обработанным.

Кроме этого, планировщик предусматривает возможность дифференциации процессов (и, как следствие, их очередей чтения) по классам и приоритетам, позволяя выделить долю пропускной способности для определенных процессов чуть «справедливее», чем для других. Очереди записи для всех процессов общие, но тоже подразделяются по классам и приоритетам.

Порядок выбора очереди для обработки запросов определяется сначала ее классом, а внутри класса — при помощи специальных отметок «времени начала» обработки, назначаемых в зависимости от приоритета. При этом запросы в каждой из них обрабатываются в течение времени, ограниченного сверху некоторым интервалом (slice) времени, так же определяемым приоритетом очереди.

Различают три класса обслуживания: realtime, best-effort, idle, которые задаются процессам явно при помощи системного вызова ioprio_set(2) и утилиты ionice(1). В случае, если для процесса явно не определен класс обслуживания (по умолчанию все процессы отнесены к «классу» none), он неявно «зеркалируется» на приоритет планировщика центрального процессора CFS (см. разд. 4.6.1). Так, например, процессы из CFS класса SCHED_IDLE неявно расцениваются как находящиеся в CFQ-классе idle, а процессы из классов SCHED_FIFO, SCHED_RR и SCHED_DEADLINE — как в классе realtime. Для остальных процессов используется класс best-effort, при этом не заданные явно приоритеты так же неявно высчитываются пропорционально «любезности» NICE.

В классах realtime и best-effort различают по 8 приоритетов (min 7→0 max), от которых зависит длительность интервала времени, выделяемого очередям на обработку. Базовый интервал времени S обычно равняется 100 мс (см. ① в листинге 4.32), который назначается «среднему» приоритету p = 4, а для остальных они масштабируются от 40 мс (для приоритета 7) до 180 мс (для приоритета 0), как S_p = S + S·k·(4 − p), где k = 1/5 — масштабный множитель шкалы приорите-