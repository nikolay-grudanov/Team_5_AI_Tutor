---
source_image: page_152.png
page_number: 152
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 34.64
tokens: 7649
characters: 2759
timestamp: 2025-12-24T04:36:21.818636
finish_reason: stop
---

ства взаимодействия с пользователями (мыши, клавиатуры, терминалы и пр.) и «попакетные» устройства, в большинстве своем — сетевые интерфейсы.

В каждом классе устройств способы их распределения часто связаны с эффективностью их работы, т. к. решение задачи «в лоб» приводит к неприемлемым результатам. Например, при распределении доступа к дисковым накопителям оказывается, что количество считываемых данных в единицу времени (пропускная способность, throughput) существенно зависит от того, в каком порядке обслуживать запросы отдельных процессов на чтение/запись накопителя. Такой результат в основном обусловлен свойствами самих накопителей, все еще являющихся механическими дисками. Для проведения операции чтения или записи дискового блока контроллер накопителя должен потратить время на перемещение головки над нужной дорожкой, а затем дождаться «приезда» нужного сектора этой дорожки, который содержит данные искомого блока. На все это нужно колоссальное (с точки зрения центрального процессора и процессов) время¹, что и ограничивает количество данных, обрабатываемых в единицу времени.

Если представить себе операции линейного считывания или записи, когда обрабатываются дисковые блоки, находящиеся в последовательных секторах одной дорожки, затем последовательно в секторах соседней дорожки, то можно добиться максимальной производительности, но это невозможно по двум причинам. Во-первых, процессы работают с абстракциями более высокого уровня — с файлами, данные которых могут размещаться файловыми системами в произвольных дисковых блоках. Даже если последовательные блоки файла размещены в последовательных дисковых блоках, программы в принципе могут читать произвольные файлы в каком угодно порядке. Во-вторых, сама мультипрограммная смесь в принципе генерирует общий поток запросов к произвольным местам диска. При попытке обслуживать этот поток «как есть» количество накладных расходов на хаотичный поиск (seek time) нужных дисковых блоков будет достаточно велико, а результирующая пропускная способность диска — мала. Именно эта задача приводит к появлению в подсистеме блочных устройств ядра планировщика ввода-вывода (I/O scheduler), т. е. специальной компоненты, обслуживающей очередь запросов к накопителю особенным образом, изначально направленным на оптимизацию пропускной способности накопителя.

Подобные планировщики часто используют алгоритмы, подобные тем, что задействованы в лифтовых системах зданий для оптимизации перемещения лифтов (elevator), и носят название лифтовых алгоритмов. Наиболее известными алгоритмами являются так называемые SCAN, C-SCAN, LOOK и C-LOOK, см. W:[Elevator algorithm], W:[LOOK algorithm]. Принцип их действия (упрощенно) состоит в том, что

¹ Что, однако, и привело в свое время к многозадачным ОС.