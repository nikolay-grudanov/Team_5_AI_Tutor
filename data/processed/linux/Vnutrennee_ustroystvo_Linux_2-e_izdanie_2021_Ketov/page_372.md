---
source_image: page_372.png
page_number: 372
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 30.36
tokens: 7705
characters: 2947
timestamp: 2025-12-24T04:43:05.259108
finish_reason: stop
---

(при помощи сетевых сокетов) и отказывается работать, если обращение было неудачным. При использовании классических «модульных» сценариев приходилось сначала запускать первую, затем дожидаться¹, пока она откроет свой (серверный) сокет, и только потом запускать вторую. В этом случае systemd берет задачу по одновременному открытию сокетов служб на себя, а затем одновременно запускает обе службы, вручая каждой из них ее уже открытый сокет (в результате службы даже становятся проще). Даже если вторая служба немедленно обратится к сокету первой и сразу отправит запрос, то ей придется всего лишь подождать², пока первая не будет готова его обработать. Важно отметить: несмотря на то что службы в данном примере будут зависеть от открытости сокетов (первая служба зависит только от своего сокета, а вторая еще и от чужого), сами службы становятся независимыми друг от друга, что и позволяет запускать их одновременно.

Несмотря на то что в примере выше службы должны быть адаптированы к использованию такого systemd-подхода, он хорошо иллюстрирует разделение работы на мелкие единицы — в данном случае работа по открытию сокета (см. systemd.socket(5)) и работа по запуску (см. systemd.exec(5)) собственно службы (см. systemd.service(5)) разделены в угоду эффективности общего процесса. Кроме того, такое разделение еще и позволяет организовать так называемую сокет-активацию служб, когда они запускаются только при поступлении подключений на этот сокет, а в их отсутствие остановлены, тем самым экономя ресурсы операционной системы.

Еще одна иллюстрация эффективности разбиения работы по запуску операционной системы на небольшие единицы и их параллелизации может быть проведена относительно инициализации системы, проводимой перед стартом служб. Как уже упоминалось, типичными действиями на этом этапе являются формирование дерева каталогов путем монтирования туда файловых систем, упомянутых в fstab(5), или конфигурирование сетевых интерфейсов. При классическом подходе все файловые системы монтировались в дерево последовательно, и если что-то шло не так, то инициализация останавливалась, приглашая администратора к ручному исправлению проблем посредством спасательного (rescue) командного интерпретатора. В systemd монтирование каждой файловой системы — это отдельный юнит (автоматически создаваемый чтением fstab(5), см. systemd.mount(5) и systemd-fstab-generator(8)), а зависят от нее только те другие юниты, которым она на самом деле нужна, а не судьба инициализации целиком. Поскольку для монтирования файловых систем необходимо иметь созданные файлы устройств (и загруженные драйвера устройств), а эту работу асинхронно выполняет udev(7), то systemd считает файлы устройств отдельными юнитами (см. systemd.device(5)), от которых, в свою очередь, зависят юниты

¹ Обычно путем циклического опроса, что достаточно неэффективно.
² При этом будут работать эффективные событийные механизмы ядра по работе с сокетами, а не циклический опрос.