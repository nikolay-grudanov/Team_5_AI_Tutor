---
source_image: page_218.png
page_number: 218
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 24.31
tokens: 5767
characters: 1786
timestamp: 2025-12-24T04:14:15.932593
finish_reason: stop
---

<table>
  <tr>
    <th>Нажатия клавиш</th>
    <th>Содержимое буфера</th>
  </tr>
  <tr>
    <td>qa</td>
    <td>1. one<br>2. two</td>
  </tr>
  <tr>
    <td>0f.</td>
    <td>1. one<br>2. two</td>
  </tr>
  <tr>
    <td>r)</td>
    <td>1) one<br>2. two</td>
  </tr>
  <tr>
    <td>w~</td>
    <td>1) One<br>2. two</td>
  </tr>
  <tr>
    <td>j</td>
    <td>1) One<br>2. two</td>
  </tr>
  <tr>
    <td>q</td>
    <td>1) One<br>2. two</td>
  </tr>
</table>

Обратите внимание на команды перемещения курсора в этом макросе. Мы начинаем запись с команды 0, которая нормализует позицию курсора, помещая его в начало строки. Это означает, что следующее перемещение курсора всегда будет начинаться с одного и того же места, чем обеспечивается более высокая повторяемость.

Кто-то, взглянув на следующую команду перемещения, f., мог бы посчитать ее слишком расточительной. Она перемещает курсор всего на одну позицию вправо, как и команда l. Зачем нажимать на клавиши два раза, если достаточно одного?

Повторюсь еще раз — это сделано в угоду повторяемости. В нашем примере имеются всего четыре строки, пронумерованные от одного до четырех. А теперь представьте, что в тексте имеются строки, начинающиеся с двух цифр.

1. one
2. two
...
10. ten
11. eleven

В первых девяти строках команда 0l переместит курсор на второй символ строки — точку. Но, начиная с десятой строки, эта же команда не будет достигать цели, тогда как команда f. прекрасно справится со всеми этими строками и любыми другими, начинающимися с любого количества цифр.

Кроме того, команда f. является еще одним «предохранителем». Если в строке отсутствует символ точки (.), команда f. закончится неудачей, и выполнение макроса прервется. Мы задействуем эту особенность чуть ниже, поэтому попридержите пока эту мысль в голове.