---
source_image: page_219.png
page_number: 219
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 16.51
tokens: 5592
characters: 1351
timestamp: 2025-12-24T04:14:08.257809
finish_reason: stop
---

Последовательное выполнение макроса

Выполнить только что записанный макрос можно командой @a. Она выполнит следующие действия: переместит курсор на первый символ точки (.) в строке, заменит его скобкой ), переведет в верхний регистр первую букву следующего слова и переместит курсор на следующую строку.
Чтобы решить поставленную задачу, можно трижды выполнить команду @a, но команда 3@a выглядит короче:

<table>
  <tr>
    <th>Нажатия клавиш</th>
    <th>Содержимое буфера</th>
  </tr>
  <tr>
    <td>{start}</td>
    <td>1) One<br>2. two<br>3. three<br>4. four</td>
  </tr>
  <tr>
    <td>3@a</td>
    <td>1) One<br>2) Two<br>3) Three<br>4) Four</td>
  </tr>
</table>

Давайте усложним задачу. Пусть последовательность строк, на которую требуется воздействовать, разбита на фрагменты случайными комментариями:

macros/broken-lines.txt
http://media.pragprog.com/titles/dnvim/code/macros/broken-lines.txt

1. one
2. two
// break up the monotony
3. three
4. four

Теперь взгляните, что получится, если применить тот же самый макрос к этому файлу (табл. 11.2).
Макрос замер на третьей строке, содержащей комментарий. Команда f. не обнаружила символа точки в этой строке, и выполнение макроса было прервано. Предохранитель сработал, и это хорошо, потому что если бы макрос продолжил выполнение в этой строке, он внес бы нежелательные для нас изменения.