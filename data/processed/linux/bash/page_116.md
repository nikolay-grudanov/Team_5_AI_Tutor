---
source_image: page_116.png
page_number: 116
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 9.72
tokens: 7430
characters: 1495
timestamp: 2025-12-23T23:06:07.004730
finish_reason: stop
---

алфавитный или какой-то другой конкретный порядок. Это объясняется природой алгоритма хеширования значений индекса.

5 При выводе значения и ключа мы помещаем значения в кавычки, чтобы всегда получать одно значение для каждого аргумента, даже если оно содержит один или два пробела. Мы не думаем, что такое произойдет при работе этого сценария, но подобная практика кодирования делает сценарии более надежными при использовании в различных ситуациях.

В примере 7.4 показана другая версия сценария, с использованием команды awk.

Пример 7.4. countem.awk

# Bash и кибербезопасность
# countem.awk
#
# Описание:
# Подсчет количества экземпляров элемента с помощью команды awk
#
# Использование:
# countem.awk < inputfile
#

awk '{ cnt[$1]++ }
END { for (id in cnt) {
        printf "%d %s\n", cnt[id], id
    }
}'
Оба сценария будут хорошо работать в конвейере команд:

cut -d' ' -f1 logfile | bash countem.sh

Команда cut на самом деле здесь не нужна ни для одной из версий. Почему? Потому что сценарий awk явно ссылается на первое поле ($1), а то, что команда cut в сценарии оболочки не нужна, объясняется кодировкой команды read (см. 2). Так что мы можем запустить сценарий следующим образом:

bash countem.sh < logfile

Например, чтобы подсчитать, сколько раз IP-адрес делал HTTP-запрос, на который возвращалось сообщение об ошибке 404 («Страница не найдена»), нужно ввести такую команду:

$ awk '$9 == 404 {print $1}' access.log | bash countem.sh

1 192.168.0.36
2 192.168.0.37
1 192.168.0.11