---
source_image: page_152.png
page_number: 152
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 7.89
tokens: 7410
characters: 1625
timestamp: 2025-12-23T23:07:31.401545
finish_reason: stop
---

действительно только на время выполнения данной команды. К своему предыдущему значению переменная возвращается сразу после выполнения команды. Вот почему мы в этой строке не повторяем $LOOKFOR — это не будет действительным значением. Мы бы могли разделить это выражение на две отдельные команды — присваивание переменной и вызов функции. Но тогда бы вы не узнали об этой функции в bash.

8 Здесь демонстрируется новый вариант использования файловых дескрипторов. Файловый дескриптор 4 получает «перенаправление» для чтения входных данных из файла, указанного в первом аргументе сценария. Соответственно дескриптор 5 получает свои входные данные из второго аргумента. Если один или оба параметра не заданы, сценарий будет использовать имена, указанные по умолчанию.

Шаг 3. Автоматизация и уведомление

Хотя вы можете выполнять сценарий вручную, было бы гораздо лучше, если бы он автоматически запускался каждый день или каждые несколько дней и уведомлял вас о любых обнаруженных изменениях. Сценарий autoscan.sh, показанный в примере 9.4, является единственным сценарием, использующим для сканирования сети и вывода любых изменений файлы scan.sh и fd2.sh.

Пример 9.4. autoscan.sh

#!/bin/bash -
#
# Bash и кибербезопасность
# autoscan.sh
#
# Описание:
# Автоматическое сканирование портов (с помощью сценария scan.sh)
# Сравнение вывода с предыдущими результатами и e-mail пользователя
# Предполагается, что сценарий scan.sh находится в текущем каталоге
#
# Использование: ./autoscan.sh
#

./scan.sh < hostlist

FILELIST=$(ls scan_* | tail -2)    ①
FILES=( $FILELIST )                ②

TMPFILE=$(tempfile)                 ③