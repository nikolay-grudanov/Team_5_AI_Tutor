---
source_image: page_179.png
page_number: 179
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 12.46
tokens: 7601
characters: 2299
timestamp: 2025-12-23T23:08:37.278983
finish_reason: stop
---

then
    VIRUS="${BASH_REMATCH[1]}"
    FOUND="${BASH_REMATCH[2]}"
    RESLT="${BASH_REMATCH[3]}"
    if [[ $FOUND =~ .*true.* ]]
    then
        echo $VIRUS "- result:" $RESLT
    fi
fi
done

① Это сложное регулярное выражение (или RE) ищет строки, содержащие слова DETECT, RESULT и UPDATE в указанной последовательности. Более того, RE также находит в пределах любой строки три подстроки, которые соответствуют этим трем ключевым словам. Подстроки обозначены круглыми скобками; скобок не должно быть в строках, которые мы ищем, — они скорее являются синтаксисом RE, обозначающим группировку.

Рассмотрим в этом примере первую группу. RE заключено в одинарные кавычки. Здесь может быть много специальных символов, но нам не нужно, чтобы они были интерпретированы как специальные символы оболочки; желательно, чтобы они передавались буквально процессору regex. Следующий символ, ^, говорит о том, что этот поиск следует привязать к началу строки. Символ «точка» (.) соответствует любому символу в строке ввода. Затем идет группа любых символов (.), повторяющаяся любое количество раз, обозначаемое символом *.

Итак, сколько символов потребуется для заполнения этой первой группы? Мы должны и дальше просматривать RE, чтобы найти соответствия. То, что должно находиться после данной группы, — это три символа, за которыми следует левая скобка. Итак, теперь мы можем описать эту первую группировку как все символы, начиная со второго символа строки вплоть до трех символов перед левой скобкой, но эти три символа исключаются.

Данная ситуация похожа на ситуацию с другими группами, местоположение которых ограничивается точками и ключевыми словами. Да, это довольно жесткий формат, но предсказуемый. Данный сценарий мог быть написан для более гибкой обработки формата ввода (см. упражнения в конце главы).

② Команда sed готовит наши входные данные для более легкой обработки. Она самостоятельно помещает в строку исходное ключевое слово JSON scans и связанные с ним знаки пунктуации. Далее в конце каждой правой скобки (с запятой после нее) также добавляется символ новой строки. В обоих выражениях редактирования символ & в правой части подстановки представляет собой то, что было сопоставлено с левой стороны. Например, во второй замене амперсанд является сокращением для правой скобки и запятой.