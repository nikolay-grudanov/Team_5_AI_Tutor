---
source_image: page_141.png
page_number: 141
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 9.14
tokens: 7446
characters: 1760
timestamp: 2025-12-23T23:07:05.927875
finish_reason: stop
---

4 Здесь сохраняется идентификатор процесса сценария, который мы только что запустили в фоновом режиме.

5 Данное перенаправление — просто мера предосторожности. Весь вывод, поступающий из цикла while или от операторов kill/sleep (хотя их мы не ожидаем), не должен смешиваться с любыми выводами функции looper.sh, которая, хотя и работает в фоновом режиме, все равно отправляет их в stdout. Поэтому мы перенаправляем данные из stdout в stderr.

Подводя итог, мы видим, что, хотя функция looper.sh была помещена в фоновый режим, идентификатор ее процесса сохраняется в переменной оболочки. Каждые пять секунд сценарий tailcount.sh отправляет данному процессу (который выполняется в функции looper.sh) сигнал SIGUSR1, который, в свою очередь, вызывает сценарий looper.sh, чтобы распечатать зафиксированное в нем текущее количество строк и перезапустить подсчет. После выхода сценарий tailcount.sh очистится, отправив сигнал SIGTERM в функцию looper.sh для ее прерывания.

С помощью двух сценариев — сценария, выполняющего подсчет строк, и сценария с секундомером (таймера), управляющего первым сценарием, — вы можете получить вывод (количество строк за определенный период), на основе которого следующий сценарий построит гистограмму. Он вызывается таким образом:

bash tailcount.sh | bash livebar.sh

Сценарий livebar.sh считывает данные из stdin и печатает вывод в stdout, по одной строке для каждой строки ввода (пример 8.5).

Пример 8.5. livebar.sh

#!/bin/bash -
#
# Bash и кибербезопасность
# livebar.sh
#
# Описание:
# Создание горизонтальной гистограммы «живых» данных
#
# Использование:
# <output from other script or program> | bash livebar.sh

function pr_bar () {
    local raw maxraw scaled
    raw=$1
    maxraw=$2
    ((scaled=(maxbar*raw)/maxraw))