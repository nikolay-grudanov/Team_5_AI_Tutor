---
source_image: page_130.png
page_number: 130
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 9.18
tokens: 7434
characters: 1807
timestamp: 2025-12-23T23:06:42.951178
finish_reason: stop
---

function mismatch ()
{
    local -i i
    for ((i=0; i<$KNSIZE; i++))
    do
        [[ "$1" =~ .*${KNOWN[$i]}.* ]] && return 1
    done
    return 0
}

readarray -t KNOWN < "useragents.txt"
KNSIZE=${#KNOWN[@]}

# предварительная обработка лог-файла (stdin),
# чтобы выбрать IP-адреса и пользовательские агенты
awk -F'"' '{print $1, $6}' | \
while read ipaddr dash1 dash2 dtstamp delta useragent
do
    if mismatch "$useragent"
    then
        echo "anomaly: $ipaddr $useragent"
    fi
done

① Сценарий будет основан на функции несовпадения. Если обнаружится несоответствие, будет возвращено значение success или true. Это значит, что совпадение со списком известных пользовательских агентов не найдено. Данная логика может показаться нестандартной, но так удобнее читать оператор if, содержащий вызов mismatch.

② Объявление нашего цикла for в качестве локальной переменной — хорошая идея. Данный шаг в сценарии не является обязательным.

③ Здесь представлены две строки для сравнения: входные данные из файла журнала и строка из списка известных пользовательских агентов. Для гибкого сравнения используется оператор сравнения регулярных выражений (the=~). Значение .* (ноль или более вхождений любого символа), размещённое по обе стороны ссылки массива $KNOWN, говорит о том, что совпадение известной строки может быть найдено в любом месте другой строки.

④ Каждая строка файла добавляется как элемент к указанному имени массива. Это дает нам массив известных пользовательских агентов. В bash существует два способа добавить строки к массиву: использовать либо readarray, как сделано в этом примере, либо mapfile. Опция -t удаляет завершающий символ новой строки из каждой прочитанной строки. Здесь указан файл, содержащий список известных пользовательских агентов; при необходимости его можно изменить.