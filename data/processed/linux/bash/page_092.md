---
source_image: page_092.png
page_number: 92
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 8.58
tokens: 7393
characters: 1561
timestamp: 2025-12-23T23:05:05.718257
finish_reason: stop
---

HASH=$1
DIR=${2:-.}    # cwd, по умолчанию это здесь

# конвертируем путь в абсолютный
function mkabspath ()
{
    if [[ $1 == /* ]]
    then
        ABS=$1
    else
        ABS="$PWD/$1"
    fi
}

find $DIR -type f |
while read fn
do
    THISONE=$(sha1sum "$fn")
    THISONE=${THISONE%% *}
    if [[ $THISONE == $HASH ]]
    then
        mkabspath "$fn"
        echo $ABS
    fi
done

① Для нашего хеша мы будем искать любой простой файл. Нам следует избегать специальных файлов; чтение FIFO приведет к зависанию программы, так как она станет ожидать, когда кто-нибудь что-то запишет в FIFO. Чтение блочного или специального символьного файла — тоже не очень хорошая идея. Параметр -type f гарантирует, что мы получим только простые файлы. Сценарий выводит имена этих файлов, по одному в строке, в стандартный вывод, который мы перенаправляем через канал передачи данных в команды while read.

② Здесь вычисляется значение хеша в подоболочке, захватывается его вывод (то есть все, что записывается в стандартный вывод), после чего эти данные присваиваются переменной. Кавычки нужны, если в имени файла есть пробелы.

③ Это переназначение удаляет с правой стороны самую большую подстроку, начинаяющуюся с пробела. Вывод sha1sum — это и вычисленный хеш, и имя файла. Нам же нужно только хеш-значение, поэтому с помощью этой замены мы удаляем имя файла.

④ Далее вызывается функция mkabspath, а имя файла помещается в кавычки. Кавычки гарантируют, что все имя файла отображается как один аргумент функции, даже если в имени содержится один или несколько пробелов.