---
source_image: page_230.png
page_number: 230
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 11.48
tokens: 7562
characters: 2156
timestamp: 2025-12-23T23:10:34.421686
finish_reason: stop
---

for ((i=1; i <= MAX; i++)) do
    FUZARG="${FUZARG}${FUZONE}" # то есть +=
    ALIST[$NDX]="$FUZARG"
    # порядок >s важен
    $THEAPP "${ALIST[@]}" 2>&1 >/dev/null
    if (( $? )) ; then echo "Caused by: $FUZARG" >&2 ; fi
done

1 Мы определяем функцию usagexit, чтобы выдать пользователю сообщение об ошибке, которая укажет правильный способ использования сценария. После печати сообщения сценарий завершит работу и будет вызван при ошибочной активации (в нашем случае, если аргументов станет недостаточно) (см. 3). Аргумент -lpt в примере сообщения является аргументом для пользовательской программы myapp, а не для сценария fuzzer.sh.

2 Поскольку эта функция выдает сообщение об ошибке, а не предполагаемый вывод программы, мы хотим, чтобы сообщение перешло в stderr. После этого весь вывод из функции, который был направлен в stdout, перенаправляется в stderr.

3 Если аргументов недостаточно, следует завершить работу сценария; мы вызываем эту функцию, чтобы объяснить пользователю, как ее правильно использовать (функция выйдет из сценария и не возвратится).

4 Сохранив в приложении первый аргумент, мы смещаем аргументы. Таким образом, $2 становится $1, $3 становится $2 и т. д.

5 Тип встроенного приложения определяет тип исполняемого файла ( псевдоним, ключевое слово, функция, встроенный файл ). Поскольку вывод нас не интересует, мы перенаправляем его в /dev/null и отбрасываем. Нам необходимо получить возвращаемое значение type. Если пользовательское приложение (один из перечисленных типов ) может быть запущено, возвращается значение 0. Если нет — возвращается значение 1 и выполняется второе условие этой строки: вызывается функция usagexit, а работа сценария завершается.

6 Этот цикл for будет перебирать количество аргументов ($#), хотя это количество с каждым сдвигом будет уменьшаться. Данные аргументы предназначены для пользовательской программы, то есть программы, к которой мы применяем метод фаззинга.

7 Мы сохраняем каждый аргумент, добавляя его в переменную массива ALIST. Почему бы нам просто не добавить каждый аргумент в строку, а не хранить их как элементы массива? Все будет работать нормально, если ни один из аргуме-