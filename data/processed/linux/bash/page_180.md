---
source_image: page_180.png
page_number: 180
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 8.18
tokens: 7465
characters: 1764
timestamp: 2025-12-23T23:08:33.132324
finish_reason: stop
---

3 Здесь используется регулярное выражение. Не задавайте $RE внутри кавычек, иначе $RE будет соответствовать таким специальным символам, как литералы. Чтобы определить поведение регулярного выражения, не заключайте его в кавычки.

4 Если в регулярном выражении используются скобки, они обозначают подстроку, которую можно извлечь из переменной массива оболочки BASH_REMATCH. Индекс 1 обозначает первую подстроку и т. д.

5 Это еще один вариант использования сопоставления регулярных выражений. Мы ищем слово true в любом месте строки. Здесь делается предположение о наших входных данных: что слово true не появляется ни в каком другом поле, кроме того, в котором мы ожидаем его встретить. Мы могли бы сделать сопоставление более конкретным (например, расположив слово true рядом со словом detected), но такой оператор гораздо лучше читается и будет работать до тех пор, пока четыре буквы t-r-u-e не появятся в данной последовательности в любом другом поле.

Для решения этой задачи не обязательно использовать регулярные выражения. В примере 11.3 приводится решение с использованием awk. Теперь в awk можно эффективно задействовать регулярные выражения, но они вам здесь не нужны из-за другой мощной функции awk: синтаксического разбора входных данных на поля.

Пример 11.3. vtjson.awk

# Bash и кибербезопасность
# vtjson.awk
#
# Описание:
# Поиск вредоносных программ в файле JSON
#
# Использование:
# vtjson.awk <json file>
#   <json file> Файл с результатами VirusTotal
#

FN="${1:-Calc_VirusTotal.txt}"
sed -e 's/{"scans": {/&\n /' -e 's/},/&\n/g' "$FN" |
awk '
NF == 9 {
    COMMA=","
    QUOTE='"'
    if ( $3 == "true" COMMA ) {
        VIRUS=$1
        gsub(QUOTE, "", VIRUS)

        RESLT=$7
        gsub(QUOTE, "", RESLT)
        gsub(COMMA, "", RESLT)
