---
source_image: page_139.png
page_number: 139
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 12.73
tokens: 7594
characters: 2305
timestamp: 2025-12-23T23:07:08.208370
finish_reason: stop
---

trap interval SIGUSR1

shopt -s lastpipe

tail -f --pid=$$ ${1:-log.file} | while read aline
do
    let cnt++
done

① Функция interval будет вызываться при получении каждого сигнала. Конечно, интервал должен быть определен до того, как мы сможем его назвать и использовать в нашем выражении trap.

② Команда date вызывается, чтобы предоставить временную метку для значения переменной cnt, которое мы распечатываем. После вывода показания счетчика мы сбрасываем это значение на 0, чтобы начать отсчет следующего интервала.

③ Теперь, когда интервал определен, мы можем указать, чтобы функция вызывалась всякий раз, когда наш процесс получает сигнал SIGUSR1.

④ Это очень важный шаг. Обычно, когда есть конвейер команд (например, ls-1 | grep rwx | wc), части конвейера (каждая команда) выполняются в подсетях и каждый процесс заканчивается своим собственным идентификатором процесса. Это могло бы стать проблемой для данного сценария, потому что цикл while будет находиться в подоболочке с другим идентификатором процесса. Какой бы процесс ни начался, сценарий looper.sh не будет знать идентификатора процесса цикла while, чтобы отправить ему сигнал. Кроме того, изменение значения переменной cnt в подоболочке не изменяет значение cnt в основном процессе, поэтому сигнал для основного процесса каждый раз приведет к установке значения 0. Решить эту проблему можно с помощью команды shopt, которая устанавливает (-s) параметр lastpipe. Он указывает оболочке не создавать для последней команды в конвейере подоболочку, а запускать эту команду в том же процессе, в котором запущен сам сценарий. В нашем случае это означает, что команда tail будет выполнятьсь в подоболочке (то есть в другом процессе), а цикл while станет частью основного процесса сценария. Внимание: эта опция оболочки доступна только в bash версии 4.x и выше и только для неинтерактивных оболочек (то есть сценариев).

⑤ Это команда tail -f еще с одним параметром --pid. Мы указываем идентификатор процесса, который по завершении данного процесса завершит работу команды tail. Мы указываем идентификатор процесса текущего сценария оболочки $$, который нужно просмотреть. Это действие позволяет очистить процессы и не оставлять команду tail выполнятьсь в фоновом режиме (если, скажем, этот сценарий выполняется в фоновом режиме; пример 8.4).