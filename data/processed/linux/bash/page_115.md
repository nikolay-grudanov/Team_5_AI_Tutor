---
source_image: page_115.png
page_number: 115
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 12.63
tokens: 7580
characters: 2283
timestamp: 2025-12-23T23:06:04.712057
finish_reason: stop
---

while read id xtra
do
    let cnt[$id]++
done
# вывести то, что мы подсчитали
# для каждого ключа в ассоциативном массиве в виде (ключ, значение)
for id in "${!cnt[@]}"
do
    printf '%d %s\n' "${cnt[$id]}" "$id"
done

1 Поскольку мы не знаем, с какими IP-адресами (или другими строками) можем столкнуться, будем использовать ассоциативный массив (также известный как хеш-таблица или словарь). В этом примере массив задан с параметром -A, который позволит нам использовать любую строку в качестве нашего индекса.

Функция ассоциативного массива предусмотрена в bash версии 4.0 и выше. В таком массиве индекс не обязательно должен быть числом и может быть представлен в виде любой строки. Таким образом, вы можете индексировать массив по IP-адресу и подсчитывать количество обращений этого IP-адреса. В случае если вы используете версию программы старше, чем bash 4.0, альтернативой этому сценарию будет сценарий, показанный в примере 7.4. Здесь вместо ассоциативного массива используется команда awk.

В bash для ссылок на массив, как и для ссылок на элемент массива, используется синтаксис ${var[index]}. Чтобы получить все возможные значения индекса (ключи, если эти массивы рассматриваются как пара («ключ/значение»)), укажите ${!cnt[@]}.

2 Хотя мы ожидаем в строке только одно слово ввода, добавим переменную xtra, чтобы захватить любые другие слова, которые появятся в строке. Каждой переменной в команде read присваивается соответствующее слово из входных данных (то есть первая переменная получает первое слово, вторая переменная — второе слово и т. д.). При этом последняя переменная получает все оставшиеся слова. С другой стороны, если в строке входных слов меньше, чем переменных в команде read, этим дополнительным переменным присваивается пустая строка. Поэтому в нашем примере, если в строке ввода есть дополнительные слова, они все будут присвоены переменной xtra. Если же нет дополнительных слов, переменной xtra будет присвоено значение null.

3 Строка используется в качестве индекса и увеличивает его предыдущее значение. При первом использовании индекса предыдущее значение не будет установлено и он будет равен 0.

4 Данный синтаксис позволяет нам перебирать все различные значения индекса. Обратите внимание: нельзя гарантировать, что при сортировке мы получим