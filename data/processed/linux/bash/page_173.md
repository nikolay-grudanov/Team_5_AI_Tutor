---
source_image: page_173.png
page_number: 173
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 11.46
tokens: 7690
characters: 1700
timestamp: 2025-12-23T23:08:21.571366
finish_reason: stop
---

деления количества возвращаемых байтов добавьте параметр -l (для десятичного формата). Начальную позицию и длину также можно указать в шестнадцатеричном формате, добавив к числу символы 0x (то есть 0x2A). Как и ожидалось, мы увидели магическое число ELF:

$ xxd -s 0 -l 4 helloworld

00000000: 7f45 4c46 .ELF

Пятый байт файла покажет вам архитектуру этого файла: является ли он 32-разрядным (0x01) или 64-разрядным (0x02) исполняемым файлом. В данном случае это 64-разрядный исполняемый файл:

$ xxd -s 4 -l 1 helloworld

00000004: 02

Шестой байт описывает порядок записи байтов: little-endian (от младшего к старшему) (0x01) или big-endian (от старшего к младшему) (0x02). В данном случае порядок записи байтов little-endian:

$ xxd -s 5 -l 1 helloworld

00000005: 01

Формат и порядок байтов — важная информация, используемая для анализа остальной части файла. Например, 8 байт 64-битного файла ELF, начинающихся с 0x20, определяют заголовок программы:

$ xxd -s 0x20 -l 8 helloworld

00000020: 4000 0000 0000 0000

Нам уже известно, что порядок записи нашего файла — little-endian, поэтому заголовок начинается с 0x40.

Эти данные мы можем использовать для отображения заголовка программы, длина которого для 64-битного ELF-файла должна составлять 0x38 байт:

$ xxd -s 0x40 -l 0x38 helloworld

00000040: 0600 0000 0500 0000 4000 0000 0000 0000 .......@.....
00000050: 4000 4000 0000 0000 4000 4000 0000 0000 @.@....@.@....
00000060: f801 0000 0000 0000 f801 0000 0000 0000 .............
00000070: 0800 0000 0000 0000

Дополнительные сведения о формате файла Linux ELF можно найти в спецификации Tool Interface Standard (TIS) и Executable and Linking Format (ELF) по адресу http://bit.ly/2HVOMu7.