---
source_image: page_036.png
page_number: 36
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 9.35
tokens: 7460
characters: 1803
timestamp: 2025-12-23T23:02:55.787228
finish_reason: stop
---

Если вы хотите выполнить численное сравнение со знаком «меньше», используйте конструкцию с двойными скобками. Предполагается, что все переменные являются числовыми, поэтому они так и будут оцениваться. Пустые или неустановленные переменные оцениваются как 0. Внутри скобок вам не нужен оператор $ для получения значения, за исключением позиционных параметров, таких как $1 и $2 (чтобы не путать их с константами 1 и 2). Например:

if (( VAL < 12 ))
then
    echo "value $VAL is too small"
fi

В двойных скобках воспроизводится числовая (C/Java/Python) логика повышенного уровня. Любое ненулевое значение считается истинным, и только ноль — обратное значение всем остальным операторам if в bash — ложным. Например:

if (( $? )) ; then echo "previous command failed" ; fi

сделает то, что вы хотите/ожидаете, — если предыдущая команда завершилась неудачно, то $? будет содержать ненулевое значение; внутри (( )) ненулевое значение будет истинным и ветвь then будет выполнена.

В bash вы можете даже принимать решения о ветвлении без явной конструкции if/then. Команды обычно разделяются новой строкой, то есть вводятся по одной команде на строку. Можно достичь того же эффекта, разделяя их точкой с запятой. Если вы пишете cd $DIR ; ls, bash сначала выполнит команду cd, а затем команду ls.

Две команды также могут быть разделены символами && или ||. Если вы напишете cd $DIR && ls, команда ls будет выполняться только в случае успешного выполнения команды cd. Аналогично, если вы введете cd $DIR || echo cd failed, сообщение будет напечатано только в случае сбоя команды cd.

Вы можете использовать синтаксис [[ для выполнения различных тестов, даже без задания в явном виде if:

[[ -d $DIR ]] && ls "$DIR"

Это работает так же, как если бы вы написали следующее:

if [[ -d $DIR ]]
then
    ls "$DIR"
fi