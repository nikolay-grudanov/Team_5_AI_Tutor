---
source_image: page_123.png
page_number: 123
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 10.73
tokens: 7536
characters: 1931
timestamp: 2025-12-23T23:06:24.506364
finish_reason: stop
---

max=0
maxbar=50    # размер самой длинной строки

ndx=0
while read labl val
do
    RA_key[$ndx]=$labl
    RA_value[$ndx]=$val
    # сохранить наибольшее значение; для масштабирования
    (( val > max )) && max=$val
    let ndx++
done

# масштабировать и вывести
for ((j=0; j<ndx; j++))
do
    printf "%-20.20s " ${RA_key[$j]}
    pr_bar ${RA_value[$j]} $max
done

Эта версия сценария позволяет избежать использования ассоциативных массивов (например, в более старых версиях bash или в системах macOS). Здесь мы применяем два отдельных массива: один для индексного значения и один — для счетчиков. Поскольку это обычные массивы, мы должны использовать целочисленный индекс и будем вести простой подсчет в переменной ndx.

1 Здесь имена переменных объявляются как массивы. Строчная а указывает, что они являются массивами, но это не ассоциативные массивы. Это не обязательное требование, зато рекомендуемая практика. Аналогично в следующей строке мы задаем параметр -i для объявления этих переменных целыми числами, что делает их более эффективными, чем необъявленные переменные оболочки (которые хранятся в виде строк). Повторимся: как видно из того, что мы не объявляем maxbar, а просто используем его, это необязательное требование.

2 Пары «ключ/значение» хранятся в отдельных массивах, но в одном и том же месте индекса. Это ненадежный подход — изменения в сценарии в какой-то момент могут привести к тому, что два массива не синхронизируются.

3 Цикл for, в отличие от предыдущего сценария, используется для простого подсчета целых чисел от 0 до ndx. Здесь переменная j выступает препятствием для индекса в цикле for внутри сценария pr_bar, несмотря на то что внутри функции мы достаточно аккуратно объявляем эту версию i как локальную функцию. Вы доверяете этой функции? Измените здесь j на i и проверьте, работает ли цикл (а он работает). Затем попробуйте удалить локальное объявление и проверить, успешно ли завершится цикл.