---
source_image: page_040.png
page_number: 40
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 9.86
tokens: 7513
characters: 2047
timestamp: 2025-12-23T23:03:07.253683
finish_reason: stop
---

В определении функции параметры не объявляются. Какие бы аргументы и их количество при вызове функции ни приводились, они передаются этой функции.

Функция вызывается (активизируется) так же, как и любая команда в командной оболочке. Определив myfun как функцию, вы можете вызвать ее следующим образом:

myfun 2 /arb "14 years"

Эта команда вызывает функцию myfun, предоставляя ей три аргумента.

Аргументы функции

Внутри определения функции аргументы упоминаются так же, как параметры сценария оболочки, то есть как $1, $2 и т. д. Это означает, что аргументы «скрывают» параметры, первоначально переданные в сценарий. Если вы хотите получить доступ к первому параметру скрипта, то перед вызовом функции нужно сохранить $1 в переменной (или передать его в качестве параметра функции).

Другие переменные установлены соответственно: $# выдает количество аргументов, переданных функции, хотя обычно мы получаем количество аргументов, переданных самому сценарию. Единственное исключение — $0, которая в функции не изменяется. Она сохраняет свое значение как имя скрипта, а не функции.

Возвращаемые значения

Функции, как и команды, должны возвращать статус: 0, если все идет хорошо, и значение, отличное от нуля, если произошла ошибка. Чтобы возвращать другие типы значений (например, пути или вычисленные значения), можно установить для хранения значения переменную, потому что переменные являются глобальными, если они не объявлены локально внутри функции. Кроме того, вы можете отправить результат в stdout, то есть напечатать ответ. Только не пытайтесь делать и то и другое одновременно.

Если ваша функция выводит ответ, вы можете использовать этот вывод как часть конвейера команд (например, myfunc args | next step | etc). Или можете захватить вывод следующим образом: RETVAL = $ (myfunc args). В обоих случаях функция будет выполняться в подоболочке, а не в текущей оболочке. Таким образом, изменения любых глобальных переменных будут эффективны только в этой подоболочке, а не в основном экземпляре оболочки. Фактически они будут потеряны.