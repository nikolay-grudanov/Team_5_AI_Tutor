---
source_image: page_164.png
page_number: 164
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 15.48
tokens: 8040
characters: 792
timestamp: 2025-12-24T00:35:43.664441
finish_reason: stop
---

top=top,
    status=state)
var.frame.pack(side=LEFT, expand=YES,
        padx=2, pady=6)
idx = idx + 1

This code is not quite so elegant, but it allows access to the methods of the instance:

self.swin0.turnon()
self.swin3.blinkon()

There will be several examples of using composite widgets and inherited methods in examples in later chapters.

7.3 Summary

In this chapter we have seen how we can build classes to define quite complex GUI objects and that these can be instantiated so that they exhibit quite different appearance even though the underlying behavior of the objects is quite similar. I have demonstrated the use of mixin classes to encapsulate common properties within related classes, and I have given you some insight into the way that Python handles multiple-inheritance.