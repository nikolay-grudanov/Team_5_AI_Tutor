---
source_image: page_154.png
page_number: 154
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 40.49
tokens: 8396
characters: 2233
timestamp: 2025-12-24T00:35:42.242961
finish_reason: stop
---

if not self.onState:
    self.onState = self.status
    self.status = STATUS_OFF
    self.on = 0
else:
    if self.onState:
        self.status = self.onState  # Current ON color
        self.on = 1

    # Set color for current status
    self.canvas.itemconfig(self.light, fill=self.Colors[self.status])

    self.canvas.update_idletasks()

    if self.blink:
        self.frame.after(self.blinkrate * 1000, self.update)

Code comments
① First, we import the newly-created constants file and the GUI mixins.
② We inherit from the GUICommon mixin. This mixin does not have a constructor so we do not need to call it.
③ We build a list of colors, which act as an enumeration when we key by current status.
④ We extract the appropriate list of x/y coordinate data and eval each value to calculate the offset based on the current location.

7.1.2 What has changed?
Actually, we have not changed very much. We have removed some common code and created a mixin class to allow us to create a superclass to contain some of the reusable code. To eliminate at least one of the if-elif-else constructs we have made color attributes for the class into a list. The ugly code to draw arrowheads has been replaced by a list reference to the arrowhead vertices. Similarly, the references to statuses have been converted to a reference to a list. Finally, we’ve changed the appearance of some of the LEDs by changing sizes and outlines so that you know that we have not just copied figure 7.1!

If Example_7_2.py is run, we’ll observe a screen similar to the one generated by the previous example (figure 7.2). I don’t expect you to see any change in the execution of the example, but the Python code is somewhat more compact.

7.2 Building a class library
Now that we have seen the concept of mixin classes and subclassing at work, we can start to build our class library of useful objects for our GUIs. There is often a need to create a series of coordinated colors in our displays, so let’s create a routine to create a range of coordinated shades from a base color.

First, we have to extend our GUICommon class to add some color transformation methods. Here are the mixin methods that we will add to GUICommon_7_1.py to create GUICommon_7_2.py: