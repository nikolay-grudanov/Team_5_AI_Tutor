---
source_image: page_257.png
page_number: 257
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 28.00
tokens: 8245
characters: 1555
timestamp: 2025-12-24T00:38:33.318068
finish_reason: stop
---

self._chkSioExec(SioRxClear, (port,))
self._chkSioExec(SioDTR, (port, cfg['dtrSignal'][1:]))
self._chkSioExec(SioRTS, (port, cfg['rtsSignal'][1:]))
self._chkSioExec(SioFlow, (port, 'N'))

Running Example_9_2.py displays the multimeter. Since there are no changes to the display methods, the display is indistinguishable from the one shown in figure 9.12, so it will not be shown here.

9.6 Virtual machines using POV-Ray

Of course, some applications may not have a physical device; for these cases, it is possible to create ray-traced images (using Persistence of Vision POV-Ray, or other rendering systems, for example) to create virtual machines.

Figure 9.14 shows an example of a ray-traced GUI which has been used in a commercial application. This employs the same overlay technique used to develop the front panel shown in figure 9.9, except that the image was completely fabricated. The application that this GUI supported was intended to be used by airline pilots, and so the display is constructed to be similar to some of the radio stacks encountered in aircraft. The GUI has a strong three-dimensional content, with shadows and highlights. All of this is computer generated by POV-Ray. The text, LEDs and navigable buttons are overlaid Tkinter widgets. The important feature to note is that the application has nothing to do with radio stacks; it is really a database access application. This is an application with punch!

![Ray-traced user interface](../images/fig9-14.png)

Figure 9.14 Ray-traced user interface
Photo courtesy INVOTEC, Inc.