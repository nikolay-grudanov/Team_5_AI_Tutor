---
source_image: page_459.png
page_number: 459
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 26.23
tokens: 7487
characters: 1905
timestamp: 2025-12-24T01:03:05.350046
finish_reason: stop
---

и дождливым полуднем), а также проигнорировали корреляции между днями (такие как возможное влияние дождливого вторника на показатели среды или влияние внезапного солнечного дня после полосы дождливых). Это все очень интересные влияния, и у вас, если захотите, теперь есть инструменты для их исследования!

Заглянем глубже: метод опорных векторов

Метод опорных векторов (support vector machines, SVMs) — очень мощный и гибкий класс алгоритмов обучения с учителем как для классификации, так и регрессии. В этом разделе мы научимся интуитивно понимать, как использовать метод опорных векторов в задачах классификации.

Начнем с обычных импортов:

In[1]: %matplotlib inline
    import numpy as np
    import matplotlib.pyplot as plt
    from scipy import stats

    # Воспользуемся настройками по умолчанию библиотеки Seaborn
    import seaborn as sns; sns.set()

Основания для использования метода опорных векторов

В ходе нашего обсуждения байесовской классификации (см. раздел «Заглянем глубже: наивная байесовская классификация» данной главы) мы изучили простую модель, описывающую распределение всех базовых классов, и воспользовались подобными порождающими моделями для вероятностного определения меток для новых точек. Это был пример порождающей классификации (generative classification), здесь же мы рассмотрим разделяющую классификацию (discriminative classification).

Вместо моделирования каждого из классов мы найдем прямую или кривую (в двумерном пространстве) или многообразие (в многомерном пространстве), отделяющее классы друг от друга.

В качестве примера рассмотрим простой случай задачи классификации, в котором два класса точек вполне разделены (рис. 5.53):

In[2]: from sklearn.datasets.samples_generator import make_blobs
    X, y = make_blobs(n_samples=50, centers=2,
                      random_state=0, cluster_std=0.60)
    plt.scatter(X[:, 0], X[:, 1], c=y, s=50, cmap='autumn');