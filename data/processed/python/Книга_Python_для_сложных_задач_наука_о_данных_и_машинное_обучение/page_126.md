---
source_image: page_126.png
page_number: 126
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 38.37
tokens: 7864
characters: 2421
timestamp: 2025-12-24T00:54:57.663756
finish_reason: stop
---

In[11]: np.dtype({'names':('name', 'age', 'weight'),
    'formats':((np.str_, 10), int, np.float32)})

Out[11]: dtype([('name', '<U10'), ('age', '<i8'), ('weight', '<f4')])

Составные типы данных можно задавать в виде списка кортежей:

In[12]: np.dtype([('name', 'S10'), ('age', 'i4'), ('weight', 'f8')])

Out[12]: dtype([('name', 'S10'), ('age', '<i4'), ('weight', '<f8')])

Если названия типов для вас не важны, можете задать только сами типы данных в разделенной запятыми строке:

In[13]: np.dtype('S10,i4,f8')

Out[13]: dtype([('f0', 'S10'), ('f1', '<i4'), ('f2', '<f8')])

Сокращенные строковые коды форматов могут показаться запутанными, но они основаны на простых принципах. Первый (необязательный) символ — < или >, означает «число с прямым порядком байтов» или «число с обратным порядком байтов» соответственно и задает порядок значащих битов. Следующий символ задает тип данных: символы, байтовый тип, целые числа, числа с плавающей точкой и т. д. (табл. 2.6). Последний символ или символы отражают размер объекта в байтах.

Таблица 2.6. Типы данных библиотеки NumPy

<table>
  <tr>
    <th>Символ</th>
    <th>Описание</th>
    <th>Пример</th>
  </tr>
  <tr>
    <td>'b'</td>
    <td>Байтовый тип</td>
    <td>np.dtype('b')</td>
  </tr>
  <tr>
    <td>'i'</td>
    <td>Знаковое целое число</td>
    <td>np.dtype('i4') == np.int32</td>
  </tr>
  <tr>
    <td>'u'</td>
    <td>Беззнаковое целое число</td>
    <td>np.dtype('u1') == np.uint8</td>
  </tr>
  <tr>
    <td>'f'</td>
    <td>Число с плавающей точкой</td>
    <td>np.dtype('f8') == np.int64</td>
  </tr>
  <tr>
    <td>'c'</td>
    <td>Комплексное число с плавающей точкой</td>
    <td>np.dtype('c16') == np.complex128</td>
  </tr>
  <tr>
    <td>'S', 'a'</td>
    <td>Строка</td>
    <td>np.dtype('S5')</td>
  </tr>
  <tr>
    <td>'U'</td>
    <td>Строка в кодировке Unicode</td>
    <td>np.dtype('U') == np.str_</td>
  </tr>
  <tr>
    <td>'V'</td>
    <td>Неформатированные данные (тип void)</td>
    <td>np.dtype('V') == np.void</td>
  </tr>
</table>

Более продвинутые типы данных

Можно описывать и еще более продвинутые типы данных. Например, можно создать тип, в котором каждый элемент содержит массив или матрицу значений. В следующем примере мы создаем тип данных, содержащий компонент mat, состоящий из матрицы 3 × 3 значения с плавающей точкой:

In[14]: tp = np.dtype([('id', 'i8'), ('mat', 'f8', (3, 3))])
        X = np.zeros(1, dtype=tp)