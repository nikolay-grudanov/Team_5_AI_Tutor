---
source_image: page_121.png
page_number: 121
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 35.40
tokens: 7589
characters: 1572
timestamp: 2025-12-24T00:54:46.893213
finish_reason: stop
---

In[20]: dist_sq.diagonal()

Out[20]: array([ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.])

Проверка пройдена! Теперь, получив матрицу квадратов расстояний между взятыми попарно точками, мы можем воспользоваться функцией np.argsort для сортировки по каждой строке. Крайние слева столбцы будут представлять собой индексы ближайших соседей:

In[21]: nearest = np.argsort(dist_sq, axis=1)
    print(nearest)

[[0 3 9 7 1 4 2 5 6 8]
 [1 4 7 9 3 6 8 5 0 2]
 [2 1 4 6 3 0 8 9 7 5]
 [3 9 7 0 1 4 5 8 6 2]
 [4 1 8 5 6 7 9 3 0 2]
 [5 8 6 4 1 7 9 3 2 0]
 [6 8 5 4 1 7 9 3 2 0]
 [7 9 3 1 4 0 5 8 6 2]
 [8 5 6 4 1 7 9 3 2 0]
 [9 7 3 0 1 4 5 8 6 2]]

Обратите внимание, что первый столбец представляет собой числа с 0 до 9 в порядке возрастания: это происходит из-за того, что ближайший сосед каждой точки — она сама, как и можно было ожидать.

Выполнив полную сортировку, мы проделали лишнюю работу. Если нас интересовали K ближайших соседей, было достаточно секционировать все строки так, чтобы сначала шли K+1 минимальных квадратов расстояний, а большие расстояния заполняли оставшиеся позиции массива. Сделать это можно с помощью функции np.argpartition:

In[22]: K = 2
    nearest_partition = np.argpartition(dist_sq, K + 1, axis=1)

Чтобы визуализировать эту сетку соседей, выведем на диаграмму точки вдоль линий, связывающих каждую точку с ее ближайшими двумя соседями (рис. 2.11):

In[23]: plt.scatter(X[:, 0], X[:, 1], s=100)

    # Рисуем линии из каждой точки к ее двум ближайшим соседям
    K = 2

    for i in range(X.shape[0]):
        for j in nearest_partition[i, :K+1]: