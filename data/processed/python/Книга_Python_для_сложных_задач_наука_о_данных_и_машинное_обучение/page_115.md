---
source_image: page_115.png
page_number: 115
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 32.49
tokens: 7608
characters: 2203
timestamp: 2025-12-24T00:54:35.861169
finish_reason: stop
---

Эта функция создаст практически точно такую же диаграмму, как на рис. 2.9. Для расчета разбиения по интервалам библиотека Matplotlib использует функцию np.histogram, выполняющую вычисления, очень похожие на сделанные нами. Давайте сравним их:

In[25]: print("NumPy routine:")
    %timeit counts, edges = np.histogram(x, bins)
    print("Custom routine:")
    %timeit np.add.at(counts, np.searchsorted(bins, x), 1)

NumPy routine:
10000 loops, best of 3: 97.6 µs per loop
Custom routine:
10000 loops, best of 3: 19.5 µs per loop

Наш собственный односторочный алгоритм работает в несколько раз быстрее, чем оптимизированный алгоритм из библиотеки NumPy! Как это возможно? Если мы заглянем в исходный код процедуры np.histogram (в оболочке IPython это можно сделать, введя команду np.histogram??), то увидим, что она гораздо сложнее простого поиска-и-подсчета, выполненного нами. Дело в том, что алгоритм из библиотеки NumPy более гибок, потому что разработан с ориентацией на более высокую производительность при значительном увеличении количества точек данных:

In[26]: x = np.random.randn(1000000)
    print("NumPy routine:")
    %timeit counts, edges = np.histogram(x, bins)

    print("Custom routine:")
    %timeit np.add.at(counts, np.searchsorted(bins, x), 1)

NumPy routine:
10 loops, best of 3: 68.7 ms per loop
Custom routine:
10 loops, best of 3: 135 ms per loop

Это сравнение демонстрирует нам, что эффективность алгоритма почти всегда не-простой вопрос. Эффективный для больших наборов данных алгоритм не всегда окажется оптимальным вариантом для маленьких, и наоборот (см. врезку «Нотация “О-большого”» далее). Но преимущество самостоятельного программирования этого алгоритма заключается в том, что, получив понимание работы подобных простых методов, вы сможете «строить» из этих «кирпичиков» очень интересные варианты пользовательского поведения. Ключ к эффективному использованию языка Python в приложениях, требующих обработки больших объемов данных, заключается в том, чтобы знать о существовании удобных процедур, таких как np.histogram, и сферах их использования. Кроме того, нужно знать, как применять низкоуровневую функциональность при необходимости в узконаправленном поведении.