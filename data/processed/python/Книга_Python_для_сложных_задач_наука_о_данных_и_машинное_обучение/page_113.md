---
source_image: page_113.png
page_number: 113
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 33.85
tokens: 7629
characters: 1891
timestamp: 2025-12-24T00:54:34.043843
finish_reason: stop
---

Замечу, однако, что повторяющиеся индексы при подобных операциях могут привести к некоторым потенциально неожиданным результатам. Рассмотрим следующий пример:

In[20]: x = np.zeros(10)
    x[[0, 0]] = [4, 6]
    print(x)

[ 6.  0.  0.  0.  0.  0.  0.  0.  0.]

Куда пропало 4? В результате этой операции сначала выполняется присваивание x[0] = 4 с последующим присваиванием x[0] = 6. В итоге x[0] содержит значение 6.

Довольно логично, но рассмотрим такую операцию:

In[21]: i = [2, 3, 3, 4, 4, 4]
    x[i] += 1
    x

Out[21]: array([ 6.,  0.,  1.,  1.,  1.,  0.,  0.,  0.,  0.,  0.])

Можно было ожидать, что x[3] будет содержать значение 2, а x[4] — значение 3, так как именно столько раз повторяется каждый из этих индексов. Почему же это не так? По сути, не из-за того, что выражение x[i] += 1 задумывалось как сокращенная форма записи для x[i] = x[i] + 1. Вычисляется выражение x[i] + 1, после чего результат присваивается соответствующим индексам элементам в массиве x. Получается, что это не выполняемый несколько раз инкремент, а присваивание, приводящее к интуитивно не очевидным результатам.

Что же делать, если требуется другое поведение при повторяющейся операции? В этом случае можно воспользоваться методом at() универсальных функций (доступен начиная с версии 1.8 библиотеки NumPy) и сделать следующее:

In[22]: x = np.zeros(10)
    np.add.at(x, i, 1)
    print(x)

[ 0.  0.  1.  2.  3.  0.  0.  0.  0.  0.]

Метод at() применяет соответствующий оператор к элементам с заданными индексами (в данном случае i) с использованием заданного значения (в данном случае 1). Аналогичный по духу метод универсальных функций reduceat(), о котором можно прочитать в документации библиотеки NumPy.

Пример: разбиение данных на интервалы

Можно использовать эти идеи для эффективного разбиения данных с целью построения гистограммы вручную. Например, пусть у нас есть 1000 значений и нам