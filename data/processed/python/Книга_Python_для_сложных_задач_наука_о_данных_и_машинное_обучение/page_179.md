---
source_image: page_179.png
page_number: 179
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 27.31
tokens: 7496
characters: 1773
timestamp: 2025-12-24T00:55:55.546632
finish_reason: stop
---

более сложных соединений и сливаний в стиле баз данных, корректно обрабатывающих все возможные частичные совпадения наборов. Объекты Series и DataFrame созданы в расчете на подобные операции, и библиотека Pandas содержит функции и методы для быстрого и удобного выполнения таких манипуляций.

Мы рассмотрим простую конкатенацию объектов Series и DataFrame с помощью функции pd.concat, углубимся в реализованные в библиотеке Pandas более запутанные слияния и соединения, выполняемые в оперативной памяти.

Начнем с обычных импортов:

In[1]: import pandas as pd
        import numpy as np

Для удобства опишем следующую функцию, создающую объект DataFrame определенной формы, которая нам пригодится в дальнейшем:

In[2]: def make_df(cols, ind):
        """Быстро создаем объект DataFrame"""
        data = {c: [str(c) + str(i) for i in ind]
                for c in cols}
        return pd.DataFrame(data, ind)

    # Экземпляр DataFrame
    make_df('ABC', range(3))

Out[2]:    A   B   C
           0  A0  B0  C0
           1  A1  B1  C1
           2  A2  B2  C2

Напоминание: конкатенация массивов NumPy

Конкатенация объектов Series и DataFrame очень похожа на конкатенацию массивов библиотеки NumPy, которую можно осуществить посредством функции np.concatenate, обсуждавшейся в разделе «Введение в массивы библиотеки NumPy» главы 2. Напомним, что таким образом можно объединять содержимое двух или более массивов в один:

In[4]: x = [1, 2, 3]
        y = [4, 5, 6]
        z = [7, 8, 9]
        np.concatenate([x, y, z])

Out[4]: array([1, 2, 3, 4, 5, 6, 7, 8, 9])

Первый аргумент данной функции — список или кортеж объединяемых массивов. Кроме того, она принимает на входе ключевое слово axis, дающее возможность задавать ось, по которой будет выполняться конкатенация: