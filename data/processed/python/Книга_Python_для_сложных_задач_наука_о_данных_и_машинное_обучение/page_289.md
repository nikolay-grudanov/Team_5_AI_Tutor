---
source_image: page_289.png
page_number: 289
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 32.33
tokens: 7464
characters: 1804
timestamp: 2025-12-24T00:58:53.072576
finish_reason: stop
---

Шкала цветов наглядно демонстрирует, что черные области — точки максимума, а красные — точки минимума.

Потенциальная проблема этого графика — его « пятнистость ». Дело в том, что градации цветов здесь дискретны, а не непрерывны, что не всегда удобно. Исправить это можно путем задания очень большого количества контуров, что приведет к низкой производительности: библиотеке Matplotlib придется визуализировать новый полигон для каждого шага уровня. Лучшее решение — воспользоваться функцией plt.imshow(), интерпретирующей двумерную сетку данных как изображение.

На рис. 4.33 показан результат выполнения следующего кода:

In[7]: plt.imshow(Z, extent=[0, 5, 0, 5], origin='lower', cmap='RdGy')
    plt.colorbar()
    plt.axis(aspect='image');

Однако есть несколько потенциальных проблем и с функцией imshow().

□ Функция plt.imshow() не принимает в качестве параметров координатные сетки x и y, так что вам придется вручную задать размеры изображения на графике: extent [xmin, xmax, ymin, ymax].

□ По умолчанию функция plt.imshow() следует стандартному определению массива для изображения, в котором начало координат находится в верхнем левом, а не в нижнем левом углу, как на большинстве контурных графиков. Это поведение можно изменить в случае отображения данных с привязкой к сетке.

□ Функция plt.imshow() автоматически настраивает соотношение сторон графика в соответствии с входными данными. Это поведение можно изменить, задав, например, plt.axis(aspect='image'), чтобы отрезки по осям X и Y были одинаковыми.

![Представляем трехмерные данные в виде изображения](../images/fig_4_33.png)

Рис. 4.33. Представляем трехмерные данные в виде изображения

Иногда удобно комбинировать контурный график с графиком-изображением. Например, для создания показанного на рис. 4.34 эффекта мы воспользуемся