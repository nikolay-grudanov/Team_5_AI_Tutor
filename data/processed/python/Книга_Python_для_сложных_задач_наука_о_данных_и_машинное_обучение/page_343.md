---
source_image: page_343.png
page_number: 343
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 45.44
tokens: 7752
characters: 2442
timestamp: 2025-12-24T01:00:28.263497
finish_reason: stop
---

Пример: визуализация ленты Мебиуса. Лента Мебиуса представляет собой полоску бумаги, склеенную в кольцо концами, перевернутыми на 180 градусов. Она весьма интересна топологически, поскольку у нее, несмотря на внешний вид, только одна сторона! В этом разделе мы визуализируем ее с помощью трехмерных инструментов библиотеки Matplotlib. Ключ к созданию ленты Мебиуса — ее параметризация. Это двумерная лента, поэтому нам понадобятся для нее две собственные координаты. Назовем одну из них \( \theta \) (ее диапазон значений — от 0 до \( 2\pi \)), а вторую — \( w \), с диапазоном значений от \(-1\) на одном краю ленты (по ширине) до 1 на другом:

In[14]: theta = np.linspace(0, 2 * np.pi, 30)
w = np.linspace(-0.25, 0.25, 8)
w, theta = np.meshgrid(w, theta)

Теперь нам нужно на основе этой параметризации вычислить координаты \((x, y, z)\) ленты.

Размышляя, можно понять, что в данном случае происходят два вращательных движения: одно — изменение расположения кольца относительно его центра (координата, которую мы назвали \( \theta \)), а второе — скручивание полоски относительно ее оси координат (назовем эту координату \( \varphi \)). Чтобы получилась лента Мебиуса, полоска должна выполнить половину скручивания за время полного сворачивания в кольцо, то есть \( \Delta \varphi = \Delta \theta / 2 \).

In[15]: phi = 0.5 * theta

Теперь вспомним тригонометрию, чтобы выполнить трехмерное наложение. Определим переменную \( r \) — расстояние каждой точки от центра и воспользуемся ею для нахождения внутренних координат \((x, y, z)\):

In[16]: # радиус в плоскости X-Y
    r = 1 + w * np.cos(phi)
    x = np.ravel(r * np.cos(theta))
    y = np.ravel(r * np.sin(theta))
    z = np.ravel(w * np.sin(phi))

Для построения графика этого объекта нужно убедиться, что триангуляция выполнена правильно. Лучший способ сделать это — описать триангуляцию в координатах базовой параметризации, после чего позволить библиотеке Matplotlib выполнить проекцию полученной триангуляции в трехмерное пространство ленты Мебиуса. Это можно сделать следующим образом (рис. 4.101):

In[17]: # Выполняем триангуляцию в координатах базовой параметризации
    from matplotlib.tri import Triangulation
    tri = Triangulation(np.ravel(w), np.ravel(theta))

    ax = plt.axes(projection='3d')
    ax.plot_trisurf(x, y, z, triangles=tri.triangles,
                    cmap='viridis', linewidths=0.2);

    ax.set_xlim(-1, 1); ax.set_ylim(-1, 1); ax.set_zlim(-1, 1);