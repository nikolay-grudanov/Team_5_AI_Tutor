---
source_image: page_493.png
page_number: 493
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 38.85
tokens: 7599
characters: 1991
timestamp: 2025-12-24T01:04:09.614259
finish_reason: stop
---

Вспомним, что означают эти компоненты: полный набор данных представляет собой 64-мерное облако, а эти точки — проекции каждой из точек данных вдоль направлений максимальной дисперсии. По существу, мы нашли оптимальные растяжение и вращение в 64-мерном пространстве, позволяющие увидеть, как цифры выглядят в двух измерениях, причем сделать это с помощью метода без учителя, то есть безотносительно меток.

В чем смысл компонент?

Заглянем еще глубже и спросим себя, что означает понижение размерности. Ответ на этот вопрос удобнее всего выразить в терминах сочетаний базисных векторов. Например, каждое изображение из обучающей последовательности описывается набором 64 значений пикселов, которые мы назовем вектором \( x \):

\[
x = [X_1, X_2, X_3 ... X_{64}].
\]

Мы можем рассматривать это в терминах пиксельного базиса, то есть для формирования изображения необходимо умножить каждый элемент вышеприведенного вектора на значение описываемого им пикселя, после чего сложить результаты:

\[
\text{image}(x) = x_1 \times (\text{пиксел 1}) + x_2 \times (\text{пиксел 2}) + x_3 \times (\text{пиксел 3}) + ... + x_{64} \times (\text{пиксел 64}).
\]

Один из возможных способов понижения размерности этих данных — обнуление большей части базисных векторов. Например, если мы будем использовать только первые восемь пикселов, то получим восьмимерную проекцию данных (рис. 5.85), но она будет плохо отражать изображение в целом: мы отбрасываем почти 90 % пикселов!

![Наивный метод понижения размерности путем отбрасывания пикселов](https://i.imgur.com/3Q5z5QG.png)

Рис. 5.85. Наивный метод понижения размерности путем отбрасывания пикселов

Верхний ряд на рисунке демонстрирует отдельные пиксели, а нижний — общий вклад этих пикселов в структуру изображения. С помощью только восьми из компонент пиксельного базиса можно сконструировать лишь небольшую часть 64-пиксельного изображения. Продолжив эту последовательность действий и использовав все 64 пикселя, мы бы получили исходное изображение.