---
source_image: page_228.png
page_number: 228
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 24.51
tokens: 7487
characters: 1810
timestamp: 2025-12-24T00:57:12.970594
finish_reason: stop
---

50%      221.000000
75%      314.000000
max      9067.000000
Name: ingredients, dtype: float64

Средняя длина списка ингредиентов составляет 250 символов при минимальной длине 0 и максимальной — почти 10 000 символов!

Из любопытства посмотрим, у какого рецепта самый длинный список ингредиентов:

In[24]: recipes.name[np.argmax(recipes.ingredients.str.len())]

Out[24]: 'Carrot Pineapple Spice & Brownie Layer Cake with Whipped Cream & Cream Cheese Frosting and Marzipan Carrots'

Этот рецепт явно выглядит не очень простым.

Можно сделать и другие открытия на основе сводных показателей. Например, посмотрим, сколько рецептов описывают еду, предназначенную для завтрака:

In[33]: recipes.description.str.contains('[Bb]reakfast').sum()

Out[33]: 3524

Или сколько рецептов содержат корицу (cinnamon) в списке ингредиентов:

In[34]: recipes.ingredients.str.contains('[Cc]innamon').sum()

Out[34]: 10526

Можно даже посмотреть, есть ли рецепты, в которых название этого ингредиента написано с орфографической ошибкой, как cinamon:

In[27]: recipes.ingredients.str.contains('[Cc]inamom').sum()

Out[27]: 11

Такая разновидность обязательного предварительного изучения данных возможна благодаря инструментам по работе со строками библиотеки Pandas. Именно в сфере такой очистки данных Python действительно силен.

Простая рекомендательная система для рецептов

Немного углубимся в этот пример и начнем работу над простой рекомендательной системой для рецептов: по заданному списку ингредиентов необходимо найти рецепт, использующий их все. Концептуально простая, эта задача усложняется неоднородностью данных: не существует удобной операции, которая позволила бы извлечь из каждой строки очищенный список ингредиентов. Так что мы немного сжульничаем: начнем со списка распространенных ингредиентов и будем искать,