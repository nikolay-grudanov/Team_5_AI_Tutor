---
source_image: page_403.png
page_number: 403
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 33.86
tokens: 7525
characters: 1920
timestamp: 2025-12-24T01:01:48.326102
finish_reason: stop
---

In[21]:
iris['cluster'] = y_gmm
sns.lmplot("PCA1", "PCA2", data=iris, hue='species',
    col='cluster', fit_reg=False);

Разбив данные в соответствии с номерами кластеров, мы видим, насколько хорошо алгоритм GMM восстановил требуемые метки: вид setosa идеально выделен в кластер 0, правда, небольшое количество экземпляров видов versicolor и virginica смешались между собой. Следовательно, даже если у нас нет эксперта, который мог бы сообщить нам, к каким видам относятся отдельные цветки, одних измерений вполне достаточно для автоматического распознания этих различных разновидностей цветков с помощью простого алгоритма кластеризации! Подобный алгоритм может в дальнейшем помочь специалистам по предметной области выяснить связи между исследуемыми образцами.

Прикладная задача: анализ рукописных цифр

Продемонстрируем эти принципы на более интересной задаче, рассмотрев один из аспектов задачи оптического распознавания символов — распознавание рукописных цифр. Традиционно эта задача включает как определение местоположения на рисунке, так и распознание символов. Мы пойдем самым коротким путем и воспользуемся встроенным в библиотеку Scikit-Learn набором преформатированных цифр.

Загрузка и визуализация цифр

Воспользуемся интерфейсом доступа к данным библиотеки Scikit-Learn и посмотрим на эти данные:

In[22]: from sklearn.datasets import load_digits
    digits = load_digits()
    digits.images.shape

Out[22]: (1797, 8, 8)

Данные изображений представляют собой трехмерный массив: 1797 выборок, каждая состоит из сетки пикселов размером 8 × 8. Визуализируем первую их сотню (рис. 5.18):

In[23]: import matplotlib.pyplot as plt

    fig, axes = plt.subplots(10, 10, figsize=(8, 8),
        subplot_kw={'xticks':[], 'yticks':[]},
        gridspec_kw=dict(hspace=0.1, wspace=0.1))

    for i, ax in enumerate(axes.flat):
        ax.imshow(digits.images[i], cmap='binary',
            interpolation='nearest')