---
source_image: page_052.png
page_number: 52
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 28.38
tokens: 7433
characters: 1641
timestamp: 2025-12-24T00:52:50.843979
finish_reason: stop
---

В случае как %time, так и %timeit использование синтаксиса с двойным знаком процента блочной «магической» функции дает возможность оценивать время выполнения многострочных сценариев:

In[6]: %%time
    total = 0
    for i in range(1000):
        for j in range(1000):
            total += i * (-1) ** j

CPU times: user 504 ms, sys: 979 μs, total: 505 ms
Wall time: 505 ms

Для получения дальнейшей информации по «магическим» функциям %time и %timeit, а также их параметрам воспользуйтесь справочными функциями оболочки IPython (то есть наберите %time? в командной строке IPython).

Профилирование сценариев целиком: %prun

Программы состоят из множества отдельных операторов, и иногда оценка времени их выполнения в контексте важнее, чем по отдельности. В языке Python имеется встроенный профилировщик кода (о котором можно прочитать в документации языка Python), но оболочка IPython предоставляет намного более удобный способ его использования в виде «магической» функции %prun.

В качестве примера я опишу простую функцию, выполняющую определенные вычисления:

In[7]: def sum_of_lists(N):
    total = 0
    for i in range(5):
        L = [j ^ (j >> i) for j in range(N)]
        total += sum(L)
    return total

Теперь мы можем обратиться к «магической» функции %prun с указанием вызова функции, чтобы увидеть результаты профилирования:

In[8]: %prun sum_of_lists(1000000)

В блокноте результат будет выведен в пейджер¹ и будет выглядеть следующим образом:

14 function calls in 0.714 seconds

Ordered by: internal time

ncalls  tottime  percall  cumtime  percall filename:lineno(function)

¹ Область вывода в нижней части окна блокнота.