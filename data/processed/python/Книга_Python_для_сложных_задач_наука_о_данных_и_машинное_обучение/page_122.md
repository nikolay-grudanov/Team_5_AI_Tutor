---
source_image: page_122.png
page_number: 122
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 24.40
tokens: 7437
characters: 1591
timestamp: 2025-12-24T00:54:36.034473
finish_reason: stop
---

# чертим линию от X[i] до X[j]
# Используем для этого «магическую» функцию zip:
plt.plot(*zip(X[j], X[i]), color='black')

От каждой нарисованной на диаграмме точки ведут линии к двум ее ближайшим соседям. На первый взгляд может показаться странным, что из некоторых точек отходит более двух линий. Дело в том, что, если точка А — один из двух ближайших соседей точки В, вовсе не обязательно, что точка В — один из двух ближайших соседей точки А.

Хотя применяемые при этом транслирование и построчная сортировка могут показаться более запутанным подходом, чем написание цикла, оказывается, что такой способ работы с подобными данными на языке Python весьма эффективен. Как бы ни было заманчиво сделать то же самое, вручную организовав цикл по данным и сортировку каждого набора соседей отдельно, получившийся в итоге алгоритм почти наверняка будет работать медленнее, чем рассмотренная выше векторизованная версия. Красота такого подхода — в его независимости от размера входных данных: можно с одинаковой легкостью вычислить соседей среди 100 или 1 000 000 точек в любом количестве измерений, и код будет выглядеть точно так же.

![Визуализация соседей каждой точки](../images/2_11.png)

Рис. 2.11. Визуализация соседей каждой точки

Наконец, отмечу, что для выполнения поисков соседей в очень больших массивах данных существуют основанные на деревьях и/или аппроксимационные алгоритмы, масштабирующиеся как \( O[N \log N] \): или даже лучше, в отличие от грубого подхода \( O[N^2] \). Один из примеров таких алгоритмов — К-мерное дерево (KD-tree), реализованное в библиотеке Scikit-Learn.