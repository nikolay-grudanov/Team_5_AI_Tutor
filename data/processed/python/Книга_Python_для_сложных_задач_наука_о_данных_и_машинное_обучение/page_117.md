---
source_image: page_117.png
page_number: 117
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 32.98
tokens: 7533
characters: 1804
timestamp: 2025-12-24T00:54:40.356708
finish_reason: stop
---

In[4]: x = np.array([2, 1, 4, 3, 5])
    bogosort(x)

Out[4]: array([1, 2, 3, 4, 5])

Этот алгоритм сортировки опирается в своей работе на чистое везение: он многократно перетасовывает массив случайным образом до тех пор, пока результат не окажется отсортированным. При средней сложности порядка \( O[N \times N!] \): (это \( N \) умножить на \( N \) факториал) его не стоит использовать ни для каких реальных расчетов.

В Python имеются намного более эффективные встроенные алгоритмы сортировки. Начнем с изучения встроенных алгоритмов языка Python, после чего рассмотрим утилиты, включенные в библиотеку NumPy и оптимизированные под NumPy-массивы.

Быстрая сортировка в библиотеке NumPy: функции np.sort и np.argsort

Хотя в языке Python имеются встроенные функции sort и sorted для работы со списками, мы не будем их рассматривать, поскольку функция библиотеки NumPy np.sort оказывается намного более эффективной и подходящей для наших целей. По умолчанию функция np.sort использует имеющий сложность \( O[N \log N] \): алгоритм быстрой сортировки (quicksort), хотя доступны для использования также алгоритмы сортировки слиянием (mergesort) и пирамидальной сортировки (heapsort). Для большинства приложений используемой по умолчанию быстрой сортировки более чем достаточно.

Чтобы получить отсортированную версию входного массива без его изменения, можно использовать функцию np.sort:

In[5]: x = np.array([2, 1, 4, 3, 5])
    np.sort(x)

Out[5]: array([1, 2, 3, 4, 5])

Если же вы предпочитаете отсортировать имеющийся массив, то можно вместо этого применять метод sort массивов:

In[6]: x.sort()
    print(x)

[1 2 3 4 5]

Имеется также родственная функция argsort, возвращающая индексы отсортированных элементов:

In[7]: x = np.array([2, 1, 4, 3, 5])
    i = np.argsort(x)
    print(i)

[1 0 3 2 4]