---
source_image: page_096.png
page_number: 96
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 28.07
tokens: 7488
characters: 1734
timestamp: 2025-12-24T00:54:00.343209
finish_reason: stop
---

М.shape -> (3, 2)
a.shape -> (3, 3)

Теперь вступает в действие правило 3 — итоговые формы не совпадают, так что массивы несовместимы, что мы и видим, попытавшись выполнить данную операцию:

In[13]: M + a

---------------------------------------------------------------------------
ValueError                                 Traceback (most recent call last)
<ipython-input-13-9e16e9f98da6> in <module>()
----> 1 M + a

ValueError: operands could not be broadcast together with shapes (3,2) (3,)

Обратите внимание на имеющийся потенциальный источник ошибки: можно было бы сделать массивы a и M совместимыми, скажем путем дополнения формы a единицами справа, а не слева. Но правила транслирования работают не так! Если вам хочется применить правостороннее дополнение, можете сделать это явным образом, поменяв форму массива (мы воспользуемся ключевым словом np.newaxis, описанным в разделе «Введение в массивы библиотеки NumPy» данной главы):

In[14]: a[:, np.newaxis].shape

Out[14]: (3, 1)

In[15]: M + a[:, np.newaxis]

Out[15]: array([[ 1.,  1.],
                [ 2.,  2.],
                [ 3.,  3.]])

Хотя мы сосредоточили внимание на операторе +, данные правила транслирования применимы ко всем бинарным универсальным функциям. Например, рассмотрим функцию logaddexp(a, b), вычисляющую \(\log(\exp(a) + \exp(b))\) с большей точностью, чем при стандартном подходе:

In[16]: np.logaddexp(M, a[:, np.newaxis])

Out[16]: array([[ 1.31326169,  1.31326169],
                [ 1.69314718,  1.69314718],
                [ 2.31326169,  2.31326169]])

Для получения дальнейшей информации по множеству доступных универсальных функций см. раздел «Выполнение вычислений над массивами библиотеки NumPy: универсальные функции» данной главы.