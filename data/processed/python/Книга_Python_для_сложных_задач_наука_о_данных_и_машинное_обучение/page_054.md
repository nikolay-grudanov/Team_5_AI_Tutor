---
source_image: page_054.png
page_number: 54
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 44.42
tokens: 7763
characters: 2382
timestamp: 2025-12-24T00:53:09.871026
finish_reason: stop
---

<table>
  <tr>
    <th>3</th>
    <th>6</th>
    <th>8</th>
    <th>1.3</th>
    <th>0.1</th>
    <th>for i in range(5):<br>L = [j ^ (j >> i)...<br>total += sum(L)<br>return total</th>
  </tr>
  <tr>
    <td>4</td>
    <td>5</td>
    <td>9001</td>
    <td>1800.2</td>
    <td>95.9</td>
    <td></td>
  </tr>
  <tr>
    <td>5</td>
    <td>5</td>
    <td>371</td>
    <td>74.2</td>
    <td>4.0</td>
    <td></td>
  </tr>
  <tr>
    <td>6</td>
    <td>1</td>
    <td>0</td>
    <td>0.0</td>
    <td>0.0</td>
    <td></td>
  </tr>
</table>

Информация в заголовке дает нам ключ к чтению результатов: время указывается в микросекундах, и мы можем увидеть, в каком месте выполнение программы занимает наибольшее количество времени. На этой стадии мы получаем возможность применить эту информацию для модификации кода и улучшения его производительности для желаемого сценария использования.

Для получения дополнительной информации о «магической» функции %lprun, а также о доступных для нее параметрах воспользуйтесь справочной функциональностью оболочки IPython (то есть наберите %lprun? в командной строке IPython).

Профилирование использования памяти: %memit и %mprun

Другой аспект профилирования — количество используемой операциями памяти. Это количество можно оценить с помощью еще одного расширения оболочки IPython — memory_profiler. Как и в случае с утилитой line_profiler, мы начнем с установки расширения с помощью утилиты pip:

$ pip install memory_profiler

Затем можно воспользоваться оболочкой IPython для загрузки этого расширения:

In[12]: %load_ext memory_profiler

Расширение профилировщика памяти содержит две удобные «магические» функции: %memit (аналог %timeit для измерения количества памяти) и %mprun (аналог %lprun для измерения количества памяти). Применять функцию %memit несложно:

In[13]: %memit sum_of_lists(1000000)

peak memory: 100.08 MiB, increment: 61.36 MiB

Мы видим, что данная функция использует около 100 Мбайт памяти.

Для построчного описания применения памяти можно использовать «магическую» функцию %mprun. К сожалению, она работает только для функций, описанных в отдельных модулях, а не в самом блокноте, так что начнем с применения «магической» функции %%file для создания простого модуля под названием mprun_demo.py, содержащего нашу функцию sum_of_lists, с одним дополнением, которое немного прояснит нам результаты профилирования памяти: