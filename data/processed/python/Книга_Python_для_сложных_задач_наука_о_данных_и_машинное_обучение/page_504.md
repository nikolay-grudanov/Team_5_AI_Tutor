---
source_image: page_504.png
page_number: 504
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 26.90
tokens: 7387
characters: 1504
timestamp: 2025-12-24T01:04:18.487707
finish_reason: stop
---

Рис. 5.96. Визуализация попарных расстояний между точками

Сформировав аналогичным образом матрицу расстояний между подвергшимися вращению и сдвигу точками, увидим, что она не поменялась:

In[7]: D2 = pairwise_distances(X2)
    np.allclose(D, D2)

Out[7]: True

Благодаря подобной матрице расстояний мы получаем инвариантное к вращениям и сдвигам представление данных, но визуализация матрицы интуитивно не слишком ясна. В представлении на рис. 5.96 потеряны всякие следы интересной структуры данных: виденного нами ранее слова HELLO.

Хотя вычисление матрицы расстояний на основе координат \((x, y)\) не представляет труда, обратное преобразование расстояний в координаты \(x\) и \(y\) — непростая задача. Именно для этого и служит алгоритм многомерного масштабирования: по заданной матрице расстояний между точками он восстанавливает \(D\)-мерное координатное представление данных. Посмотрим, как это будет выглядеть для нашей матрицы расстояний. Воспользуемся, чтобы указать, что мы передаем матрицу расстояний, опцией precomputed параметра dissimilarity (рис. 5.97):

In[8]: from sklearn.manifold import MDS
    model = MDS(n_components=2, dissimilarity='precomputed',
        random_state=1)
    out = model.fit_transform(D)
    plt.scatter(out[:, 0], out[:, 1], **colorize)
    plt.axis('equal');

Алгоритм MDS восстанавливает одно из возможных двумерных координатных представлений данных на основе одной лишь матрицы расстояний размера \(N \times N\), описывающей зависимости между точками данных.