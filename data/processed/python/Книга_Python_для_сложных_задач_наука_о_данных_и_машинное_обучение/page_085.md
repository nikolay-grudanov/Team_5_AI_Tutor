---
source_image: page_085.png
page_number: 85
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 24.61
tokens: 7447
characters: 1657
timestamp: 2025-12-24T00:53:38.169214
finish_reason: stop
---

In[25]: y = np.zeros(10)
    np.power(2, x, out=y[::2])
    print(y)

[ 1.   0.   2.   0.   4.   0.   8.   0.  16.   0.]

Если бы мы вместо этого написали y[::2] = 2 ** x, был бы создан временный массив для хранения результатов операции 2 ** x с последующим копированием этих значений в массив y. Для столь незначительных объемов вычислений особой разницы нет, но для очень больших массивов экономия памяти за счет аккуратного использования аргумента out может оказаться значительной.

Сводные показатели

У бинарных универсальных функций есть возможность вычислять непосредственно на основе объекта некоторые сводные данные. Например, если нам нужно редуцировать массив с помощью данной конкретной операции, можно воспользоваться методом reduce соответствующей универсальной функции. Операция reduce многократно применяет заданную операцию к элементам массива до тех пор, пока не останется только один результат.

Например, вызов метода reduce для универсальной функции add возвращает сумму всех элементов массива:

In[26]: x = np.arange(1, 6)
    np.add.reduce(x)

Out[26]: 15

Аналогично вызов метода reduce для универсальной функции multiply возвращает произведение всех элементов массива:

In[27]: np.multiply.reduce(x)

Out[27]: 120

Если же мы хотим сохранить все промежуточные результаты вычислений, можно вместо reduce воспользоваться функцией accumulate:

In[28]: np.add.accumulate(x)

Out[28]: array([ 1,  3,  6, 10, 15])

In[29]: np.multiply.accumulate(x)

Out[29]: array([  1,   2,   6,  24, 120])

Обратите внимание, что в данных конкретных случаях для вычисления этих значений существуют и специализированные функции библиотеки NumPy (np.sum,