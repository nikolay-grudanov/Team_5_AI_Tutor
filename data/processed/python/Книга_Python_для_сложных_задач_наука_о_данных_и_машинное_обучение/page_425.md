---
source_image: page_425.png
page_number: 425
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 29.78
tokens: 7490
characters: 2042
timestamp: 2025-12-24T01:02:18.070739
finish_reason: stop
---

Проверка на практике: поиск по сетке

Из предшествующего обсуждения вы должны были понять смысл компромисса между систематической ошибкой и дисперсией и его зависимость от сложности модели и размера обучающей последовательности. На практике у моделей обычно больше одного параметра, поэтому графики кривых проверки и обучения превращаются из двумерных линий в многомерные поверхности. Выполнение подобных визуализаций в таких случаях представляет собой непростую задачу, поэтому лучше отыскать конкретную модель, при которой оценка эффективности для проверки достигает максимума.

Библиотека Scikit-Learn предоставляет для этой цели специальные автоматические инструменты, содержащиеся в модуле grid_search. Рассмотрим трехмерную сетку признаков модели — степени многочлена, флага, указывающего, нужно ли подбирать точку пересечения с осью координат, и флага, указывающего, следует ли выполнять нормализацию. Выполнить эти настройки можно с помощью метаоценивателя GridSearchCV библиотеки Scikit-Learn:

In[18]: from sklearn.grid_search import GridSearchCV

    param_grid = {'polynomialfeatures__degree': np.arange(21),
                  'linearregression__fit_intercept': [True, False],
                  'linearregression__normalize': [True, False]}

    grid = GridSearchCV(PolynomialRegression(), param_grid, cv=7)

Отмечу, что, как и обычный оцениватель, он еще не был применен к каким-либо данным. Обучение модели наряду с отслеживанием промежуточных оценок эффективности в каждой из точек сетки производится путем вызова метода fit():

In[19]: grid.fit(X, y);

После обучения можно узнать значения оптимальных параметров:

In[20]: grid.best_params_

Out[20]: {'linearregression__fit_intercept': False,
          'linearregression__normalize': True,
          'polynomialfeatures__degree': 4}

При необходимости можно воспользоваться этой оптимальной моделью и продемонстрировать аппроксимацию с помощью уже виденного вами выше кода (рис. 5.34):

In[21]: model = grid.best_estimator_

    plt.scatter(X.ravel(), y)
    lim = plt.axis()