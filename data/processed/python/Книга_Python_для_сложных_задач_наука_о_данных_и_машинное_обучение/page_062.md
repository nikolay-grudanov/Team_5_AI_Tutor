---
source_image: page_062.png
page_number: 62
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 23.34
tokens: 7447
characters: 1618
timestamp: 2025-12-24T00:52:55.528489
finish_reason: stop
---

целого числа и является тем, что позволяет так свободно программировать на языке Python с использованием динамической типизации. Однако эта дополнительная информация в типах Python влечет и накладные расходы, что становится особенно заметно в структурах, объединяющих значительное количество таких объектов.

Список в языке Python — больше, чем просто список

Теперь рассмотрим, что происходит при использовании структуры языка Python, содержащей много объектов. Стандартным изменяемым многоэлементным контейнером в Python является список. Создать список целочисленных значений можно следующим образом:

In[1]: L = list(range(10))
    L

Out[1]: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

In[2]: type(L[0])

Out[2]: int

Или аналогичным образом — список строк:

In[3]: L2 = [strI for c in L]
    L2

Out[3]: ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']

In[4]: type(L2[0])

Out[4]: str

В силу динамической типизации языка Python можно создавать даже неоднородные списки:

In[5]: L3 = [True, "2", 3.0, 4]
    [type(item) for item in L3]

Out[5]: [bool, str, float, int] Однако подобная гибкость имеет свою цену: для использования гибких типов данных каждый элемент списка должен содержать информацию о типе, счетчик ссылок и другую информацию, то есть каждый элемент представляет собой целый объект языка Python. В частном случае совпадения типа всех переменных большая часть этой информации избыточна: намного рациональнее хранить данные в массиве с фиксированным типом значений. Различие между списком с динамическим типом значений и списком с фиксированным типом (в стиле библиотеки NumPy) проиллюстрировано на рис. 2.2.