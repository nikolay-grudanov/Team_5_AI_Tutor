---
source_image: page_109.png
page_number: 109
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 32.03
tokens: 7507
characters: 1544
timestamp: 2025-12-24T00:54:24.874989
finish_reason: stop
---

Out[4]: array([[71, 86],
              [60, 20]])

«Прихотливая» индексация работает и в случае многомерных массивов. Рассмотрим следующий массив:

In[5]: X = np.arange(12).reshape((3, 4))
    X

Out[5]: array([[ 0,  1,  2,  3],
              [ 4,  5,  6,  7],
              [ 8,  9, 10, 11]])

Аналогично обычной индексации первый индекс относится к строкам, а второй — к столбцам:

In[6]: row = np.array([0, 1, 2])
    col = np.array([2, 1, 3])
    X[row, col]

Out[6]: array([ 2,  5, 11])

Первое значение в результате — X[0, 2], второе — X[1, 1], и третье — X[2, 3]. Составление пар индексов при «прихотливой» индексации подчиняется всем правилам транслирования, описанным в разделе «Операции над массивами. Транслирование» данной главы. Так, например, если мы скомбинируем вектор-столбец и вектор-строку в индексах, то получим двумерный результат:

In[7]: X[row[:, np.newaxis], col]

Out[7]: array([[ 2,  1,  3],
              [ 6,  5,  7],
              [10,  9, 11]])

Каждое строчное значение соединяется с каждым вектором-столбцом точно так же, как при транслировании арифметических операций. Например:

In[8]: row[:, np.newaxis] * col

Out[8]: array([[0, 0, 0],
              [2, 1, 3],
              [4, 2, 6]])

При работе с «прихотливой» индексацией важно никогда не забывать, что возвращаемое значение отражает транслируемую форму индексов, а не форму индексируемого массива.

Комбинированная индексация

Для реализации еще более сложных операций «прихотливую» индексацию можно использовать совместно с другими схемами индексации: