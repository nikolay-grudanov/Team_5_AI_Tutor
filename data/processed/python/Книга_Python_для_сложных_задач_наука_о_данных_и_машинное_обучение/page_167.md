---
source_image: page_167.png
page_number: 167
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 42.50
tokens: 7739
characters: 2121
timestamp: 2025-12-24T00:55:49.789506
finish_reason: stop
---

Как и можно ожидать, метод stack() выполняет противоположную операцию:

In[9]: pop_df.stack()

Out[9]:    California   2000    33871648
              2010    37253956
           New York   2000    18976457
              2010    19378102
           Texas     2000    20851820
              2010    25145561
    dtype: int64

Почему вообще имеет смысл возиться с иерархической индексацией? Причина проста: аналогично тому, как мы использовали мультииндексацию для представления двумерных данных в одномерном объекте Series, можно использовать ее для представления данных с тремя или более измерениями в объектах Series или DataFrame. Каждый новый уровень в мультииндексе представляет дополнительное измерение данных. Благодаря использованию этого свойства мы получаем намного больше свободы в представлении типов данных. Например, нам может понадобиться добавить в демографические данные по каждому штату за каждый год еще один столбец (допустим, количество населения младше 18 лет). Благодаря типу MultiIndex это сводится к добавлению еще одного столбца в объект DataFrame:

In[10]: pop_df = pd.DataFrame({'total': pop,
                             'under18': [9267089, 9284094,
                                         4687374, 4318033,
                                         5906301, 6879014]})

pop_df

Out[10]:        total  under18
      California  2000  33871648  9267089
              2010  37253956  9284094
           New York  2000  18976457  4687374
              2010  19378102  4318033
           Texas     2000  20851820  5906301
              2010  25145561  6879014

Помимо этого, все универсальные функции и остальная функциональность, обсуждавшаяся в разделе «Операции над данными в библиотеке Pandas» этой главы, также прекрасно работают с иерархическими индексами. В следующем фрагменте кода мы вычисляем по годам долю населения младше 18 лет на основе вышеприведенных данных:

In[11]: f_u18 = pop_df['under18'] / pop_df['total']
        f_u18.unstack()

Out[11]:        2000   2010
      California  0.273594  0.249211
           New York  0.247010  0.222831
           Texas     0.283251  0.273568