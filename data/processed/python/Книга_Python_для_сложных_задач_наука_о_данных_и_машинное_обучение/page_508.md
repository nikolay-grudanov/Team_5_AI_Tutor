---
source_image: page_508.png
page_number: 508
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 27.70
tokens: 7394
characters: 1526
timestamp: 2025-12-24T01:04:20.392766
finish_reason: stop
---

Базовые зависимости между точками данных сохранены, но на этот раз данные были преобразованы нелинейным образом: они были свернуты в форму буквы S.

Если попытаться использовать для этих данных простой алгоритм MDS, он не сумеет «развернуть» это нелинейное вложение и мы потеряем из виду существенные зависимости во вложенном многообразии (рис. 5.101):

In[14]: from sklearn.manifold import MDS
    model = MDS(n_components=2, random_state=2)
    outS = model.fit_transform(XS)
    plt.scatter(outS[:, 0], outS[:, 1], **colorize)
    plt.axis('equal');

![Использование алгоритма MDS для нелинейных данных: попытка восстановления исходной структуры оказывается неудачной](../images/5_101.png)

Рис. 5.101. Использование алгоритма MDS для нелинейных данных: попытка восстановления исходной структуры оказывается неудачной

Даже самое лучшее двумерное линейное вложение не сможет развернуть обратно нашу S-образную кривую, а отбросит вместо этого исходную ось координат Y.

Нелинейные многообразия:
локально линейное вложение

Корень проблемы в том, что MDS пытается сохранять расстояния между удаленными точками при формировании вложения. Но что, если изменить алгоритм так, чтобы он сохранял расстояния только между близлежащими точками? Полученное в результате вложение будет лучше решать нашу задачу.

Наглядно можно представить этот метод так, как показано на рис. 5.102.

Тонкие линии отражают расстояния, которые необходимо сохранить при вложении. Слева представлена модель, используемая в методе MDS: сохраняются рассто-