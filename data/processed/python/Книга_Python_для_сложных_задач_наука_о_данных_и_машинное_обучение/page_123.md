---
source_image: page_123.png
page_number: 123
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 45.22
tokens: 7904
characters: 2922
timestamp: 2025-12-24T00:54:57.054145
finish_reason: stop
---

Нотация «О-большого»

Нотация «О-большого» — средство, позволяющее описывать рост числа операций, необходимых для выполнения алгоритма, по мере роста объема входных данных. Для правильного использования нужно немного углубиться в теорию вычислительной техники и уметь отличать данную нотацию от родственных нотаций «о-маленького», «θ-большого», «Ω-большого» и, вероятно, множества их гибридов. Хотя эти варианты позволяют с большей точностью выражать информацию о масштабируемости алгоритмов, помимо экзаменов по теории вычислительной техники и замечаний педантичных комментаторов в блогах, их редко где можно увидеть. Намного более распространенной в мире науки о данных является более гибкая нотация «О-большого»: общее (хотя и не такое точное) описание масштабируемости алгоритма. Простите нас, теоретики и педанты, но именно эту интерпретацию мы и будем использовать в данной книге.

Нотация «О-большого» показывает, во сколько раз больше времени будет занимать выполнение алгоритма при росте количества данных. Если ваш алгоритм O[N] (читается «порядка N») выполняется 1 секунду при работе со списком длины \( N = 1000 \), то следует ожидать, что его выполнение займет примерно 5 секунд для списка длиной \( N = 5000 \). Если же у вас алгоритм \( O[N^2] \) (читается «порядка N квадрат») выполняется 1 секунду при работе со списком длины \( N = 1000 \), то следует ожидать, что его выполнение займет примерно 25 секунд для списка длиной \( N = 5000 \).

Для наших целей \( N \) будет обычно обозначать какой-либо аспект размера набора данных (количество точек, количество измерений и т. п.). При попытке анализа миллиардов или триллионов выборок разница между сложностью \( O[N] \) и \( O[N^2] \) может быть более чем существенной!

Обратите внимание, что нотация «О-большого» сама по себе ничего не говорит о фактическом времени выполнения вычислений, а только о его масштабировании при изменении \( N \). Обычно, например, алгоритм со сложностью \( O[N] \) считается лучше масштабируемым, чем алгоритм с \( O[N^2] \), и на то есть веские причины. Но, в частности, для маленьких наборов данных лучше масштабируемый алгоритм не обязательно будет более быстрым. Например, при работе с конкретной задачей алгоритм с \( O[N^2] \) может выполняться 0,01 секунды, а «лучший» алгоритм \( O[N] \) — 1 секунду. Увеличьте, однако, \( N \) на три порядка, и алгоритм \( O[N] \) окажется победителем.

Даже такая упрощенная версия нотации «О-большого» может оказаться очень удобной для сравнения производительности алгоритмов, и мы будем использовать эту нотацию в нашей книге, где будет идти речь о масштабируемости алгоритмов.

Структурированные данные: структурированные массивы библиотеки NumPy

Часто данные можно представить с помощью однородного массива значений, но иногда это не удается. В этом разделе демонстрируется использование таких возможностей библиотеки NumPy, как структурированные массивы (structured arrays)