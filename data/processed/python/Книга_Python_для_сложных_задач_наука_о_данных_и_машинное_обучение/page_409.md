---
source_image: page_409.png
page_number: 409
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 26.25
tokens: 7463
characters: 1933
timestamp: 2025-12-24T01:01:48.247460
finish_reason: stop
---

3. Обучить модель на данных обучающей последовательности.
4. Использовать модель, чтобы предсказать метки для новых данных.

Первые два пункта — выбор модели и выбор гиперпараметров — вероятно, важнее всего для эффективного использования этих инструментов и методов. Для оптимального их выбора необходим способ проверки того, что конкретная модель с конкретными гиперпараметрами хорошо аппроксимирует конкретные данные. Хотя эта задача может показаться несложной, в ней встречаются определенные подводные камни, которые необходимо обойти.

Соображения относительно проверки модели

В принципе, проверка модели очень проста: после выбора модели и гиперпараметров оценить ее эффективность можно, воспользовавшись ею для части обучающей последовательности и сравнив предсказания с известными значениями.

В следующих разделах я сначала продемонстрирую «наивный» подход к проверке модели и покажу, почему он не работает, прежде чем обратиться к анализу использования отложенных наборов данных и перекрестной проверки в целях более надежной оценки модели.

Плохой способ проверки модели

Посмотрим на «наивный» подход к проверке на наборе данных Iris, с которым мы работали в предыдущем разделе. Начнем с загрузки данных:

In[1]: from sklearn.datasets import load_iris
    iris = load_iris()
    X = iris.data
    y = iris.target

Выберем теперь модель и гиперпараметры. Мы будем использовать в этом примере классификатор на основе метода k-средних с n_neighbors=1. Это очень простая и интуитивно понятная модель, которую можно описать фразой «Метка для неизвестной точки такая же, как и метка ближайшей к ней обучающей точки»:

In[2]: from sklearn.neighbors import KNeighborsClassifier
    model = KNeighborsClassifier(n_neighbors=1)

Далее мы обучаем модель и используем ее для предсказания меток для уже известных данных:

In[3]: model.fit(X, y)
    y_model = model.predict(X)

Наконец, мы вычисляем долю правильно маркированных точек: