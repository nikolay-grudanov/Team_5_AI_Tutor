---
source_image: page_232.png
page_number: 232
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 39.25
tokens: 7697
characters: 2220
timestamp: 2025-12-24T00:57:36.321234
finish_reason: stop
---

переменных языка Python, работающим неоптимально по сравнению с типизированными числовыми массивами в стиле библиотеки NumPy, списки объектов даты/времени Python работают с меньшей производительностью, чем типизированные массивы кодированных дат.

Типизированные массивы значений времени: тип datetime64 библиотеки NumPy

Указанная слабая сторона формата даты/времени языка Python побудила команду разработчиков библиотеки NumPy добавить набор нативных типов данных временных рядов. Тип (dtype) datetime64 кодирует даты как 64-битные целые числа, так что представление массивов дат оказывается очень компактным. Для типа datetime64 требуется очень точно заданный формат входных данных:

In[4]: import numpy as np
    date = np.array('2015-07-04', dtype=np.datetime64)
    date

Out[4]: array(datetime.date(2015, 7, 4), dtype='datetime64[D]')

Но как только дата отформатирована, можно быстро выполнять над ней различные векторизованные операции:

In[5]: date + np.arange(12)

Out[5]:
array(['2015-07-04', '2015-07-05', '2015-07-06', '2015-07-07',
       '2015-07-08', '2015-07-09', '2015-07-10', '2015-07-11',
       '2015-07-12', '2015-07-13', '2015-07-14', '2015-07-15'],
      dtype='datetime64[D]')

Поскольку datetime64-массивы библиотеки NumPy содержат данные одного типа, подобные операции выполняются намного быстрее, чем если работать непосредственно с объектами datetime языка Python, особенно если речь идет о больших массивах (мы рассматривали эту разновидность векторизации в разделе «Выполнение вычислений над массивами библиотеки NumPy: универсальные функции» главы 2).

Важный нюанс относительно объектов datetime64 и timedelta64: они основаны на базовой единице времени (fundamental time unit). Поскольку объект datetime64 ограничен точностью 64 бита, кодируемый им диапазон времени составляет эту базовую единицу, умноженную на \(2^{64}\). Другими словами, datetime64 навязывает компромисс между разрешающей способностью по времени и максимальным промежутком времени.

Например, если нам требуется разрешающая способность 1 наносекунда, то у нас будет информация, достаточная для кодирования только интервала \(2^{64}\) наносекунды, или чуть более 600 лет. Библиотека NumPy определяет требуемую единицу