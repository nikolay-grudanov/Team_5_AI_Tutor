---
source_image: page_125.png
page_number: 125
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 19.60
tokens: 7404
characters: 1449
timestamp: 2025-12-24T00:54:36.097604
finish_reason: stop
---

Как мы и хотели, данные теперь располагаются все вместе в одном удобном блоке памяти.

В структурированных массивах удобно то, что можно ссылаться на значения и по имени, и по индексу:

In[6]: # Извлечь все имена
    data['name']

Out[6]: array(['Alice', 'Bob', 'Cathy', 'Doug'],
    dtype='<U10')

In[7]: # Извлечь первую строку данных
    data[0]

Out[7]: ('Alice', 25, 55.0)

In[8]: # Извлечь имя из последней строки
    data[-1]['name']

Out[8]: 'Doug'

Появляется возможность с помощью булева маскирования выполнять и более сложные операции, такие как фильтрация по возрасту:

In[9]: # Извлечь имена людей с возрастом менее 30
    data[data['age'] < 30]['name']

Out[9]: array(['Alice', 'Doug'],
    dtype='<U10')

Для выполнения более сложных операций лучше использовать пакет Pandas, который будет рассмотрен в главе 3. Библиотека Pandas предоставляет объект DataFrame — основанную на массивах библиотеки NumPy структуру, обладающую массой полезной функциональности по работе с данными.

Создание структурированных массивов

Типы данных для структурированных массивов можно задавать несколькими способами. Ранее мы рассмотрели метод с использованием словаря:

In[10]: np.dtype({'names':('name', 'age', 'weight'),
    'formats':('U10', 'i4', 'f8')})

Out[10]: dtype([('name', '<U10'), ('age', '<i4'), ('weight', '<f8')])

Для ясности можно задавать числовые типы как с применением типов данных языка Python, так и типов dtype библиотеки NumPy: