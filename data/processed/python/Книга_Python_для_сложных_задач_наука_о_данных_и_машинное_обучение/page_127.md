---
source_image: page_127.png
page_number: 127
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 28.01
tokens: 7537
characters: 1789
timestamp: 2025-12-24T00:54:47.534556
finish_reason: stop
---

print(X[0])
print(X['mat'][0])

(0, [[0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0]])
[[ 0.  0.  0.]
 [ 0.  0.  0.]
 [ 0.  0.  0.]]

Теперь каждый элемент массива X состоит из целого числа id и матрицы 3 × 3. Почему такой массив может оказаться предпочтительнее, чем простой многомерный массив или, возможно, словарь языка Python? Дело в том, что dtype библиотеки NumPy напрямую соответствует описанию структуры из языка C, так что можно обращаться к содержащему этот массив буферу памяти непосредственно из соответствующим образом написанной программы на языке C. Если вам понадобится написать на языке Python интерфейс к уже существующей библиотеке на языке C или Fortran, которая работает со структурированными данными, вероятно, структурированные массивы будут вам весьма полезны!

Массивы записей: структурированные массивы с дополнительными возможностями

Библиотека NumPy предоставляет класс np.recarray, практически идентичный только что описанным структурированным массивам, но с одной дополнительной возможностью: доступ к полям можно осуществлять как к атрибутам, а не только как к ключам словаря. Как вы помните, ранее мы обращались к значениям возраста путем написания следующей строки кода:

In[15]: data['age']

Out[15]: array([25, 45, 37, 19], dtype=int32)

Если же представить наши данные как массив записей, то можно обращаться к этим данным с помощью чуть более короткого синтаксиса:

In[16]: data_rec = data.view(np.recarray)
    data_rec.age

Out[16]: array([25, 45, 37, 19], dtype=int32)

Недостаток такого подхода состоит в том, что при доступе к полям массивов записей неизбежны дополнительные накладные расходы, даже при использовании того же синтаксиса. Это видно из следующего:

In[17]: %timeit data['age']
    %timeit data_rec['age']
    %timeit data_rec.age