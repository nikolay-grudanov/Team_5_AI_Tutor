---
source_image: page_174.png
page_number: 174
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 27.45
tokens: 7515
characters: 1784
timestamp: 2025-12-24T00:55:40.978533
finish_reason: stop
---

Избежать этого можно, сформировав срез явным образом с помощью встроенной функции Python slice(), но лучше в данном случае использовать объект IndexSlice, предназначенный библиотекой Pandas как раз для подобной ситуации. Например:

In[33]: idx = pd.IndexSlice
    health_data.loc[idx[:, 1], idx[:, 'HR']]

Out[33]: subject    Bob   Guido   Sue
         type        HR     HR     HR
         year visit
         2013 1      31.0   32.0   35.0
         2014 1      30.0   39.0   61.0

Существует множество способов взаимодействия с данными в мультииндексированных объектах Series и DataFrame, и лучший способ привыкнуть к ним — начать с ними экспериментировать!

Перегруппировка мультииндексов

Один из ключей к эффективной работе с мультииндексированными данными — умение эффективно преобразовывать данные. Существует немало операций, сохраняющих всю информацию из набора данных, но преобразующих ее ради удобства проведения различных вычислений. Мы рассмотрели небольшой пример этого с методами stack() и unstack(), но есть гораздо больше способов точного контроля над перегруппировкой данных между иерархическими индексами и столбцами.

Отсортированные и неотсортированные индексы

Большинство операций срезов с мультииндексами завершится ошибкой, если индекс не отсортирован. Рассмотрим этот вопрос.

Начнем с создания простых мультииндексированных данных, индексы в которых не отсортированы лексикографически:

In[34]: index = pd.MultiIndex.from_product([['a', 'c', 'b'], [1, 2]])
data = pd.Series(np.random.rand(6), index=index)
data.index.names = ['char', 'int']
data

Out[34]: char  int
          a    1    0.003001
                2    0.164974
          c    1    0.741650
                2    0.569264
          b    1    0.001693
                2    0.526226
dtype: float64