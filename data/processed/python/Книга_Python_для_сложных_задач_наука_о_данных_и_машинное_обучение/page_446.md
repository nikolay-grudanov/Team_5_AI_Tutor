---
source_image: page_446.png
page_number: 446
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 37.82
tokens: 7586
characters: 2037
timestamp: 2025-12-24T01:02:58.477031
finish_reason: stop
---

Аналогичным образом можно использовать оцениватель LinearRegression для аппроксимации наших данных прямыми, плоскостями и гиперплоскостями. По-прежнему складывается впечатление, что этот подход ограничивается лишь строго линейными отношениями между переменными, но оказывается, что ослабление этого требования также возможно.

Регрессия по комбинации базисных функций

Один из трюков, позволяющих приспособить линейную регрессию к нелинейным отношениям между переменными, — преобразование данных в соответствии с новыми базисными функциями. Один из вариантов этого трюка мы уже встречали в конвейере PolynomialRegression, который использовался в разделах «Гиперпараметры и проверка модели» и «Проектирование признаков» данной главы. Идея состоит в том, чтобы взять многомерную линейную модель:

\[
y = a_0 + a_1 x_1 + a_2 x^2 + a_3 x^3 + ...
\]

и построить \( x_1, x_2, x_3 \) и т. д. на основе имеющегося одномерного входного значения \( x \). То есть у нас \( x_n = f_n(x) \), где \( f_n(x) \) — некая функция, выполняющая преобразование данных.

Например, если \( f_n(x) = x^n \), наша модель превращается в полиномиальную регрессию:

\[
y = a_0 + a_1 x + a_2 x^2 + a_3 x^3 + ...
\]

Обратите внимание, что модель по-прежнему остается линейной — линейность относится к тому, что коэффициенты \( a_n \) никогда не умножаются и не делятся друг на друга. Фактически мы взяли наши одномерные значения \( x \) и выполнили проекцию их на более многомерное пространство, так что с помощью линейной аппроксимации мы можем теперь отражать более сложные зависимости между \( x \) и \( y \).

Полиномиальные базисные функции

Данная полиномиальная проекция настолько удобна, что была встроена в библиотеку Scikit-Learn в виде преобразователя PolynomialFeatures:

In[6]: from sklearn.preprocessing import PolynomialFeatures
    x = np.array([2, 3, 4])
    poly = PolynomialFeatures(3, include_bias=False)
    poly.fit_transform(x[:, None])

Out[6]: array([[ 2.,   4.,   8.],
                [ 3.,   9.,  27.],
                [ 4.,  16.,  64.]])