---
source_image: page_165.png
page_number: 165
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 34.61
tokens: 7628
characters: 1790
timestamp: 2025-12-24T00:55:41.453652
finish_reason: stop
---

(California, 2010)    37253956
(New York, 2000)     18976457
(New York, 2010)     19378102
(Texas, 2000)        20851820
(Texas, 2010)        25145561
dtype: int64

При подобной схеме индексации появляется возможность непосредственно индексировать или выполнять срез ряда данных на основе такого мультииндекса:

In[3]: pop[('California', 2010):('Texas', 2000)]

Out[3]: (California, 2010)    37253956
        (New York, 2000)     18976457
        (New York, 2010)     19378102
        (Texas, 2000)        20851820
        dtype: int64

Однако на этом удобство заканчивается. Например, при необходимости выбрать все значения из 2010 года придется проделать громоздкую (и потенциально медленную) очистку данных:

In[4]: pop[[i for i in pop.index if i[1] == 2010]]

Out[4]: (California, 2010)    37253956
        (New York, 2010)     19378102
        (Texas, 2010)        25145561
        dtype: int64

Это хоть и приводит к желаемому результату, но гораздо менее изящно (и далеко не так эффективно), как использование синтаксиса срезов, столь полюбившегося нам в библиотеке Pandas.

Лучший способ

В библиотеке Pandas есть лучший способ выполнения таких операций. Наша индексация, основанная на кортежах, по сути, является примитивным мультииндексом, и тип MultiIndex библиотеки Pandas как раз обеспечивает необходимые нам операции. Создать мультииндекс из кортежей можно следующим образом:

In[5]: index = pd.MultiIndex.from_tuples(index)
       index

Out[5]: MultiIndex(levels=[['California', 'New York', 'Texas'], [2000, 2010]],
       labels=[[0, 0, 1, 1, 2, 2], [0, 1, 0, 1, 0, 1]])

Обратите внимание, что MultiIndex содержит несколько уровней (levels) индексации. В данном случае названия штатов и годы, а также несколько кодирующих эти уровни меток (labels) для каждой точки данных.