---
source_image: page_255.png
page_number: 255
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 25.29
tokens: 7491
characters: 1808
timestamp: 2025-12-24T00:57:57.251441
finish_reason: stop
---

Библиотека Numexpr позволяет вычислять подобные составные выражения по-элементно, не требуя выделения памяти под промежуточные массивы целиком. В документации библиотеки Numexpr (https://github.com/pydata/numexpr) приведено больше подробностей, но пока достаточно будет сказать, что функции этой библиотеки принимают на входе строку, содержащую выражение в стиле библиотеки NumPy, которое требуется вычислить:

In[5]: import numexpr
    mask_numexpr = numexpr.evaluate('(x > 0.5) & (y < 0.5)')
    np.allclose(mask, mask_numexpr)

Out[5]: True

Преимущество заключается в том, что библиотека Numexpr вычисляет выражение, не используя полноразмерных временных массивов, а потому оказывается намного более эффективной, чем NumPy, особенно в случае больших массивов. Инструменты query() и eval(), которые мы будем обсуждать, идеологически схожи и используют пакет Numexpr.

Использование функции pandas.eval() для эффективных операций

Функция eval() библиотеки Pandas применяет строковые выражения для эффективных вычислительных операций с объектами DataFrame. Например, рассмотрим следующие объекты DataFrame:

In[6]: import pandas as pd
    nrows, ncols = 100000, 100
    rng = np.random.RandomState(42)
    df1, df2, df3, df4 = (pd.DataFrame(rng.rand(nrows, ncols))
        for i in range(4))

Для вычисления суммы всех четырех объектов DataFrame при стандартном подходе библиотеки Pandas можно написать сумму:

In[7]: %timeit df1 + df2 + df3 + df4

10 loops, best of 3: 87.1 ms per loop

Можно вычислить тот же результат с помощью функции pd.eval(), задав выражение в виде строки:

In[8]: %timeit pd.eval('df1 + df2 + df3 + df4')

10 loops, best of 3: 42.2 ms per loop

Версия этого выражения с функцией eval() работает на 50% быстрее (и использует намного меньше памяти), возвращая тот же самый результат: