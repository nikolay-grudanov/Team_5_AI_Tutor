---
source_image: page_079.png
page_number: 79
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 30.42
tokens: 7615
characters: 2033
timestamp: 2025-12-24T00:53:35.297765
finish_reason: stop
---

Введение в универсальные функции

Библиотека NumPy предоставляет для многих типов операций удобный интерфейс для компилируемой процедуры со статической типизацией. Он известен под названием векторизованной операции. Для этого достаточно просто выполнить операцию с массивом, которая затем будет применена для каждого из его элементов. Векторизованный подход спроектирован так, чтобы переносить цикл в скомпилированный слой, лежащий в основе библиотеки NumPy, что обеспечивает гораздо более высокую производительность.

Сравните результаты следующих двух фрагментов кода:

In[3]: print(compute_reciprocals(values))
    print(1.0 / values)
[ 0.16666667   1.      0.25     0.25     0.125 ]
[ 0.16666667   1.      0.25     0.25     0.125 ]

Можем отметить, что векторизованная операция выполняется на несколько порядков быстрее, чем стандартный цикл Python:

In[4]: %timeit (1.0 / big_array)
100 loops, best of 3: 4.6 ms per loop

Векторизованные операции в библиотеке NumPy реализованы посредством универсальных функций (ufuncs), главная задача которых состоит в быстром выполнении повторяющихся операций над значениями из массивов библиотеки NumPy. Универсальные функции исключительно гибки. Выше была показана операция между скалярным значением и массивом, но можно также выполнять операции над двумя массивами:

In[5]: np.arange(5) / np.arange(1, 6)

Out[5]: array([ 0.        ,  0.5       ,  0.66666667,  0.75      ,  0.8      ])

Операции с универсальными функциями не ограничиваются одномерными массивами, они также могут работать и с многомерными:

In[6]: x = np.arange(9).reshape((3, 3))
    2 ** x
Out[6]: array([[ 1,   2,   4],
               [ 8,  16,  32],
               [64, 128, 256]])

Вычисления с применением векторизации посредством универсальных функций практически всегда более эффективны, чем их эквиваленты, реализованные с помощью циклов Python, особенно при росте размера массивов. Столкнувшись с подобным циклом в сценарии на языке Python, следует обдумать, не стоит ли заменить его векторизованным выражением.