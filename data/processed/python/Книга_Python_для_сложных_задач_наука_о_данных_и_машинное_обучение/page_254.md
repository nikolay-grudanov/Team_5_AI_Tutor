---
source_image: page_254.png
page_number: 254
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 25.66
tokens: 7513
characters: 1782
timestamp: 2025-12-24T00:57:57.559489
finish_reason: stop
---

По состоянию на версию 0.13 (выпущенную в январе 2014 года) библиотека Pandas включает некоторые экспериментальные инструменты, позволяющие обращаться к работающим со скоростью написанных на языке С операциям без выделения существенных объемов памяти на промежуточные массивы. Эти утилиты — функции eval() и query(), основанные на пакете Numexpr (https://github.com/pydata/numexpr). Мы рассмотрим их использование и приведем некоторые эмпирические правила, позволяющие решить, имеет ли смысл их применять.

Основания для использования функций query() и eval(): составные выражения

Библиотеки NumPy и Pandas поддерживают выполнение быстрых векторизованных операций; например, при сложении элементов двух массивов:

In[1]: import numpy as np
    rng = np.random.RandomState(42)
    x = rng.rand(1E6)
    y = rng.rand(1E6)
    %timeit x + y 100 loops, best of 3: 3.39 ms per loop

Как уже обсуждалось в разделе «Выполнение вычислений над массивами библиотеки NumPy: универсальные функции» главы 2, такая операция выполняется гораздо быстрее, чем сложение с помощью цикла или спискового включения языка Python:

In[2]:
%timeit np.fromiter((xi + yi for xi, yi in zip(x, y)),
    dtype=x.dtype, count=len(x))

1 loop, best of 3: 266 ms per loop

Однако данная абстракция оказывается менее эффективной при вычислении составных выражений. Например, рассмотрим выражение:

In[3]: mask = (x > 0.5) & (y < 0.5)

Поскольку библиотека NumPy вычисляет каждое подвыражение, оно эквивалентно следующему:

In[4]: tmp1 = (x > 0.5)
    tmp2 = (y < 0.5)
    mask = tmp1 & tmp2

Другими словами, для каждого промежуточного шага явным образом выделяется оперативная память. Если массивы x и y очень велики, это может привести к значительным накладным расходам оперативной памяти и процессорного времени.