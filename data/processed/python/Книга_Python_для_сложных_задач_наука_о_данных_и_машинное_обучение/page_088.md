---
source_image: page_088.png
page_number: 88
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 35.09
tokens: 7643
characters: 1643
timestamp: 2025-12-24T00:53:55.210916
finish_reason: stop
---

Синтаксис соответствующих функций из библиотеки NumPy аналогичен, причем они также работают намного быстрее:

In[6]: np.min(big_array), np.max(big_array)

Out[6]: (1.1717128136634614e-06, 0.9999976784968716)

In[7]: %timeit min(big_array)
    %timeit np.min(big_array)

10 loops, best of 3: 82.3 ms per loop
1000 loops, best of 3: 497 µs per loop

Для min, max, sum и еще нескольких функций вычисления сводных показателей библиотеки NumPy существует сокращенная запись операции путем применения методов самого объекта массива:

In[8]: print(big_array.min(), big_array.max(), big_array.sum())

1.17171281366e-060.999997678497499911.628197

При работе с массивами библиотеки NumPy обязательно проверяйте, используете ли вы NumPy-версию функций для вычисления сводных показателей!

Многомерные сводные показатели

Агрегирование по столбцу или строке — один из часто применяемых видов операций агрегирования. Пусть имеются какие-либо данные, находящиеся в двумерном массиве:

In[9]: M = np.random.random((3, 4))
    print(M)

[[ 0.8967576   0.03783739   0.75952519   0.06682827]
 [ 0.8354065   0.99196818   0.19544769   0.43447084]
 [ 0.66859307   0.15038721   0.37911423   0.6687194 ]]

По умолчанию все функции агрегирования библиотеки NumPy возвращают сводный показатель по всему массиву:

In[10]: M.sum()

Out[10]: 6.0850555667307118

Но функции агрегирования принимают на входе дополнительный аргумент, позволяющий указать ось, по которой вычисляется сводный показатель. Например, можно найти минимальное значение каждого из столбцов, указав axis=0:

In[11]: M.min(axis=0)

Out[11]: array([ 0.66859307,  0.03783739,  0.19544769,  0.06682827])