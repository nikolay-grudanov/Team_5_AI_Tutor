---
source_image: page_570.png
page_number: 570
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 19.74
tokens: 7755
characters: 2978
timestamp: 2025-12-24T01:05:50.842918
finish_reason: stop
---

Можно было бы попытаться решить эту проблему путем добавления в отрицательную обучающую последовательность множества разнообразных изображений, и это, вероятно, действительно привело бы к некоторому улучшению ситуации. Другой способ — использование узконаправленного подхода, например, hard negative mining. При подходе hard negative mining, берется новый, еще не виденный классификатором набор изображений и все фрагменты в нем, соответствующие ложноположительным результатам, явным образом добавляются в качестве отрицательных примеров в обучающую последовательность до повторного обучения классификатора.

Текущий конвейер выполняет поиск только при одном значении масштаба. В текущем виде наш алгоритм будет распознавать только те лица, чей размер примерно равен 62 × 47 пикселов. Эту проблему можно решить довольно просто путем применения скользящих окон различных размеров и изменения размера каждого из фрагментов с помощью функции skimage.transform.resize до по-дачи его на вход модели. На самом деле используемая здесь вспомогательная функция sliding_window() уже учитывает этот нюанс.

Желательно комбинировать перекрывающиеся фрагменты, на которых обнаружены лица. В случае готового к промышленной эксплуатации конвейера получение 30 обнаружений одного и того же лица представляется нежелательным. Хотелось бы сократить перекрывающиеся группы обнаруженных лиц до одного. Это можно сделать с помощью одного из методов кластеризации без учителя (хороший кандидат на эту роль — кластеризация путем сдвига среднего значения (meanshift clustering)) или посредством процедурного подхода, например алгоритма подавления немаксимумов (nonmaximum suppression), часто используемого в сфере машинного зрения.

Конвейер должен быть более продвинутым. После решение вышеописанных проблем неплохо было бы создать более продвинутый конвейер, который бы получал на входе обучающие изображения и выдавал предсказания на основе скользящих окон. Именно в этом вопросе язык Python как инструмент науки о данных демонстрирует все свои возможности: приложив немного труда, мы сможем скомпоновать наш предварительный код с качественно спроектированным объектно-ориентированным API, обеспечивающим для пользователя легкость в использовании. Оставлю это в качестве упражнения читателю.

Желательно обдумать возможность применения более современных средств предварительной обработки, таких как глубокое обучение. Наконец, мне хотелось бы добавить, что HOG и другие процедурные методы выделения признаков для изображений более не считаются современными. Вместо них многие современные конвейеры обнаружения объектов используют различные варианты глубоких нейронных сетей. Нейронные сети можно рассматривать как оцениватель, определяющий оптимальную стратегию выделения признаков на основе самих данных, а не полагающийся на интуицию пользователя. Знакомство с методами глубоких нейронных сетей выходит за рамки этого раздела концептуально (и вычислительно!), хотя некоторые инструменты с открытым