---
source_image: page_078.png
page_number: 78
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 29.21
tokens: 7603
characters: 2218
timestamp: 2025-12-24T00:53:32.219312
finish_reason: stop
---

проект Numba (http://numba.pydata.org), преобразующий фрагменты кода на языке Python в быстрый LLVM-байткод.

У каждого проекта есть свои сильные и слабые стороны, но ни один из них пока не обошел стандартный механизм CPython по популярности.

Относительная медлительность Python обычно обнаруживается при повторении множества мелких операций, например при выполнении обработки всех элементов массива в цикле. Пусть у нас имеется массив значений и необходимо вычислить обратную величину каждого из них. Очевидное решение могло бы выглядеть следующим образом:

In[1]: import numpy as np
    np.random.seed(0)

    def compute_reciprocals(values):
        output = np.empty(len(values))
        for i in range(len(values)):
            output[i] = 1.0 / values[i]
        return output

    values = np.random.randint(1, 10, size=5)
    compute_reciprocals(values)

Out[1]: array([ 0.16666667,   1.        ,   0.25      ,   0.25      ,   0.125     ])

Такая реализация, вероятно, кажется вполне естественной разработчикам с опытом работы на языках программирования С или Java. Однако, оценив время выполнения этого кода для большого объема данных, мы обнаружим, что данная операция выполняется крайне медленно. Оценим это время с помощью «магической» функции %timeit оболочки IPython (обсуждавшейся в разделе «Профилирование и мониторинг скорости выполнения кода» главы 1):

In[2]: big_array = np.random.randint(1, 100, size=1000000)
    %timeit compute_reciprocals(big_array)

1 loop, best of 3: 2.91 s per loop

Выполнение миллионов операций и сохранение результата заняло несколько секунд! В наши дни, когда даже у смартфонов быстродействие измеряется в гигафлопсах (то есть миллиардах операций с плавающей точкой в секунду), это представляется медленным практически до абсурда. Оказывается, проблема не в самих операциях, а в проверке типов и диспетчеризации функций, выполняемых CPython при каждом проходе цикла. Всякий раз, когда вычисляется обратная величина, Python сначала проверяет тип объекта и выполняет динамический поиск подходящей для этого типа функции. Если бы мы работали с компилируемым кодом, сведения о типе были бы известны до выполнения кода, а значит, результат вычислялся бы намного эффективнее.