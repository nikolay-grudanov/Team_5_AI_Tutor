---
source_image: page_101.png
page_number: 101
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 29.53
tokens: 7598
characters: 2464
timestamp: 2025-12-24T02:23:46.744804
finish_reason: stop
---

Точность модели на контрольных данных составляет около 50 %. Если запустить процедуру обучения из прилагаемого к книге блокнота, вы увидите, что эффективность на обучающих данных выше. Дело в том, что модель всегда лучше приспособлена к данным, на которых обучается, так что эффективность на обучающих данных не показательна для обучения на новых данных. Если вы проверяете работу кода примеров, рекомендуем попробовать различные размеры скрытого измерения. При этом вы должны наблюдать рост эффективности1. Впрочем, этот рост не очень велик (особенно по сравнению с моделью из раздела «Пример: классификация фамилий с помощью CNN» на с. 130). Основная причина: неудачность свернутой унитарной векторизации как метода представления. Хотя каждая из фамилий компактно представляется в виде одного вектора, при этом теряется информация об упорядоченности символов, играющая большое значение при идентификации происхождения фамилии.

Классификация новой фамилии

Пример 4.11 демонстрирует код для классификации новой фамилии. Функция сначала запускает процесс векторизации по отношению к полученной в виде строкового значения фамилии, а затем получает предсказания модели. Обратите внимание на включенный флаг apply_softmax — это означает, что переменная result содержит вероятности. Предсказание модели в полиномиальном случае представляет собой список вероятностей различных классов. Для получения оптимального класса, соответствующего наибольшей предсказанной вероятности, воспользуемся функцией max() тензора PyTorch.

Пример 4.11. Вывод с помощью существующей модели (классификатора). Предсказание национальности по фамилии

def predict_nationality(name, classifier, vectorizer):
    vectorized_name = vectorizer.vectorize(name)
    vectorized_name = torch.tensor(vectorized_name).view(1, -1)
    result = classifier(vectorized_name, apply_softmax=True)

    probability_values, indices = result.max(dim=1)
    index = indices.item()

    predicted_nationality = vectorizer.nationality_vocab.lookup_index(index)
    probability_value = probability_values.item()

    return {'nationality': predicted_nationality,
            'probability': probability_value}

1 Напомним уже сказанное в главе 3: при экспериментах с гиперпараметрами, такими как размер скрытого измерения и количество слоев, оценка должна производиться на проверочном наборе данных, а не на контрольном. Если же текущие гиперпараметры вас устраивают, можете выполнить оценку на контрольных данных.