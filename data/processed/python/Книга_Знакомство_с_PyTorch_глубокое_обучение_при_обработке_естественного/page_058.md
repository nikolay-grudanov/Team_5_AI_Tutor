---
source_image: page_058.png
page_number: 58
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 33.98
tokens: 7643
characters: 2400
timestamp: 2025-12-24T02:22:46.997042
finish_reason: stop
---

Для правильного применения функции CrossEntropyLoss() фреймворка PyTorch важно понимать взаимосвязь между выходными параметрами сети, способом вычисления функции потерь и вычислительными ограничениями, возникающими вследствие фактического представления чисел с плавающей точкой. А именно, нюансы взаимосвязи между выходными параметрами сети и функцией потерь определяют четыре элемента информации. Во-первых, существуют ограничения на размер чисел сверху и снизу. Во-вторых, если входной параметр экспоненциальной функции в формуле многомерной логистической функции — отрицательное число, то результант окажется экспоненциально малым числом, а если положительное, то результант окажется экспоненциально большим числом. Далее, непосредственно перед многомерной логистической функцией на выходе сети предполагается вектор1. Наконец, функция логарифма (log) является обратной к экспоненциальной2, так что log(exp(x)) равно x. Исходя из этих четырех нюансов, можно выполнить математические упрощения, предполагающие, что лежащая в основе многомерной логистической функции экспонента и используемая при вычислении перекрестной энтропии логарифмическая функция численно устойчивы и избегают действительно больших или малых чисел. Вследствие этих упрощений выходные значения сети (без применения многомерной логистической функции) можно использовать совместно с функцией CrossEntropyLoss() фреймворка PyTorch для оптимизации распределения вероятности. Далее, после обучения сети, с помощью многомерной логистической функции можно создать распределение вероятности, как показано в примере 3.8.

Пример 3.8. Функция потерь на основе дискретной перекрестной энтропии

Input[0]
import torch
import torch.nn as nn

ce_loss = nn.CrossEntropyLoss()
outputs = torch.randn(3, 5, requires_grad=True)
targets = torch.tensor([1, 0, 3], dtype=torch.int64)
loss = ce_loss(outputs, targets)
print(loss)

Output[0]
tensor(2.7256)

В этом примере кода с помощью вектора случайных значений сначала моделируется выход сети. Далее создается вектор контрольных данных targets, состоящий

1 В PyTorch на самом деле есть две многомерные логистические функции: Softmax() и LogSoftmax(). Последняя генерирует логарифмические вероятности с сохранением относительного соотношения любых двух чисел.
2 Это справедливо только в том случае, когда основание логарифма равно числу e — как раз основание по умолчанию для функции log PyTorch.