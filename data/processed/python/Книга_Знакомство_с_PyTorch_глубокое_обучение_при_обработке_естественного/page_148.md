---
source_image: page_148.png
page_number: 148
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 32.90
tokens: 7544
characters: 2241
timestamp: 2025-12-24T02:25:10.895115
finish_reason: stop
---

Возвращает:
    словарь, содержащий признаки (x_data), метку (y_target)
    и длину признака (x_length) точки данных
    """
    row = self._target_df.iloc[index]

    surname_vector, vec_length = \
        self._vectorizer.vectorize(row.surname, self._max_seq_length)

    nationality_index = \
        self._vectorizer.nationality_vocab.lookup_token(row.nationality)

    return {'x_data': surname_vector,
            'y_target': nationality_index,
            'x_length': vec_length}

Структуры данных для векторизации

Первый этап конвейера векторизации — отображение токенов всех символов фамилии в уникальные целочисленные значения. Для этого воспользуемся структурой данных SequenceVocabulary, описанной в разделе «Пример: перенос обучения для классификации документов с использованием предобученных вложений» на с. 158. Напомним, что эта структура данных не только задает соответствия символов в фамилиях целочисленным значениям, но и включает четыре специальных токена: UNK, MASK, BEGIN-OF-SEQUENCE и END-OF-SEQUENCE. Первые два из них жизненно важны для языковых данных: UNK используется для ранее не виденных и отсутствующих в словаре токенов во входных данных, а MASK позволяет работать с последовательностями переменной длины. Последние два токена служат для модели признаками границ предложения и присоединяются к предложению спереди и сзади соответственно. Более подробное описание SequenceVocabulary вы можете найти в разделе «Классы Vocabulary, Vectorizer и DataLoader» на с. 160.

Общую процедуру векторизации выполняет класс SurnameVectorizer, использующий SequenceVocabulary для отображения символов в фамилиях в целочисленные значения. В примере 6.3 приведена его реализация, которая должна выглядеть для вас очень знакомой; в предыдущей главе мы обсуждали классификацию заголовков новостных статей по категориям и конвейер векторизации был практически точно таким же.

Пример 6.3. Векторизатор для фамилий

class SurnameVectorizer(object):
    """Векторизатор, приводящий словари в соответствие друг другу
    и использующий их"""
    def vectorize(self, surname, vector_length=-1):
        """
        Аргументы:
            title (str): строка символов
            vector_length (int): аргумент, жестко задающий длину