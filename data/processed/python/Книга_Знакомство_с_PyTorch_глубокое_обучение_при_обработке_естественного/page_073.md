---
source_image: page_073.png
page_number: 73
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 26.59
tokens: 7511
characters: 2187
timestamp: 2025-12-24T02:23:00.102725
finish_reason: stop
---

for data_dict in dataloader:
    out_data_dict = {}
    for name, tensor in data_dict.items():
        out_data_dict[name] = data_dict[name].to(device)
    yield out_data_dict

Классификатор-перцептрон

Используемая в этом примере модель представляет собой новую реализацию классификатора Perceptron, с которой вы уже встречались в начале главы. Класс ReviewClassifier наследует класс Module фреймворка PyTorch и создает слой преобразования типа Linear, возвращающего один результат. Поскольку речь идет о бинарной классификации (обзор может быть позитивным или негативным), этого вполне достаточно. В качестве завершающего нелинейного преобразования используется сигма-функция (пример 3.18).

Благодаря параметризации метода forward() применение сигма-функции необязательно. Чтобы разобраться, для чего это нужно, укажем сначала, что наиболее подходящей функцией потерь для задачи бинарной классификации является бинарная функция потерь на основе перекрестной энтропии (torch.nn.BCELoss()). Она специально сформулирована математически в расчете на бинарные вероятности. Однако в случае применения сигма-функции, а затем этой функции потерь возникают проблемы с численной устойчивостью. PyTorch предоставляет пользователям более устойчивый численно вариант — BCEWithLogitsLoss(). При использовании функции потерь не следует применять сигма-функцию (поэтому по умолчанию она у нас не применяется). Но если пользователю классификатора хотелось бы получить вероятностное значение, понадобится сигма-функция, так что такую возможность необходимо оставить в качестве необязательной. Мы рассмотрим пример подобного ее использования в примере 3.20.

Пример 3.18. Классификатор на основе перцептрона для классификации обзоров Yelp

import torch.nn as nn
import torch.nn.functional as F

class ReviewClassifier(nn.Module):
    """ Простой классификатор на основе перцептрона """
    def __init__(self, num_features):
        """
        Аргументы:
            num_features (int): размер входного вектора признаков
        """
        super(ReviewClassifier, self).__init__()
        self.fc1 = nn.Linear(in_features=num_features, out_features=1)

    def forward(self, x_in, apply_sigmoid=False):