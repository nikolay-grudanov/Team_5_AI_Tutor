---
source_image: page_132.png
page_number: 132
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 27.44
tokens: 7541
characters: 2365
timestamp: 2025-12-24T02:24:39.132070
finish_reason: stop
---

Модель CBOWClassifier

Показанный в примере 5.9 класс CBOWClassifier выполняет три важных действия. Во-первых, для всех слов из контекста создаются векторы с помощью слоя вложений и соответствующих этим словам индексов. Во-вторых, задача состоит в сочетании векторов таким образом, чтобы уловить общий контекст. В данном примере мы суммируем значения из векторов. Впрочем, можно также находить максимальное или среднее значение либо даже воспользоваться многослойным перцептроном. В-третьих, с помощью линейного слоя и вектора контекста вычисляется вектор предсказаний, представляющий собой распределение вероятности для всего словаря. Максимальное (наиболее вероятное) значение в векторе предсказаний указывает на наиболее подходящее предсказание для целевого слова — пропущенного в контексте центрального слова.

Используемый здесь слой вложений параметризуется в основном двумя числами: количеством вложений (размером словаря) и размером вложений. Во фрагменте кода из примера 5.9 есть и третий аргумент: padding_idx. Он используется как значение-индикатор в подобных нашему случаях, когда длины точек данных могут различаться1. Слой вложений делает так, чтобы соответствующий этому индексу вектор и все его градиенты были равны нулю.

Пример 5.9. Модель CBOWClassifier

class CBOWClassifier(nn.Module):
    def __init__(self, vocabulary_size, embedding_size, padding_idx=0):
        """
        Аргументы:
            vocabulary_size (int): количество записей в словаре,
                определяет число вложений и размер вектора предсказаний
            embedding_size (int): размер вложений
            padding_idx (int): по умолчанию 0; слой Embedding этот индекс не использует
        """
        super(CBOWClassifier, self).__init__()
        self.embedding = nn.Embedding(num_embeddings=vocabulary_size,
                                      embedding_dim=embedding_size,
                                      padding_idx=padding_idx)
        self.fc1 = nn.Linear(in_features=embedding_size,
                             out_features=vocabulary_size)

    def forward(self, x_in, apply_softmax=False):
        """ Прямой проход классификатора

1 Этот паттерн указания индекса для дополнения нулями (чтобы можно было использовать точки данных переменной длины) будет повторяться во многих примерах, поскольку так часто встречается в лингвистических данных.