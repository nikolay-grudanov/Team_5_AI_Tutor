---
source_image: page_096.png
page_number: 96
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 34.97
tokens: 7645
characters: 2542
timestamp: 2025-12-24T02:23:46.374595
finish_reason: stop
---

для обзоров Yelp, мы используем унитарное представление¹, не подсчитываем частоту вхождения символов и ограничиваемся только часто встречающимися элементами. В основном потому, что набор данных невелик и большинство символов встречаются достаточно часто.

Класс SurnameVectorizer

Если класс Vocabulary преобразует отдельные токены (символьные) в целые числа, то класс SurnameVectorizer отвечает за применение Vocabulary и преобразование фамилии в вектор. Создание экземпляра и его использование аналогичны работе класса ReviewVectorizer в пункте «Класс Vectorizer» на с. 85, но с одним ключевым отличием: строковое значение не разбивается по пробелам. Фамилии представляют собой последовательности символов, каждый из которых — отдельный токен в нашем словаре. Однако вплоть до раздела «Сверточные нейронные сети» на с. 120 мы будем игнорировать информацию о последовательности и создавать свернутое унитарное представление входных данных, проходя в цикле по всем символам входной строки. Для ранее не встреченных символов мы выделим специальный токен UNK. Он используется в словаре символов, поскольку мы создаем экземпляр Vocabulary на основе только обучающих данных, и в проверочных/контрольных данных вполне могут оказаться уникальные символы².

Следует заметить, что, хотя в этом примере используется свернутое унитарное представление, в последующих главах вы узнаете и о других методах векторизации, альтернативных, а иногда и превосходящих унитарное кодирование. А именно, в разделе «Пример: классификация фамилий с помощью CNN» на с. 130 вы встретите матрицу из уникальных векторов, в которой каждый символ занимает определенную позицию и обладает своим собственным унитарным вектором. Далее, в главе 5, вы узнаете о слое вложений — векторизации, которая возвращает вектор целочисленных значений, и создании на их основе матрицы плотных векторов. А пока рассмотрим код класса SurnameVectorizer (пример 4.6).

Пример 4.6. Реализация класса SurnameVectorizer

class SurnameVectorizer(object):
    """ Векторизатор, приводящий словари в соответствие друг другу и использующий их"""
    def __init__(self, surname_vocab, nationality_vocab):
        self.surname_vocab = surname_vocab
        self.nationality_vocab = nationality_vocab

    def vectorize(self, surname):

_____________________
¹ См. описание унитарных представлений в подразделе «Унитарное представление» на с. 24.
² А при нашем разбиении данных в проверочном наборе действительно есть уникальные символы, которые могут привести к сбою обучения, если не использовать UNK.