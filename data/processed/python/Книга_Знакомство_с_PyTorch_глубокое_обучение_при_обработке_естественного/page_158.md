---
source_image: page_158.png
page_number: 158
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 34.06
tokens: 7619
characters: 2434
timestamp: 2025-12-24T02:25:29.808491
finish_reason: stop
---

Пример: символьная RNN для генерации фамилий

В этом примере1 мы рассмотрим простую задачу предсказания последовательностей: генерацию фамилий с помощью RNN. На практике это означает, что для каждого временного шага RNN вычисляет распределение вероятности по множеству возможных символов в фамилии. Эти распределения вероятности можно использовать или для оптимизации сети, чтобы улучшить выдаваемые ею предсказания (при условии, что мы знаем, какие символы должны быть предсказаны), или для генерации совершенно новых фамилий.

Хотя набор данных для этой задачи уже использовался в предыдущих примерах и должен быть вам хорошо знаком, способ формирования выборок данных для предсказания последовательности несколько отличается. После описания набора данных и задачи вкратце обрисуем вспомогательные структуры данных, обеспечивающие возможность предсказания последовательностей.

Далее мы опишем две модели генерации фамилий: контекстно не обусловленную (unconditioned) SurnameGenerationModel и контекстно обусловленную (conditioned) SurnameGenerationModel. Контекстно не обусловленная модель предсказывает последовательности символов фамилий без какой-либо информации о национальной принадлежности. И напротив, контекстно обусловленная модель использует конкретные вложения для национальностей в качестве начального скрытого состояния RNN для смещения (bias) предсказаний последовательностей.

Класс SurnameDataset

Впервые приведенный в разделе «Пример: классификация фамилий с помощью MLP» на с. 109, набор данных фамилий представляет собой список фамилий и стран их происхождения. Пока мы использовали его для задач классификации — правильного определения по новой фамилии страны ее происхождения. В этом же примере мы покажем, как на основе этого набора данных обучить модель распределять вероятности по последовательностям символов и генерировать новые последовательности.

Класс SurnameDataset практически не отличается от приведенного в предыдущих главах: мы используем объект DataFrame библиотеки Pandas для загрузки набора данных и создаем векторизатор для инкапсуляции отображения токенов в целочисленные значения, необходимые для модели и имеющейся задачи. Чтобы отразить различие задач, метод SurnameDataset.__getitem__() модифицируется:

_____________________
1 Код для него вы можете найти в каталоге /chapters/chapter_7/7_3_surname_generation в репозитории GitHub этой книги (https://nlproc.info/PyTorchNLPBook/repo/).