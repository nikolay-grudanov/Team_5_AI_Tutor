---
source_image: page_165.png
page_number: 165
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 29.18
tokens: 7594
characters: 2379
timestamp: 2025-12-24T02:25:35.301264
finish_reason: stop
---

x_embedded = self.char_embedding(x_in)
# hidden_size: (num_layers * num_directions, batch_size, rnn_hidden_size)
nationality_embedded = self.nation_emb(nationality_index).unsqueeze(0)
y_out, _ = self.rnn(x_embedded, nationality_embedded)
# ...

Процедура обучения и результаты

В этом примере представлена задача предсказания последовательностей символов для генерации фамилий. Хотя во многих отношениях детали реализации и процедуры обучения напоминают примеры классификации последовательностей из главы 6, есть и несколько отличий. В данном разделе мы сосредоточим наше внимание на этих отличиях, используемых гиперпараметрах и результатах.

Для вычисления функции потерь необходимо внести два изменения, по сравнению с предыдущими примерами, поскольку предсказания выполняются на каждом временному шаге последовательности. Во-первых, нужно преобразовать трехмерные тензоры1 в двумерные (матрицы), чтобы удовлетворить вычислительные ограничения. Во-вторых, нужно согласовать mask_index, благодаря которому возможна работа с последовательностями переменной длины, с функцией потерь, чтобы она не учитывала маскированные места в расчетах.

Для решения обеих этих проблем — с трехмерными тензорами и последовательностями переменной длины — воспользуемся кодом из примера 7.5. Во-первых, выполним нормализацию предсказаний и целей до ожидаемых функцией потерь размеров (двумерные для предсказаний и одномерные для целей). Теперь каждая строка соответствует отдельной выборке: одному временному шагу в одной последовательности. Далее вычисляется функция потерь на основе перекрестной энтропии (при значении параметра ignore_index, равном mask_index). В результате этого функция потерь будет игнорировать все позиции в целевых векторах, соответствующие ignore_index.

Пример 7.5. Преобразование трехмерных тензоров и вычисление потерь в масштабах последовательности
def normalize_sizes(y_pred, y_true):
    """ Нормализация размеров тензоров

    Аргументы:
        y_pred (torch.Tensor): выходные данные модели
            Если они представляют собой трехмерный тензор, преобразуем его в матрицу
        y_true (torch.Tensor): целевые предсказания
            Если они представляют собой матрицу, преобразуем ее в вектор
    """
1 В трехмерных тензорах информация о пакете располагается в первом измерении, последовательность находится во втором, а векторы предсказаний — в третьем.