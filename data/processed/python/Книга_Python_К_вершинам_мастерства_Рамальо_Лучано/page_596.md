---
source_image: page_596.png
page_number: 596
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 59.97
tokens: 11949
characters: 2432
timestamp: 2025-12-24T02:02:45.213996
finish_reason: stop
---

Пример 18.16. tcp_charfinder.py: это серверная часть сеанса, показанного на рис. 18.2

$ python3 tcp_charfinder.py
Serving on ('127.0.0.1', 2323). Hit CTRL-C to stop.
Received from ('127.0.0.1', 62910): 'chess black'
Sent 6 results
Received from ('127.0.0.1', 62910): 'sun'
Sent 10 results
Received from ('127.0.0.1', 62910): '\x00'
Close the client socket

1 Это выводит main.
2 Первая итерация цикла while в сопрограмме handle_queries.
3 Вторая итерация цикла while.
4 Пользователь нажал CTRL-C; сервер получает управляющий символ и закрывает сеанс.
5 Сокет клиента закрыт, но сервер продолжает работать и обслуживать других клиентов.

Обратите внимание, что main почти сразу выводит сообщение Serving on... и блокируется на время выполнения метода loop.run_forever(). В этот момент управление попадает в цикл обработки событий. Цикл работает, время от времени уступая процессор сопрограмме handle_queries, а та уступает его обратно циклу, ожидая завершения приема или передачи по сети. Пока цикл обработки событий не завершился, для каждого нового клиента, подключившегося к серверу, создается новый экземпляр сопрограммы handle_queries. Таким образом, к этому простому серверу могут одновременно обращаться несколько клиентов. Сервер продолжает работать, пока не возникнет исключение KeyboardInterrupt или программа не будет снята операционной системой.

В скрипте tcp_charfinder.py мы воспользовались высокоуровневым интерфейсом Streams API, включенным в пакет asyncio (https://docs.python.org/3/library/asyncio-stream.html), который предоставляет готовый сервер, так что нам нужно только реализовать функцию-обработчик, которая может быть как простым обратным вызовом, так и сопрограммой. Существует также низкоуровневый интерфейс Transports and Protocols API (https://docs.python.org/3/library/asyncio-protocol.html), построенный по образцу абстракций транспорта и протоколов из библиотеки Twisted. Дополнительные сведения см. в разделе «Транспорты и протоколы» документации по asyncio (http://bit.ly/1f6D9i6), где приведен также пример реализации TCP-сервера эхо-контроля с помощью этого API.

В следующем разделе представлен HTTP-сервер поиска символов.

Веб-сервер на основе библиотеки aiohttp

Библиотека aiohttp, которой мы пользовались в скриптах загрузки флагов с применением пакета asyncio, поддерживает также и программирование HTTP-серверов, поэтому я взял ее для реализации скрипта http_charfinder.py. На рис. 18.3