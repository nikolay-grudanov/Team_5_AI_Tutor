---
source_image: page_116.png
page_number: 116
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 42.76
tokens: 11935
characters: 2172
timestamp: 2025-12-24T01:39:57.517731
finish_reason: stop
---

d2 = dict(sorted(DIAL_CODES)) ②
print('d2:', d2.keys())
d3 = dict(sorted(DIAL_CODES, key=lambda x:x[1])) ③
print('d3:', d3.keys())
assert d1 == d2 and d2 == d3 ④

① d1: построен из кортежей, отсортированных в порядке убывания численности населения страны.
② d2: инициализирован кортежами, отсортированными по телефонному коду.
③ d3: инициализирован кортежами, отсортированными по названию страны.
④ Словари равны, потому что содержат одни и те же пары key:value.

В примере 3.18 показан результат работы.

Пример 3.18. Из распечатки dialcodes.py видно, что порядок ключей различен.

d1: dict_keys([880, 1, 86, 55, 7, 234, 91, 92, 62, 81])
d2: dict_keys([880, 1, 91, 86, 81, 55, 234, 7, 92, 62])
d3: dict_keys([880, 81, 1, 86, 55, 7, 234, 91, 92, 62])

При добавлении новых элементов в словарь может измениться порядок существующих ключей

Когда в словарь добавляется новый элемент, интерпретатор Python может решить, что хэш-таблицу словаря следует перестроить. В результате все существующие элементы будут перемещены в новую таблицу. В процессе этой операции могут возникнуть новые (уже другие) коллизии, в силу чего ключи в новой таблице будут упорядочены по-другому. Все это зависит от реализации, поэтому невозможно предсказать, когда такое случится, невозможно. Если при обходе всех ключей словаря вы будете одновременно изменять их, то может оказаться, что будут просмотрены не все элементы — даже не все из тех, что уже присутствовали в словаре перед добавлением новых.

Именно поэтому модификация содержимого словаря в процессе обхода — неудачная мысль. Если необходимо просмотреть и добавить элементы в словарь, сделайте это в два этапа: прочитайте словарь от начала до конца, а все необходимые изменения соберите во втором словаре. Затем обновите первый словарь с помощью второго.

В Python 3 методы .keys(), .items() и .values() возвращают представления словаря, которые ведут себя скорее как множества, чем как списки, которые возвращались в Python 2. Эти представления к тому же динамичны: они не копируют содержимое словаря, а непосредственно отражают все производимые в нем изменения.

Теперь мы можем применить все, что узнали о хэш-таблицах, к множествам.