---
source_image: page_223.png
page_number: 223
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 44.56
tokens: 11749
characters: 1832
timestamp: 2025-12-24T01:45:01.963215
finish_reason: stop
---

Реализация простого декоратора

мом деле, если импортировать модуль clockdeco_demo и вывести атрибут __name__ функции factorial, то мы увидим:

```python
>>> import clockdeco_demo
>>> clockdeco_demo.factorial.__name__
'clocked'
```

Таким образом, factorial действительно хранит ссылку на функцию clocked.
Начиная с этого момента, при каждом вызове factorial(n) выполняется clocked(n).
А делает clocked вот что:

1. Запоминает начальный момент времени t0.
2. Вызывает исходную функцию factorial и сохраняет результат.
3. Вычисляет, сколько прошло времени.
4. Форматирует и печатает собранные данные.
5. Возвращает результат, сохраненный на шаге 2.

Это типичное поведение декоратора: заменить декорируемую функцию новой, которая принимает те же самые аргументы и (как правило) возвращает то, что должна была бы вернуть декорируемая функция, но при этом произвести какие-то дополнительные действия.

В книге Гамма и др. «Паттерны проектирования» краткое описание паттерна Декоратор начинается словами: «Динамически добавляет объекту новые обязанности». Декораторы функций отвечают этому описанию. Но на уровне реализации декораторы в Python имеют мало общего с классическим Декоратором, описанным в оригинальной книге. Ниже, во врезке «Поговорим», я еще вернусь к этой теме.

Декоратор clock, реализованный в примере 7.15, имеет ряд недостатков: он не поддерживает именованные аргументы и маскирует атрибуты __name__ и __doc__ декорированной функции. В примере 7.17 используется декоратор functools.wraps, который копирует необходимые атрибуты из func в clocked. К тому же, в этой новой версии правильно обрабатываются именованные аргументы.

Пример 7.17. Улучшенный декоратор clock

# clockdeco2.py

import time
import functools

def clock(func):
    @functools.wraps(func)
    def clocked(*args, **kwargs):
        t0 = time.time()