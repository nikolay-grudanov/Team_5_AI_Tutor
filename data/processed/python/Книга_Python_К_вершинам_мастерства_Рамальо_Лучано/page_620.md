---
source_image: page_620.png
page_number: 620
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 68.80
tokens: 11964
characters: 2539
timestamp: 2025-12-24T02:04:02.393519
finish_reason: stop
---

Глава 19. Динамические атрибуты и свойства

1 Загружаем модель osconfeed.py из примера 19.2.
2 Стандартный прием для построения объекта, атрибуты которого создаются из позиционных аргументов (подробное объяснение см. ниже).
3 Этот метод может загрузить набор данных в формате JSON из сети, если отсутствует локальная копия.
4 Обходим коллекции ('conferences', 'events' и т. д.).
5 В record_type записывается имя коллекции без последней буквы 's' (т. е. 'events' превращается в 'event').
6 Строим ключ key из record_type и поля 'serial'.
7 Заменяем поле 'serial' полным ключом.
8 Строим экземпляр Record и сохраняем его в базе данных в качестве значения ключа key.

В методе Record.__init__ иллюстрируется распространенный при программировании на Python прием. Напомню, что в словаре __dict__ объекта хранятся атрибуты — если только в классе не объявлен атрибут __slots__ (см. раздел «Экономия памяти с помощью атрибута класса __slots__» главы 9). Поэтому копирование в __dict__ отображения — быстрый способ создать сразу несколько атрибутов экземпляра9.

Я не стану повторять детали, которые уже обсуждались в разделе «Проблема недопустимого имени атрибута» выше, но скажу, что в зависимости от контекста приложения в классе Record, возможно, придется иметь дело с ключами, которые не являются допустимыми именами атрибутов.

Определение класса Record в примере 19.9 настолько простое, что вы, наверное, недоумеваете, почему мы не использовали его раньше вместо более сложного класса FrozenJSON. Причины две. Во-первых, FrozenJSON рекурсивно преобразует вложенные отображения и списки; в классе Record это не нужно, потому что в преобразованном наборе данных нет отображений, вложенных в другие отображения или списки. Записи могут содержать только строки, целые числа, списки строк и списки целых чисел. Вторая причина заключается в том, что FrozenJSON предоставляет доступ к внутреннему словарю атрибутов __data — который мы использовали для вызова методов, например keys, — а здесь эта функциональность не нужна.

В стандартной библиотеке Python есть по меньшей мере два класса, аналогичных нашему классу Record, экземпляры которых содержат произвольный набор атрибутов, переданных конструктору в виде позиционных аргументов: multiprocessing.Namespace

9 Кстати, Bunch — имя класса, который Алекс Мартелли в 2001 году использовал при публикации этого рецепта, названного им «The simple but handy collector of a bunch of named stuff class» (Простой и удобный способ создания класса, содержащего именованные поля) (http://bit.ly/1cPM8T3).