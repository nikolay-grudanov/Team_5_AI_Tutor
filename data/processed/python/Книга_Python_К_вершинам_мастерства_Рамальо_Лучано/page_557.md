---
source_image: page_557.png
page_number: 557
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 68.12
tokens: 12190
characters: 3110
timestamp: 2025-12-24T02:01:08.581427
finish_reason: stop
---

Дополнительная литература

В книге Бизли и Джонса «Python Cookbook», издание 3 (O'Reilly), есть рецепты использования concurrent.futures, и первым из них является рецепт 11.12 «Принципы событийно-управляемого ввода-вывода». В рецепте 12.7 «Создание пула потоков» демонстрируется простой TCP-сервер эхо-контроля, а в рецепте 12.8 «Простой пример параллельного программирования» приводится практически полезный пример: анализ каталога, содержащего сжатые программой gzip файлы журналов Apache, с помощью класса ProcessPoolExecutor. Дополнительные сведения о потоках, рассыпанные по всей главе 12 книги Бизли и Джонса, чрезвычайно интересны, а особо хочется отметить рецепт 12.10 «Определение задачи-актора», в котором иллюстрируется модель акторов: проверенный на практике способ координации потоков посредством передачи сообщений.

В книге Brett Slatkin «Effective Python» (http://www.effectivepython.com/) (Addison-Wesley) есть посвященная распараллеливанию глава, где рассматриваются сопрограммы, потоки и процессы в пакете concurrent.futures, а также использование блокировок и очередей для программирования потоков, не прибегая к классу ThreadPoolExecutor.

Потоки и процессы рассматриваются также в книгах Micha Gorelick, Ian Ozsvald «High Performance Python» (O'Reilly) и Doug Hellmann «The Python Standard Library by Example» (Addison-Wesley).

Обзор современного состояния дел в области конкурентности и параллелизма без потоков и обратных вызовов изложен в книге Paul Butcher «Seven Concurrency Models in Seven Weeks»8. Мне особенно нравится ее подзаголовок «Раскрываем тайны потоков». Потоки и блокировки рассматриваются в первой главе этой книги, а остальные шесть глав посвящены современным альтернативам параллельного программирования, поддерживаемым в различных языках. Python, Ruby и JavaScript в их число не входят.

Если вас заинтриговали тайны GIL, начните с документа «Python Library and Extension FAQ» (раздел «Нельзя ли избавиться от глобальной блокировки интерпретатора?») по адресу http://bit.ly/1HGtb0F. Также стоит прочитать статьи Гвидо ван Россума и Джесси Ноллера (автора пакета multiprocessing) «It isn't Easy to Remove the GIL» (http://bit.ly/1HGtcBF) и «Python Threads and the Global Interpreter Lock» (http://bit.ly/1JlvgwD). Наконец, Дэвид Бизли очень детально исследует внутренние механизмы работы GIL в докладе «Understanding the Python GIL» (http://www.dabeaz.com/GIL/)9. На слайде 54 (http://bit.ly/1HGtCrK) Бизли приводит кое-какие тревожные результаты и, в частности, данные о 20-кратном увеличении времени работы одного эталонного теста после включения в версию Python 3.2 нового алгоритма GIL. Однако Бизли использовал для моделирования счетной задачи цикл while True: pass, чего на практике не бывает. В реальных приложениях проблема не настолько серьезна, как следует из комментария Антуана Петру (http://bugs.python.org/issue7946#msg223110) — автора нового алгоритма GIL — к извещению об ошибке, поданному Бизли.

8 П. Батчер «Семь моделей конкуренции и параллелизма за семь недель. Раскрываем тайны потоков». ДМК Пресс, 2015
9 Спасибо Лукасу Бруниалти за эту ссылку.