---
source_image: page_041.png
page_number: 41
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 56.85
tokens: 11886
characters: 2179
timestamp: 2025-12-24T01:36:40.042579
finish_reason: stop
---

Списковое включение и генераторные выражения

Пример 2.2. Построить список кодовых позиций Unicode по строке, вторая попытка

```python
>>> symbols = '$¢£¥€¤'
>>> codes = [ord(symbol) for symbol in symbols]
>>> codes
[36, 162, 163, 165, 8364, 164]
```

Всякий, кто хоть немного знаком с Python, сможет прочитать пример 2.1. Но после того как я узнал о списковом включении, пример 2.2 стал казаться мне более удобочитаемым, потому что намерение программиста в нем выражено отчетливее.

Цикл for можно использовать для самых разных целей: просмотра последовательности для подсчета или выборки элементов, вычисления агрегатов (суммы, среднего) и т. д. Так, код в примере 2.1 строит список. А у спискового включения только одна задача — построить новый список, ничего другого оно не умеет.

Разумеется, списковое включение можно использовать и во вред, так что код станет абсолютно непонятным. Я встречал код на Python, в котором listcomp'ы применялись просто для повторения блока кода ради его побочного эффекта. Если вы ничего не собираетесь делать с порожденным списком, то не пользуйтесь этой конструкцией. Кроме того, не переусердствуйте: если списковое включение занимает больше двух строчек, то, быть может, лучше разбить его на части или переписать в виде старого доброго цикла for. Действуйте по ситуации: в Python, как и в любом естественном языке, не существует твердых и однозначных правил для написания ясного текста.

Замечание о синтаксисе

В программе на Python переход на другую строку внутри пар скобок [], {} и () игнорируется. Поэтому при построении многострочных списков, списковых включений, генераторных выражений, словарей и прочего можно обходиться без уродливой косой черты \ для экранирования символа новой строки.

Переменные больше не покидают списковое включение

В Python 2.x переменные, значение которым присваивалось в списковом включении, устанавливались в объемлющей области видимости, что иногда приводило к трагическим последствиям. Взгляните на следующий сеанс оболочки в Python 2.7:

Python 2.7.6 (default, Mar 22 2014, 22:59:38)
[GCC 4.8.2] on linux2
Type "help", "copyright", "credits" or "license" for more information.
>>> x = 'my precious'