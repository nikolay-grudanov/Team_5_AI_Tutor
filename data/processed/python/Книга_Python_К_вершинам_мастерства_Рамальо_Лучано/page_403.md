---
source_image: page_403.png
page_number: 403
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 51.74
tokens: 12060
characters: 2685
timestamp: 2025-12-24T01:53:31.026342
finish_reason: stop
---

Перегрузка оператора сложения векторов +

выполняет операцию \( a + b \) для каждой пары, возвращаемой zip_longest(...), поэтому подойдет любой итерируемый объект, порождающий числа.

Однако если поменять операнды местами (пример 13.6), то сложение операндов разных типов даст ошибку.

Пример 13.6. Vector.__add__ из примера 13.4 дает ошибку, если тип левого операнда — не Vector

```python
>>> v1 = Vector([3, 4, 5])
>>> (10, 20, 30) + v1
Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
TypeError: can only concatenate tuple (not 'Vector') to tuple
>>> from vector2d_v3 import Vector2d
>>> v2d = Vector2d(1, 2)
>>> v2d + v1
Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
TypeError: unsupported operand type(s) for +: 'Vector2d' and 'Vector'
```

Для поддержки операций с объектами разных типов в Python имеется особый механизм диспетчеризации для специальных методов, ассоциированных с инфиксными операторами. Видя выражение \( a + b \), интерпретатор выполняет следующие шаги (см. рис. 13.1).

1. Если у \( a \) есть метод __add__, вызвать \( a.__add__(b) \) и вернуть результат, если только он не равен NotImplemented.
2. Если у \( a \) нет метода __add__ или его вызов вернул NotImplemented, проверить, есть ли у \( b \) метод __radd__, и, если да, вызвать \( b.__radd__(a) \) и вернуть результат, если только он не равен NotImplemented.
3. Если у \( b \) нет метода __radd__ или его вызов вернул NotImplemented, возбудить исключение TypeError с сообщением unsupported operand types (неподдерживаемые типы операндов).

Метод __radd__ называется «инверсным» (reversed) или «отраженным» (reflected) вариантом __add__. Я предпочитаю термин «инверсные» специальные методы². Три рецензента книги — Алекс, Анна и Лео — говорили мне, что представляют их как «правые» (right) специальные методы, потому что они вызываются от имени правого операнда. В общем, сами решайте, какое слово на «г» вам больше нравится.

Итак, чтобы сложение операндов разных типов в примере 13.6 заработало, мы должны реализовать метод Vector.__radd__, который Python вызовет, если у лево-

² В документации по Python встречаются оба термина. В главе «Модель данных» (https://docs.python.org/3/reference/datamodel.html) используется «reflected», а в разделе 9.1.2.2 «Реализация арифметических операций» (http://bit.ly/1JHWP8W) при описании модуля numbers упоминаются «forward» (прямые) и «reverse» (инверсные) методы, и мне эта терминология нравится больше, потому что слова «прямой» и «инверсный» (не «обратный», чтобы не путать с обратной функцией — Прим. перев.) сразу наводят на мысль о направлении, тогда как у слова «reflected» нет очевидного антонима.