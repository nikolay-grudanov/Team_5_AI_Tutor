---
source_image: page_341.png
page_number: 341
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 56.74
tokens: 12000
characters: 2661
timestamp: 2025-12-24T01:50:39.587705
finish_reason: stop
---

вые качества (старомодная фенетика!) гораздо важнее кладистики. Но в других вопросах, например в отношении восприимчивости к различным патогенным организмам (следует ли пытаться выращивать птицу в неволе или сохранять их в дикой природе), близость ДНК может оказаться гораздо важнее...

Итак, в силу наличия отдаленной аналогии с таксономической революцией в мире водоплавающих птиц я рекомендую дополнить старую добрую утиную типизацию (не вовсе заменить — в некоторых контекстах она нам еще послужит) ... гусиной типизацией!

Гусиная типизация означает следующее: вызов isinstance(obj, cls) теперь считается приемлемым... при условии, что cls — абстрактный базовый класс, т. е. метаклассом cls является abc.ABCMeta.

В модуле collections.abc можно найти немало полезных абстрактных классов (они есть также в модуле numbers из стандартной библиотеки Python)3.

Из многих концептуальных преимуществ ABC по сравнению с конкретными классами (например, Скотт Мейер в своей книге «Более эффективный C++», совет 33 — http://ptgmedia.pearsoncmg.com/images/020163371x/items/item33.html — говорит, что «все нелистовые классы должны быть абстрактными») выделим одно практически важное достоинство ABC в Python: метод класса register, который дает возможность конечному пользователю «объявить» некоторый класс «виртуальным» подклассом ABC (для этого зарегистрированный класс должен удовлетворять требованиям ABC к имени и сигнатура и, что еще важнее, подразумеваемому семантическому контракту, но его необязательно разрабатывать с учетом ABC и, в частности, не требуется наследовать ему!). Это большой шаг на пути к устранению жесткости и сильной сцепленности, из-за которых к наследованию следует относиться с куда большей настороженностью, чем позволяют себе большинство программирующих на ОО-языках...

Иногда даже и регистрировать класс не нужно, чтобы ABC распознал его как подкласс!

Так бывает в случае ABC, существующих только ради нескольких специальных методов. Например:

```python
>>> class Struggle:
... def __len__(self): return 23,
```

3 Разумеется, вы можете определить и свои ABC, но я не советую это делать никому, кроме самых опытных питонистов, равно как не советую определять свои метаклассы... и даже для этих «самых опытных питонистов», знающих обо всех потасанных уголках и темных закоулках языка, это инструменты не для каждодневного использования. Эти средства «углубленного метапрограммирования» предназначены авторам каркасов широкого назначения, которые предположительно будут независимо развивать многочисленные не связанные между собой команды разработчиков. В общем, они могут понадобиться менее чем 1% «самых опытных питонистов»! — А. М.