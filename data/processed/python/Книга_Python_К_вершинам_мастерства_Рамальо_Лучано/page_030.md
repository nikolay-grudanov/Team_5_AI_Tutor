---
source_image: page_030.png
page_number: 30
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 53.16
tokens: 11819
characters: 2169
timestamp: 2025-12-24T01:36:11.992400
finish_reason: stop
---

Я в этой книге использую оператор % и метод str.format, как и большая часть сообщества Python. Мне очень нравится более мощный метод str.format, но я знаю, что многие питонисты предпочитают более простой оператор %, так что в обозримом будущем мы, скорее всего, будем встречать в написанных на Python программах оба варианта.

Отметим, что в нашей реализации метода __repr__ мы использовали %r для получения стандартного представления отображаемых атрибутов. Это разумный подход, потому что в нем отчетливо проявляется существенное различие между Vector(1, 2) и Vector('1', '2') — второй вариант в контексте этого примера не заработал бы, потому что аргументами конструктора должны быть числа, а не строки.

Строка, возвращаемая методом __repr__, должна быть однозначно определена и по возможности соответствовать коду, необходимому для восстановления объекта. Именно поэтому мы выбрали представление, напоминающее вызов конструктора класса (например, Vector(3, 4)).

В отличие от __repr__, метод __str__ вызывается конструктором str() и неявно используется в функции print. Метод __str__ должен возвращать строку, пригодную для показа пользователям.

Если вы реализуете только один из этих двух методов, то пусть это будет __repr__, потому что в отсутствие пользовательского метода __str__ интерпретатор Python вызывает __repr__.

На сайте Stack Overflow был задан вопрос «Difference between __str__ and __repr__ in Python» (http://bit.ly/1Vm7j1N), ответ на который содержит прекрасные разъяснения Алекса Мартелли и Мартина Питерса.

Арифметические операторы

В примере 1.2 реализованы два оператора: + и *, чтобы продемонстрировать принципы работы методов __add__ и __mul__. Отметим, что оба метода создают и возвращают новый экземпляр Vector, не модифицируя ни один operand, — аргументы self и other только читаются. Это ожидаемое поведение инфиксных операторов: создавать новые объекты, не трогая операнды. Я еще вернусь к этому вопросу в главе 13.

В примере 1.2 реализовано умножение объекта Vector на число, но не числа на объект Vector, что нарушает свойство коммутативности умножения. В главе 13 мы исправим этот недочет с помощью специального метода __rmul__.