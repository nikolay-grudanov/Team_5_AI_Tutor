---
source_image: page_423.png
page_number: 423
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 38.04
tokens: 11831
characters: 2081
timestamp: 2025-12-24T01:54:18.973109
finish_reason: stop
---

Поговорим

тивным типам. Вот как та же формула в Java записывается для работы с объектами BigDecimal:

BigDecimal interest = principal.multiply(BigDecimal.ONE.add(rate).pow(periods).subtract(BigDecimal.ONE));

Очевидно, что с инфиксными операторами формулы становятся понятными, по крайней мере, для большинства из нас6. И перегрузка операторов необходима для поддержки инфиксной нотации в типах, отличных от примитивных. Наличие перегрузки операторов в простом языке высокого уровня стало, пожалуй, основной причиной на удивление широкого использования Python в научных расчетах, наблюдаемого в последние годы.

Разумеется, и у решения запретить перегрузку операторов в языке есть свои плюсы. Вероятно, такое решение оправдано в низкоуровневых языках системного программирования, где производительность и безопасность играют важнейшую роль. Гораздо более новый язык Go последовал в этом отношении примеру Java — перегрузка операторов в нем не поддерживается.

Но при разумном использовании перегруженные операторы упрощают чтение и написание кода. В современных высокоуровневых языках эта возможность очень полезна.

Беглый взгляд на отложенные вычисления

Внимательно присмотревшись к обратной трассировке в примере 13.9, вы заметите следы отложенного, или ленивого вычисления генераторных выражений. В примере 13.19 показана та же трассировка, но с выносками.

Пример 13.19. Повторение примере 13.9

>>> v1 + 'ABC'
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "vector_v6.py", line 329, in __add__
    return Vector(a + b for a, b in pairs) # 1
  File "vector_v6.py", line 243, in __init__
    self._components = array(self.typecode, components) # 2
  File "vector_v6.py", line 329, in <genexpr>
    return Vector(a + b for a, b in pairs) # 3
TypeError: unsupported operand type(s) for +: 'float' and 'str'

1 Конструктору Vector передается генераторное выражение в аргументе components. Пока никаких проблем.

6 Мой друг Марио Доменик Гулар, разработчик ядра компилятора CHICKEN Scheme (http://www.callcc.org/), наверное, с этим не согласится.