---
source_image: page_311.png
page_number: 311
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 47.35
tokens: 11900
characters: 2264
timestamp: 2025-12-24T01:49:01.660401
finish_reason: stop
---

Vector, попытка № 3: доступ к динамическим атрибутам

нятно, прочитайте еще раз, как работает метод __getattr__ (перед примером 10.8). Это тонкий момент, но от него зависит многое из того, с чем мы встретимся далее в этой книге.

Несогласованность в примере 10.9 возникла из-за способа работы __getattr__: Python вызывает этот метод только в том случае, когда у объекта нет атрибута с указанным именем. Однако же после присваивания v.x = 10 у объекта v появился атрибут x, поэтому __getattr__ больше не вызывается для доступа к v.x: интерпретатор просто вернет значение 10, связанное с v.x. С другой стороны, в реализации __getattr__ мы игнорируем все атрибуты экземпляра, кроме self._components, откуда читаются значения «виртуальных атрибутов», перечисленных в строке shortcut_names.

Чтобы избежать рассогласования, мы должны изменить логику установки атрибутов в классе Vector.

Напомним, что в последних вариантах класса Vector2d в главе 9 попытка присвоить значение атрибутам экземпляра .x или .y приводила к исключению AttributeError. В классе Vector мы хотим возбуждать такое же исключение при любой попытке присвоить значение атрибуту с однобуквенным именем — просто во избежание недоразумений. Для этого реализуем метод __setattr__, как показано в примере 10.10.

Пример 10.10. Часть файла vector_v3.py: метод __setattr__ в классе Vector

def __setattr__(self, name, value):
    cls = type(self)
    if len(name) == 1: ①
        if name in cls.shortcut_names: ②
            error = 'readonly attribute {attr_name!r}'
        elif name.islower(): ③
            error = "can't set attributes 'a' to 'z' in {cls_name!r}"
    else:
        error = '' ④
    if error: ⑤
        msg = error.format(cls_name=cls.__name__, attr_name=name)
        raise AttributeError(msg)
    super().__setattr__(name, value) ⑥

① Специальная обработка односимвольных имен атрибутов.
② Если имя совпадает с одним из символов xyzt, задать один текст сообщения об ошибке.
③ Если имя — строчная буква, задать другой текст сообщения — обо всех однобуквенных именах.
④ В противном случае оставить сообщение об ошибке пустым.
⑤ Если сообщение об ошибке не пусто, возбуждаем исключение.
⑥ Случай по умолчанию: вызвать метод __setattr__ суперкласса для получения стандартного поведения.