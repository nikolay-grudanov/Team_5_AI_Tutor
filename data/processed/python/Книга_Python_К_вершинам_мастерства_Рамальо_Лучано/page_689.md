---
source_image: page_689.png
page_number: 689
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 47.75
tokens: 11718
characters: 1742
timestamp: 2025-12-24T02:06:42.232878
finish_reason: stop
---

Основы метаклассов

collections.Iterable является abc.ABCMeta. Класс Iterable абстрактный, а ABCMeta нет — да и как может быть иначе, если Iterable является экземпляром ABCMeta:

```python
>>> import collections
>>> collections.Iterable.__class__
<class 'abc.ABCMeta'>
>>> import abc
>>> abc.ABCMeta.__class__
<class 'type'>
>>> abc.ABCMeta.__mro__
(<class 'abc.ABCMeta'>, <class 'type'>, <class 'object'>)
```

Классом ABCMeta также является type. Любой класс является экземпляром type, прямо или косвенно, но только метаклассы являются также подклассами type. Это самое главное, что нужно знать о метаклассах: любой метакласс, в частности ABCMeta, наследует от type могущество, необходимое для конструирования классов. На рис. 21.3 показана эта важнейшая связь.

![Диаграмма связей между классами object, ABCMeta, Iterable и type](https://i.imgur.com/3Q5z5QG.png)

Рис. 21.3. Iterable — подкласс object и экземпляр ABCMeta. И object, и ABCMeta — экземпляры type, но ключевая связь здесь — тот факт, что ABCMeta еще и подкласс type, поскольку ABCMeta является метаклассом.
На этой диаграмме Iterable — единственный абстрактный класс

Необходимо твердо запомнить, что все классы являются экземплярами type, а метаклассы — еще и подклассами type, поэтому они работают как фабрики классов. В частности, метакласс может настраивать экземпляры посредством реализации __init__. Метод __init__ метакласса может делать все, на что способен декоратор, но его действие распространяется глубже, как будет видно из следующего упражнения.

Демонстрация работы метакласса

Это вариация на тему раздела «Демонстрация работы интерпретатора» выше. Модуль evalsupport.py такой же, как в примере 21.7, а главный скрипт evaltime_meta.py показан в примере 21.10.