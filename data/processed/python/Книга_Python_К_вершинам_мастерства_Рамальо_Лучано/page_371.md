---
source_image: page_371.png
page_number: 371
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 55.42
tokens: 11948
characters: 2545
timestamp: 2025-12-24T01:51:56.918489
finish_reason: stop
---

Поговорим

латать встроенные типы. Лично я считаю это плюсом, так как есть уверенность, что объект str всегда будет иметь один и тот же набор методов. Это ограничение снижает шансы на то, что внешние библиотеки попытаются применить конфликтующие заплаты.

Интерфейсы в Java, Go и Ruby

Во времена C++ 2.0 (1989) абстрактные классы использовались для описания интерфейсов в этом языке. Проектировщики Java решили запретить множественное наследование классов, лишив тем самым абстрактные классы возможности специфицировать интерфейсы, поскольку зачастую класс должен реализовывать несколько интерфейсов. Зато они добавили в язык конструкцию interface и разрешили классу реализовывать более одного интерфейса — некоторый вид множественного наследования. Более явное выделение интерфейсов можно отнести к значительным заслугам Java. В Java 8 разрешено включать реализации методов в интерфейс, это называется «методами по умолчанию» (https://docs.oracle.com/javase/tutorial/java/IandI/defaultmethods.html). С таким дополнением интерфейсы Java стали ближе к абстрактным классам в C++ и Python.

В языке Go принят совершенно другой подход. Прежде всего, в Go нет наследования. Определять интерфейсы можно, но нет нужды (а фактически и возможности) явно говорить, что некий тип реализует интерфейс. Компилятор определяет это автоматически. Таким образом, механизм, реализованный в Go, можно было бы назвать «статической динамической типизацией» в том смысле, что интерфейсы проверяются на этапе компиляции, но значение имеет лишь то, что именно реализует каждый тип.

Если бы Python был устроен как Go, то в каждом ABC был бы реализован метод subclasshook, проверяющий имена и сигнатуры функций, а мы никогда не наследовали бы ABC и не регистрировали виртуальные подклассы. Если бы мы хотели, чтобы Python больше походил на Go, то должны были бы проверять типы всех аргументов функции. Отчасти такая инфраструктура имеется (вспомните раздел «Аннотации функций» на стр. 186). Гвидо уже говорил, что считает нормальным использовать такие аннотации для проверки типов — по крайней мере, во вспомогательных инструментальных средствах. Дополнительные соображения на эту тему см. на врезке «Поговорим» в главе 5.

Рубисты твердо верят в динамическую типизацию, и в Ruby нет никакого формального способа объявить интерфейс или абстрактный класс, кроме того, что существовал в Python до версии 2.6: возбудить исключение NotImplementedError в теле метода, чтобы сделать его абстрактным и заставить пользователя создать подкласс, в котором метод будет реализован.