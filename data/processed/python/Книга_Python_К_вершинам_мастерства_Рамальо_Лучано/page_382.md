---
source_image: page_382.png
page_number: 382
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 33.75
tokens: 11672
characters: 1496
timestamp: 2025-12-24T01:52:17.079494
finish_reason: stop
---

Глава 12. Наследование: хорошо или плохо

начните с класса Text внизу. Класс Text реализует многострочный редактируемый текстовый виджет. Он обладает богатой функциональностью сам по себе, но еще и наследует многочисленные методы от других классов. В левой части рисунка показана обычная UML-диаграмма классов. А справа она дополнена стрелками, показывающими порядок MRO, полученный с помощью вспомогательной функции print_mro из примера 12.8:

>>> import tkinter
>>> print_mro(tkinter.Text)
Text, Widget, BaseWidget, Misc, Pack, Place, Grid, XView, YView, object

![UML-диаграммы класса виджета Text](../images/ch12_02.png)

Рис. 12.2. Слева: UML-диаграмма класса виджета Text из пакета Tkinter и его суперклассов. Справа: пунктирными стрелками обозначен Text.mro

В следующем разделе мы обсудим аргументы за и против множественного наследования и приведем примеры из реальных каркасов.

Множественное наследование в реальном мире

Вполне возможно применить множественное наследование с пользой. В паттерне Адаптер из книги «Паттерны проектирования» множественное наследование используется, так что не скажешь, что оно совсем уж никуда не годится (остальные 22 паттерна, правда, обошлись одиночным наследованием, т. е. множественное наследование, очевидно, не панацея).

В стандартной библиотеке Python множественное наследование особенно хорошо заметно в пакете collections.abc. И тут нет никакого противоречия: в конце концов, даже в Java поддерживается множественное наследование интерфейсов,