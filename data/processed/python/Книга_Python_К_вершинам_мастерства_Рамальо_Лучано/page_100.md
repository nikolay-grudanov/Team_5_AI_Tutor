---
source_image: page_100.png
page_number: 100
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 41.52
tokens: 11842
characters: 2177
timestamp: 2025-12-24T01:39:09.355052
finish_reason: stop
---

UserDict, MutableMapping или Mapping. В двух последних есть несколько полезных конкретных методов, хотя они и являются абстрактными базовыми классами (ABC). Стоит отметить следующие методы.

MutableMapping.update

Этот метод можно вызывать напрямую, но им также пользуется метод __init__ для инициализации экземпляра другими отображениями, итерируемыми объектами, порождающими пары (key, value), и именованными аргументами. Поскольку для добавления элементов в нем используется конструкция self[key] = value, то в конечном итоге будет вызвана наша реализация __setitem__.

Mapping.get

В классе StrKeyDict0 (пример 3.7) мы вынуждены были самостоятельно написать метод get, чтобы получаемые результаты были согласованы с __getitem__, но в примере 3.8 мы унаследовали Mapping.get, который реализован в точности так, как StrKeyDict0.get (см. исходный код Python (http://bit.ly/1FEOPPB)).

Уже написав класс StrKeyDict, я обнаружил, что Антуан Питру (Antoine Pitrou) опубликовал документ «PEP 455 – Adding a key-transforming dictionary to collections» (https://www.python.org/dev/peps/pep-0455/) и исправление, дополняющее модуль collections классом TransformDict. Это исправление присоединено к проблеме issue18986 (http://bugs.python.org/issue18986) и может быть включено в версию Python 3.5. Чтобы поэкспериментировать с классом TransformDict, я «выдернул» его в отдельный модуль (03-dictset/transformdict.py (http://bit.ly/1Vm7OJ5) в репозитории кода к этой книге (https://github.com/fluentpython/example-code)). Класс TransformDict более общий, чем StrKeyDict, и усложняется наличием требования сохранять ключи в том виде, в котором они вставлялись первоначально.

Мы знаем, что существует несколько неизменяемых типов последовательностей, а как насчет неизменяемого словаря? В стандартной библиотеке такого не имеется, но выход есть. Читайте дальше.

Неизменяемые отображения

Все типы отображений в стандартной библиотеке изменяемые, но иногда нужно гарантировать, что пользователь не сможет по ошибке модифицировать отображение. Конкретный пример снова дает проект Pingo.io, который я уже описывал в разделе «Метод __missing__» выше: отображение board.pins представляет фи-