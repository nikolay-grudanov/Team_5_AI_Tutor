---
source_image: page_492.png
page_number: 492
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 46.44
tokens: 11850
characters: 2064
timestamp: 2025-12-24T01:57:48.399525
finish_reason: stop
---

>>> next(my_coro2) ②
-> Started: a = 14
14
>>> getgeneratorstate(my_coro2) ③
'GEN_SUSPENDED'
>>> my_coro2.send(28) ④
-> Received: b = 28
42
>>> my_coro2.send(99) ⑤
-> Received: c = 99
Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
StopIteration
>>> getgeneratorstate(my_coro2) ⑥
'GEN_CLOSED'

① inspect.getgeneratorstate возвращает GEN_CREATED (т. е. сопрограмма еще не начала работать).
② Продвигаем сопрограмму к первому yield, она печатает сообщение started: a = 14, затем отдает значение a и приостанавливается в ожидании значения, которое нужно присвоить b.
③ getgeneratorstate возвращает GEN_SUSPENDED (т. е. сопрограмма приостановлена в выражении yield).
④ Посылаем приостановленной сопрограмме число 28, выражение yield отдает это значение, и оно связывается с переменной b. Печатается сообщение -> Received: b = 28, отдаётся результат вычисления a + b (42) и сопрограмма приостанавливается в ожидании значения, которое можно будет присвоить c.
⑤ Посылаем приостановленной сопрограмме число 99, выражение yield отдает это значение, и оно связывается с переменной c. Печатается сообщение -> Received: b = 99, затем сопрограмма завершается, в результате чего объект-генератор возбуждает исключение StopIteration.
⑥ getgeneratorstate возвращает GEN_CLOSED (т. е. сопрограмма завершилась).

Важно понимать, что выполнение сопрограммы приостанавливается именно по достижении ключевого слова yield — не раньше и не позже. Выше уже отмечалось, что код в правой части выражения присваивания вычисляется до выполнения присваивания. Это означает, что в строке вида b = yield a значение b будет установлено только после активации сопрограммы из клиентского кода. Чтобы осознать этот факт, требуется некоторое усилие, но его понимание абсолютно необходимо для осмысленного использования yield в асинхронном программировании, о чем речь пойдет ниже.

Выполнение сопрограммы simple_coro2 можно разбить на три стадии, показанные на рис. 16.1.

1. next(my_coro2) печатает первое сообщение и выполняется до точки yield a, где отдает значение 14.