---
source_image: page_655.png
page_number: 655
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 57.36
tokens: 11912
characters: 2424
timestamp: 2025-12-24T02:05:25.584477
finish_reason: stop
---

Пример дескриптора: проверка значений атрибутов

Протестировав bulkfood_v4.py, мы увидим, что дескрипторы weight и price работают в соответствии с ожиданиями, а атрибуты хранения можно читать напрямую, что полезно для отладки:

```python
>>> from bulkfood_v4 import LineItem
>>> coconuts = LineItem('Brazilian coconut', 20, 17.95)
>>> coconuts.weight, coconuts.price
(20, 17.95)
>>> getattr(raisins, '_Quantity#0'), getattr(raisins, '_Quantity#1')
(20, 17.95)
```

Если бы мы хотели следовать соглашению, используемому в Python для декорирования имен (например, _LineItem__quantity0), то должны были бы знать имя управляемого класса (LineItem), однако определение тела класса обрабатывается еще до того, как интерпретатор построит сам класс, поэтому у нас нет этой информации в момент, когда создается экземпляр дескриптора. Но в данном случае и не нужно включать имя управляемого класса, чтобы избежать случайного перезаписывания в подклассах: значение __counter в дескрипторном классе увеличивается при создании каждого нового дескриптора, а, значит, имя атрибута хранения гарантированно будет уникальным во всех управляемых классах.

Отметим, что __get__ получает три аргумента: self, instance и owner. Аргумент owner содержит ссылку на управляемый класс (LineItem) и оказывается полезен, когда дескриптор используется для получения атрибутов из этого класса. Если управляемый атрибут, например weight, читается с помощью класса, например LineItem.weight, то метод дескриптора __get__ получает значение None в качестве аргумента instance. Это объясняет, почему в следующем сеансе оболочки возникает исключение AttributeError:

```python
>>> from bulkfood_v4 import LineItem
>>> LineItem.weight
Traceback (most recent call last):
    ...
File ".../descriptors/bulkfood_v4.py", line 54, in __get__
return getattr(instance, self.storage_name)
AttributeError: 'NoneType' object has no attribute '_Quantity#0'
```

Возбуждать исключение AttributeError при реализации __get__ можно, но если вы решите пойти по этому пути, то поправьте сообщение, чтобы не было упоминаний о NoneType и _Quantity#0, поскольку это детали реализации. Гораздо лучше звучало бы сообщение "'LineItem' class has no such attribute" (В классе 'LineItem' нет такого атрибута). В идеале следовало бы указать имя отсутствующего атрибута, но в данном случае дескриптор не знает имени управляемого атрибута, так что пока ничего лучшего мы предложить не можем.