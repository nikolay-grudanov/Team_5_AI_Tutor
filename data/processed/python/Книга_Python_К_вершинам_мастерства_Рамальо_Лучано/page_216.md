---
source_image: page_216.png
page_number: 216
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 47.05
tokens: 11809
characters: 1811
timestamp: 2025-12-24T01:44:46.879285
finish_reason: stop
---

13 LOAD_GLOBAL 1 (b) 3
16 CALL_FUNCTION 1 (1 positional, 0 keyword pair)
19 POP_TOP
20 LOAD_CONST 0 (None)
23 RETURN_VALUE

1 Загрузить глобальное имя print.
2 Загрузить локальное имя а.
3 Загрузить глобальное имя b.

А теперь сравните с байт-кодом функции f2 из примера 7.7.

Пример 7.7. Дизассемблированная функция f1 из примера 7.5

>>> dis(f2)
2   0 LOAD_GLOBAL 0 (print)
3   3 LOAD_FAST 0 (a)
6   6 CALL_FUNCTION 1 (1 positional, 0 keyword pair)
9   9 POP_TOP
3   10 LOAD_GLOBAL 0 (print)
13  13 LOAD_FAST 1 (b) 1
16  16 CALL_FUNCTION 1 (1 positional, 0 keyword pair)
19  19 POP_TOP
4   20 LOAD_CONST 1 (9)
23  23 STORE_FAST 1 (b)
26  26 LOAD_CONST 0 (None)
29  29 RETURN_VALUE

1 Загрузить локальное имя b. Как видим, компилятор считает b локальной переменной, даже если присваивание b встречается позже, поскольку природа переменной — локальная она или нет — не должна приводить к изменению тела функции.

Виртуальная машина CPython, которая исполняет байт-код, — это стековая машина, т. е. операции LOAD и POP относятся к стеку. Дальнейшее описание кодов операций Python выходит за рамки этой книги, но они документированы в разделе, посвященном модулю dis: «Дизассемблер байт-кода Python» (http://docs.python.org/3/library/dis.html).

Замыкания
В блогосфере замыкания иногда путают с анонимными функциями. Причина тому историческая: определение функций внутри функций кажется делом необычным, до тех пор пока мы не начинаем пользоваться анонимными функциями. А замыкания вступают в игру только при наличии вложенных функций. Поэтому многие изучают обе концепции одновременно.

На самом деле, замыкание — это функция с расширенной областью видимости, которая охватывает все неглобальные переменные, на которые есть ссылки в теле функции, хотя они в нем не определены. Не имеет значения, является функция