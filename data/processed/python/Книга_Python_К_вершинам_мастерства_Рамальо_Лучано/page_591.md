---
source_image: page_591.png
page_number: 591
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 53.49
tokens: 11900
characters: 2453
timestamp: 2025-12-24T02:02:29.657139
finish_reason: stop
---

Разработка серверов с помощью пакета asyncio

```python
msg = 'OK'

if verbose and msg:
    print(cc, msg)

return Result(status, cc)
```

1 Если тип содержимого содержит подстроку 'json' или аргумент url заканчивается строкой .json, то разбираем ответ методом response.json() и возвращаем структуру данных Python — в данном случае словарь dict.
2 В противном случае просто читаем поступающие байты методом .read().
3 В metadata записывается словарь Python, построенный в результате разбора содержимого в формате JSON.
4 Здесь внешние скобки необходимы, потому что, увидев подряд три слова return yield from, синтаксический анализатор Python выдаст ошибку.
5 Я поместил вызовы get_flag и get_country в разные блоки with, управляемые семафором semaphore, потому что не хочу удерживать семафор дольше, чем необходимо.

В примере 18.13 конструкция yield from встречается девять раз. Сейчас вы уже, вероятно, понимаете, как она используется для делегирования работы от одной сопограммы другой без блокировки цикла обработки событий.

Проблема в том, как узнать, когда нужно использовать yield from, а когда это делать нельзя. Принципиальный ответ прост: сопограммы и экземпляры класса asyncio.Future, в том числе задачи, активируются с помощью yield from. Но бывают запутанные API, где сопограммы и обычные функции комбинируются произвольными, на первый взгляд, способами, например, класс StreamWriter, которым мы воспользуемся при написании одного из серверов в следующем разделе.

Пример 18.13 завершает набор примеров из серии flags2. Рекомендую вам поэкспериментировать с ними, чтобы развить интуитивное понимание работы параллельных HTTP-клиентов. Параметры командной строки -a, -e и -1 позволяют изменять количество операций загрузки, а параметр -m — количество параллельных операций. Прогоните тесты на серверах типа LOCAL, REMOTE, DELAY и ERROR. Найдите, при каком количестве параллельных операций загрузки достигается максимальная производительность для каждого сервера. Поиграйте с настройками скрипта vaurien_error_delay.sh (http://bit.ly/1f6CY6B), чтобы добавить или устранить задержку и ошибки.

Мы же теперь перейдем к применению пакета asyncio для написания серверов.

Разработка серверов с помощью пакета asyncio

Классический пример «игрушечного» TCP-сервера — сервер эхо-контроля. Но мы разработаем чуть более интересные игрушки: сервер поиска символов Unicode — сначала по протоколу TCP, а затем — HTTP. Эти серверы позволяют клиентам за-