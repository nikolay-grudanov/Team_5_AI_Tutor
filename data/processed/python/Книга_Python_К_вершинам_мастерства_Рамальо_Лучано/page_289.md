---
source_image: page_289.png
page_number: 289
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 47.54
tokens: 11937
characters: 2100
timestamp: 2025-12-24T01:48:01.414181
finish_reason: stop
---

Экономия памяти с помощью атрибута класса __slots__

Пример 9.12. mem_test.py создает 10 миллионов экземпляров класса Vector2d из указанного при запуске модуля (например, vector2d_v3.py)

$ time python3 mem_test.py vector2d_v3.py
Selected Vector2d type: vector2d_v3.Vector2d
Creating 10,000,000 Vector2d instances
Initial RAM usage:      5,623,808
Final RAM usage: 1,558,482,944

real 0m16.721s
user 0m15.568s
sys 0m1.149s

$ time python3 mem_test.py vector2d_v3_slots.py
Selected Vector2d type: vector2d_v3_slots.Vector2d
Creating 10,000,000 Vector2d instances
Initial RAM usage:      5,718,016
Final RAM usage: 655,466,496

real 0m13.605s
user 0m13.163s
sys 0m0.434s

Как видно из примера 9.12, потребление памяти составляет 1,5 ГБ при использовании в каждом из 10 миллионов экземпляров Vector2d словаря __dict__, но снижается до 655 МБ, если используется атрибут __slots__. К тому же, версия с __slots__ еще и быстрее. Скрипт mem_test.py просто загружает модуль, измеряет потребление памяти и красиво выводит результаты. Его код не имеет отношения к делу, но приведен в приложении А (пример А-4).

Если в классе определен атрибут __slots__, то запрещается включать в его экземпляры какие-либо атрибуты, кроме перечисленных в __slots__. Но это побочный эффект, а не причина существования __slots__. Считается дурным тоном использовать __slots__ только для того, чтобы не дать пользователям класса создавать новые атрибуты в его экземплярах. Атрибут __slots__ предназначен для оптимизации, а не для связывания рук программистам.

Однако же возможно и «память сэкономить, и косточкой не подавиться»: если добавить имя '__dict__' в список __slots__, то все атрибуты, перечисленные в __slots__, будут храниться в кортеже, принадлежащем экземпляру, но при этом разрешено динамически создавать новые атрибуты, которые хранятся в словаре __dict__, как обычно. Разумеется, помещение '__dict__' в атрибут __slots__ может свести на нет все преимущества последнего, но это зависит от количества статических и динамических атрибутов и того, как они используются. Бездумная оптимизация еще хуже преждевременной.