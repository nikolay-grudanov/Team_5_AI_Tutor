---
source_image: page_588.png
page_number: 588
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 53.62
tokens: 11924
characters: 2542
timestamp: 2025-12-24T02:02:22.047526
finish_reason: stop
---

Глава 18. Применение пакета asyncio для организации...

уже недоступно. Для его сохранения между разными шагами обработки придется прибегнуть к замыканиям или внешним структурам данных.

Сопрограммы могли бы в этой ситуации оказаться очень полезны. Чтобы выполнить три асинхронных действия внутри сопрограммы, нужно три раза написать yield, уступая тем самым процессор циклу обработки событий. Когда результат будет готов, сопрограмма активируется вызовом .send(). С точки зрения цикла обработки событий, это аналогично активации функции обратного вызова. Но для пользователей асинхронного API на основе сопрограмм ситуация выглядит существенно лучше: вся последовательность трех операций находится внутри тела одной функции, как обычный последовательный код, а для сохранения контекста используются локальные переменные. См. пример 18.12.

Пример 18.12. Сопрограммы и выражение yield from открывают возможность для асинхронного программирования без обратных вызовов

@asyncio.coroutine
def three_stages(request1):
    response1 = yield from api_call1(request1)
    # шаг 1
    request2 = step1(response1)
    response2 = yield from api_call2(request2)
    # шаг 2
    request3 = step2(response2)
    response3 = yield from api_call3(request3)
    # шаг 3
    step3(response3)

# выполнение необходимо планировать явно
loop.create_task(three_stages(request1))

За логикой кода в примере 18.12 следить гораздо проще, чем в приведенных выше примерах на JavaScript и Python: все три шага операции следуют один за другим, не покидая тела функции. Использование предыдущих результатов для последующей обработки становится тривиальным делом, а, кроме того, имеется контекст для уведомления об ошибках посредством исключений.

Допустим, что в примере 18.11 вызов api_call2(request2, stage2) приводит к исключению ввода-вывода (в последней строке функции stage1). Перехватить его в stage1 невозможно, потому что вызов api_call2 асинхронный: он возвращает управление еще до выполнения ввода-вывода. В API на основе обратных вызовов эта проблема решается с помощью регистрации двух функций обратного вызова для каждого асинхронного вызова: одна вызывается в случае успешного завершения операции, другая — в случае ошибки. Условия работы в аду обратных вызовов быстро становятся невыносимыми, если приходится еще и обрабатывать ошибки.

А теперь сравните с примером 18.12, где все асинхронные вызовы трехшаговой операции находятся в одной функции three_stages: исключения, возникающие при асинхронном выполнении api_call1, api_call2 или api_call3, можно