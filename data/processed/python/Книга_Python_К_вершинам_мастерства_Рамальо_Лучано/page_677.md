---
source_image: page_677.png
page_number: 677
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 42.71
tokens: 11757
characters: 1767
timestamp: 2025-12-24T02:06:08.221180
finish_reason: stop
---

Фабрика классов

Эта тема настолько завораживает, что легко увлечься. Поэтому в самом начале главе я помещаю такое увещевание:

Если вы не занимаетесь разработкой каркаса, не пишите метаклассы — разве что для забавы или чтобы на практике освоить концепции.

Для начала опишем, как создавать класс на этапе выполнения.

Фабрика классов

В стандартной библиотеке есть фабрика классов, с которой мы уже неоднократно встречались: collections.namedtuple. Если этой функции передать имя класса и имена атрибутов, то она создаст подкласс tuple, который обеспечивает доступ к элементам по имени и предоставляет метод __repr__ для отладки.

Иногда у меня возникала потребность в аналогичной фабрике, порождающей изменяемые объекты. Предположим, что мы пишем приложение для зоомагазина и хотим обрабатывать данные о собаках как простые записи. Плохо, если придется писать такой стереотипный код:

class Dog:
    def __init__(self, name, weight, owner):
        self.name = name
        self.weight = weight
        self.owner = owner

Нудно-то как... каждое имя поля встречается по три раза. И даже симпатичного представления repr мы при этом не получили:

>>> rex = Dog('Rex', 30, 'Bob')
>>> rex
<__main__.Dog object at 0x2865bac>

Позаимствовав идею у collections.namedtuple, напишем функцию record_factory, которая будет создавать простые классы вроде Dog на лету. В примере 21.1 показано, как она должна работать.

Пример 21.1. Тестирование record_factory, простой фабрики классов

>>> Dog = record_factory('Dog', 'name weight owner') ①
>>> rex = Dog('Rex', 30, 'Bob') ②
>>> rex
Dog(name='Rex', weight=30, owner='Bob')
>>> name, weight, _ = rex ③
>>> name, weight
('Rex', 30)
>>> "{2}'s dog weighs {1}kg".format(*rex) ④
"Bob's dog weighs 30kg"
>>> rex.weight = 32 ⑤
>>> rex