---
source_image: page_445.png
page_number: 445
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 39.19
tokens: 11825
characters: 2083
timestamp: 2025-12-24T01:55:19.548965
finish_reason: stop
---

Другой пример: генератор арифметической прогрессии

В вызове конструктора Vector из метода __mul__ в примере 10.16 (воспроизведен ниже). Однако если после генераторного выражения есть еще аргументы, то его необходимо заключить в скобки во избежание синтаксической ошибки:

def __mul__(self, scalar):
    if isinstance(scalar, numbers.Real):
        return Vector(n * scalar for n in self)
    else:
        return NotImplemented

В примерах класса Sentence мы видели, как генераторы играют роль классических итераторов: извлекают элементы из коллекции. Но генераторы можно использовать и для порождения значений безо всякого источника данных.

Другой пример: генератор арифметической прогрессии

Классический паттерн Итератор относится к обходу некоторой структуры данных. Но стандартный интерфейс, основанный на методе извлечения следующего элемента ряда, полезен и тогда, когда элементы порождаются «на лету», а не выбираются из коллекции. Например, встроенная функция range генерирует ограниченную арифметическую прогрессию целых чисел, а функция itertools.count генерирует неограниченную арифметическую прогрессию.

В следующем разделе мы рассмотрим функции itertools.count, но что, если требуется сгенерировать ограниченную арифметическую прогрессию чисел произвольного типа?

В примере 14.10 показано несколько тестов класса ArithmeticProgression, который мы вскоре напишем. Конструктор имеет сигнатуру ArithmeticProgression(begin, step[, end]). Функция range() похожа на ArithmeticProgression, только ее полная сигнатура имеет вид range(start, stop[, step]). Я выбрал другую сигнатуру, потому что для арифметической прогрессии шаг step обязателен, а конечное значение end — нет. Кроме того, я заменил имена аргументов start/stop на begin/end, дав понять, что сигнатура поменялась. Во всех тестах в примере 14.10 я вызываю конструктор list() для просмотра сгенерированных значений.

Пример 14.10. Демонстрация класса ArithmeticProgression

>>> ap = ArithmeticProgression(0, 1, 3)
>>> list(ap)
[0, 1, 2]
>>> ap = ArithmeticProgression(1, .5, 3)
>>> list(ap)
[1.0, 1.5, 2.0, 2.5]