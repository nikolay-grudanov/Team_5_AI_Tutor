---
source_image: page_103.png
page_number: 103
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 43.05
tokens: 11814
characters: 1902
timestamp: 2025-12-24T01:39:20.128061
finish_reason: stop
---

Теория множеств

if n in haystack:
    found += 1

Программа из примера 3.10 работает чуть быстрее, чем из примера 3.11. С другой стороны, пример 3.11 работает для любых итерируемых объектов needles и haystack, тогда как в примере 3.10 требуется, чтобы оба были множествами. Впрочем, если исходные объекты множествами не были, то их легко можно построить на лету, как показано в примере 3.12.

Пример 3.12. Подсчет количества вхождений needles в haystack; этот код работает для любых итерируемых типов

found = len(set(needles) & set(haystack))

# или по-другому:
found = len(set(needles).intersection(haystack))

Разумеется, построение множеств в примере 3.12 обходится не бесплатно, но если needles или haystack уже является множеством, то варианты, показанные в примере 3.12, могут оказаться дешевле кода из примера 3.11.

Любой из показанных выше примеров тратит на поиск 1000 «иголок» в «стоге» haystack, состоящем из 10 000 000 элементов, чуть больше 3 миллисекунд, т. е. по 3 микросекунды на одну «иголку».

Помимо чрезвычайно быстрой проверки вхождения (благодаря механизму хэш-таблиц), встроенные типы set и frozenset предоставляют богатый набор операций для создания новых множеств или — в случае set — модификации существующих. Ниже мы обсудим эти операции, но сначала сделаем одно замечание о синтаксисе.

Литеральные множества

Синтаксис литералов типа set — {1},{1, 2} и т. д. — выглядит в точности, как математическая нотация за одним важным исключением: не существует литературного обозначения пустого множества, в таком случае приходится писать set().

Синтаксический подвох

Не забывайте: для создания пустого множества следует использовать конструктор без аргументов: set(). Написав {}, вы, как и в прошлых версиях, создадите пустой словарь.

В Python 3 для представления множеств строками используется нотация {...} во всех случаях, кроме пустого множества:

>>> s = {1}
>>> type(s)