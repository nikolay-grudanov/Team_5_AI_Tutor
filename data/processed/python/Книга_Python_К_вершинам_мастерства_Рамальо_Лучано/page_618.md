---
source_image: page_618.png
page_number: 618
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 50.25
tokens: 11874
characters: 2363
timestamp: 2025-12-24T02:03:35.576468
finish_reason: stop
---

### Изменение структуры набора данных OSCON с помощью модуля shelve

Забавное имя стандартного модуля shelve (полка) обретает смысл, если вспомнить что формат сериализации объектов в Python, а также модуль, преобразующий объекты в этот формат и обратно, называется pickle (консервы). Ну а поскольку банки с консервами хранятся на полках в кладовой, то не удивительно, что shelve предоставляет pickle средства хранения.

Высокоуровневая функция shelve.open возвращает экземпляр shelve.Shelf — простое хранилище ключей и значений, поддерживаемое модулем dbm и обладающее следующими характеристиками:

• класс shelve.Shelf является подклассом abc.MutableMapping, поэтому предоставляет все методы, которых мы ожидаем от типа отображения;
• кроме того, shelve.Shelf предоставляет несколько методов управления вводом-выводом, в частности sync и close, а также является контекстным менеджером;
• ключи и значения сохраняются в тот момент, когда ключу присваивается новое значение;
• ключи должны быть строками;
• значения должны быть объектами, с которыми умеет работать модуль pickle.

Подробности и подводные камни описаны в документации по модулям shelve (https://docs.python.org/3/library/shelve.html), dbm (https://docs.python.org/3/library/dbm.html) и pickle (https://docs.python.org/3/library/pickle.html). Нам важно, что shelve предлагает простой и эффективный способ реорганизовать набор данных OSCON: мы прочитаем все записи из JSON-файла и сохраним их в объекте shelve.Shelf. Ключ будет состоять из типа записи и порядкового номера (например, 'event.33950' или 'speaker.3471'), а значением станет экземпляр нового класса Record, который мы скоро напишем.

В примере 19.8 показаны doctest-скрипты для скрипта schedule1.py с использованием модуля shelve. Для интерактивного запуска выполните команду python -i schedule1.py, которая загрузит модуль и выведет приглашение. Основная работа возложена на функцию load_db: она вызывает метод osconfeed.load (из примера 19.2) для чтения JSON-данных и сохраняет каждую запись в виде экземпляра Record в объекте Shelf, который передан в аргументе db. После этого для получения записи о докладчике достаточно написать speaker = db['speaker.3471'].

Пример 19.8. Тестирование скрипта schedule1.py (пример 19.9)

```python
>>> import shelve
>>> db = shelve.open(DB_NAME)
>>> if CONFERENCE not in db:
...     load_db(db)
...