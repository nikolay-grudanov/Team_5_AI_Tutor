---
source_image: page_560.png
page_number: 560
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 44.66
tokens: 11838
characters: 2100
timestamp: 2025-12-24T02:00:54.467428
finish_reason: stop
---

поведение и производительность. И это большой плюс в тех особо ответственных задачах с высоким уровнем параллелизма, где Go рассчитывает заменить C++, Java и Python.

Хотя Elixir и Go — прямые конкуренты на поле параллелизма, их философия рассчитана на разную аудиторию. Скорее всего, обоим языкам уготована счастливая судьба. Но история учит, что более консервативные языки программирования привлекают больше последователей. Лично я хотел бы научиться уверенно писать на Go и Elixir.

К вопросу о GIL

GIL упрощает реализацию интерпретатора CPython и написанных на C расширений, поэтому мы можем сказать ей спасибо за огромное количество расширений, имеющихся для Python, а это, конечно же, одна из основных причин широчайшей популярности Python в наши дни.

Много лет мне казалось, что из-за GIL потоки Python полезны разве что в игрушечных приложениях. Так было до тех пор, пока я не открыл для себя, что все блокирующие функции ввода-вывода из стандартной библиотеки освобождают GIL, а, значит, потоки отлично подходят для систем с большим объемом ввода-вывода. А это как раз те приложения, за разработку которых мне платят заказчики.

Конкуренция в сфере параллелизма

В MRI — эталонной реализации Ruby — также имеется GIL, а, значит, потоки в этом языке подвержены тем же ограничениям, что в Python. А в JavaScript потоки на уровне пользователя не поддерживаются во-все; единственная возможность распараллеливания — асинхронное программирование с обратными вызовами. Я упомянул об этом, потому что Ruby и JavaScript — ближайшие прямые конкуренты Python на поле динамических языков программирования общего назначения.

Если же говорить о новом поколении языков с развитой поддержкой параллелизма, то Go и Elixir, пожалуй, скорее других способны отобрать у Python его долю. Если толпы людей верят, что Node.js с его ничем не прикрашенными обратными вызовами — жизнеспособная платформа для параллельного программирования, то как же трудно им будет устоять перед натиском Python, когда его экосистема на базе пакета asyncio достигнет зрелости? Но это тема для вкладки «Поговорим» в следующей главе.