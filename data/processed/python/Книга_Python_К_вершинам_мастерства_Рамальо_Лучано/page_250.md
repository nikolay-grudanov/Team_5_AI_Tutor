---
source_image: page_250.png
page_number: 250
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 42.94
tokens: 11788
characters: 1532
timestamp: 2025-12-24T01:46:10.089551
finish_reason: stop
---

11: [3, [66, 44, 33, 22], (7, 8, 9), 100]
12: [3, [66, 44, 33, 22], (7, 8, 9, 10, 11)]

<table>
  <tr>
    <th>Frames</th>
    <th>Objects</th>
  </tr>
  <tr>
    <td>Global frame</td>
    <td>list<br>0 1 2 3 100<br>list<br>0 1 2 3<br>66 44 33 22<br>tuple<br>0 1 2<br>7 8 9<br>list<br>0 1 2<br>3<br>tuple<br>0 1 2 3 4<br>7 8 9 10 11</td>
  </tr>
</table>

Рис. 8.4. Конечное состояние 11 и 12: они по-прежнему разделяют ссылки на один и тот же объект списка, который теперь содержит [66, 44, 33, 22], но в результате операции 12[2] += (10, 11) был создан новый кортеж (7, 8, 9, 10, 11), не связанный с кортежем (7, 8, 9), на который ссылается элемент 11[2] (рисунок построен сайтом Online Python Tutor)

Теперь должно быть понятно, что создать поверхностную копию легко, но это не всегда то, что нам нужно. В следующем разделе мы обсудим создание глубоких копий.

Глубокое и поверхностное копирование произвольных объектов

Не всегда поверхностное копирование является проблемой, но иногда требуется получить глубокую копию (когда копия не разделяет с оригиналом ссылки на внутренние объекты). В модуле copy имеются функции deepcopy и copy, которые возвращают соответственно глубокие и поверхностные копии произвольных объектов.

Для иллюстрации работы copy() и deepcopy() в примере 8.8 определен простой класс Bus, представляющий школьный, который по ходу маршрута подбирает и высаживает пассажиров.

Пример 8.8. Автобус подбирает и высаживает пассажиров

class Bus:

def __init__(self, passengers=None):
    if passengers is None: