---
source_image: page_099.png
page_number: 99
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 43.03
tokens: 11883
characters: 2316
timestamp: 2025-12-24T01:39:10.139536
finish_reason: stop
---

Создание подкласса UserDict

Создание подкласса UserDict

Почти всегда проще создать новый тип отображения путем расширения UserDict, а не dict. Ценность этого подхода можно оценить на примере класса StrKeyDict0 из примера 3.7, который преобразует ключ любого типа в тип str на этапе поиска.

Основная причина, по которой предпочтительнее наследовать классу UserDict, а не dict, заключается в том, что в реализации dict некоторые углы срезаны, что вынуждает нас переопределять методы, которые можно безо всяких проблем унаследовать от UserDict3.

Отметим, что UserDict не наследует dict, а хранит внутри себя экземпляр dict в атрибуте data, где и находятся сами элементы. Это позволяет избежать нежелательной рекурсии при кодировании таких специальных методов, как __setitem__, и упрощает код __contains__ по сравнению с тем, что показан в примере 3.7.

Благодаря UserDict класс StrKeyDict (пример 3.8) получился короче, чем StrKeyDict0 (пример 3.7), но умеет при этом больше: он хранит все ключи в виде str, обходя тем самым неприятные сюрпризы, возможные, если при создании или обновлении экземпляра были добавлены данные с нестроковыми ключами.

Пример 3.8. StrKeyDict всегда преобразует нестроковые ключи в тип str — при вставке, обновлении и поиске

import collections

class StrKeyDict(collections.UserDict): ①

    def __missing__(self, key): ②
        if isinstance(key, str):
            raise KeyError(key)
        return self[str(key)]

    def __contains__(self, key):
        return str(key) in self.data ③

    def __setitem__(self, key, item):
        self.data[str(key)] = item ④

① StrKeyDict расширяет UserDict.
② Метод __missing__ точно такой же, как в примере 3.7.
③ Метод __contains__ проще: можно предполагать, что все хранимые ключи имеют тип str, так что можно искать ключ в самом словаре self.data, а не вызывать self.keys(), как в классе StrKeyDict0.
④ Метод __setitem__ преобразует любой ключ в тип str. Этот метод проще переопределить, если можно делегировать работу атрибуту self.data.

Поскольку UserDict — подкласс MutableMapping, остальные методы, благодаря которым StrKeyDict является полноценным отображением, наследуются от

3 Точное описание проблем, сопряженных с наследованием dict и другим встроенным классам, см в разделе «Сложности наследования встроенным типам» на стр. 380.