---
source_image: page_632.png
page_number: 632
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 49.93
tokens: 11793
characters: 1745
timestamp: 2025-12-24T02:04:14.070006
finish_reason: stop
---

6 Теперь, читая obj.data, мы получаем значение атрибута экземпляра. Чтение экземпляра obj маскирует атрибут класса data.
7 Атрибут Class.data не изменился.

Попробуем теперь переопределить атрибут prop экземпляра obj. В примере 19.20 показано продолжение предыдущего сеанса.

Пример 19.20. Атрибут экземпляра не маскирует свойство класса (продолжение примера 19.19)

```python
>>> Class.prop # 1
<property object at 0x1072b7408>
>>> obj.prop # 2
'the prop value'
>>> obj.prop = 'foo' # 3
Traceback (most recent call last):
    ...
AttributeError: can't set attribute
>>> obj.__dict__['prop'] = 'foo' # 4
>>> vars(obj) # 5
{'prop': 'foo', 'attr': 'bar'}
>>> obj.prop # 6
'the prop value'
>>> Class.prop = 'baz' # 7
>>> obj.prop # 8
'foo'
```

1 Чтение prop непосредственно из Class возвращает сам объект свойства, при этом его метод чтения не выполняется.
2 Чтение obj.prop приводит к выполнению метода чтения.
3 Попытка установить атрибут экземпляра prop завершается ошибкой.
4 Запись 'prop' напрямую в obj.__dict__ работает.
5 Как видим, теперь у obj есть два атрибута экземпляра: attr и prop.
6 Однако при чтении obj.prop по-прежнему выполняется метод чтения свойства. Свойство не маскируется атрибутом экземпляра.
7 В случае перезаписывания Class.prop объект свойства уничтожается.
8 Теперь чтение obj.prop возвращает атрибут экземпляра. Class.prop больше не является свойством, поэтому и не переопределяет obj.prop.

В качестве заключительной демонстрации добавим новое свойство в Class и убедимся, что оно переопределяет атрибут экземпляра. Пример 19.21 продолжает предыдущий.

Пример 19.21. Новое свойство класса маскирует существующий атрибут экземпляра (продолжение примера 19.20)

```python
>>> obj.data # 1
'bar'
>>> Class.data # 2
```