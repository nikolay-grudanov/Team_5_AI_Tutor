---
source_image: page_239.png
page_number: 239
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 52.75
tokens: 11937
characters: 2319
timestamp: 2025-12-24T01:45:54.849368
finish_reason: stop
---

бота Маккарти — такой же шедевр, как Девятая симфония Бетховена. Пол Грэхем перевел ее для всех нас — с языка математики на английский, а затем на язык кода.

Из комментария Пола Грэхема также видно, что динамические области видимости далеко не тривиальны. Приведем цитату из его статьи:

Красноречивым свидетельством того, какими опасностями чреваты динамические области видимости, является тот факт, что даже самый первый пример функции высшего порядка в Lisp не работал — именно из-за них. Быть может, в 1960 году Маккарти не вполне сознавал последствия использования динамических областей видимости. Как бы то ни было, они оставались в реализациях Lisp на удивление долго — пока Сассмен (Sussman) и Стил (Steele) не разработали язык Scheme в 1975 году. Лексические области видимости не слишком усложняют определение eval, но затрудняют написание компиляторов.

Сегодня лексическая область видимости считается нормой: свободные переменные вычисляются в том окружении, в котором функция определена. Лексические области видимости усложняют реализацию языков с полноправными функциями, потому что зависят от поддержки замыканий. С другой стороны, исходный код с лексическими областями видимости проще читать. В большинстве языков, придуманных после Algol, имеются лексические области видимости.

В течение многих лет лямбда-выражения в Python не поддерживали замыкания, что снискало им дурную славу среди адептов функционального программирования в блогосфере. Это было исправлено в версии Python 2.2 (декабрь, 2001), но у блогосферы долгая память. С тех пор к конструкции lambda есть только одна претензия: синтаксические ограничения.

Декораторы в Python и паттерн проектирования Декоратор

Декораторы функций в Python согласуются с общим описанием паттерна Декоратор в книге Гамма и др. «Паттерны проектирования»: «Динамически добавляет объекту новые обязанности. Является гибкой альтернативой порождению подклассов с целью расширения функциональности». На уровне реализации декораторы в Python не имеют ничего общего с классическим паттерном Декоратор, но какую-то аналогию провести можно.

В паттерне проектирования Decorator и Component — абстрактные классы. Экземпляр конкретного декоратора обертывает экземпляр конкретного компонента, чтобы расширить его поведение. Приведем цитату из «Паттернов проектирования»: