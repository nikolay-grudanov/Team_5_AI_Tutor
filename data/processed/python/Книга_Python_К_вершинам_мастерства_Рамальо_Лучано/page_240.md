---
source_image: page_240.png
page_number: 240
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 38.01
tokens: 11597
characters: 1445
timestamp: 2025-12-24T01:45:46.116413
finish_reason: stop
---

Декоратор следует интерфейсу декорируемого объекта, поэтому его присутствие прозрачно для клиентов компонента. Декоратор переадресует запросы внутреннему компоненту, но может выполнять и дополнительные действия (например, рисовать рамку) до или после переадресации. Поскольку декораторы прозрачны, они могут вкладываться друг в друга, добавляя тем самым любое число новых обязанностей.

В Python декоратор играет роль конкретного подкласса Decorator, а внутренняя функция, которую он возвращает, является экземпляром декоратора. Возвращенная функция обертывает декорируемую функцию, которая может быть уподоблена компоненту в паттерне проектирования. Возвращенная функция прозрачна, потому что согласуется с интерфейсом компонента, ведь она принимает те же самые аргументы. Она переадресует вызов компоненту и может выполнять дополнительные действия до или после переадресации. Мы можем перформулировать последнее предложение из приведенной цитаты следующим образом: «Поскольку декораторы прозрачны, они могут вкладываться друг в друга, добавляя тем самым любое число новых видов поведения». Именно это свойство открывает возможность композиции декораторов.

Я вовсе не предлагаю использовать декораторы для реализации паттерна Декоратор в программах на Python. Хотя в некоторых специфических ситуациях это возможно, в общем случае паттерн Декоратор лучше реализовать с помощью классов, представляющих сам Декоратор и обертываемые им компоненты.