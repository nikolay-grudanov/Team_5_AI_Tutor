---
source_image: page_268.png
page_number: 268
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 50.76
tokens: 11911
characters: 2349
timestamp: 2025-12-24T01:47:02.069801
finish_reason: stop
---

вреждены. С другой стороны, если синхронизации слишком много, возникают взаимоблокировки.

Уничтожение объектов и сборка мусора

В Python нет механизма прямого уничтожения объекта, и это не упущение, а великое благо: если бы можно было уничтожить объект в любой момент, что стало бы с указывающими на него сильными ссылками?

В CPython сборка мусора основана, главным образом, на механизме подсчета ссылок; он легко реализуется, но ведет к утечке памяти при наличии циклических ссылок. Поэтому в версии 2.0 (октябрь, 2000) был реализован сборщик мусора на основе поколений, который умеет уничтожать группы объектов, связанных только циклическими ссылками и недостижимых извне.

Но подсчет ссылок по-прежнему остается основным механизмом и приводит к немедленному уничтожению объектов, на которые не осталось ссылок. Это означает, что в CPython — по крайней мере, сейчас — безопасно такое предложение:

open('test.txt', 'wt', encoding='utf-8').write('1, 2, 3')

Этот код безопасен, потому что счетчик ссылок на объект файла окажется равен нулю после возврата из метода write, и Python немедленно закроет файл, перед тем как уничтожить объект, представляющий его в памяти. Однако в Jython или IronPython эта строка небезопасна, т. к. они пользуются более сложными сборщиками мусора в объемлющей среде выполнения (Java VM и .NET CLR соответственно), которые не опираются на подсчет ссылок и могут отложить уничтожение объекта и закрытие файла на неопределенное время. Поэтому в любом случае и, в частности, в CPython рекомендуется явно закрывать файл, а самый надежный способ сделать это — воспользоваться предложением with, которое гарантирует закрытие файла, даже если пока он был открыт, произошло исключение. С использованием with показанный выше фрагмент можно записать так:

with open('test.txt', 'wt', encoding='utf-8') as fp:
    fp.write('1, 2, 3')

Если вас заинтересовала тема сборщиков мусора, можете почитать статью Томаса Перла (Thomas Perl) «Python Garbage Collector Implementations: CPython, PyPy and GaS» (http://bit.ly/1Gt0HrJ), из которой я узнал о безопасности open().write() в CPython.

Передача параметров: вызов по соиспользованию

Популярным объяснением механизма передачи параметров в Python является фраза: «Параметры передаются по значению, но значениями являются ссылки». Нельзя сказать, что это неверно, но вводит в заблуж-