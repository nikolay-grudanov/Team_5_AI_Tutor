---
source_image: page_303.png
page_number: 303
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 45.34
tokens: 11899
characters: 2514
timestamp: 2025-12-24T01:48:40.050889
finish_reason: stop
---

Протоколы и динамическая типизация

структора возвращают одинаковые объекты Vector, я предпочел более простой синтаксис с использованием аргумента типа list.

При написании метода __repr__ я мог бы вывести упрощенное отображение components с помощью такого выражения: reprlib.repr(list(self._components)). Но это было бы расточительно, поскольку пришлось бы копировать каждый элемент self._components в list только для того, чтобы использовать list repr. Вместо этого я решил применить reprlib.repr непосредственно к массиву self._components, а затем отбросить все символы, оказавшиеся вне квадратных скобок []. Для этого и предназначена вторая строка метода __repr__ в примере 10.2.

Поскольку метод repr() вызывается во время отладки, он никогда не должен возбуждать исключение. Если в __repr__ происходит какая-то ошибка, вы должны обработать ее сами и сделать все возможное, чтобы показать пользователю нечто разумное, позволяющее идентифицировать объект.

Отметим, что методы __str__, __eq__ и __bool__ остались такими же, как в классе Vector2d, а в методе frombytes изменился только один символ (удален символ * в последней строке). Это воздействие за то, что класс Vector2d изначально был сделан итерируемым.

Кстати, я мог бы сделать Vector подклассом Vector2d, но не стал по двум причинам. Во-первых, при наличии несовместимых конструкторов создавать подклассы не рекомендуется. Эту трудность можно было бы обойти за счет хитроумной обработки параметров в __init__, но есть и вторая, более важная, причина: я хочу, чтобы Vector был не зависящим от других классов примером реализации протокола последовательности. Этим мы и займемся далее, предварительно обсудив сам термин протокол.

Протоколы и динамическая типизация

Еще в главе 1 мы видели, что для создания полнофункционального типа последовательности в Python необязательно наследовать какому-то специальному классу; нужно лишь реализовать методы, удовлетворяющие протоколу последовательности. Но что это за протокол такой?

В объектно-ориентированном программировании протоколом называется неформальный интерфейс, определенный только в документации, но не в коде. Например, протокол последовательности в Python подразумевает только наличие методов __len__ и __getitem__. Любой класс Spam, в котором есть такие методы со стандартной сигнатурой и семантикой, можно использовать всюду, где ожидается последовательность. Является Spam подклассом какого-то другого класса или нет, роли не играет. Мы видели это в примере 1.1, который воспроизведен ниже.