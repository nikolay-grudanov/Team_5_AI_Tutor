---
source_image: page_210.png
page_number: 210
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 25.94
tokens: 11589
characters: 1354
timestamp: 2025-12-24T01:44:10.059463
finish_reason: stop
---

3 При вызове декорированной функции target на самом деле выполняется inner.
4 Инспекция показывает, что target теперь ссылается на inner.

Строго говоря, декораторы — не более чем синтаксическая глазурь. Как мы видели, всегда можно просто вызвать декоратор как обычный вызываемый объект, передав ему функцию. Иногда это действительно удобно, особенно для метапрограммирования — изменения поведения программы в процессе ее выполнения.

Подведем итоги: главное, что нужно знать о декораторах, — тот факт, что они властны заменить декорируемую функцию другой. Второе — что они выполняются сразу после загрузки модуля. Этот момент мы объясним в следующем разделе.

Когда Python выполняет декораторы

Главное свойство декораторов — то, что они выполняются сразу после определения декорируемой функции. Обычно на этапе импорта (т. е. когда Python загружает модуль). Рассмотрим скрипт registration.py в примере 7.2.

Пример 7.2. Модуль registration.py

registry = [] ①

def register(func): ②
    print('running register(%s)' % func) ③
    registry.append(func) ④
    return func ⑤

@register ⑥
def f1():
    print('running f1()')

@register
def f2():
    print('running f2()')

def f3(): ⑦
    print('running f3()')

def main(): ⑧
    print('running main()')
    print('registry ->', registry)
    f1()
    f2()
    f3()

if __name__ == '__main__':
    main() ⑨