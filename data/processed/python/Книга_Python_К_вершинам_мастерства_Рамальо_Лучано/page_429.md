---
source_image: page_429.png
page_number: 429
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 40.04
tokens: 11779
characters: 2052
timestamp: 2025-12-24T01:54:39.962859
finish_reason: stop
---

Класс Sentence, попытка № 1: последовательность слов

>>> list(s) # 4
['The', 'time', 'has', 'come', 'the', 'Walrus', 'said']

1 По строке создается предложение — объект класса Sentence.
2 Обратите внимание на результат __repr__ — строку, содержащую многоточие, которая была сгенерирована функцией reprlib.repr.
3 Объекты Sentence являются итерируемыми, скоро мы в этом убедимся.
4 Будучи итерируемыми, объекты sentence могут быть использованы для конструирования списков и других итерируемых типов.

Далее мы разработаем другие классы Sentence, которые будут успешно проходить тесты из примера 14.2. Но реализация из примера 14.1 отличается от всех остальных тем, что является также последовательностью, а, значит, допускает доступ к слову по индексу.

>>> s[0]
'The'
>>> s[5]
'Walrus'
>>> s[-1]
'said'

Любой программирующий на Python знает, что последовательности — итерируемые объекты. Разберемся, почему это так.

Почему последовательности итерируемы: функция iter

Всякий раз как интерпретатору нужно обойти объект x, он автоматически вызывает функцию iter(x).

Встроенная функция iter выполняет следующие действия.

1. Смотрим, реализует ли объект метод __iter__, и, если да, вызывает его, чтобы получить итератор.
2. Если метод __iter__ не реализован, но реализован метод __getitem__, то Python создает итератор, который пытается извлекать элементы по порядку, начиная с индекса 0.
3. Если и это не получается, то возбуждается исключение — обычно с сообщением «C object is not iterable», где C — класс объекта.

Именно поэтому любая последовательность в Python является итерируемой: все они реализуют метод __getitem__. На самом деле, стандартные последовательности реализуют и метод __iter__, и ваши должны поступать так же, поскольку специальная обработка метода __getitem__ оставлена только ради обратной совместимости и может быть исключена в будущем (хотя пока не объявлена нерекомендуемой).

В разделе «Python в поисках следов последовательностей» главы 11 отмечалось, что это крайняя форма динамической типизации: объект считается итери-