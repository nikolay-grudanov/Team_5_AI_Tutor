---
source_image: page_161.png
page_number: 161
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 48.87
tokens: 11979
characters: 2513
timestamp: 2025-12-24T01:42:11.778666
finish_reason: stop
---

Unicode. Я сожалею об отсутствии более определенных рекомендаций, но исключений из правил Unicode так много, что утверждать что-то с полной уверенностью трудно.

Например, символ μ (микро) считается «символом совместимости», а Ω (ом) и Å (ангстрем) — нет. Это различие имеет практические последствия: алгоритм нормализации NFC — рекомендуемый для сравнения текстов — заменяет символ Ω (ом) символом Ω (заглавная греческая буква омега), а символ Å (ангстрем) — символом Å (заглавная А с кружочком). Но «символ совместимости» μ (знак микро) заменяется визуально идентичным ему символом μ (строчная греческая буква мю) только в более строгих формах нормализации NFKC и NFKD, которые влекут за собой потерю информации.

Я понимаю, что символ μ (знак микро) включен в Unicode, потому что он имеется в наборе символов latin1, и замена его греческой буквой мю нарушила бы обратимость преобразования. В конце концов, именно поэтому знак микро и сделан «символом совместимости». Но если символы ома и ангстрема включены в Unicode не по соображениям совместимости, то зачем было вообще включать их? Ведь есть же уже кодовые позиции GREEK CAPITAL LETTER OMEGA и LATIN CAPITAL LETTER A WITH RING ABOVE, которые выглядят точно так же и подставляются алгоритмом нормализации NFC. Поди угадай.

После многих часов изучения Unicode я пришел к выводу: этот стандарт неимоверно сложен и полон особых случаев, что отражает чудесное многообразие естественных языков и политику, принятую при разработке отраслевых стандартов.

Как объекты str представлены в памяти?

В официальном руководстве по Python старательно обходится вопрос о том, как кодовые позиции строки str хранятся в памяти. В конце концов, это действительно деталь реализации. Теоретически это не имеет значения: каким бы ни было внутреннее представление, каждая строка при выводе должна перекодироваться в объект типа bytes.

В Python 3 объект str хранится в памяти как последовательность кодовых позиций с фиксированным количеством байтов на одну позицию, чтобы обеспечить прямой доступ к любому символу или срезу.

До версии Python 3.3 CPython можно было откомпилировать, так чтобы под кодовую позицию в памяти отводилось 16 или 32 бит; первый способ назывался «узкой сборкой», второй — «широкой сборкой». Чтобы узнать, как откомпилирована ваша версия, нужно проверить параметр sys.maxunicode: 65535 означает «узкую сборку», которая не способна без вмешательства программиста работать с кодовыми позициями, большими U+FFFF. У «широкой сборки» такого ограничения нет,