---
source_image: page_063.png
page_number: 63
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 49.03
tokens: 11889
characters: 2166
timestamp: 2025-12-24T01:37:33.130954
finish_reason: stop
---

Метод list.sort и встроенная функция sorted

строк задать key=str.lower, то строки будут сортироваться без учета регистра, а если key=len, то по длине в символах. По умолчанию подразумевается тождественная функция (т. е. сравниваются сами элементы).

Необязательный именованный параметр key можно также использовать совместно с встроенными функциями min() и max() и другими функциями из стандартной библиотеки (например, itertools.groupby() или heapq.nlargest()).

Примеры ниже иллюстрируют применение этих функций и именованных аргументов6:

>>> fruits = ['grape', 'raspberry', 'apple', 'banana']
>>> sorted(fruits)
['apple', 'banana', 'grape', 'raspberry'] ①
>>> fruits
['grape', 'raspberry', 'apple', 'banana'] ②
>>> sorted(fruits, reverse=True)
['raspberry', 'grape', 'banana', 'apple'] ③
>>> sorted(fruits, key=len)
['grape', 'apple', 'banana', 'raspberry'] ④
>>> sorted(fruits, key=len, reverse=True)
['raspberry', 'banana', 'grape', 'apple'] ⑤
>>> fruits
['grape', 'raspberry', 'apple', 'banana'] ⑥
>>> fruits.sort()
>>> fruits
['apple', 'banana', 'grape', 'raspberry'] ⑧

① Порождает новый список строк, отсортированный в алфавитном порядке.
② Инспекция исходного списка показывает, что он не изменился.
③ Это сортировка в обратном алфавитном порядке.
④ Новый список строк, отсортированный уже по длине. Поскольку алгоритм сортировки устойчивый, строки «grape» и «apple», обе длины 5, остались в том же порядке.
⑤ Здесь строки отсортированы в порядке убывания длины. Результат не является инверсией предыдущего, потому что в силу устойчивости сортировки «grape» по-прежнему оказывается раньше «apple».
⑥ До сих пор порядок исходного списка fruits не изменился.
⑦ Этот метод сортирует список на месте и возвращает None (оболочка не показывает это значение).
⑧ Теперь массив fruits отсортирован.

В отсортированной последовательности поиск производится очень эффективно. К счастью, стандартный алгоритм двоичного поиска уже имеется в модуле

6 Примеры заодно демонстрируют, что используемый в Python алгоритм Timsort устойчив (т. е. сохраняет относительный порядок равных элементов). Алгоритм Timsort обсуждается далее на врезке «Поговорим» в конце этой главы.