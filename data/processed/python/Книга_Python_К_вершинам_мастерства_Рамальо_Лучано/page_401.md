---
source_image: page_401.png
page_number: 401
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 38.19
tokens: 11763
characters: 1593
timestamp: 2025-12-24T01:53:12.074084
finish_reason: stop
---

Перегрузка оператора сложения векторов +

вым счетчиком. А унарный + прибавляет пустой объект Counter и, следовательно, сохраняет только те элементы, в которых счетчик больше нуля.

Пример 13.3. Унарный + порождает новый объект Counter, в который не входят элементы с нулевыми и отрицательными счетчиками

```python
>>> ct = Counter('abracadabra')
>>> ct
Counter({'a': 5, 'r': 2, 'b': 2, 'd': 1, 'c': 1})
>>> ct['r'] = -3
>>> ct['d'] = 0
>>> ct
Counter({'a': 5, 'b': 2, 'c': 1, 'd': 0, 'r': -3})
>>> +ct
Counter({'a': 5, 'b': 2, 'c': 1})
```

А теперь вернемся к обычному программированию.

Перегрузка оператора сложения векторов +

Класс Vector — это последовательность, а в разделе 3.3.6 «Эмуляция контейнерных типов» главы «Модель данных» (http://bit.ly/1QOyDQY) говорится, что последовательности должны поддерживать оператор + с семантикой конкатенации и * с семантикой повторения. Однако в данном случае мы реализуем + и * как математические операторы, что несколько труднее, но для типа Vector более осмысленно.

Сложение двух евклидовых векторов дает новый вектор, компоненты которого являются суммами соответственных компонент слагаемых, например:

```python
>>> v1 = Vector([3, 4, 5])
>>> v2 = Vector([6, 7, 8])
>>> v1 + v2
Vector([9.0, 11.0, 13.0])
>>> v1 + v2 == Vector([3+6, 4+7, 5+8])
True
```

Что будет, если сложить два экземпляра Vector разной длины? Мы могли бы возбудить исключение, но в реальных приложениях (например, в информационном поиске) лучше дополнить более короткий вектор нулями. Вот какой результат мы хотим получить:

```python
>>> v1 = Vector([3, 4, 5, 6])
```