---
source_image: page_315.png
page_number: 315
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 33.66
tokens: 11687
characters: 1625
timestamp: 2025-12-24T01:49:00.751602
finish_reason: stop
---

Vector, попытка № 4: хэширование и ускорение оператора ==

return functools.reduce(operator.xor, hashes, 0) # 5
# последующие строки опущены...

1 Импортируем functools для использования reduce.
2 Импортируем operator для использования xor.
3 Метод __eq__ не изменился; я привел его, только потому что методы __eq__ и __hash__ принято располагать в исходном коде рядом, т. к. они дополняют друг друга.
4 Создаем генераторное выражение для отложенного вычисления хэша каждой компоненты.
5 Подаем выражение hashes на вход reduce вместе с функцией xor — для вычисления итогового хэш-значения; третий аргумент, равный 0, — инициализатор (см. предупреждение ниже).

При использовании reduce рекомендуется задавать третий аргумент, reduce(function, iterable, initializer), чтобы предотвратить появление исключения TypeError: reduce() of empty sequence with no initial value (отличное сообщение: описывается проблема и способ исправления). Значение initializer возвращается, если последовательность пуста, а, кроме того, используется в качестве первого аргумента в цикле редукции, поэтому оно должно быть нейтральным элементом относительно выполняемой операции. Так, для операций +, |, ^ initializer должен быть равен 0, а для *, & — 1.

Метод __hash__ в примере 10.8 — отличный пример техники mapreduce (рис. 10.2).

![Рис. 10.2. Map-reduce: применить функцию к каждому элементу для генерации новой последовательности (map), затем вычислить агрегат (reduce)](https://i.imgur.com/3Q5z5QG.png)

Рис. 10.2. Map-reduce: применить функцию к каждому элементу для генерации новой последовательности (map), затем вычислить агрегат (reduce)