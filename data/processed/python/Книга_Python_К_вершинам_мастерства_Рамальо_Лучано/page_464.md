---
source_image: page_464.png
page_number: 464
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 52.21
tokens: 12053
characters: 2725
timestamp: 2025-12-24T01:56:34.721240
finish_reason: stop
---

Глава 14. Итерируемые объекты, итераторы и генераторы

мощью двух разных API в одном и том же цикле for, где еще и порождался JSON, оказалось бы очень громоздким.

Было принято решение инкапсулировать логику чтения в двух генераторных функциях, по одной для каждого поддерживаемого формата. В итоге скрипт isis2json.py распался на четыре функции. Головной скрипт приведен в примере А-5, а полный исходный код со всеми зависимостями находится в каталоге fluentpython/isis2json (http://bit.ly/1HGqzzT) на GitHub.

Приведу общее описание структуры скрипта.

main
Функция main вызывает argparse для разбора параметров командной строки, управляющих структурой выходных записей. В зависимости от расширения имени входного файла выбирается та или иная генераторная функция для чтения данных и отдачи записей по одной.

iter_iso_records
Эта генераторная функция читает iso-файлы (в формате ISO-2709). Она принимает два аргумента: имя файла и флаг isis_json_type, относящийся к структуре записи. На каждой итерации своего цикла for она читает одну запись, создает пустой словарь, заполняет его данными полей и отдает объект dict.

iter_mst_records
Эта генераторная функция читает mst-файлы11. Заглянув в исходный код isis2json.py, вы увидите, что она не так проста, как iter_iso_records, но ее интерфейс и общая структура такие же: принимает имя файла и аргумент isis_json_type, затем входит в цикл for, где на каждой итерации строит и отдает объект dict, представляющий одну запись.

write_json
Эта функция выводит JSON-записи, по одной за раз. У нее много аргументов, но самый первый — input_gen — содержит ссылку на генераторную функцию: iter_iso_records ИЛИ iter_mst_records. Главный цикл for в функции write_json потребляет словари, которые отдает генератор input_gen, обрабатывает их различными способами, определяемыми параметрами в командной строке, и дописывает JSON-запись в конец выходного файла.

Воспользовавшись генераторными функциями, я смог разделить логику чтения и записи. Конечно, проще всего это было бы сделать, прочитав сразу все записи в память, затем обработать их и записать на диск в другом формате. Но из-за размера набора данных такое решение не проходит. Благодаря генераторам чтение и запись чередуются, так что скрипт может обрабатывать файлы любого размера.

11 Библиотека для чтения сложных двоичных mst-файлов написана на Java, так что эта функциональность доступна, только когда скрипт isis2json.py выполняется интерпретатором Jython версии не ниже 2.5. Дополнительные сведения см. в файле README.rst (http://bit.ly/1MM5aXD) в репозитории. Зависимости импортируются в генераторных функциях, которым они необходимы, так что скрипт может работать, даже если доступна только одна из внешних библиотек.