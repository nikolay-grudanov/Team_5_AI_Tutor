---
source_image: page_680.png
page_number: 680
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 49.16
tokens: 11898
characters: 2241
timestamp: 2025-12-24T02:06:21.824714
finish_reason: stop
---

Глава 21. Метапрограммирование классов

шаблон исходного кода в виде строки, а функция namedtuple подставляет в него значения, вызывая метод _class_template.format(...). Получившийся исходный код затем интерпретируется с помощью встроенной функции exec.

Занимаясь метапрограммированием на Python, лучше избегать функций exec и eval. Они небезопасны, если получают на вход строки (даже фрагменты) из источников, не заслуживающих доверия. Python располагает достаточным набором средств интроспекции, чтобы в большинстве случаев обойтись без exec и eval. Однако разработчики ядра Python решили использовать exec при реализации namedtuple. При таком подходе сгенерированный исходный код класса можно получить из атрибута .source (http://bit.ly/1HGwAfW).

У экземпляров классов, созданных функцией record_factory, есть ограничение: они не сериализуемы, т. е. к ним неприменимы функции dump и load из модуля pickle. Решение этой проблемы выходит за рамки настоящего примера, цель которого — продемонстрировать использование класса type в простом случае. Полное решение смотрите в исходном коде collections.namedtuple (http://bit.ly/1HGwexRl); ищите по слову «pickling».

Декоратор класса для настройки дескрипторов

Когда мы расстались с классом LineItem в разделе «LineItem попытка № 5: новый тип дескриптора» главы 20, остался нерешенным вопрос о содержательных именах атрибутов хранения: значение атрибута, например weight, хранилось в атрибуте экземпляра с именем вида _Quantity#0, что затрудняло отладку. Получить имя атрибута хранения от дескриптора в примере 20.7 можно с помощью такого кода:

>>> LineItem.weight.storage_name
'_Quantity#0'

Но было бы лучше, если бы имена атрибутов хранения включали имя управляемого атрибута, например:

>>> LineItem.weight.storage_name
'_Quantity#weight'

Напомним, что в разделе «LineItem попытка № 4: автоматическая генерация имен атрибутов хранения» главы 20 мы не могли использовать содержательные имена атрибутов хранения, потому что в момент создания дескриптора нет никакой возможности узнать имя управляемого атрибута (т. е. атрибута класса, с которым будет связан дескриптор, например, weight в примерах выше). Но после того как весь класс собран и дескрипторы привязаны к атрибутам класса, мы