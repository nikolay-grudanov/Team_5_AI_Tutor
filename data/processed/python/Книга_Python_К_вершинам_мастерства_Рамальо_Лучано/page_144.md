---
source_image: page_144.png
page_number: 144
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 24.50
tokens: 11620
characters: 1372
timestamp: 2025-12-24T01:41:04.017957
finish_reason: stop
---

имеющих имена символов в Unicode 6.3.

Как все связанное с Unicode, сворачивание регистра — сложная лингвистическая проблема с множеством особых случаев, но разработчики ядра Python приложили максимум усилий, чтобы предложить решение, устраивающее большинство пользователей.

В следующих двух разделах мы применим знания о нормализации к разработке служебных функций.

Служебные функции для сравнения нормализованного текста

Как мы видели, формы нормализации NFC и NFD безопасны и позволяют достаточно осмысленно сравнивать Unicode-строки. Для большинства приложений NFC — наилучшая нормализованная форма. Для сравнения строк без учета регистра предназначен метод str.casefold().

Если вы работаете с текстами на многих языках, рекомендуем включить в свой арсенал функции наподобие nfc_equal и fold_equal, показанные в примере 4.13.

Пример 4.13. normeq.py: сравнение нормализованных Unicode-строк

"""
Служебные функции для сравнения нормализованных Unicode-строк.

Использование нормальной формы C, с учетом регистра:

>>> s1 = 'café'
>>> s2 = 'cafe\u0301'
>>> s1 == s2
False
>>> nfc_equal(s1, s2)
True
>>> nfc_equal('A', 'a')
False

Использование нормальной формы C, со сворачиванием регистра:

>>> s3 = 'Straße'
>>> s4 = 'strasse'
>>> s3 == s4
False
>>> nfc_equal(s3, s4)
False
>>> fold_equal(s3, s4)
True
>>> fold_equal(s1, s2)
True
>>> fold_equal('A', 'a')
True
"""