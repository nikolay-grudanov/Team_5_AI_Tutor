---
source_image: page_568.png
page_number: 568
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 45.83
tokens: 11797
characters: 2200
timestamp: 2025-12-24T02:01:08.225982
finish_reason: stop
---

Пример 18.4. spinner_asyncio.py: асинхронная сопрограмма supervisor

@asyncio.coroutine
def supervisor():
    spinner = asyncio.async(spin('thinking!'))
    print('spinner object:', spinner)
    result = yield from slow_function()
    spinner.cancel()
    return result

Ниже перечислены основные различия между этими двумя реализациями.

• Класс asyncio.Task — грубый эквивалент threading.Thread. Виктор Стиннер, рецензировавший эту главу, говорит, что «Task подобен зеленому потоку в библиотеках, реализующих невытесняющую многозадачность, например gevent».
• Объект Task управляет сопрограммой, а Thread исполняет вызываемый объект.
• Мы не создаем объекты Task самостоятельно, а получаем их, передав сопрограмму функции asyncio.async(...) или loop.create_task(...).
• Для полученного объекта Task уже запланировано выполнение (например, функцией asyncio.async); экземпляру Thread необходимо явно сказать, что пора начать выполнение, вызвав для этого его метод start.
• В потоковой версии supervisor обычная функция slow_function напрямую вызывается из потока. В asyncio supervisor slow_function — сопрограмма, управляемая с помощью yield from.
• Не существует функции, которая позволяла бы завершить поток извне, поскольку прерывание потока в произвольной точке могло бы оставить систему в некорректном состоянии. Для задач имеется метод экземпляра Task.cancel(), который возбуждает исключение CancelledError в том месте сопрограммы, где находится выражение yield, вызвавшее ее приостановку. Сопрограмма может перехватить это исключение и решить, что с ним делать.
• Сопрограмма supervisor должна быть передана в качестве аргумента функции loop.run_until_complete, вызванной из main.

Из этого сравнения должно быть ясно, что asyncio координирует параллельные задачи иначе, чем более привычный модуль threading.

И последнее, что хочется сказать в этой связи: если вам приходилось писать нетривиальные программы с потоками, то вы знаете, как сложно рассуждать о программе, поскольку планировщик может прервать поток в любой момент. Вы должны не забывать ставить блокировки для защиты критических секций программы, чтобы прерывание в середине многошаговой операции не привело к повреждению данных.