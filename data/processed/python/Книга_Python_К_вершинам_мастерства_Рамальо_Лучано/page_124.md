---
source_image: page_124.png
page_number: 124
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 42.23
tokens: 11939
characters: 2281
timestamp: 2025-12-24T01:40:22.021672
finish_reason: stop
---

Для двоичных последовательностей существует метод класса, отсутствующий в типе str: fromhex, который строит последовательность, разбирая пары шестнадцатеричных цифр, которые могут быть разделены пробелами, хотя это и необязательно.

```python
>>> bytes.fromhex('31 4B CE A9')
b'1K\xce\xa9'
```

Другие способы построения объектов bytes и bytearray связаны с вызовом различных конструкторов:

• с именованными аргументами str и encoding;
• с итерируемым объектом, порождающим элементы со значениями от 0 до 255;
• с одним целым числом, для создания двоичной последовательности такого размера, инициализированной нулевыми байтами (эта сигнатура будет объявлена нерекомендуемой в Python 3.5 и исключена в Python 3.6. См. документ «PEP 467 – Minor API improvements for binary sequences» (https://www.python.org/dev/peps/pep-0467/));
• с объектом, который реализует протокол буфера (например, bytes, bytearray, memoryview, array.array), при этом байты копируются из исходного объекта во вновь созданную двоичную последовательность.

Построение двоичной последовательности из буфероподобного объекта — это низкоуровневая операция, которая может потребовать приведения типов. См. пример 4.3.

Пример 4.3. Инициализация байтов данными, хранящимися в массиве

```python
>>> import array
>>> numbers = array.array('h', [-2, -1, 0, 1, 2])  # Код типа 'h' означает создание массива коротких целых (16-разрядных).
>>> octets = bytes(numbers)  # В объекте octets хранится копия байтов, из которых составлены числа в массиве numbers.
>>> octets
b'\xfe\xff\xff\xff\x00\x00\x01\x00\x02\x00'  # Это десять байтов, представляющих пять коротких целых.
```

1 Код типа 'h' означает создание массива коротких целых (16-разрядных).
2 В объекте octets хранится копия байтов, из которых составлены числа в массиве numbers.
3 Это десять байтов, представляющих пять коротких целых.

Создание объекта bytes или bytearray из буфероподобного источника всегда сопровождается копированием байтов. Напротив, объекты типа memoryview позволяют разным двоичным структурам данных использовать одну и ту же область памяти. Для извлечения структурированной информации из двоичной последовательности бесценную пользу может оказать модуль struct. В следующем разделе мы увидим, как он работает с типами bytes и memoryview.