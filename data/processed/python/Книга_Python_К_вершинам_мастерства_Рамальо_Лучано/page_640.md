---
source_image: page_640.png
page_number: 640
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 45.37
tokens: 11846
characters: 2219
timestamp: 2025-12-24T02:04:33.521319
finish_reason: stop
---

getattr(object, name[, default])
Получает атрибут, идентифицируемый строкой name, объекта object. В результате может быть найден атрибут, определенный в классе или суперклассе объекта. Если такого атрибута не существует, getattr возбуждает исключение AttributeError либо возвращает значение default, если оно задано.

hasattr(object, name)
Возвращает True, если атрибут с указанным именем существует в объекте object или может быть найден с его помощью (например, в результате наследования). В документации (https://docs.python.org/3/library/functions.html#hasattr) приводится следующее объяснение: «Реализовано так: вызываем getattr(object, name), а затем смотрим, возникло исключение AttributeError или нет».

setattr(object, name, value)
Присваивает значение value поименованному атрибуту object, если object это допускает. В результате может быть создан новый атрибут или изменен существующий.

vars([object])
Возвращает атрибут __dict__ объекта object; функция vars не умеет работать с классами, в которых определен атрибут __slots__ и нет атрибута __dict__ (в отличие от функции dir, которая справляется с такими экземплярами). Без аргумента vars() делает то же самое, что locals(): возвращает словарь, описывающий локальную область видимости.

Специальные методы для работы с атрибутами

Специальные методы, описанные ниже, отвечают за чтение, установку, удаление и получение списка атрибутов (если они реализованы в пользовательском классе).

Доступ к атрибутам — с помощью нотации с точкой или встроенных функций getattr, hasattr и setattr — приводит к вызову соответствующих специальных методов. Чтение и запись атрибутов непосредственно в атрибуте __dict__ экземпляра производится в обход специальных методов.

В разделе 3.3.9 «Поиск специальных методов» (http://bit.ly/1cPO3qP) главы «Модель данных» есть такое предупреждение:

Для пользовательских классов правильность работы при неявном вызове специальных методов гарантируется, только если они определены в типе объекта, а не в словаре экземпляра.

Иными словами, следует считать, что специальные методы ищутся в самом классе, даже если вызываются от имени экземпляра. По этой причине специальные методы не маскируются одноименными атрибутами экземпляра.