---
source_image: page_109.png
page_number: 109
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 55.26
tokens: 12158
characters: 2481
timestamp: 2025-12-24T01:39:44.113446
finish_reason: stop
---

Под капотом dict и set

• Почему порядок ключей словаря и элементов множества зависит от порядка вставки и может изменяться на протяжении времени жизни структуры данных?
• Почему нельзя добавлять в словарь или множество элементы во время обхода?

Чтобы у вас появился стимул прочитать про хэш-таблицы, мы начнем с демонстрации поразительной производительности dict и set в простом тесте для нескольких миллионов элементов.

Экспериментальная демонстрация производительности

По своему опыту все пишущие на Python программисты знают, что словари и множества работают быстро. Подтвердим это контролируемым экспериментом.

Чтобы понять, как размер dict, set или list влияет на скорость поиска с помощью оператора in, я сгенерировал массив, содержащий 10 миллионов различных чисел с плавающей точкой двойной точности, — «стог». Затем я сгенерировал массив «иголок»: 1000 чисел с плавающей точкой, из которых 500 было взято из стога, а 500 гарантированно отсутствовали в нем.

Для измерения производительности dict я с помощью метода dict.fromkeys() создал объект dict с именем haystack, содержащий 1000 чисел с плавающей точкой. Это было сделано на этапе подготовки теста dict. Время работы кода, показанного в примере 3.14 (почти такого же, как в примере 3.11), измерялось с помощью модуля timeit.

Пример 3.14. Поиск иголок в стоге сена с подсчетом найденных

found = 0
for n in needles:
    if n in haystack:
        found += 1

Тест был повторен еще четыре раза, и при каждом повторе размер haystack увеличивался в десять раз, пока не достиг значения 10 000 000. Результаты измерения производительности dict приведены в табл. 3.5.

Таблица 3.5. Общее время поиска 1000 иголок в стогах сена пяти разных размеров с помощью оператора in. Тесты были выполнены на ноутбуке с процессором Core i7 в версии Python 3.4.0 (замерялось время работы цикла в примере 3.14)

<table>
  <tr>
    <th>Длина haystack</th>
    <th>Коэффициент</th>
    <th>Время работы</th>
    <th>Коэффициент</th>
  </tr>
  <tr>
    <td>1000</td>
    <td>1x</td>
    <td>0,000202 с</td>
    <td>1,00x</td>
  </tr>
  <tr>
    <td>10 000</td>
    <td>10x</td>
    <td>0,000140 с</td>
    <td>0,69x</td>
  </tr>
  <tr>
    <td>100 000</td>
    <td>100x</td>
    <td>0,000228 с</td>
    <td>1,13x</td>
  </tr>
  <tr>
    <td>1 000 000</td>
    <td>1000x</td>
    <td>0,000290 с</td>
    <td>1,44x</td>
  </tr>
  <tr>
    <td>10 000 000</td>
    <td>10000x</td>
    <td>0,000337 с</td>
    <td>1,67x</td>
  </tr>
</table>