---
source_image: page_679.png
page_number: 679
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 52.12
tokens: 11964
characters: 2474
timestamp: 2025-12-24T02:06:21.824611
finish_reason: stop
---

Фабрика классов

2 Строим кортеж имен атрибутов, он станет атрибутом __slots__ нового класса; заодно он определяет порядок полей при распаковке и в представлении методом __repr__.
3 Эта функция станет методом __init__ в новом классе. Она принимает позиционные и (или) именованные аргументы.
4 Реализуем метод __iter__, чтобы экземпляры класса были итерируемыми объектами; отдаем значения полей в порядке, определяемом атрибутом __slots__.
5 Порождаем удобное представление, обходя __slots__ и self.
6 Строим словарь атрибутов класса.
7 Конструируем и возвращаем новый класс, вызывая конструктор type.

Обычно мы рассматриваем type как функцию, потому что так ее и используем, например, мы пишем type(my_object), чтобы получить класс объекта — то же самое, что my_object.__class__. Однако на самом деле type — класс. Он ведет себя, как класс, который возвращает новый класс при вызове с тремя аргументами:

MyClass = type('MyClass', (MySuperClass, MyMixin),
    {'x': 42, 'x2': lambda self: self.x * 2})

Три аргумента конструктора type называются name, bases и dict, последний из них является отображением, состоящим из имен и значений атрибутов нового класса. Показанный выше код эквивалентен такому:

class MyClass(MySuperClass, MyMixin):
    x = 42
    def x2(self):
        return self.x * 2

Новым здесь является то, что экземпляры type — это классы, например MyClass здесь или Dog в примере 21.1.

Таким образом, в последней строке функции record_factory строится класс с именем, равным значению cls_name, наследующий object и имеющий атрибуты класса __slots__, __init__, __iter__ и __repr__, последние три из которых являются методами экземпляра.

Мы могли бы назвать атрибут класса __slots__ как-то иначе, но тогда пришлось бы реализовывать метод __setattr__, проверяющий имена атрибутов, которым присваиваются значения, потому что мы хотим, чтобы в наших классах, подобных записям, набор атрибутов всегда был один и тот же и чтобы атрибуты в нем следовали в одном и том же порядке. Напомню, однако, что основное назначение __slots__ — экономия памяти в случае, когда экземпляров миллионы, и что использование __slots__ сопряжено с некоторыми недостатками, описанными в разделе «Экономия памяти с помощью атрибута класса __slots__» главы 9.

Вызов type с тремя аргументами — типичный способ динамического создания класса. Заглянув в исходный код функции collections.namedtuple (http://bit.ly/1HGwRl), вы увидите другой подход: там имеется переменная _class_template,