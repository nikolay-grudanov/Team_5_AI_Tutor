---
source_image: page_295.png
page_number: 295
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 60.50
tokens: 12007
characters: 2630
timestamp: 2025-12-24T01:48:26.980118
finish_reason: stop
---

Поговорим

В этой главе мы рассмотрели все специальные методы, относящиеся к представлению объектов, кроме __index__. Последний служит для приведения объекта к целочисленному индексу в контексте получения среза последовательности. Он был введен для решения одной проблемы в NumPy. На практике нам с вами вряд ли придется реализовывать метод __index__, если только мы не захотим написать новый числовой тип данных, да еще так, чтобы объекты этого типа можно было передавать в качестве аргументов __getitem__. Если вас это интересует, почитайте статью А. М. Кухлинга «What's New in Python 2.5» (https://docs.python.org/2.5/whatsnew/pep-357.html), где приведено краткое объяснение, а также документ «PEP 357 – Allowing Any Object to be Used for Slicing» (https://www.python.org/dev/peps/pep-0357/), где детально обосновывается необходимость метода __index__ с точки зрения автора C-расширения, Трэвиса Олифант — ведущего разработчика NumPy.

Впервые необходимость различных строковых представлений объекта была осознана в языке Smalltalk. В статье 1996 года «How to Display an Object as a String: printString and displayString» (http://bit.ly/1IIKX6t) Бобби Вулф (Bobby Woolf) обсуждает реализацию методов printString и displayString в этом языке. Из этой статьи я позаимствовал выражения «в виде, удобном для разработчика» и «в виде, удобном для пользователя» для описания методов repr() и str() в разделе «Представления объекта».

Поговорим

Свойства позволяют снизить начальные затраты

В первых версиях класса Vector2d атрибуты x и y были открытыми, как и все атрибуты класса и экземпляра по умолчанию. Естественно, пользователям вектора необходим доступ к его компонентам. И хотя наши векторы являются итерируемыми объектами и могут быть распакованы в пару переменных, желательно также иметь возможность писать my_vector.x и my_vector.y для прямого доступа к компонентам по отдельности.

Озознав необходимость воспрепятствовать случайному изменению атрибутов x и y, мы реализовали свойства, но больше нигде — ни в коде, ни в открытом интерфейсе класса Vector2d — менять ничего не пришлось, что доказывают doctest-скрипты. Мы по-прежнему можем обращаться к компонентам с помощью нотации my_vector.x и my_vector.y.

Это доказывает, что начинать разработку класса всегда надо с простейшего варианта, оставив атрибуты открытыми, а когда (и если) мы впоследствии захотим усилить контроль доступа с помощью методов чтения и установки, это можно будет сделать, реализовав свойства и ничего не меняя в уже написанном коде работы с компонентами объекта по именам (например, x и y), которые первоначально были просто открытыми атрибутами.