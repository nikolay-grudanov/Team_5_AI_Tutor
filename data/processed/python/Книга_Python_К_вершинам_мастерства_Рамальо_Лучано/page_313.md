---
source_image: page_313.png
page_number: 313
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 48.84
tokens: 11975
characters: 2383
timestamp: 2025-12-24T01:49:10.552799
finish_reason: stop
---

Vector, попытка № 4: хэширование и ускорение оператора ==

Vector, попытка № 4: хэширование и ускорение оператора ==

И снова нам предстоит реализовать метод __hash__. В сочетании с уже имеющимся методом __eq__ это сделает экземпляры класса Vector хэшируемыми.

Метод __hash__ в примере 9.8 просто вычислял выражение hash(self.x) ^ hash(self.y). Теперь мы хотели бы применить оператор ^ (ИСКЛЮЧАЮЩЕЕ ИЛИ) к хэшам всех компонент: v[0] ^ v[1] ^ v[2]... . Тут нам на помощь придет функция functools.reduce. Выше я говорил, что функция reduce уже не так популярна, как в былые времена⁴, но для вычисления хэша всех компонент она подходит идеально. На рис. 10.1 представлена общая идея функции reduce.

![Редуцирующие функции — reduce, sum, any, all — порождают единственное значение-агрегат из последовательности или произвольного конечного итерируемого объекта](https://i.imgur.com/319.png)

Рис. 10.1. Редуцирующие функции — reduce, sum, any, all — порождают единственное значение-агрегат из последовательности или произвольного конечного итерируемого объекта

До сих пор мы видели, что функцию functools.reduce() можно заменить функцией sum(), а теперь объясним, как же она все-таки работает. Идея в том, чтобы редуцировать последовательность значений в единственное значение. Первый аргумент reduce() — функция с двумя аргументами, а второй — итерируемый объект. Допустим, что имеется функция с двумя аргументами fn и список lst. Если написать reduce(fn, lst), то fn сначала применяется к первым двум элементам — fn(lst[0], lst[1]) — и в результате получится первый результат r1. Затем fn применяется к r1 и следующему элементу — fn(r1, lst[2]); так мы получаем второй результат r2. Затем вызов fn(r2, lst[3]) порождает r3 ... и так далее до последнего элемента, после чего возвращается окончательный результат rN.

Вот как можно было бы применить reduce для вычисления 5! (факториал 5):

```python
>>> 2 * 3 * 4 * 5 # ожидаемый результат: 5! == 120
120
>>> import functools
>>> functools.reduce(lambda a,b: a*b, range(1, 6))
120
```

Но вернемся к проблеме хэширования. В примере 10.11 показано, как можно было бы вычислить результат многократного применения ^ тремя способами: один — с помощью цикла for и два — с помощью reduce.

⁴ Функции sum, any и all покрывают большинство типичных применений reduce. См. обсуждение в разделе «Современные замены map, filter и reduce» главы 5.