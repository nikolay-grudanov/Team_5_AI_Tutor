---
source_image: page_406.png
page_number: 406
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 34.34
tokens: 11744
characters: 1943
timestamp: 2025-12-24T01:53:25.596033
finish_reason: stop
---

Глава 13. Перегрузка операторов: как правильно?

возбуждать исключение TypeError. Возвращая NotImplemented, вы оставляете разработчику типа другого операнда возможность выполнить операцию, когда Python попробует вызвать инверсный метод.

Оставаясь верны духу динамической типизации, мы воздержимся от проверки типа операнда other или его элементов. Вместо этого мы перехватим исключение и вернем NotImplemented. Если интерпретатор еще не пробовал операнды в обратном порядке, то сделает это. Если же значение NotImplemented вернул инверсный метод, то Python возбудит исключение TypeError со стандартным сообщением вида «unsupported operand type(s) for +: Vector and str».

Окончательная реализация специальных методов для сложения объектов класса Vector приведена в примере 13.10.

Пример 13.10. vector_v6.py: специальные методы оператора +, добавленные в файл vector_v5.py (пример 10.16)

def __add__(self, other):
    try:
        pairs = itertools.zip_longest(self, other, fillvalue=0.0)
        return Vector(a + b for a, b in pairs)
    except TypeError:
        return NotImplemented

def __radd__(self, other):
    return self + other

Если метод инфиксного оператора возбуждает исключение, то работа алгоритма диспетчеризации прерывается. В частном случае исключения TypeError зачастую лучше перехватить его и вернуть значение NotImplemented. Это позволит интерпретатору вызвать метод инверсного оператора, который, возможно, сумеет завершить вычисление, поменяв местами операнды разных типов.

Итак, мы безопасно перегрузили оператор +, написав методы __add__ и __radd__.
Теперь займемся инфиксным оператором *.

Перегрузка оператора умножения на скаляр *

Что означает запись Vector([1, 2, 3]) * x? Если x — число, то это умножение на скаляр, результатом которого является новый объект Vector, каждая компонента которого является произведением x и соответственной компоненты исходного вектора:

>>> v1 = Vector([1, 2, 3])
>>> v1 * 10