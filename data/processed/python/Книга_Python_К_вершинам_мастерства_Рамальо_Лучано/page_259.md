---
source_image: page_259.png
page_number: 259
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 45.46
tokens: 11838
characters: 2115
timestamp: 2025-12-24T01:46:40.789980
finish_reason: stop
---

Слабые ссылки

Смысл примера 8.16 — ясно показать, что предложение del не удаляет объекты, хотя объекты могут быть удалены из-за того, что после выполнения del оказываются недоступны.

Быть может, вам непонятно, почему в примере 8.16 был уничтожен объект {1, 2, 3}. Ведь ссылка s1 была передана функции finalize, которая должна была бы удержать ее, чтобы следить за объектом и вызвать функцию обратного вызова. Это работает, потому что finalize удерживает слабую ссылку на объект {1, 2, 3}, а что это такое, объясняется в следующем разделе.

Слабые ссылки

Наличие ссылок — вот что удерживает объект в памяти. Как только счетчик ссылок на объект обращается в нуль, сборщик мусора уничтожает его. Но иногда полезно иметь такую ссылку на объект, которая не удерживает его в памяти дольше, чем необходимо. Типичный пример — кэш.

Слабые ссылки на объект не увеличивают счетчик ссылок. Объект, на который указывает ссылка, называется объектом ссылки. Таким образом, слабая ссылка не препятствует уничтожению объекта ссылки сборщиком мусора.

Слабые ссылки полезны для кэширования, потому что мы не хотим, чтобы кэшированный объект оставался жив только потому, что на него ссылается сам кэш.

В примере 8.17 показано, как можно вызвать экземпляр weakref.ref для получения его объекта ссылки. Если этот объект еще жив, то он и возвращается, иначе возвращается None.

В примере 8.17 показан сеанс оболочки, а оболочка Python автоматически связывает переменную _ с результатом выражения, если он отличен от None. Это мешает моей демонстрации, но одновременно подчеркивает практически важный момент: пытаясь заниматься управлением памятью на низком уровне, мы часто натыкаемся на скрытые неявные присваивания, в результате которых создаются новые ссылки на наши объекты. Переменная оболочки _ — один из таких примеров. Другой распространенный источник неожиданных ссылок — объект обратной трассировки стека.

Пример 8.17. Слабая ссылка — это вызываемый объект, который возвращает объект ссылки, если он еще существует, а в противном случае None

>>> import weakref
>>> a_set = {0, 1}
>>> wref = weakref.ref(a_set) ①
>>> wref