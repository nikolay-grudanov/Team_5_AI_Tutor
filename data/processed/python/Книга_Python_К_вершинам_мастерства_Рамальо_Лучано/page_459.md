---
source_image: page_459.png
page_number: 459
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 37.96
tokens: 11747
characters: 1691
timestamp: 2025-12-24T01:56:07.106792
finish_reason: stop
---

yield from — новая конструкция в Python 3.3

Последняя генераторная функция в этой группе, iterator.tee, обладает уникальным поведением: она порождает несколько генераторов для одного входного итерируемого объекта, каждый из которых отдает все элементы этого объекта. Эти генераторы можно потреблять независимо, как показано в примере 14.22.

Пример 14.22. itertools.tee порождает несколько генераторов, каждый из которых отдает все элементы входного итерируемого объекта

```python
>>> list(itertools.tee('ABC'))
[<itertools._tee object at 0x10222abc8>, <itertools._tee object at 0x10222ac08>]
>>> g1, g2 = itertools.tee('ABC')
>>> next(g1)
'A'
>>> next(g2)
'A'
>>> next(g2)
'B'
>>> list(g1)
['B', 'C']
>>> list(g2)
['C']
>>> list(zip(*itertools.tee('ABC')))
[('A', 'A'), ('B', 'B'), ('C', 'C')]
```

Отметим, что в нескольких примерах из этого раздела использовались комбинации генераторных функций. Это возможно, потому что все они принимают генераторы в качестве аргументов и возвращают генераторы.

И раз уж мы заговорили о комбинировании генераторов, рассмотрим предложение yield from, появившееся в версии Python 3.3, которое как раз для этого и предназначено.

yield from — новая конструкция в Python 3.3

Вложенные циклы for — традиционное решение в случае, когда генераторная функция должна отдавать значения, порождаемые другим генератором.

Вот, например, доморощенная реализация сцепляющего генератора¹⁰:

```python
>>> def chain(*iterables):
...     for it in iterables:
...         for i in it:
...             yield i
...
>>> s = 'ABC'
>>> t = tuple(range(3))
>>> list(chain(s, t))
['A', 'B', 'C', 0, 1, 2]

¹⁰ Функция itertools.chain из стандартной библиотеки написана на С.