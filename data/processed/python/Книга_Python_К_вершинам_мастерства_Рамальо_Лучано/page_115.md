---
source_image: page_115.png
page_number: 115
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 43.08
tokens: 11918
characters: 2136
timestamp: 2025-12-24T01:39:53.342511
finish_reason: stop
---

Под капотом dict и set

Для пользовательских типов атрибут класса __slots__ изменяет способ хранения атрибутов экземпляра: со словаря на кортеж. Мы обсудим этот вопрос в разделе «Экономия памяти с помощью атрибута класса __slots__» главы 9.

Помните, что мы говорим об оптимизации использования памяти. Если вы работаете с несколькими миллионами объектов, а машина оснащена несколькими гигабайтами оперативной памяти, то такая оптимизация вряд ли оправдана, и ее следует отложить. Оптимизация — этот тот алтарь, на котором приносят в жертву удобство сопровождения.

Поиск по ключу выполняется очень быстро

Реализация dict — пример компромисса, когда жертвуют памятью ради скорости: накладные расходы словаря в части памяти велики, зато доступ производится быстро независимо от размера словаря — если, конечно, он умещается целиком в памяти. Из табл. 3.5 видно, что при увеличении размера dict с 1000 до 10 000 000 элементов время поиска возросло всего в 2,8 раза, с 0,000163 с до 0,000456 с. Последняя величина означает, что в словаре с 10 миллионами элементов можно было выполнить более 2 миллионов операций поиска в секунду.

Упорядочение ключей зависит от порядка вставки

При возникновении коллизии второй ключ оказывается в позиции, которую не должен был бы занимать, если бы был вставлен первым. Таким образом, объект dict, построенный как dict([(key1, value1), (key2, value2)]) равен объекту dict([(key2, value2), (key1, value1)]), но порядок ключей в них может различаться, если при хэшировании key1 и key2 возникает коллизия.

В примере 3.17 демонстрируется результат загрузки трех словарей с одними и теми же данными, но в разном порядке. Все получающиеся словари равны, хотя порядок ключей в них разный.

Пример 3.17. dialcodes.py: заполнить три словаря одинаковыми данными, отсортированными по-разному

# телефонные коды 10 самых населенных стран
DIAL_CODES = [
    (86, 'China'),
    (91, 'India'),
    (1, 'United States'),
    (62, 'Indonesia'),
    (55, 'Brazil'),
    (92, 'Pakistan'),
    (880, 'Bangladesh'),
    (234, 'Nigeria'),
    (7, 'Russia'),
    (81, 'Japan')
]

d1 = dict(DIAL_CODES)
print('d1:', d1.keys())