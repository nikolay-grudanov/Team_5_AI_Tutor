---
source_image: page_387.png
page_number: 387
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 48.50
tokens: 11919
characters: 2404
timestamp: 2025-12-24T01:52:39.171091
finish_reason: stop
---

Жизнь с множественным наследованием

Вот, например, полный исходный код класса tkinter.Widget (http://bit.ly/1JHQqKU):

class Widget(BaseWidget, Pack, Place, Grid):
    """Internal class.

Base class for a widget which can be positioned with the geometry managers Pack, Place or Grid."""

pass

Тело класса Widget пусто, но сам класс несет полезную функцию: объединяет четыре суперкласса, так что желающему создать виджет не нужно помнить все примеси или задаваться вопросом, в каком порядке их объявлять в предложении class. Более интересный пример дает класс ListView из веб-каркаса Django, который мы обсудим чуть ниже.

8. Предпочитайте композицию наследованию класса

Эта цитата взята прямиком из книги «Паттерны проектирования», и лучше совета не придумаешь. Освоив наследование, очень легко впасть в грех злоупотребления им. Организация объектов в симпатичную иерархию импонирует нашему чувству порядка; а программисты делают это просто забавы ради.

Однако, отдавая предпочтение композиции, мы получаем более гибкий дизайн. Например, класс tkinter.Widget мог бы не наследовать методы от всех менеджеров компоновки, а хранить ссылку на менеджер и вызывать его методы. В конце концов, widget же не должен «быть» менеджером компоновки, но мог бы пользоваться его услугами с помощью делегирования. Тогда было бы нетрудно добавить новый менеджер компоновки, не изменяя иерархию классов виджетов и не беспокоясь по поводу возможных конфликтов имен. Даже в случае одиночного наследования этот принцип повышает гибкость, поскольку создание подкласса — форма тесной связанности, а глубокие деревья наследования обычно оказываются хрупкими.

Композиция и делегирование могут заменить использование примесей, когда нужно предоставить некоторый набор поведений различным классам, но не могут заменить наследование интерфейсов как средство определения иерархии типов.

Проанализируем Tkinter в свете этих рекомендаций

Tkinter: хороший, плохой, злой

Помните, что Tkinter является частью стандартной библиотеки еще со времен версии Python 1.1, выпущенной в 1994 году. Tkinter — этой слой поверх великолепной библиотеки Tk, поставляемой вместе с языком Tcl. Комбинация Tcl/Tk изначально не была объектно-ориентированной, поэтому Tk API представляет собой просто обширный набор функций. Однако концептуально эта библиотека в высшей степени объектно-ориентированная, пусть даже ее реализация таковой не является.