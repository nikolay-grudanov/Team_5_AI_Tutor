---
source_image: page_524.png
page_number: 524
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 57.82
tokens: 12130
characters: 3211
timestamp: 2025-12-24T01:59:25.532806
finish_reason: stop
---

му с помощью декоратора, иногда это бывает удобно. Но помните, что инициализирующие декораторы несовместимы с некоторыми способами использования сопрограмм. В частности, конструкция yield from subgenerator() предполагает, что subgenerator не инициализирован и инициализирует его автоматически.

Аккумулирующие сопрограммы могут отдавать частичные результаты при каждом вызове метода send, но особенно полезны те из них, которые возвращают значения — эта возможность была описана в документе PEP 380 и включена в версию Python 3.3. Мы видели, что предложение return the_result внутри генератора теперь возбуждает исключение StopIteration(the_result), что позволяет вызывающей стороне извлечь результат the_result из атрибута исключения value. Такой способ получения результата сопрограммы изящным не назовешь, но предложение yield from, описанное в PEP 380, делает это автоматически.

Мы начали рассмотрение yield from с тривиальных примеров работы с простыми итерируемыми объектами, а затем перешли к примеру, демонстрирующему три главных составных части yield from: делегирующий генератор (определяемый выражением yield from в его теле), субгенератор, активируемый yield from, и клиентский код, который организует совместную работу всех компонентов, отправляя субгенератору значения по сквозному каналу, который устанавливает yield from в делегирующим генераторе. В конце раздела мы познакомились с формальным определением поведения yield from, как оно описано в PEP 380 на обычном языке и на псевдокоде, напоминающем Python.

В заключение мы разобрали пример моделирования дискретных событий, показав, как можно использовать генераторы вместе потоков и обратных вызовов для поддержки одного из видов параллелизма. И хотя пример моделирования работы такси был совсем простым, он все же дает представление о том, как в таких событийно-управляемых каркасах, как Tornado и asyncio, главный цикл используется для управления сопрограммами, которые выполняют параллельные действия в одном потоке. В событийно-ориентированных программах на основе сопрограмм каждая параллельная операция выполняется сопрограммой, которая периодически уступает управление главному циклу, давая возможность поработать другим сопрограммам. Это вариант невытесняющей многозадачности: сопрограммы добровольно и явно уступают управление центральному планировщику. Противоположностью являются потоки, реализующие вытесняющую многозадачность. Планировщик может приостановить поток в любой момент времени — даже в середине предложения — и передать управление другому потоку.

И последнее замечание: в этой главе было принято широкое неформальное определение сопрограммы: генераторная функция, управляемая клиентским кодом, который посылает ей данные с помощью метода .send(...) или предложения yield from. Именно такое широкое определение используется в документе «PEP 342 — Coroutines via Enhanced Generators» (https://www.python.org/dev/peps/pep-0342/) и в большинстве книг по Python. Библиотека asyncio, с которой мы познакомимся в главе 18, построена на основе сопрограмм, но там определение сопрограммы более строгое: сопрограммы в asyncio (обычно) снабжены декоратором @asyncio.coroutine и управляются только с помощью yield from — метод