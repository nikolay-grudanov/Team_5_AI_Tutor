---
source_image: page_412.png
page_number: 412
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 33.41
tokens: 11772
characters: 1737
timestamp: 2025-12-24T01:53:40.792445
finish_reason: stop
---

В примере 13.12 показаны результаты работы этого метода.

Пример 13.12. Сравнение Vector с Vector, с Vector2d и tuple

```python
>>> va = Vector([1.0, 2.0, 3.0])
>>> vb = Vector(range(1, 4))
>>> va == vb # ①
True
>>> vc = Vector([1, 2])
>>> from vector2d_v3 import Vector2d
>>> v2d = Vector2d(1, 2)
>>> vc == v2d # ②
True
>>> t3 = (1, 2, 3)
>>> va == t3 # ③
True
```

① Два объекта Vector с равными числовыми компонентами должны быть равны.
② Объекты Vector и Vector2d также равны, если равны их компоненты.
③ Vector считается равным кортежу или любому другому итерируемому объекту, элементы которого соответственно равны его компонентам.

Последний результат в примере 13.12 вряд ли следует считать желательным. Впрочем, твердой уверенности у меня нет — все зависит от контекста. Однако в «Дзен Python» сказано:

Встретив неоднозначность, отбрось искушение угадать.

Излишняя либеральность при вычислении операндов может преподнести сюрпризы, а программисты их ненавидят.

Если в поисках ключа обратиться к самому Python, то мы увидим, что сравнение [1, 2] == (1, 2) дает False. Поэтому будем осторожны и добавим сравнение типов. Если второй операнд — объект класса Vector (или его подкласса), то оставим ту же логику, что в текущей реализации __eq__. Иначе вернем NotImplemented, и пусть Python разбирается.

Пример 13.13. vector_v8.py: улучшенный метод __eq__ в классе Vector

```python
def __eq__(self, other):
    if isinstance(other, Vector): ①
        return (len(self) == len(other) and
                all(a == b for a, b in zip(self, other)))
    else:
        return NotImplemented ②
```

① Если operand other — объект класса Vector (или его подкласса), то выполняем сравнение, как и раньше.
② Иначе возвращаем NotImplemented.