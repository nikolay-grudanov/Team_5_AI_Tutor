---
source_image: page_576.png
page_number: 576
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 62.76
tokens: 12036
characters: 2520
timestamp: 2025-12-24T02:01:57.374610
finish_reason: stop
---

Глава 18. Применение пакета asyncio для организации...

• Цепочки написанных нами сопрограмм всегда управляются путем передачи самого внешнего делегирующего генератора какой-то функции asyncio API, например loop.run_until_complete(...).

• Иначе говоря, при работе с asyncio наш код не управляет сопрограммой, вызывая next(...) или .send(...) — за него это делает цикл обработки событий asyncio.

• Цепочки написанных нами сопрограмм всегда заканчиваются делегированием с помощью yield from какой-то сопрограммной функции или сопрограммному методу asyncio (например, yield from asyncio.sleep(...) в примере 18.2) или сопрограммам из библиотек, реализующих протоколы более высокого уровня (например, resp = yield from aiohttp.request('GET', url) в сопрограмме get_flag из примера 18.5).
Иначе говоря, самый внутренний субгенератор будет библиотечной функцией, которая собственно и выполняет ввод-вывод, а не чем-то написанным нами.

Подведем итог: при использовании asyncio наш асинхронный код состоит из сопрограмм, которые являются делегирующими генераторами, управляемыми самим asyncio, и в конечном итоге делегируют работу библиотечным сопрограммам из asyncio — возможно, при посредничестве функций из какой-то сторонней библиотеки, например aiohttp. При такой организации создаются конвейеры, в которых цикл обработки событий asyncio управляет — посредством наших сопрограмм — библиотечными функциями, выполняющими низкоуровневый асинхронный ввод-вывод.

Теперь мы готовы ответить на вопрос, заданный в главе 17:

• Как получилось, что скрипт flags_asyncio.py работает в 5 раз быстрее flags.py, если тот и другой однопоточные?

Объезд блокирующих вызовов

Райан Дал, создатель Node.js, начинает разговор о философии своего проекта словами «Весь наш ввод-вывод никуда не годится»4. Он определяет блокирующую функцию как такую, которая занимается дисковым или сетевым вводом-выводом, и утверждает, что с ними нельзя обращаться так же, как с неблокирующими. Чтобы объяснить, почему, он приводит данные из табл. 18.1.

Таблица 18.1. Характерные для современных компьютеров задержки при чтении данных с различных устройств; в третьей колонке показано пропорционально увеличенное время в масштабе, понятном «медленному» человеку

<table>
  <tr>
    <th>Устройство</th>
    <th>Тактов ЦП</th>
    <th>Пропорциональная «человеческая» шкала</th>
  </tr>
  <tr>
    <td>Кэш L1</td>
    <td>3</td>
    <td>3 секунды</td>
  </tr>
</table>

4 Видео «Введение в Node.js» (https://www.youtube.com/watch?v=M-sc73Y-zQA), момент 4:55.