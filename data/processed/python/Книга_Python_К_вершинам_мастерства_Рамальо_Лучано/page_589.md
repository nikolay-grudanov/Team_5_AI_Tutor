---
source_image: page_589.png
page_number: 589
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 60.24
tokens: 11977
characters: 2700
timestamp: 2025-12-24T02:02:28.968037
finish_reason: stop
---

От обратных вызовов к будущим объектам и сопрограммам

обработать, поместив соответствующее выражение yield from внутрь блока try/except.

Это куда лучше ада обратных вызовов, но я бы не стал употреблять термин «рай сопрограмм», потому что за все приходится платить. Вместо обычных функций мы должны использовать сопрограммы и привыкнуть к yield from; это первое препятствие. Коль скоро в функции встречается выражение yield from, она становится сопрограммой и ее нельзя вызвать, просто написав api_call1(request1, stage1), чтобы запустить цепочку обратных вызовов, как в примере 18.11. Необходимо либо явно запланировать выполнение сопрограммы в цикле обработки событий, либо активировать ее с помощью yield from в другой сопрограмме, которая уже запланирована. Не будь в последней строке примера 18.12 обращения loop.create_task(three_stages(request1)), не произошло бы вообще ничего.

В следующем примере изложенная теория демонстрируется на практике.

Выполнение нескольких запросов для каждой операции загрузки

Предположим, что вместе с флагом нужно сохранять не только код страны, но и ее название. Тогда нам потребуется два HTTP-запроса на каждый флаг: одно — для получения изображения флага, другое — для загрузки файла metadata.json, находящегося в том же каталоге, что и изображение, в этом файле хранится название страны.

В многопоточном скрипте выполнить несколько запросов в составе одной задачи нетрудно: достаточно расположить их один за другим (при этом поток будет блокирован дважды) и запомнить оба элемента данных (код и название страны) в локальных переменных, которые можно будет использовать при сохранении файлов. Попытавшись сделать то же самое в асинхронном скрипте с помощью обратных вызовов, мы почувствуем серный запах ада: код и название страны придется передавать в замыкании или запоминать где-то до момента сохранения файла, потому что функция обратного вызова исполняется в совершенно другом локальном контексте. Сопрограммы и yield from избавляют нас от этого. Решение не такое простое, как в случае потоков, но все же более обозримое, чем сцепленные или вложенные обратные вызовы.

В примере 18.13 показан код из третьего варианта скрипта загрузки флагов с применением asyncio, только имя файла, в котором сохраняется флаг, образовано на основе названия страны. Функции download_many и downloader_coro такие же, как в файле flags2_asyncio.py (примеры 18.7 и 18.8). Перечислим изменения:

download_one
Теперь в этой сопрограмме используется yield from для делегирования работы сопрограммам get_flag и get_country.

get_flag
Большая часть кода перенесена из этой сопрограммы в новую сопрограмму http_get, чтобы этим кодом можно было воспользоваться и в get_country.