---
source_image: page_292.png
page_number: 292
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 49.11
tokens: 11886
characters: 2182
timestamp: 2025-12-24T01:48:14.836992
finish_reason: stop
---

Теперь должно быть понятно, почему при экспорте объекта Vector2d в формате bytes результирующее представление начинается с typecode: мы хотели поддержать различные форматы экспорта.

Если вы хотите изменить сам атрибут класса, то должны присвоить ему значение напрямую, а не через экземпляр. Чтобы изменить значение typecode по умолчанию, распространяющееся на все экземпляры (не имеющие собственного атрибута typecode), нужно написать:

```python
>>> Vector2d.typecode = 'f'
```

Однако существует идиоматический способ добиться более постоянного эффекта и явно выразить смысл изменения. Поскольку атрибуты класса открыты и наследуются подклассами, то принято настраивать атрибут класса в подклассе. В основанных на классах представлениях Django эта техника применяется сплошь и рядом. Она демонстрируется в примере 9.14.

Пример 9.14. ShortVector2d — подкласс Vector2d, единственное отличие которого — переопределение атрибута typecode по умолчанию

```python
>>> from vector2d_v3 import Vector2d
>>> class ShortVector2d(Vector2d): # 1
...     typecode = 'f'
...
>>> sv = ShortVector2d(1/11, 1/27) # 2
>>> sv
ShortVector2d(0.09090909090909091, 0.037037037037037035) # 3
>>> len(bytes(sv)) # 4
9
```

1 Создаем ShortVector2d как подкласс Vector2d только для того, чтобы переопределить атрибут класса typecode.
2 Создаем экземпляр ShortVector2d — объект sv.
3 Инспектируем представление sv.
4 Проверяем, что экспортировано 9 байтов, а не 17, как раньше.

Этот пример также объясняет, почему я не стал «зашивать» значение class_name в код Vector2d.__repr__, а получаю его в виде type(self).__name__:

```python
# в классе Vector2d:
def __repr__(self):
    class_name = type(self).__name__
    return '{{}({!r}, {!r})}'.format(class_name, *self)
```

Если бы я зашил class_name, то подклассы Vector2d и, в частности, ShortVector2d должны были бы переопределять метод __repr__ только для того, чтобы изменить class_name. А, получая имя от функции type, примененной к экземпляру, я сделал __repr__ безопасным относительно наследования.

На этом завершается рассмотрение реализации простого класса, который ведет себя как положено в Python, пользуясь средствами, предоставляемыми моделью