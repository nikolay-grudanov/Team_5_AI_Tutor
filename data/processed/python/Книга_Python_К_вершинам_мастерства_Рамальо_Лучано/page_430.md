---
source_image: page_430.png
page_number: 430
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 40.21
tokens: 11792
characters: 2144
timestamp: 2025-12-24T01:54:40.244017
finish_reason: stop
---

Глава 14. Итерируемые объекты, итераторы и генераторы

руемым не только, когда он реализует специальный метод __iter__, но и когда реализует метод __getitem__ при условии, что тот принимает в качестве аргумента значения типа int, начинающиеся с нуля.

Если подходить с точки зрения гусиной типизации, то определение итерируемого объекта становится более простым, но не таким гибким: объект считается итерируемым, если реализует метод __iter__. Не требуется ни наследования, ни регистрации, потому что класс abc.Iterable реализует метод __subclasshook__ (см. раздел «Гуси могут вести себя как утки» главы 11). Продемонстрируем это:

```python
>>> class Foo:
...     def __iter__(self):
...         pass
...
>>> from collections import abc
>>> issubclass(Foo, abc.Iterable)
True
>>> f = Foo()
>>> isinstance(f, abc.Iterable)
True
```

Отметим, однако, что наша первоначальная версия класса Sentence не проходит проверку issubclass(Sentence, abc.Iterable), хотя на практике является итерируемым объектом.

В версии Python 3.4 самый точный способ проверить, является ли объект x итерируемым, — вызвать iter(x) и перехватить исключение TypeError, если оно возникнет. Это надежнее, чем использовать isinstance(x, abc.Iterable), потому что iter(x) учитывает также доставшийся в наследство метод __getitem__, а класс Iterable этого не делает.

Явно проверять, является ли объект итерируемым, вряд ли стоит, если сразу после проверки вы намереваетесь обойти объект. Ведь, если попытаться обойти неитерируемый объект, Python возбудит исключение с недвусмысленным сообщением: TypeError: 'C' object is not iterable. Если вы можете сделать что-то более разумное, чем возбуждать TypeError, делайте это в блоке try/except, а не путем явной проверки. Явная проверка, возможно, имеет смысл, если вы хотите сохранить объект и воспользоваться им для итерирования позже; в таком случае было бы полезно обнаружить ошибку на ранней стадии.

В следующем разделе мы проясним связь между итерируемыми объектами и итераторами.

Итерируемые объекты и итераторы

Из объяснения в разделе «Почему последовательности итерируемы: функция iter» можно вывести такое определение: