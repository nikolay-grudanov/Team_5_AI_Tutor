---
source_image: page_490.png
page_number: 490
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 36.18
tokens: 11737
characters: 1807
timestamp: 2025-12-24T01:57:26.110986
finish_reason: stop
---

Послеуем установившейся в этой книге традиции: начнем с простых фактов и примеров и постепенно перейдем к более головоломным средствам.

Базовое поведение генератора, используемого в качестве сопрограммы

В примере 16.1 иллюстрируется поведение сопрограммы.

Пример 16.1. Простейшая демонстрация сопрограммы в действии

```python
>>> def simple_coroutine(): # ①
...     print('-> coroutine started')
...     x = yield # ②
...     print('-> coroutine received:', x)
...
>>> my_coro = simple_coroutine()
>>> my_coro # ③
<generator object simple_coroutine at 0x100c2be10>
>>> next(my_coro) # ④
-> coroutine started
>>> my_coro.send(42) # ⑤
-> coroutine received: 42
Traceback (most recent call last): # ⑥
    ...
StopIteration
```

① Сопрограмма определяется так же, как генераторная функция: в теле присутствует ключевое слово yield.
② yield используется в выражении присваивания; если сопрограмма предназначена только для получения данных от клиента, yield отдает None — это неявно подразумевается, потому что справа от слова yield нет никакого значения.
③ Как всегда с генераторами, мы вызываем функцию, чтобы получить объект-генератор.
④ Первой вызывается функция next(...), потому что генератор еще не начал работу, т. е. он еще не приостановился, достигнув yield, поэтому мы не можем послать ему данные.
⑤ В результате этого обращения yield в теле сопрограммы отдает значение 42; теперь выполнение сопрограммы возобновилось, и она будет работать до следующего yield или до завершения.
⑥ В данном случае управление покидает тело сопрограммы, в результате чего генератор возбуждает исключение StopIteration, как обычно.

Сопрограмма может находиться в одном из четырех состояний. Узнать, в каком именно, позволяет функция inspect.getgeneratorstate(...), которая возвращает одну из перечисленных ниже строк.