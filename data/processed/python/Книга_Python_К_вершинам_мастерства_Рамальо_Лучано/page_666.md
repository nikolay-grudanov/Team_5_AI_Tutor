---
source_image: page_666.png
page_number: 666
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 50.84
tokens: 11788
characters: 1943
timestamp: 2025-12-24T02:05:43.530101
finish_reason: stop
---

тор, делая его бесполезным для обработки соответствующего атрибута в этом экземпляре. Методы реализованы как непереопределяющие дескрипторы. В примере 20.11 показана работа непереопределяющего дескриптора.

Пример 20.11. Поведение непереопределяющего дескриптора:
obj.non_over — экземпляр класса NonOverriding (из примера 20.8)

>>> obj = Managed()
>>> obj.non_over
NonOverriding.__get__ (<NonOverriding object>, <Managed object>, <class Managed>)
>>> obj.non_over = 7
>>> obj.non_over
7
>>> Managed.non_over
NonOverriding.__get__ (<NonOverriding object>, None, <class Managed>)
>>> del obj.non_over
>>> obj.non_over
NonOverriding.__get__ (<NonOverriding object>, <Managed object>, <class Managed>)

1 obj.non_over активирует метод дескриптора __get__, передавая ему obj во втором аргументе.
2 Managed.non_over — непереопределяющий дескриптор, поэтому не существует метода __set__, который мог бы вмешаться в эту операцию присваивания.
3 Теперь в obj есть атрибут экземпляра с именем non_over, который маскирует одноименный дескрипторный атрибут в классе Managed.
4 Дескриптор Managed.non_over по-прежнему существует и перехватывает эту операцию доступа через класс.
5 Если атрибут экземпляра non_over удалить...
6 ... то чтение obj.non_over активирует метод __get__ дескриптора в классе, однако вторым аргументом будет управляемый экземпляр.

При обсуждении этих понятий авторы Python пользуются различными терминами. Переопределяющие дескрипторы называют также дескрипторами данных (data descriptor) или принудительными дескрипторами (enforced descriptor). Непереопределяющие дескрипторы известны также под названием дескрипторов без данных (nondata descriptor) или маскируемых дескрипторов (shadowable descriptor).

В предыдущих примерах мы видели несколько операций присваивания атрибуту экземпляра с таким же именем, как у дескриптора; результаты оказываются различны в зависимости от того, реализован в дескрипторе метод __set__ или нет.