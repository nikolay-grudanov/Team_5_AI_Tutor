---
source_image: page_097.png
page_number: 97
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 42.80
tokens: 11889
characters: 2460
timestamp: 2025-12-24T01:39:01.073704
finish_reason: stop
---

Вариации на тему dict

5 Если возникло исключение KeyError, значит, метод __missing__ уже завершился с ошибкой, поэтому возвращаем default.
6 Ищем сначала по немодифицированному ключу (экземпляр может содержать нестроковые ключи), а затем по строке, построенной по ключу.

Задайтесь вопросом, зачем в реализации __missing__ необходима проверка isinstance(key, str).

Без этой проверки наш метод __missing__ работал бы для любого ключа k — неважно, принадлежит он типу str или нет, — если только str(k) порождает существующий ключ. Но если ключ str(k) не существует, то возникла бы бесконечная рекурсия. В последней строке вычисление self[str(key)] привело бы к вызову __getitem__ с параметром, равным строковому представлению ключу, а это, в свою очередь, — снова к вызову __missing__.

Метод __contains__ в этом примере также необходим для обеспечения согласованного поведения, потому что его вызывает операция k in d, однако реализация этого метода, унаследованная от dict, не обращается к __missing__ в случае отсутствия ключа. В нашей реализации __contains__ есть тонкий нюанс: мы не проверяем наличие ключа принятым в Python способом — k in my_dict — потому что конструкция str(key) in self привела бы к рекурсивному вызову __contains__.
Чтобы избежать этого, мы явно ищем ключ в self.keys().

Поиск вида k in my_dict.keys() эффективен в Python 3 даже для очень больших отображений, потому что dict.keys() возвращает представление, похожее на множество, а проверка вхождения для множества производится так же быстро, как для словаря. Детали описаны в разделе документации «Объекты представления словаря» (http://bit.ly/1Vm7E4q). В Python 2 dict.keys() возвращает список, поэтому наше решение будет работать и в этом случае, но для больших словарей оно неэффективно, потому что при вычислении k in my_list приходится просматривать весь список.

Проверка наличия немодифицированного ключа — key in self.keys() — необходимо для корректности, потому что класс StrKeyDict0 не гарантирует, что все ключи словаря обязательно имеют тип str. Наша цель состоит только в том, чтобы сделать поиск более дружелюбным, а не навязывать пользователю типы.

До сих пор мы рассматривали типы отображений dict и defaultdict, но в стандартной библиотеке имеются и другие реализации отображения. Обсудим их.

Вариации на тему dict

В этом разделе мы дадим обзор типов отображений, включенных в модуль стандартной библиотеки collections (помимо рассмотренного выше defaultdict):