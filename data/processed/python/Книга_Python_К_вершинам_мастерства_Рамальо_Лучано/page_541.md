---
source_image: page_541.png
page_number: 541
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 49.89
tokens: 11982
characters: 2626
timestamp: 2025-12-24T02:00:09.675045
finish_reason: stop
---

Запуск процессов с помощью concurrent.futures

на такие:

def download_many(cc_list):
    with futures.ProcessPoolExecutor() as executor:

В простых случаях единственное заметное различие между этими двумя конкретными классами исполнителей заключается в том, что методу ThreadPoolExecutor.__init__ необходимо передать аргумент max_workers, определяющий число потоков в пуле. Для ProcessPoolExecutor этот аргумент необязателен и обычно не задается — по умолчанию подразумевается количество процессоров, возвращаемое функцией os.cpu_count(). И это разумно: для счетных задач не имеет смысла запрашивать больше исполнителей, чем имеется процессоров. С другой стороны, для задач с большим объемом ввода-вывода в ThreadPoolExecutor можно задать пул с 10, 100 или 1000 потоками; оптимальная величина зависит от решаемой задачи и от объема доступной памяти, а для ее нахождения необходимо провести тщательное тестирование.

На нескольких тестах было показано, что среднее время загрузки 20 флагов при использовании класса ProcessPoolExecutor увеличивается до 1,8 с — по сравнению с 1,4 с в первоначальной версии с классом ThreadPoolExecutor. По-видимому, основная причина заключается в том, что на моей четырехъядерной машине есть ограничение — не более четырех одновременных загрузок, тогда как в версии с пулом потоков рабочих потоков может быть 20.

Ценность ProcessPoolExecutor становится очевидной только для счетных задач. Я прогнал несколько тестов производительности на двух счетных скриптах:

arcfour_futures.py
Зашифровать и дешифрировать несколько байтовых массивов размером от 149 КБ до 384 КБ с применением написанной на чистом Python реализации алгоритма RC4 (исходный код см. в приложении А, пример А.7).

sha_futures.py
Вычислить свертку SHA-256 нескольких байтовых массивов размером 1 МБ с применением стандартного библиотечного пакета hashlib, основанного на библиотеке OpenSSL (исходный код см. в приложении А, пример А.9).

Единственная операция ввода-вывода, которую выполняют эти скрипты, — вывод конечных результатов на экран. Создание и обработка данных производятся в памяти, поэтому ввод-вывод не отражается на времени работы.

В табл. 17.1 показано среднее время после 64 прогонов первого скрипта и 48 прогонов второго. Учитывается и время запуска рабочих процессов.

Короче говоря, в случае криптографических алгоритмов можно ожидать удвоения производительности в результате запуска четырех рабочих процессов на машине с четырьмя процессорными ядрами.

Для алгоритма RC4, написанного на чистом Python, можно в 3,8 раза ускорить работу, если при тех же четырех рабочих процессах воспользоваться интерпрета-