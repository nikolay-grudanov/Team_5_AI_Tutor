---
source_image: page_575.png
page_number: 575
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 50.96
tokens: 11885
characters: 2368
timestamp: 2025-12-24T02:01:44.805000
finish_reason: stop
---

Загрузка с применением asyncio и aiohttp

По той же причине нельзя было использовать и функцию download_one из скрипта flags_threadpool.py (пример 17.3). Код в примере 18.5 управляет функцией get_flag с помощью yield_from, так что download_one сама является сопрограммой. Для каждого запроса в download_many создается объект-сопрограмма download_one, и все они управляются функцией loop.run_until_complete — после обертывания сопрограммой asyncio.wait.

В пакете asyncio немало новых концепций, которые предстоит освоить, но следить за общей логикой примера 18.5 будет проще, если последовать совету самого Гвидо ван Россума: зажмуристься и притвориться, что ключевых слов yield from нет. Поступив так, вы увидите, что читать код так же легко, как последовательный.

Например, вообразим, что тело сопрограммы...

@asyncio.coroutine
def get_flag(cc):
    url = '{}/{cc}/{cc}.gif'.format(BASE_URL, cc=cc.lower())
    resp = yield from aiohttp.request('GET', url)
    image = yield from resp.read()
    return image

... работает, как следующая функция, только никогда не блокирует программу:

def get_flag(cc):
    url = '{}/{cc}/{cc}.gif'.format(BASE_URL, cc=cc.lower())
    resp = aiohttp.request('GET', url)
    image = resp.read()
    return image

Конструкция yield from foo позволяет избежать блокирования, потому что текущая сопрограмма (т. е. делегирующий генератор, в котором находится yield from) приостанавливается, но управление возвращается циклу обработки событий, который может управлять другими сопрограммами. Когда будущий объект или сопрограмма foo завершится, она вернет результат приостановленной сопрограмме и тем самым возобновит ее выполнение.

В конце раздела «Использование yield from» главы 16 я сформулировал два положения, касающихся любого использования yield from. Повторю их в сжатом виде.

• Любая конфигурация сопрограмм, связанных в цепочку выражениями yield from, в конечном итоге должна управляться вызывающей стороной, которой не является сопрограммой, а вызывает next(...) или .send(...) для самого внешнего делегирующего генератора — явно или неявно (т. е. в цикле for).
• Самый внутренний субгенератор в цепочке должен быть простым генератором, в котором используется предложение yield, или итерируемым объектом.

При использовании yield from совместно с asyncio API оба положения по-прежнему справедливы, но имеют свою специфику.