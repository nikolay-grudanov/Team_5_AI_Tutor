---
source_image: page_414.png
page_number: 414
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 34.15
tokens: 11789
characters: 1965
timestamp: 2025-12-24T01:53:46.353869
finish_reason: stop
---

Глава 13. Перегрузка операторов: как правильно?

А как насчет !=? Нам не нужно реализовывать этот метод, потому что поведение метода __ne__, унаследованное от object, нас вполне устраивает: если __eq__ определен и возвращает что-то, кроме NotImplemented, то __ne__ возвращает противоположное значение.

Иными словами, при тех же объектах, что в примере 13.14, результаты оператора != непротиворечивы:

    >>> va != vb
    False
    >>> vc != v2d
    False
    >>> va != (1, 2, 3)
    True

Метод __ne__, унаследованный от object, работает, как показано в следующем фрагменте, хотя в действительности он написан на C:4

def __ne__(self, other):
    eq_result = self == other
    if eq_result is NotImplemented:
        return NotImplemented
    else:
        return not eq_result

Ошибки в документации по Python 3

Когда я пишу эти строки, в документации по методам сравнения (https://docs.python.org/3/reference/datamodel.html) написано: «Из того, что x==y истинно, не следует, что x!=y ложно. Поэтому при определении метода __eq__() следует также определять метод __ne__()», чтобы оба оператора были согласованы». Так было в Python 2, но в случае Python 3 это плохой совет, потому что от класса object наследуется полезная реализация __ne__ по умолчанию, и необходимость переопределять ее возникает редко. Новое поведение документировано в статье Гвидо «Что нового в Python 3.0» (http://bit.ly/1C11zP5), раздел «Операторы и специальные методы». Ошибка в документации зарегистрирована под номером 4395 (http://bugs.python.org/issue4395).

Рассмотрев перегрузку инфиксных операторов, обратимся к операторам составного присваивания.

Операторы составного присваивания

Наш класс Vector уже поддерживает операторы составного присваивания += и *=.
В примере 13.15 они показаны в действии.

4 Логика методов object.__eq__ и object.__ne__ для интерпретатора CPython реализована в функции object_richcompare в исходном файле Objects/typeobject.c (http://bit.ly/1C11uL7).