---
source_image: page_662.png
page_number: 662
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 51.27
tokens: 11799
characters: 1953
timestamp: 2025-12-24T02:05:35.906618
finish_reason: stop
---

Приведенные в этой главе варианты класса LineItem демонстрируют типичное применение дескрипторов для управления атрибутами-данными. Такой дескриптор называют еще переопределяющим, поскольку его метод __set__ переопределяет (т. е. перехватывает и подменяет) установку одноименного атрибута в управляемом экземпляре. Однако существуют и непереопределяющие дескрипторы. Различие между ними мы подробно изучим в следующем разделе.

Переопределяющие и непереопределяющие дескрипторы

Напомним, что в способе обработки атрибутов в Python существует важная асимметрия. При чтении атрибута через экземпляр обычно возвращается атрибут, определенный в этом экземпляре, а если такого атрибута в экземпляре не существует, то атрибут класса. С другой стороны, в случае присваивания атрибуту экземпляра обычно создается атрибут в этом экземпляре, а класс вообще никак не затрагивается.

Эта асимметрия распространяется и на дескрипторы, в результате чего образуются две категории дескрипторов, различающиеся наличием или отсутствием метода __set__. Чтобы увидеть отличия в поведении, нам понадобится несколько классов, и код в примере 20.8 станет нашим тестовым стендом.

Все методы __get__ и __set__ в примере 20.8 вызывают print_args, чтобы их вызовы были отчетливо видны. Понимать, как устроены вспомогательные функции print_args, cls_name и display необязательно, так что не отвлекайтесь на них.

Пример 20.8. descriptorkinds.py: простые классы для изучения поведения переопределяющих и непереопределяющих дескрипторов

###
вспомогательные функции для отображения ###
def cls_name(obj_or_cls):
    cls = type(obj_or_cls)
    if cls is type:
        cls = obj_or_cls
    return cls.__name__.split('.')[-1]

def display(obj):
    cls = type(obj)
    if cls is type:
        return '<class {}>'.format(obj.__name__)
    elif cls in [type(None), int]:
        return repr(obj)
    else:
        return '<{} object>'.format(cls_name(obj))

def print_args(name, *args):