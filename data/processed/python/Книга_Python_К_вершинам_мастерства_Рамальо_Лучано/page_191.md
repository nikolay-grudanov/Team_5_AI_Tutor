---
source_image: page_191.png
page_number: 191
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 61.53
tokens: 11976
characters: 2494
timestamp: 2025-12-24T01:43:54.664079
finish_reason: stop
---

Поговорим

дится платить за в высшей степени удобочитаемый синтаксис3. У языка Lisp много сильных сторон, но удобочитаемость не из их числа.

По иронии судьбы, заимствование синтаксиса спискового включения из другого функционального языка, Haskell, заметно сократило потребность в map и filter, да, кстати, и в lambda.

Помимо ограничений синтаксиса анонимных функций, основным препятствием для более широкого принятия идиом функционального программирования в Python служит отсутствие устранения хвостовой рекурсии — оптимизации, которая уменьшает потребление памяти функцией, выполняющей рекурсивный вызов в конце своего тела. В другом сообщении, «Tail Recursion Elimination» (http://bit.ly/1FHjdZv), Гвидо приводит несколько причин, по которым такая оптимизация плохо подходит для Python. Это сообщение весьма интересно технической аргументацией, но еще более тем, что первые три — самые важные — причины касаются удобства пользования. Тот факт, что использование, изучение и преподавание Python доставляет массу удовольствия — не случайность. Гвидо специально стремился к этому.

Итак: Python, по своему замыслу, не является функциональным языком — что бы под этим ни понимать. Python лишь заимствует кое-какие удачные идеи из функциональных языков.

Проблема анонимных функций

Помимо синтаксических ограничений, связанных со спецификой Python, у анонимных функций есть серьезный недостаток в любом языке: отсутствие имени.

И это лишь наполовину шутка. Трассировку стека проще читать, если у функций есть имя. Анонимные функции удобны, когда нужно срезать угол, программисты любят их писать, но иногда слишком увлекаются — особенно если язык и среда поощряют глубокую вложенность анонимных функций, как, скажем, JavaScript в среде Node.js. Большое количество вложенных анонимных функций усложняет отладку и обработку ошибок. Асинхронное программирование в Python более структурировано, быть может, потому что того требуют ограничения лямбда-выражений. Обещаю рассказать подробнее об асинхронном программировании в будущем, но отложу это до главы 18. Кстати, обещания, будущие и отложенные объекты — концепции, используемые в API асинхронного программирования. Наряду с сопрограммами они открывают выход из так называемого «ада обратных вызовов». Мы увидим, как работает асинхронное программирование без обратных вызовов в разделе «От обратных вызовов к будущим объектам и сопрограммам» на стр. 592.

3 Еще есть проблема потери отступов при копировании кода в веб-форумы, но это я отвлекся.