---
source_image: page_110.png
page_number: 110
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 83.39
tokens: 12777
characters: 3469
timestamp: 2025-12-24T01:40:20.179279
finish_reason: stop
---

Глава 3. Словари и множества

Говоря конкретно, на поиск 1000 ключей с плавающей точкой в словаре, содержащем 1000 элементов, на моем ноутбуке ушло 0,000202 с, а на такой же поиск в словаре из 10 000 000 элементов — 0,000337 с. Иными словами, поиск иголки в стоге размером 10 000 000 элементов в среднем занимал 0,337 мкс на одну иголку, примерно треть микросекунды.

Для сравнения я повторил этот эксперимент с такими же стогами возрастающих размеров, но имеющими тип set или list. В тестах для set я хронометрировал не только цикл for из примера 3.14, но и односторочный код, показанный в примере 3.15, который делает точно то же самое: вычисляет количество элементов из needles, встречающихся также в haystack.

Пример 3.15. Применение пересечения множеств для подсчета иголок, найденных в стоге сена

found = len(needles & haystack)

В табл. 3.6 результаты тестов показаны рядом. Наилучшее время представлено в столбце «Время set&» — результат применения оператора & в коде из примера 3.15. Наихудшее время — вполне ожидаемо — представлено в столбце «Время list», поскольку поиск с помощью оператора in в списке не поддерживал хэш-таблицей и, следовательно, приходится просматривать список целиком, т. е. время линейно увеличивается с ростом размера стога.

Таблица 3.6. Общее время поиска с помощью оператора in 1000 ключей в стогах 5 разных размеров, представленных объектами dict, set и list. Тесты были выполнены на ноутбуке с процессором Core i7 в версии Python 3.4.0 (замерялось время работы цикла в примере 3.14 за исключением столбца set&, для которого хронометрировался код из примера 3.15)

<table>
  <tr>
    <th>Длина haystack</th>
    <th>Коэфф dict</th>
    <th>Время dict</th>
    <th>Коэфф set</th>
    <th>Время set</th>
    <th>Коэфф set&</th>
    <th>Время set&</th>
    <th>Коэфф list</th>
    <th>Время list</th>
  </tr>
  <tr>
    <td>1000</td>
    <td>1x</td>
    <td>0,000202c</td>
    <td>1,00x</td>
    <td>0,000143c</td>
    <td>1,00x</td>
    <td>0,000087c</td>
    <td>1,00x</td>
    <td>0,010556c</td>
    <td>1,00x</td>
  </tr>
  <tr>
    <td>10 000</td>
    <td>10x</td>
    <td>0,000140c</td>
    <td>0,69x</td>
    <td>0,000147c</td>
    <td>1,03x</td>
    <td>0,000092c</td>
    <td>1,06x</td>
    <td>0,086586c</td>
    <td>8,20x</td>
  </tr>
  <tr>
    <td>100 000</td>
    <td>100x</td>
    <td>0,000228c</td>
    <td>1,13x</td>
    <td>0,000241c</td>
    <td>1,69x</td>
    <td>0,000163c</td>
    <td>1,87x</td>
    <td>0,871560c</td>
    <td>82,57x</td>
  </tr>
  <tr>
    <td>1 000 000</td>
    <td>1000x</td>
    <td>0,000290c</td>
    <td>1,44x</td>
    <td>0,000332c</td>
    <td>2,32x</td>
    <td>0,000250c</td>
    <td>2,87x</td>
    <td>9,189616c</td>
    <td>870,56x</td>
  </tr>
  <tr>
    <td>10 000 000</td>
    <td>10000x</td>
    <td>0,000337c</td>
    <td>1,67x</td>
    <td>0,000387c</td>
    <td>2,71x</td>
    <td>0,000314c</td>
    <td>3,61x</td>
    <td>97,948056c</td>
    <td>9278,90x</td>
  </tr>
</table>

Если программа выполняет какой-либо ввод-вывод, то время поиска по ключу в словаре или в множестве пренебрежимо мало, каким бы ни был размер dict или set (при условии, что объект целиком помещается в оперативной памяти). См. код, с помощью которого были сгенерированы данные для табл. 3.6, и сопутствующее обсуждение в приложении А, пример А.1.

Теперь, получив убедительное свидетельство быстродействия словарей и множеств, разберемся, как оно достигается. В частности, из обсуждения внутренне-