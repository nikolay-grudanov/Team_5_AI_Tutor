---
source_image: page_469.png
page_number: 469
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 46.97
tokens: 11823
characters: 2091
timestamp: 2025-12-24T01:56:39.190670
finish_reason: stop
---

Пример 14.25. Это простая абстракция, оберывающая процесс отдачи значения

def f():
    def do_yield(n):
        yield n
        x = 0
        while True:
            x += 1
            yield from do_yield(x)

Использование def для объявления генераторов с точки зрения удобства пользования было ошибкой, и проблема только усугубилась в версии Python 2.5, когда появились сопрограммы, которые тоже кодировались в виде функций со словом yield. В сопрограммах слово yield обычно встречается в правой части оператора присваивания, потому что получает аргумент, переданный клиентом при вызове .send(). Вот что пишет Дэвид Бизли:

Несмотря на внешнее сходство, генераторы и сопрограммы — совершенно разные концепции15.

Я полагаю, что сопрограммы заслуживают отдельного ключевого слова. Как мы увидим ниже, сопрограммы часто используются со специальными декораторами, которые визуально все же отличают их от обычных функций. Но генераторные функции снабжаются декораторами реже, поэтому приходится искать в их теле слово yield, чтобы понять, что это и не функции вовсе, а нечто совершенно иное.

Можно возразить, что при введении этих средств ставилась цель минимизировать синтаксические изменения, а дополнительное ключевое слово было бы просто «синтаксической глазурью». Но лично я ничего не имею против синтаксической глазури, если благодаря ей принципиально различные средства и выглядят по-разному. Именно из-за отсутствия синтаксической глазури код на Lisp так трудно читать: любая языковая конструкция в Lisp выглядит как вызов функции.

Сравнение семантики генератора и итератора

Есть по меньшей мере три способа осмыслить связь между итераторами и генераторами.

Первый — с точки зрения интерфейса. В протоколе итератора в Python определены два метода: __next__ и __iter__. Объекты-генераторы реализуют оба, так что с этой точки зрения любой генератор является итератором. Согласно этому определению, объекты, созданные встроенной функцией enumerate() являются итераторами:

15 Слайд 31 «A Curious Course on Coroutines and Concurrency» (http://www.dabeaz.com/coroutines/Coroutines.pdf).