---
source_image: page_544.png
page_number: 544
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 70.49
tokens: 12102
characters: 2478
timestamp: 2025-12-24T02:00:36.248250
finish_reason: stop
---

[15:56:50] loiter(0): done.
[15:56:50] loiter(1): doing nothing for 1s...
[15:56:50] loiter(2): doing nothing for 2s...
[15:56:50] results: <generator object result_iterator at 0x106517168>
[15:56:50] loiter(3): doing nothing for 3s...
[15:56:50] Waiting for individual results:
[15:56:50] result 0: 0
[15:56:51] loiter(1): done.
[15:56:51] loiter(4): doing nothing for 4s...
[15:56:51] result 1: 10
[15:56:52] loiter(2): done.
[15:56:52] result 2: 20
[15:56:53] loiter(3): done.
[15:56:53] result 3: 30
[15:56:55] loiter(4): done.
[15:56:55] result 4: 40

1 Прогон начался в 15:56:50.
2 Первый поток выполняет loiter(0), поэтому спит 0 с и завершается еще до того, как второй поток запустился, но на вашей машине все может быть по-другому5.
3 loiter(1) и loiter(2) запускаются немедленно (поскольку в пуле три рабочих потока, он может одновременно выполнять три функции).
4 Отсюда видно, что объект results; возвращенный executor.map, — генератор; до сих пор никаких блокировок не было вне зависимости от количества задач и значения max_workers.
5 Поскольку loiter(0) завершилась, первый рабочий поток готов к выполнению loiter(3).
6 Здесь выполнение может быть заблокировано в зависимости от параметров loiter: метод __next__ генератора results должен дождаться завершения первого будущего объекта. В данном случае блокировки не будет, потому что вызов loiter(0) завершился еще до начала цикла. Отметим, что все действия до этого места произошли в течение одной секунды: 15:56:50.
7 loiter(1) завершается в следующую секунду — в 15:56:51. Поток освобождается и готов к выполнению loiter(4).
8 Показан результат loiter(1): 10. Теперь цикл for блокируется в ожидании результата loiter(2).
9 Картина повторяется: loiter(2) завершается и печатается его результат; затем то же самое для loiter(3).
10 loiter(4) завершается после двухсекундной задержки, поскольку началась в 15:56:51 и ничего не делала 4 с.

Функцией Executor.map пользоваться легко, но у нее есть особенность, которая может оказаться полезной или вредной в зависимости от ваших потребностей: она возвращает результаты точно в том порядке, в каком производились вызовы,

5 С потоками никогда не знаешь точную последовательность событий, которые должны произойти практически одновременно; вполне возможно, что на другой машине loiter(1) начнется раньше, чем loiter(0) завершится, особенно если учесть, что sleep всегда освобождает GIL, так что Python может переключиться на другой поток, пусть даже текущий спал 0 с.