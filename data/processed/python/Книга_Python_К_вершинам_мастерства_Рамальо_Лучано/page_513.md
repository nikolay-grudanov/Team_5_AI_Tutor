---
source_image: page_513.png
page_number: 513
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 59.98
tokens: 12034
characters: 2768
timestamp: 2025-12-24T01:58:49.299788
finish_reason: stop
---

Семантика yield from

3 Если было возбуждено исключение StopIteration, то извлечь его атрибут value и присвоить его переменной _r; в простейшем случае это будет результат RESULT.
4 Пока этот цикл работает, делегирующий генератор блокирован и действует просто как канал между вызывающей стороной и субгенератором.
5 Отдаем текущий элемент, порожденный субгенератором; ждем, когда вызывающая сторона отправит значение _s. Это единственный раз, когда в листинге встречается слово yield.
6 Здесь обрабатывается закрытие делегирующего генератора и субгенератора. Поскольку субгенератор может быть произвольным итератором, то наличие у него метода close необязательно.
7 Здесь обрабатываются исключения, возбужденные вызывающей стороной с помощью метода .throw(...). И снова субгенератор может быть произвольным итератором, не имеющим метода throw, и в таком случае в делегирующем генераторе возникает исключение.
8 Если у субгенератора есть метод throw, вызываем его, передавая исключение, полученное от вызывающей стороны. Субгенератор может обработать исключение (тогда цикл продолжится) или возбудить исключение StopIteration (из него извлекается результат _r и цикл завершается) или возбудить то же самое или другое исключение, которое здесь не обрабатывается, а распространяется делегирующему генератору.
9 Если при отдаче не возникло исключение...
10 Пытаемся сдвинуть с места субгенератор...
11 Вызываем метод next субгенератора, если последнее полученное от вызывающей стороны значение было равно None; в противном случае вызываем send.
12 Если субгенератор возбудил исключение StopIteration, получить value, присвоить это значение переменной _r и выйти из цикла, возобновив тем самым делегирующий генератор.
13 _r становится результатом RESULT — значением всего выражения yield from.

Логика псевдокода yield from по большей части сосредоточена в шести вложенных до уровня 4 блоках try/except, поэтому читать его трудно. Кроме них, используются только ключевые слова управления потоком: одно while, одно if и одно yield. Найдите вхождения while, yield, а также вызовы next(...) и .send(...): это поможет составить представление о том, как работает вся конструкция.

В самом начале примере 16.19 псевдокод раскрывает одну важную деталь: инициализацию субгенератора (вторая выноска)⁹. Это означает, что автоинициализирующие декораторы типа того, чтописан в разделе «Декораторы для инициализации сопрограмм» выше, несовместимы с yield from.

В том же сообщении (http://bit.ly/1Jl0pTt), которое я цитировал в начале этого раздела, Грэг Ивинг пишет о псевдокоде, расширяющем yield from:

⁹ В сообщении в списке рассылки Python-ideas от 5 апреля 2009 (http://bit.ly/1Jl0XJ1) Ник Кофлин (Nick Coghlan) спросил, так ли хороша идея неявной инициализации, выполняемой yield.