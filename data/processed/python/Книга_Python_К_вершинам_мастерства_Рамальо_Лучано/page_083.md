---
source_image: page_083.png
page_number: 83
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 34.95
tokens: 11847
characters: 2239
timestamp: 2025-12-24T01:38:14.412393
finish_reason: stop
---

Дополнительная литература

Плоские и контейнерные последовательности

Чтобы подчеркнуть различие между моделями памяти в последовательностях разных типов, я воспользовался терминами контейнерная и плоская последовательность. Слово «контейнер» употребляется в документации по модели данных (https://docs.python.org/3/reference/datamodel.html#objects-valuesand-types):

Некоторые объекты содержат ссылки на другие объекты, они называются контейнерами.

Я остановился на термине «контейнерная последовательность» для большей точности, потому что в Python есть контейнеры, не являющиеся последовательностями, например dict и set. Контейнерные последовательности могут быть вложенными, поскольку могут содержать объекты любого типа, в том числе своего собственного.

С другой стороны, плоские последовательности не могут быть вложенными, потому что в них разрешено хранить только простые атомарные типы, например: целые, числа с плавающей точки или символы.

Я выбрал термин плоская последовательность, потому что нуждался в чем-то, противоположном «контейнерной последовательности». Не могу сослаться на работу, в которой встречалось бы такое употребление этого термина: как категории последовательностей Python, не являющихся контейнерами. В википедии такие вещи назвали бы «оригинальными изысканиями». Я предпочитаю говорить «наш термин» в надежде, что он понравится и вам, и вы его примете.

Смешанные списки

В учебниках Python для начинающих подчеркивается, что списки могут содержать объекты разных типов, но на практике такая возможность не слишком полезна: ведь мы помещаем элементы в список, чтобы впоследствии их обработать, а это значит, что все элементы должны поддерживать общий набор операций (т. е. должны «крякать», даже если не родились утками). Например, в Python 3 невозможно отсортировать список, если его элементы не сравниваются между собой:

```python
>>> l = [28, 14, '28', 5, '9', '1', 0, 6, '23', 19]
>>> sorted(l)
Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
TypeError: unorderable types: str() < int()
```

В отличие от списков, кортежи часто содержат элементы разных типов. И это естественно, потому что каждый элемент кортежа — поле, а тип каждого поля не зависит от остальных полей.