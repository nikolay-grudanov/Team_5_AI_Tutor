---
source_image: page_562.png
page_number: 562
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 56.37
tokens: 11940
characters: 2485
timestamp: 2025-12-24T02:01:08.225368
finish_reason: stop
---

Глава 18. Применение пакета asyncio для организации...

одновременно. Поэтому-то Роб Пайк и назвал свой доклад «Concurrency Is Not Parallelism (It's Better)» (Конкурентность — это не параллелизм (это лучше)).

В этой главе мы познакомимся с пакетом asyncio, в котором конкурентность реализована с помощью сопрограмм, управляемых из цикла обработки событий. Это одна из самых больших и амбициозных библиотек, когда-либо добавленных в арсенал Python. Гвидо ван Россум разрабатывал asyncio вне репозитория Python и дал проекту кодовое название Tulip (тюльпан), так что при поиске сведений об этом проекте в Интернете будут попадаться и сайты о цветке. А основная дискуссионная группа на эту тему по-прежнему называется python-tulip (http://bit.ly/1HGtMiO).

Проект Tulip был переименован в asyncio после добавления в стандартную библиотеку версии Python 3.4. Он совместим и с Python 3.3 — на сайте PyPI вы найдете его уже под новым официальным именем (https://pypi.python.org/pypi/asyncio). Поскольку в asyncio повсеместно используются выражения yield from, с более ранними версиями Python он несовместим.

Проект Trollius (купальница) (http://trollius.readthedocs.org) — в названии которого также фигурирует цветок — представляет собой обратный перенос asyncio на версию Python 2.6 и более ранние с заменой yield from на yield и специальные вызываемые объекты с именами From и Return. Выражение yield from ... принимает вид yield From(...);, а когда сопрограмме необходимо вернуть результат, мы пишем raise Return(result) вместо return result. Во главе проекта Trollius стоит Виктор Стиннер, который является также разработчиком ядра asyncio и любезно согласился отредактировать эту главу перед сдачей в печать.

В этой главе будут рассмотрены следующие вопросы.

• Сравнение однопоточной программы с эквивалентной, написанной с применением asyncio, с целью продемонстрировать связь между потоками и асинхронными задачами.
• Различия между классами asyncio.Future и concurrent.futures.Future.
• Асинхронные версии программ загрузки флагов из главы 17.
• Как асинхронная программа управляется с высокой конкурентностью в сетевых приложениях, не прибегая ни к процессам, ни к потокам.
• Сопрограммы как важное усовершенствование обратных вызовов в асинхронном программировании.
• Как избежать блокировки цикла событий, поручая блокирующие операции пулу потоков.
• Программирование серверов с помощью asyncio и переосмысление структуры веб-приложений ради достижения высокой конкурентности.