---
source_image: page_539.png
page_number: 539
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 47.09
tokens: 11884
characters: 2388
timestamp: 2025-12-24T01:59:59.965313
finish_reason: stop
---

Блокирующий ввод-вывод и GIL

4 Здесь два потока выводят коды стран, прежде чем download_many в главном потоке получает возможность вывести результат объекта в первом потоке.

Если прогнать flags_threadpool_ac.py несколько раз подряд, то мы увидим, что порядок вывода результатов изменяется. При увеличении max_workers до 5 изменчивость порядка усиливается, а при уменьшении до 1 код начинает работать последовательно, и и результаты выводятся в том же порядке, в каком коды стран по-давались методом submit.

Мы видели два варианта скрипта загрузки с применением библиотеки concurrent.futures: пример 17.3 на основе метода ThreadPoolExecutor.map и пример 17.4 на основе futures.as_completed. Если вам не терпится увидеть код скрипта flags_asyncio.py, можете взглянуть на пример 18.5 в главе 18.

Строго говоря, ни один из протестированных до сих пор скриптов не выполняет загрузку параллельно. Примеры с использованием concurrent.futures ограничены глобальной блокировкой интерпретатора GIL, а скрипт flags_asyncio.py вообще однопоточный.

Возможно, у вас возникли вопросы о результатах неформального хронометража.

• Каким образом flags_threadpool.py оказался в 5 раз быстрее flags.py, если использование потоков в Python ограничено глобальной блокировкой интерпретатора, которая позволяет в каждый момент времени работать только одному потоку?
• Как получилось, что скрипт flags_asyncio.py работает в 5 раз быстрее flags.py, если тот и другой однопоточные?

На второй вопрос я отвечу в разделе «Объезд блокирующих вызовов» на стр. 582.

А о том, почему GIL не приносит почти никакого вреда в программах, ограниченных скоростью ввода-вывода, читайте в следующем разделе.

Блокирующий ввод-вывод и GIL

Сам интерпретатор CPython не является потокобезопасным, поэтому в нем есть глобальная блокировка интерпретатора (Global Interpreter Lock — GIL), которая разрешает в каждый момент времени выполнять байт-код только одному потоку. Именно поэтому один процесс Python обычно не может задействовать несколько процессорных ядер одновременно3.

При написании кода на чистом Python у нас нет контроля над GIL, однако встроенная функция или написанное на С расширение могут освободить GIL при

3 Это ограничение интерпретатора CPython, а не самого языка Python. У Jython и Iron Python такого ограничения нет. Однако у PyPy, самого быстрого из имеющихся интерпретаторов Python, GIL тоже имеется.