---
source_image: page_390.png
page_number: 390
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 23.93
tokens: 11634
characters: 1574
timestamp: 2025-12-24T01:52:21.675261
finish_reason: stop
---

View является базовым классом всех представлений (он мог бы быть абстрактным) и предоставляет основную функциональность, например метод dispatch, delegирующий работу методам-обработчикам — get, head, post и др. — которые реализованы в конкретных классах для обработки различных глаголов HTTP8. Класс RedirectView наследует только View и, как видите, реализует методы get, head, post и т. д.

Но если предполагается, что конкретные подклассы View реализуют методы-обработчики, то почему же они не являются частью интерфейса View? Причина проста: подклассы вольны реализовывать лишь те обработчики, которым считают нужным поддержать. Класс TemplateView служит только для отображения содержимого, поэтому реализует лишь метод get. Если объекту TemplateView будет послан POST-запрос, то унаследованный метод View.dispatch обнаружит, что обработчика post нет, и отправит HTTP-ответ 405 Method Not Allowed.9

![UML-диаграмма классов из модуля django.views.generic.base](https://i.imgur.com/3Q5z5QG.png)

Рис. 12.4. UML-диаграмма классов из модуля django.views.generic.base

8 Программирующие на Django знают, что метод класса as_view — самая заметная часть интерфейса View, но нам это сейчас неинтересно.
9 Знакомые с паттернами проектирования заметят, что механизм диспетчеризации в Django — динамический вариант паттерна Шаблонный метод (http://en.wikipedia.org/wiki/Template_method_pattern). Динамический — потому что класс View не заставляет свои подклассы реализовывать все обработчики, а dispatch на этапе выполнения проверяет, существует ли обработчик поступившего запроса.