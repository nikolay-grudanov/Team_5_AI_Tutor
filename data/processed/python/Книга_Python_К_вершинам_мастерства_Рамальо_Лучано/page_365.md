---
source_image: page_365.png
page_number: 365
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 50.81
tokens: 12036
characters: 2857
timestamp: 2025-12-24T01:51:43.226969
finish_reason: stop
---

Резюме

вав его: Tombola.register(Spam). Конечно, ваш метод __subclasshook__ мог бы еще проверить сигнатуры методов и другие свойства, но не думаю, что оно того стоит.

Резюме

В этой главе мы намеревались совершить длинное путешествие: начать с динамической природы неформальных интерфейсов — протоколов, посетить статические объявления интерфейсов с помощью ABC и закончить динамической стороной ABC: виртуальными подклассами и динамическим обнаружением подклассов с помощью метода __subclasshook__.

Для начала мы напомнили о традиционном понимании интерфейсов в сообществе Python. На протяжении большей части истории Python мы знали об интерфейсах, но считали их неформальными понятиями, аналогичными протоколам в Smalltalk, а в официальной документации можно было встретить выражения «протокол foo», «интерфейс foo» и «объект, похожий на foo», означающие одно и то же. Интерфейсы в духе протоколов не имеют ничего общего с наследованием; каждый класс реализует протокол независимо от остальных. Так выглядят интерфейсы в языках с динамической типизацией.

В примере 11.3 мы видели, насколько всеобъемлющая в Python поддержка протокола последовательности. Даже если в классе реализован метод __getitem__ и ничего более, то Python все равно ухитряется обойти его, и оператор in работает. Затем мы вернулись к примеру класса FrenchDeck из главы 1 и поддержали тасование с помощью динамического добавления метода. Тем самым мы проиллюстрировали партизанское латание и еще раз подчеркнули динамическую природу протоколов. Также было показано, что иногда полезно реализовывать протокол лишь частично: просто добавление метода __setitem__, определенного в протоколе изменяемой последовательности, позволило воспользоваться функцией из стандартной библиотеки random.shuffle. Знание имеющихся протоколов позволило получить максимум пользы от богатейшей стандартной библиотеки Python.

Затем Алекс Мартелли ввел термин «гусиная типизация»17 для описания нового стиля программирования на Python. Благодаря «гусиной типизации» абстрактные базовые классы (ABC) используются, чтобы сделать интерфейсы явными, а классы могут реализовывать интерфейсы с помощью либо наследования ABC, либо регистрации, для которой не требуется сильная статическая связь, характерная для наследования.

На примере класса FrenchDeck2 мы отчетливо увидели плюсы и минусы явных ABC. Наследование классу abc.MutableSequence заставило нас реализовать два метода, которые нам вообще-то были не нужны: insert и __delitem__. С другой стороны, даже начинающий программировать на Python, взглянув на класс FrenchDeck2, поймет, что это изменяемая последовательность. А в качестве премии мы унаследовали 11 готовых методов от класса abc.MutableSequence (пять из них — опосредованно от abc.Sequence).

17 Придуманное Алексом выражение «гусиная типизация» впервые публикуется на страницах этой книги!