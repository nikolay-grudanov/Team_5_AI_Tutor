---
source_image: page_087.png
page_number: 87
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 43.34
tokens: 11819
characters: 1743
timestamp: 2025-12-24T01:38:32.841980
finish_reason: stop
---

общие типы отображений

тому что его элементы должны быть хэшируемыми по определению.
Объект типа tuple является хэшируемым только тогда, которые хэшируемы все его элементы. Взгляните на кортежи tt, t1 и tf:

```python
>>> tt = (1, 2, (30, 40))
>>> hash(tt)
8027212646858338501
>>> t1 = (1, 2, [30, 40])
>>> hash(t1)
Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
TypeError: unhashable type: 'list'
>>> tf = (1, 2, frozenset([30, 40]))
>>> hash(tf)
-4118419923444501110
```

На момент написания этой книги в глоссарии Python утверждалось (http://bit.ly/1K4qjwE): «Все неизменяемые встроенные объекты Python являются хэшируемыми», но это не совсем верно, потому что тип tuple неизвестный, но может содержать ссылки на нехэшируемые объекты.

Любой пользовательский тип является хэшируемым по определению, потому что его хэш-значение равно id() и никакие два объекта этого типа не равны. Если объект реализует метод __eq__, учитывающий внутреннее состояние, то он будет хэшируемым, только если все атрибуты неизменяемые.

Имея в виду эти основополагающие правила, мы можем строить словари несколькими способами. На странице «Встроенные типы» (http://bit.ly/1QS9Ong) справочного руководства по библиотеке приведен следующий пример, демонстрирующий различные способы построения словаря:

```python
>>> a = dict(one=1, two=2, three=3)
>>> b = {'one': 1, 'two': 2, 'three': 3}
>>> c = dict(zip(['one', 'two', 'three'], [1, 2, 3]))
>>> d = dict([('two', 2), ('one', 1), ('three', 3)])
>>> e = dict({'three': 3, 'one': 1, 'two': 2})
>>> a == b == c == d == e
True
```

Кроме литературного синтаксиса и гибкого конструктора класса dict, для построения словаря можно использовать словарное включение. Читайте следующий раздел.