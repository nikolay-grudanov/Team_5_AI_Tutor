---
source_image: page_249.png
page_number: 249
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 45.22
tokens: 11799
characters: 1407
timestamp: 2025-12-24T01:46:10.089408
finish_reason: stop
---

По умолчанию копирование поверхностное

11.append(100)    # ②
11[1].remove(55)  # ③
print('11:', 11)
print('12:', 12)
12[1] += [33, 22] # ④
12[2] += (10, 11) # ⑤
print('11:', 11)
print('12:', 12)

① 12 — поверхностная копия 11. Это состояние изображено на рис. 8.3.
② Добавление 100 в 11 не отражается на 12.
③ Здесь мы удаляем 55 из внутреннего списка 11[1]. Это отражается на 12, потому что объект 12[1] связан с тем же списком, что 11[1].
④ Для изменяемого объекта, в частности списка, на который ссылается 12[1], оператор += изменяет список на месте. Это изменение отражается на 11[1], т. к. это синоним 12[1].
⑤ Для кортежа оператор += создает новый кортеж и перепривязывает к нему переменную 12[2]. Это то же самое, что присваивание 12[2] = 12[2] + (10, 11). Отметим, что кортежи в последней позиции списков 11 и 12 уже не являются одним и тем же объектом (см. рис. 8.4).

![Диаграмма состояния программы](../images/8_3.png)

Рис. 8.3. Состояние программы сразу после присваивания 12 = list(11) в примере 8.6. 11 и 12 ссылаются на разные списки, но эти списки разделяют ссылки на один и тот же объект внутреннего списка [66, 55, 44] и кортеж (7, 8, 9) (рисунок построен сайтом Online Python Tutor)

Результат работы примера 8.6 показан в примере 8.7, а конечное состояние объектов — на рис. 8.4.

Пример 8.7. Результат работы примера 8.6

11: [3, [66, 44], (7, 8, 9), 100]
12: [3, [66, 44], (7, 8, 9)]