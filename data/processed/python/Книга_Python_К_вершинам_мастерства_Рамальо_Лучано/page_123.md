---
source_image: page_123.png
page_number: 123
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 46.70
tokens: 11955
characters: 2606
timestamp: 2025-12-24T01:40:26.180458
finish_reason: stop
---

Все, что нужно знать о байтах

2 Каждый элемент — целое число в диапазоне range(256).
3 Срезы bytes также имеют тип bytes, даже если срез состоит из одного байта.
4 Для типа bytearray не существует литерального синтаксиса: в оболочке объекты этого типа представляются в виде конструктора bytearray(), аргументом которого является литерал типа bytes.
5 Срез bytesarray также имеет тип bytesarray.

Тот факт, что my_bytes[0] возвращает int, а my_bytes[:1] — объект bytes длины 1, не должен вызывать удивления. Единственный тип последовательности, для которого s[0] == s[:1], — это тип str. И хотя на практике этот тип используется сплошь и рядом, его поведение — исключение из правила. Для всех остальных последовательностей s[i] возвращает один элемент, а s[i:i+1] — последовательность, состоящую из единственного элемента s[i].

Хотя двоичные последовательности — на самом деле, последовательности целых чисел, в их литературной нотации отражен тот факт, что часто они включают ASCII-текст. Поэтому применяются различные способы отображения, зависящие от значения каждого байта.

• Для байтов из диапазона символов ASCII, имеющих графическое начертание, — от пробела до ~ — выводится сам символ ASCII.
• Для байтов, соответствующих символам табуляции, новой строки, возврата каретки и \, выводятся управляющие последовательности \t, \n, \r и \\.
• Для всех остальных байтов выводится шестнадцатеричное представление (например, нулевой байт представляется последовательностью \x00).

Именно поэтому в примере 4.2 мы видим представление b'caf\xc3\xa9': первые три байта b'caf' принадлежат диапазону символов ASCII с графическим начертанием, последний — нет.

Оба типа bytes и bytearray поддерживают все методы типа str кроме тех, что относятся к форматированию (format, format_map), и еще нескольких, прямо зависящих от особенностей Unicode, в том числе casefold, isdecimal, isidentifier, isnumeric, isprintable и encode. Это означает, что при работе с двоичными последовательностями мы можем пользоваться знакомыми методами строк, например endswith, replace, strip, translate, upper и десятками других, только аргументы должны иметь тип bytes, а не str. К двоичным последовательностям применимы и функции для работы с регулярными выражениями из модуля re, если регулярное выражение откомпилировано из двоичной последовательности, а не из str. Оператор % не работает с двоичными последовательностями в версиях от Python 3.0 до 3.4, но, если верить документу «PEP 461 — Adding % formatting to bytes and bytearray» (https://www.python.org/dev/peps/pep-0461/), то его предполагается поддержать его в версии 3.5.