---
source_image: page_600.png
page_number: 600
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 62.25
tokens: 12110
characters: 2960
timestamp: 2025-12-24T02:02:59.747486
finish_reason: stop
---

(http://bit.ly/1HGu5dz), говорится, что обработчик, «являющийся обычной функцией, автоматически преобразуется в сопрограмму».

Функция home из примера 18.18 очень проста, но у этой простоты есть недостаток. Тот факт, что это обычная функция, а не сопрограмма, наводит на важный вопрос: мы должны переосмыслить, каким образом обеспечить высокую степень параллелизма веб-приложений. Подумаем об этом.

Повышение степени параллелизма за счет более интеллектуальных клиентов

Функция home из примера 18.18 очень похожа на функцию представления в Django или Flask. В ее реализации нет ничего асинхронного: она получает запрос, читает данные из базы и строит ответ, отрисовывая полную HTML-страницу. В данном примере «базой данных» является объект UnicodeNameIndex, хранящийся в памяти. Но к настоящей базе данных следует обращаться асинхронно, в противном случае цикл обработки событий окажется блокированным в ожидании результатов. Например, пакет aiopg (https://aiopg.readthedocs.org/en/stable/) предоставляет асинхронный драйвер СУБД PostgreSQL, совместимый с asyncio; он позволяет использовать yield from для отправки запросов и получения результатов, поэтому функция представления может вести себя как сопрограмма.

Системы с высокой степенью параллелизма должны не только избегать блокирующих вызовов, но и разбивать большие работы на более мелкие части. Эта проблема проявляется и в сервере http_charfinder.py: поиск по слову «сjk» возвращает 75 821 китайских японских и корейских иероглифов9. В данном случае функция home вернет HTML-документ размером 5,3 МБ, содержащий таблицу из 75 821 строк.

На моей машине командному HTTP-клиенту curl для получения ответа на запрос «сjk» от локального сервера http_charfinder.py потребовалось 2 секунды. Браузеру понадобится еще больше времени, чтобы отрисовать такую огромную таблицу. Разумеется, ответы на большинство запросов гораздо меньше: запрос по слову «braille» возвращает 256 строк, занимающих 19 КБ, и на моей машине выполняется за 0,017 с. Но если сервер тратит 2 с на выполнение одного запроса «сjk», то все остальные клиенты должны будут ждать по меньшей мере 2 с, а это неприемлемо.

Один из способов решить проблему длинного ответа — реализовать разбиение на страницы, т. е. возвращать, скажем, не более 200 строк и предоставить пользователю средства для листания страниц. В модуле charfinder.py из репозитория кода к этой книге (http://bit.ly/1JItSti) есть метод UnicodeNameIndex.find_descriptions, принимающий необязательные аргументы start и stop: это смещения для поддержки разбиения на страницы. Поэтому можно было бы вернуть первые 200 результатов, а затем с помощью AJAX или даже WebSockets отправлять следующую порцию, когда (и если) пользователь захочет ее увидеть.

9 Аббревиатура CJK означает «Chinese, Japanese, Korean» — постоянно расширяющийся набор китайских, японских и корейских символов. Возможно, будущие версии Python станут поддерживать даже больше иероглифов CJK, чем версия 3.4.