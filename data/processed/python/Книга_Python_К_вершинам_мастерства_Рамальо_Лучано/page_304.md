---
source_image: page_304.png
page_number: 304
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 40.75
tokens: 11757
characters: 2020
timestamp: 2025-12-24T01:48:35.638163
finish_reason: stop
---

Пример 10.3. Код из примера 1.1, воспроизведенный здесь для удобства

import collections

Card = collections.namedtuple('Card', ['rank', 'suit'])

class FrenchDeck:
    ranks = [str(n) for n in range(2, 11)] + list('JQKA')
    suits = 'spades diamonds clubs hearts'.split()

    def __init__(self):
        self._cards = [Card(rank, suit) for suit in self.suits
                       for rank in self.ranks]

    def __len__(self):
        return len(self._cards)

    def __getitem__(self, position):
        return self._cards[position]

В классе FrenchDeck из примера 10.3 применяются разнообразные средства Python, потому что он реализует протокол последовательности, хотя нигде в коде об этом явно не сказано. Любому опытному программисту на Python достаточно одного взгляда на код, что понять, что это именно класс последовательности, несмотря на то, что он является подклассом object. Мы говорим, что он является последовательностью, потому что ведет себя, как последовательность, а только это и важно.

Такой подход получил название «динамическая типизация»², и именно о нем идет речь в высказывании Алекса Мартелли, взятом в качестве эпиграфа к этой главе.

Поскольку протокол — неформальное понятие, которое не подкреплено средствами языка, мы зачастую можем реализовать лишь часть протокола, если точно знаем, в каком контексте будет использоваться класс. Например, для поддержки итерирования нужен только метод __getitem__, а без метода __len__ можно обойтись.

Далее мы реализуем протокол последовательности в классе Vector, поначалу без надлежащей поддержки операции среза, но позже добавим и ее.

Vector, попытка № 2: последовательность, допускающая срезку

В примере класса FrenchDeck мы видели, что поддержать протокол последовательности очень просто, если можно делегировать работу атрибуту объекта, который

² В оригинале используется термин duck typing (буквально «утиная типизация»), распространенный в переводной литературе, но, на мой взгляд, по-русски он звучит не слишком удачно. — Прим. перев.