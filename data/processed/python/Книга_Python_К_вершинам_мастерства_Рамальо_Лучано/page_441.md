---
source_image: page_441.png
page_number: 441
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 45.96
tokens: 11967
characters: 2663
timestamp: 2025-12-24T01:55:20.413220
finish_reason: stop
---

Класс Sentence, попытка № 4: ленивая реализация

8 Предложение yield 'A' в теле генераторной функции порождает значение а, потребляемое в цикле for, где оно присваивается переменной с и распечатывается в виде --> А.
9 Итерирование продолжается благодаря второму вызову next (g), продвигающему выполнение генераторной функции от yield 'A' к yield 'B'. Выводится строка continue — результат второго обращения к print в теле генераторной функции.
10 Предложение yield 'B' порождает значение b, потребляемое в цикле for, где оно присваивается переменной с и распечатывается в виде --> b.
11 Итерирование продолжается благодаря третьему вызову next (g), продвигающему выполнение в конец генераторной функции. Выводится строка end — результат третьего обращения к print в теле генераторной функции.
12 Когда генераторная функция доходит до конца, объект-генератор возбуждает исключение StopIteration. Цикл for перехватывает это исключение и нормально завершается.

Надеюсь, теперь понятно, как работает метод Sentence.__iter__ в примере 14.5: __iter__ — генераторная функция, которая конструирует объект-генератор, реализующий интерфейс итератора, поэтому класс SentenceIterator больше не нужен.

Вторая версия Sentence получилась гораздо короче первой, но и она не такая ленивая, какой могла бы быть. В наши дни лень считается хорошим свойством, по крайней мере, в языках программирования и API. Ленивая реализация откладывает порождение значений до последней возможности. Это экономит память и иногда позволяет избежать бесполезной работы.

Далее мы напишем ленивый класс Sentence.

Класс Sentence, попытка № 4: ленивая реализация

Интерфейс Iterator спроектирован ленивым: вызов next(my_iterator) порождает по одному элементу за раз. Противоположностью ленивому вычислению является энергичное (eager) — оба термина применяются в теории языков программирования.

До сих пор наши реализации Sentence не были ленивыми, потому что __init__ энергично строит список всех слов в тексте и связывает его с атрибутом self.words. Это влечет за собой обработку всего текста, а список может занять столько же памяти, сколько сам текст (возможно, больше — это зависит от того, сколько в тексте символов, не считающихся частью слова). И большая часть этой работы будет проделана напрасно, если пользователю нужны только первые два слова.

Всякий раз как при работе с Python 3 возникает вопрос «Существует ли ленивый способ сделать это?», ответ будет «да».

Функция re.finditer — ленивая версия re.findall, вместо списка она возвращает генератор, порождающий объекты re.MatchObject по запросу. Если соответствий много, то re.finditer заметно экономит память. С ее помощью мы напишем