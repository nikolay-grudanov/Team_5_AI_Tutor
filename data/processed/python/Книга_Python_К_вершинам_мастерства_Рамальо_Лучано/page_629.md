---
source_image: page_629.png
page_number: 629
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 51.97
tokens: 11803
characters: 2069
timestamp: 2025-12-24T02:04:03.339770
finish_reason: stop
---

Использование свойств для контроля атрибутов

return self.weight * self.price

@property
def weight(self):
    return self.__weight

@weight.setter
def weight(self, value):
    if value > 0:
        self.__weight = value
    else:
        raise ValueError('value must be > 0')

1 Здесь уже используется метод установки свойства, который гарантирует, что не может быть создан экземпляр с отрицательным значением weight.
2 Декоратором @property обозначается метод чтения свойства.
3 Имена всех методов, реализующих свойство, совпадают с именем открытого атрибута: weight.
4 Фактическое значение хранится в закрытом атрибуте __weight.
5 У декорированного метода чтения свойства имеется атрибут .setter, который является также и декоратором; тем самым методы чтения и установки связываются между собой.
6 Если значение больше нуля, присваиваем его закрытому атрибуту __weight.
7 В противном случае возбуждаем исключение ValueError.

Теперь объект LineItem с недопустимым весом создать невозможно:

>>> walnuts = LineItem('walnuts', 0, 10.00)
Traceback (most recent call last):
...
ValueError: value must be > 0

Итак, мы защитили атрибут weight от присваивания отрицательных значений пользователем. Но хотя покупатели обычно не вправе устанавливать цену товара, в результате ошибки служащего или программы все же может быть создан объект LineItem с отрицательной ценой price. Чтобы предотвратить и это, мы могли бы преобразовать price в свойство, но это повлекло бы за собой частичное повторение кода.

Напомним слова Пола Грэхема, приведенные в главе 14: «Видя в своих программах повторяющиеся структуры, я расцениваю их как знак беды». Лекарство от повторения — абстрагирование. Существует два способа абстрагировать определения свойств: фабрика свойств и дескрипторный класс. Подход на основе дескрипторного класса обладает большей гибкостью, мы посвятим ему всю главу 20. На самом деле, сами свойства реализованы как дескрипторные классы. А пока продолжим наше исследование и реализуем фабрику свойств в виде функции.

Но прежде необходимо лучше понять природу свойств.