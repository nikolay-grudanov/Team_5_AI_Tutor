---
source_image: page_033.png
page_number: 33
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 68.47
tokens: 11983
characters: 2365
timestamp: 2025-12-24T01:36:34.790196
finish_reason: stop
---

Почему len — не метод

<table>
  <tr>
    <th>Категория</th>
    <th>Имена методов</th>
  </tr>
  <tr>
    <td>Арифметические операторы присваивания</td>
    <td>_iadd_, _isub_, _imul_, _itruediv_, _ifloordiv_, _imod_, _ipow_</td>
  </tr>
  <tr>
    <td>Поразрядные операторы</td>
    <td>_invert_ ~, _lshift_ <<, _rshift_ >>, _and_ &, _or_ |, _xor_ ^</td>
  </tr>
  <tr>
    <td>Инверсные поразрядные операторы</td>
    <td>_rlshift_, _rrshift_, _rand_, _rxor_, _ror_</td>
  </tr>
  <tr>
    <td>Поразрядные операторы составного присваивания</td>
    <td>_ilshift_, _irshift_, _iand_, _ixor_, _ior_</td>
  </tr>
</table>

Инверсные операторы применяются в случае, когда операнды переставлены местами (b * a вместо a * b), а операторы составного присваивания позволяют комбинировать инфиксный оператор с присваиванием переменной (a *= b вместо a = a * b). В главе 13 инверсные операторы и составное присваивание рассматриваются подробнее.

Почему len — не метод

Я задавал этот вопрос разработчику ядра Раймонду Хэттингеру (Raymond Hettinger) в 2013 году, смысл его ответа содержится в цитате из «Дзен Python» (https://www.python.org/doc/humor/#thezen-of-python): «практичность важнее чистоты». В разделе «Как используются специальные методы» выше я писал, что функция len(x) работает очень быстро, если x — объект встроенного типа. Для встроенных объектов интерпретатор CPython вообще не вызывает методы, а просто читает значение, хранящееся в поле С-структуры. Получение количества элементов в коллекции — распространенная операция, которая должна работать эффективно для таких разных типов, как str, list, memoryview и т. п.

Иначе говоря, len не вызывается как метод, потому что играет особую роль в модели данных Python, равно как и abs. Но благодаря специальному методу __len__ можно вызывать функцию len и для пользовательских объектов. Это разумный компромисс между желанием обеспечить как эффективность встроенных объектов, так и согласованность языка. Вот еще цитата из «Дзен Python»: «особые случаи не настолько особые, чтобы из-за них нарушать правила».

Если рассматривать abs и len как унарные операторы, то, возможно, вы простите их сходство с функциями, а не с вызовами метода, чего следовало бы ожидать от ОО-языка. На самом деле, в языке АВС — непосредственном предшественнике Python, в котором впервые были реализованы многие его средства — суще-