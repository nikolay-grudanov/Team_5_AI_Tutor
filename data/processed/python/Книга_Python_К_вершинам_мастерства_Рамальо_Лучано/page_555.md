---
source_image: page_555.png
page_number: 555
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 50.81
tokens: 11975
characters: 2761
timestamp: 2025-12-24T02:00:45.673941
finish_reason: stop
---

Резюме

Альтернативы: многопоточная и многопроцессная обработка

Потоки поддерживались в Python с самой первой публичной версии 0.9.8 (1993); пакет concurrent.futures — всего лишь самый последний способ их использования. В Python 3 первоначальный модуль thread объявлен нерекомендуемым, предпочтение отдается модулю threading более высокого уровня (https://docs.python.org/3/library/threading.html)7. Если класс futures.ThreadPoolExecutor не обладает достаточной гибкостью для некоторой задачи, то можно реализовать собственное решение на основе таких примитивных компонентов из модуля threading, как Thread, Lock, Semaphore и т. д. — быть может, воспользовавшись также потокобезопасными очередями из модуля queue (https://docs.python.org/3/library/queue.html) для передачи данных между потоками. В классе futures.ThreadPoolExecutor все эти детали инкапсулированы.

Для счетных задач приходится обходить GIL посредством запуска нескольких процессов. Класс futures.ProcessPoolExecutor — простейший способ это сделать. Но если перед вами стоит особо сложная задача, то можно воспользоваться и более тонкими инструментами. Пакет multiprocessing (https://docs.python.org/3/library/multiprocessing.html) имитирует API модуля threading, но делегирует работу не потокам, а процессам. В простых программах для замены threading на multiprocessing достаточно нескольких изменений. Но multiprocessing предлагает также средства для решения самой серьезной проблемы, возникающей при организации взаимодействующих процессов: как передавать данные между ними.

Резюме

В начале этой главы мы сравнили два параллельных HTTP-клиента с последовательным и убедились в том, что распараллеливание дает значительный выигрыш в производительности.

Изучив первый пример, основанный на пакете concurrent.futures, мы решили поближе познакомиться с будущими объектами — экземплярами класса concurrent.futures.Future или asyncio.Future — уделив особое внимание общим чертам этих классов (различия между ними будут рассмотрены в главе 18). Мы видели, как создавать будущие объекты методом Executor.submit(...) и как обходить завершенные объекты с помощью функции concurrent.futures.as_completed(...).

Далее мы видели, почему потоки Python хорошо подходят для приложений с большим объемом ввода-вывода, несмотря на наличие GIL: все стандартные библиотечные функции ввода-вывода, написанные на C, освобождают GIL, поэтому пока один поток ждет завершения ввода-вывода, планировщик может

7 Модуль threading включен в Python, начиная с версии 1.5.1 (1998), и все же некоторые продолжают настаивать на использовании старого модуля. В Python 3 он был переименован в _thread, чтобы подчеркнуть, что это всего лишь низкоуровневая деталь реализации, и использовать его в прикладном коде не следует.