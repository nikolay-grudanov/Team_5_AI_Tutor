---
source_image: page_470.png
page_number: 470
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 46.11
tokens: 11876
characters: 2324
timestamp: 2025-12-24T01:56:43.162451
finish_reason: stop
---

>>> from collections import abc
>>> e = enumerate('ABC')
>>> isinstance(e, abc.Iterator)
True

Второй — с точки зрения реализации. Генератор в Python — это языковая конструкция, которую можно закодировать двумя способами: как функцию с ключевым словом yield или как генераторное выражение. Объекты-генераторы, получающиеся в результате вызова генераторной функции или вычисления генераторного выражения, — это экземпляры внутреннего типа GeneratorType (http://bit.ly/1MM6Sbm). С этой точки зрения, любой генератор также является итератором, потому что экземпляры GeneratorType реализуют интерфейс итератора. Но можно написать итератор, не являющийся генератором, — реализовав классический паттерн Итератор, как в примере 14.4, или запрограммировав расширение на C. В этом смысле объекты enumerate не являются генераторами:

>>> import types
>>> e = enumerate('ABC')
>>> isinstance(e, types.GeneratorType)
False

Так происходит, потому что тип types.GeneratorType (https://docs.python.org/3/library/types.html#types.GeneratorType) определен следующим образом: «Тип объектов генераторов-итераторов, порождаемых вызовом генераторной функции».

Третья точка зрения — концептуальная. В классическом паттерне проектирования, определенном в книге «банды четырех», итератор обходит коллекцию и отдает ее элементы. Итератор может быть устроен достаточно сложно, например, обходить древовидную структуру. Но сколь бы сложна ни была логика классического итератора, он всегда читает значения из существующего источника данных, и ожидается, что при вызове next(it) итератор не станет изменять полученный из источника элемент, а просто отдаст его.

Напротив, генератор может порождать значения, не обходя коллекцию, как делает, например, функция range. И даже если генератор связан с коллекцией, он не обязан отдавать только присутствующие в ней значения, а может модифицировать их. Пример такого генератора дает функция enumerate. С точки зрения классического паттерна проектирования, генератор, возвращенный enumerate, не является итератором, потому что создает отдаваемые кортежи на лету.

На этом концептуальном уровне способ реализации не имеет значения. Можно написать генератор, вообще не используя объекты-генераторы Python. В примере 14.26 представлен генератор чисел Фибоначчи, написанный мной для иллюстрации этой точки зрения: