---
source_image: page_226.png
page_number: 226
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 57.87
tokens: 11927
characters: 2097
timestamp: 2025-12-24T01:45:24.740979
finish_reason: stop
---

return n
return fibonacci(n-2) + fibonacci(n-1)

if __name__ == '__main__':
    print(fibonacci(6))

1 Отметим, что lru_cache следует вызывать как обычную функцию — обратите внимание на скобки: @functools.lru_cache(). Причина в том, что этот декоратор принимает конфигурационные параметры, как будет показано ниже.
2 Это пример композиции декораторов: lru_cache() применяется к функции, возвращенной декоратором @clock.

Время выполнения уменьшилось вдвое, а функция вызывается всего один раз для каждого значения n:

$ python3 fibo_demo_lru.py
[0.00000119s] fibonacci(0) -> 0
[0.00000119s] fibonacci(1) -> 1
[0.00010800s] fibonacci(2) -> 1
[0.00000787s] fibonacci(3) -> 2
[0.00016093s] fibonacci(4) -> 3
[0.00001216s] fibonacci(5) -> 5
[0.00025296s] fibonacci(6) -> 8

В другом тесте для вычисления fibonacci(30) программа из примера 7.19 выполнила 31 вызов за 0,0005 с, тогда как программа без кэширования из примера 7.18 обращалась к функции fibonacci 2 692 537 и затратила на это 17,7 с на ноутбуке с процессором Intel Core i7.

Но lru_cache умеет не только исправлять плохо написанные рекурсивные алгоритмы, во всем блеске он проявляется, когда нужно прочитать данные из веба.

Важно отметить, что lru_cache можно настроить, передав два необязательных аргумента. Полная сигнатура выглядит так:

functools.lru_cache(maxsize=128, typed=False)

Аргумент maxsize определяет, сколько результатов вызова хранить. Когда кэш заполнится, старые результаты начнут вытесняться, чтобы освободить место для новых. Для достижения оптимальной производительности значение maxsize должно быть степенью двойки. Если аргумент typed равен True, то результаты для аргументов разных типов хранятся порознь, т. е. аргументы типа float и integer, которые обычно считаются равными, например, 1 и 1.0, теперь становятся различными. Кстати, lru_cache хранит результаты в словаре dict, ключи которого составлены из позиционных и именованных аргументов вызовов, а это значит, что все аргументы, принимаемые декорируемой функцией, должны быть хэшируемыми.

Теперь рассмотрим интригующий декоратор functools.singledispatch.