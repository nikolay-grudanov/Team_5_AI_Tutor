---
source_image: page_377.png
page_number: 377
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 47.34
tokens: 11936
characters: 2297
timestamp: 2025-12-24T01:52:08.312064
finish_reason: stop
---

Сложности наследования встроенным типам

```python
>>> class DoppelDict2(collections.UserDict):
...     def __setitem__(self, key, value):
...         super().__setitem__(key, [value] * 2)
...
>>> dd = DoppelDict2(one=1)
>>> dd
{'one': [1, 1]}
>>> dd['two'] = 2
>>> dd
{'two': [2, 2], 'one': [1, 1]}
>>> dd.update(three=3)
>>> dd
{'two': [2, 2], 'three': [3, 3], 'one': [1, 1]}
>>> 
>>> class AnswerDict2(collections.UserDict):
...     def __getitem__(self, key):
...         return 42
...
>>> ad = AnswerDict2(a='foo')
>>> ad['a']
42
>>> d = {}
>>> d.update(ad)
>>> d['a']
42
>>> d
{'a': 42}
```

Для оценки дополнительных усилий на создание подкласса встроенного типа я переписал класс StrKeyDict из примера 3.8. Первоначальная версия наследовала классу collections.UserDict и реализовывала всего три метода: __missing__, __contains__ и __setitem__. Экспериментальная версия StrKeyDict наследует dict непосредственно и реализует те же три метода с косметическими изменениями, вызванными способом хранения данных. Но чтобы проходили те же тесты, что и раньше, мне пришлось реализовать методы __init__, get и update, потому что их версии, унаследованные от dict, отказывались признавать переопределенные методы __missing__, __contains__ и __setitem__. В подклассе UserDict из примера 3.8 было 16 строк, а в экспериментальном подклассе dict — целых 37 строк².

Подведем итоги: описанная в этом разделе проблема относится только к делегированию методов встроенных типов, написанных на языке C, и только к пользовательским подклассам этих типов. Если наследовать классу, написанному на Python, например UserDict или MutableMapping, то эта проблема не возникает³.

Еще один вопрос, связанный с наследованием и, в особенности, с множественным наследованием, таков: как Python решает, какой атрибут использовать, если в суперклассах из параллельных ветвей графа наследования определены одноименные атрибуты? Ответ приводится ниже.

² Для любознательных читателей — экспериментальная версия находится в файле strkeydict_dictsub.py в репозитории кода к этой книге по адресу https://github.com/fluentpython/example-code.
³ Кстати говоря, в этом отношении PyPy ведет себя «корректнее», чем CPython, но ценой незначительной нсовместимости. См. раздел «Различия между PyPy и CPython» (http://bit.ly/1JHINmhX).