---
source_image: page_219.png
page_number: 219
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 39.99
tokens: 11704
characters: 1596
timestamp: 2025-12-24T01:44:50.157508
finish_reason: stop
---

Объявление nonlocal

из них есть атрибут cell_contents, где можно найти само значение. Эти атрибуты демонстрируются в примере 7.12.

![Замыкание averager расширяет область видимости функции, включая в нее привязку свободной переменной series](../images/225.png)

Рис. 7.1. Замыкание averager расширяет область видимости функции, включая в нее привязку свободной переменной series

Пример 7.12. Продолжение примера 7.10

```python
>>> avg.__code__.co_freevars
('series',)
>>> avg.__closure__
(<cell at 0x107a44f78: list object at 0x107a91a48>,)
>>> avg.__closure__[0].cell_contents
[10, 11, 12]
```

Резюмируем: замыкание — это функция, которая запоминает привязки свободных переменных, существовавшие на момент определения функции, так что их можно использовать впоследствии при вызове функции, когда область видимости, в которой она была определена, уже не существует.

Отметим, что единственная ситуация, когда функции может понадобиться доступ к внешним неглобальным переменным, — это когда она вложена в другую функцию.

Объявление nonlocal

Приведенная выше реализация функции make_averager неэффективна. В примере 7.9 мы храним все значения во временном ряде и вычисляем их сумму при каждом вызове averager. Лучше было бы хранить предыдущую сумму и количество элементов, тогда, зная эти два числа, можно вычислить новое среднее.

Реализация в примере 7.13 некорректна и приведена только в педагогических целях. Сможете ли вы найти ошибку?

Пример 7.13. Неправильная функция высшего порядка для вычисления накопительного среднего без хранения всей истории

def make_averager():
    count = 0