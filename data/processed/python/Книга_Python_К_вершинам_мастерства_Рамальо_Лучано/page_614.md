---
source_image: page_614.png
page_number: 614
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 39.67
tokens: 11800
characters: 2169
timestamp: 2025-12-24T02:03:11.229620
finish_reason: stop
---

2 Метод __getattr__ вызывается, только когда не существует атрибута с таким именем.
3 Если имени name соответствует какой-то атрибут экземпляра __data, возвращаем его. Так обрабатываются вызовы методов словаря, например keys.
4 В противном случае получаем элемент с ключом name из self.__data и возвращаем результат вызова для него метода FrozenJSON.build().5
5 Это альтернативный конструктор, типичное применение декоратора @classmethod.
6 Если obj — отображение, строим по нему объект FrozenJSON.
7 Если это экземпляр MutableSequence, то он должен быть списком6, поэтому строим список, рекурсивно передавая каждый элемент obj методу .build().
8 Если это не dict и не list, возвращаем элемент без изменения.

Отметим, что исходный набор данных не кэшируется и не трансформируется. При его обходе вложенные структуры данных всякий раз преобразуются заново в тип FrozenJSON. Но при таком размере набора это приемлемо, да и наш скрипт предназначен только для исследования и преобразования данных.

Любой скрипт, который генерирует или эмулирует динамические атрибуты с именами, полученными из произвольного источника, должен помнить об одной проблеме: ключи, хранящиеся в исходных данных, могут не удовлетворять правилам образования имен атрибутов. В следующем разделе мы займемся этой проблемой.

Проблема недопустимого имени атрибута

У класса FrozenJSON есть ограничение: в нем не предусмотрена специальная обработка имен атрибутов, являющихся ключевыми словами Python. Например, построив объект вида:

>>> grad = FrozenJSON({'name': 'Jim Bo', 'class': 1982})

мы не сможем прочитать атрибут grad.class, т. к. class — зарезервированное слово в Python:

>>> grad.class
File "<stdin>", line 1
grad.class
^
SyntaxError: invalid syntax

Конечно, можно сделать так:

5 Именно в этой строке может возникнуть исключение KeyError: в выражении self.__data[name]. Его следует обработать и подменить исключением AttributeError, поскольку такого исключения вызывающая программа ожидает от __getattr__. Прилежному читателю предлагается написать этот код в качестве упражнения.
6 Источником данных является объект типа JSON, а он поддерживает только два типа коллекций: dict и list.