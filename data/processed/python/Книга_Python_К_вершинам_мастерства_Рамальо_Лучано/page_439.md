---
source_image: page_439.png
page_number: 439
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 36.39
tokens: 11788
characters: 1789
timestamp: 2025-12-24T01:55:06.109229
finish_reason: stop
---

Класс Sentence, попытка № 3: генераторная функция

<function gen_123 at 0x...> # ③
>>> gen_123() # doctest: +ELLIPSIS
<generator object gen_123 at 0x...> # ④
>>> for i in gen_123(): # ⑤
...    print(i)
1
2
3
>>> g = gen_123() # ⑥
>>> next(g) # ⑦
1
>>> next(g)
2
>>> next(g)
3
>>> next(g) # ⑧
Traceback (most recent call last):
...
StopIteration

① Любая функция Python, содержащая ключевое слово yield, является генераторной.
② Обычно в теле функции есть цикл, но это необязательно; здесь я просто трижды повторил слово yield.
③ Приглядевшись, мы увидим, что gen_123 — объект-функция.
④ Но при вызове gen_123() возвращает объект-генератор.
⑤ Генератор — это итератор, который порождает значения выражений, переданных yield.
⑥ Для более пристальной инспекции присваиваем объект-генератор переменной g.
⑦ Поскольку g — итератор, вызов next(g) возвращает следующий элемент, порожденный yield.
⑧ Когда выполнение доходит до конца функции, объект-генератор возбуждает исключение StopIteration.

Генераторная функция строит объект-генератор, оберывающий тело функции. При передаче объекта-генератора функции next(...) выполнение продолжается до следующего предложения yield в теле функции, а вызов next(...) возвращает значение, порожденное перед приостановкой выполнения функции. Наконец, при возврате из функции оберывающий ее объект-генератор возбуждает исключение StopIteration в полном соответствии с протоколом Iterator.

Я считаю, что в терминологии, касающейся получения результатов от генератора, лучше соблюдать строгость: я говорю, что генератор отдает (yields) или порождает (produces) значения. Фраза же «генератор возвращает значения» вносит путаницу. Значения возвращают функции. Вызов генераторной функции возвращает генератор. Генератор отдает, или порождает значения. Генератор