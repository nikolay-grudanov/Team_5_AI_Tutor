---
source_image: page_567.png
page_number: 567
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 41.61
tokens: 11790
characters: 2123
timestamp: 2025-12-24T02:01:03.901716
finish_reason: stop
---

Сравнение потока и сопрограммы

10 Управляем функцией slow_function(). Когда она завершится, мы получим возвращенное значение. А тем временем цикл обработки событий продолжает работать, потому что slow_function() уступила управление главному циклу, выполнив yield from asyncio.sleep(3).

11 Объект Task можно отменить, при этом возбуждается исключение asyncio.CancelledError в том выражении yield, на котором сопрограмма приостановилась. Сопрограмма может перехватить это исключение и отложить отмену или даже вовсе отказаться от нее.

12 Получаем ссылку на цикл обработки событий.

13 Управляем сопрограммой supervisor, пока она не завершится. Значение, возвращенное сопрограммой, будет получено здесь.

Никогда не используйте time.sleep(...) в сопрограммах asyncio, если не хотите заблокировать главный поток, а, значит, также цикл обработки событий и, скорее всего, приложение в целом. Если сопрограмма хочет провести некоторое время, бездельничая, то должна уступить управление с помощью yield from asyncio.sleep(DELAY).

Использовать декоратор @asyncio.coroutine необязательно, но настоятельно рекомендуется: он визуально отличает сопрограммы от обычных функций и помогает отлаживаться, поскольку печатает предупреждение, если сопрограмма станет жертвой сборщика мусора до возобновления посредством yield from, — это означает, что какая-то операция осталась незавершенной и, вероятнее всего, свидетельствует об ошибке. Этот декоратор не инициализирующий.

Количество строк в скриптах spinner_thread.py и spinner_asyncio.py почти одинаково. Главным элементом обоих примеров является функция supervisor. Проведем их детальное сравнение. В примере 18.3 показана функция supervisor из примера на основе модуля threading.

Пример 18.3. spinner_thread.py: функция supervisor с отдельным потоком

def supervisor():
    signal = Signal()
    spinner = threading.Thread(target=spin,
        args=('thinking!', signal))
    print('spinner object:', spinner)
    spinner.start()
    result = slow_function()
    signal.go = False
    spinner.join()
    return result

Для сравнения в примере 18.4 показана сопрограмма supervisor.