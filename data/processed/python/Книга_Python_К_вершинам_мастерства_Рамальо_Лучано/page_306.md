---
source_image: page_306.png
page_number: 306
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 41.64
tokens: 11788
characters: 1686
timestamp: 2025-12-24T01:48:44.944934
finish_reason: stop
---

Глава 10. Рубим, перемешиваем и нарезаем последовательности

>>> s[1] # ①
1
>>> s[1:4] # ②
slice(1, 4, None)
>>> s[1:4:2] # ③
slice(1, 4, 2)
>>> s[1:4:2, 9] # ④
(slice(1, 4, 2), 9)
>>> s[1:4:2, 7:9] # ⑤
(slice(1, 4, 2), slice(7, 9, None))

① Здесь __getitem__ просто возвращает то, что ему передали.
② Один индекс, ничего нового.
③ Нотация 1:4 преобразуется в slice(1, 4, None).
④ slice(1, 4, 2) означает: начать с 1, закончить на 4, шаг 2.
⑤ Сюрприз: при наличии запятых внутри [] метод __getitem__ получает кортеж.
⑥ Этот кортеж может даже содержать несколько объектов среза.

Теперь приглядимся внимательнее к самому классу slice.

Пример 10.5. Инспекция атрибутов класса slice

>>> slice # ①
<class 'slice'>
>>> dir(slice) # ②
['__class__', '__delattr__', '__dir__', '__doc__', '__eq__',
 '__format__', '__ge__', '__getattribute__', '__gt__',
 '__hash__', '__init__', '__le__', '__lt__', '__ne__',
 '__new__', '__reduce__', '__reduce_ex__', '__repr__',
 '__setattr__', '__sizeof__', '__str__', '__subclasshook__',
 'indices', 'start', 'step', 'stop']

① slice — встроенный тип (мы это уже поняли в разделе «Объекты среза» главы 2).
② Инспекция slice показывает наличие атрибутов start, stop и step, а также метода indices.

В примере 10.5 вызов dir(slice) показывает наличие метода indices — весьма интересного, хотя и малоизвестного. Вот что говорит о нем справка — help(slice.indices):

S.indices(len) -> (start, stop, stride)

В предположении, что длина последовательности равна len, вычисляет индексы start и stop, а также длину stride расширенного среза, представленного объектом S. Индексы, выходящие за границы, приводятся к границам так же, как при обработке обычных срезов.