---
source_image: page_502.png
page_number: 502
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 55.19
tokens: 11904
characters: 2510
timestamp: 2025-12-24T01:58:21.541572
finish_reason: stop
---

... result = exc.value
...
>>> result
Result(count=3, average=15.5)

Этот обходной способ получения возвращенного сопрограммой значения покажется более осмысленным, если принять во внимание, что он определен в документе PEP 380, а конструкция yield from делает все автоматически, перехватывая StopIteration внутри себя. Тут есть аналогия с использованием StopIteration в циклах for: исключение обрабатывается внутренним механизмом цикла, так что пользователь о нем ничего не знает. В случае yield from интерпретатор не только «глотает» StopIteration, но и отдает значение атрибута value в виде значения самого выражения yield from. К сожалению, мы не можем протестировать это в оболочке, потому что использование yield from — да и просто yield — вне функции является синтаксической ошибкой4.

В следующем разделе приведен пример использования yield from для возврата значения из сопрограммы averager — как предполагалось в документе PEP 380.

Использование yield from

Прежде всего, нужно ясно понимать, что yield from — совершенно новая языковая конструкция. Она умеет настолько больше yield, что использование одного и того же ключевого слова только вводит в заблуждение. Аналогичные конструкции в других языках называются await, и это куда более подходящее имя, потому что передает важнейшую мысль: когда генератор gen вызывает yield from subgen(), subgen перехватывает управление и начинает отдавать значения непосредственно функции, из которой был вызван gen, т. е. вызывающая сторона напрямую управляет subgen. А тем временем gen остается блокированным в ожидании завершения subgen5.

В главе 14 мы видели, что yield from можно использовать вместо yield в цикле for. Например, фрагмент:

>>> def gen():
    ... for c in 'AB':
    ...     yield c
    ... for i in range(1, 3):
    ...     yield i
...
>>> list(gen())
['A', 'B', 1, 2]

4 Существует расширение iPython — ipython-yf (https://github.com/tecki/ipython-yf) — которое позволяет вычислять yield прямо в оболочке iPython. Оно используется для тестирования асинхронного кода и работает совместно с asyncio. Это расширение предлагалось для включения в версию Python 3.5, но не было принято. См. проблему #22412 «Towards an asyncio-enabled command line» (http://bugs.python.org/issue22412) в системе отслеживания ошибок в Python.
5 На момент написания этих строк существует открытый документ, в котором предлагается добавить ключевые слова await и async: «PEP 492 — Coroutines with async and await syntax» (https://www.python.org/dev/peps/pep-0492/).