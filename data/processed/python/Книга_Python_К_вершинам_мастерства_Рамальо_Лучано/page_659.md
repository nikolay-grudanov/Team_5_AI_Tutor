---
source_image: page_659.png
page_number: 659
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 46.48
tokens: 11748
characters: 1770
timestamp: 2025-12-24T02:05:25.413580
finish_reason: stop
---

Пример дескриптора: проверка значений атрибутов

свойств не зависит от странных связей между объектами, которые проявляются в именах аргументов дескриптора: self и instance.
Короче говоря, паттерн фабрики свойств в некоторых отношениях проще, но дескрипторный класс лучше обобщается. И используется последний подход шире.

LineItem попытка № 5: новый тип дескриптора

Воображаемый магазин натуральных пищевых продуктов столкнулся с неожиданной проблемой: каким-то образом была создана строка заказа с пустым описанием, и теперь заказ невозможно выполнить. Чтобы предотвратить такие инциденты в будущем, мы создадим новый дескриптор, NonBlank. Проектируя NonBlank, мы обнаруживаем, что он очень похож на дескриптор Quantity, а отличается только логика проверки.

Присмотревшись к функциональности Quantity, мы замечаем, что этот класс делает две разные вещи: отвечает за работу с атрибутами хранения в управляемых экземплярах и проверяет значения, записываемые в эти атрибуты. Это наводит на мысль о рефакторинге и заведении двух базовых классов:

AutoStorage
Дескрипторный класс, который автоматически управляет атрибутами хранения.

Validated
Абстрактный подкласс AutoStorage, который переопределяет метод __set__, вызывая метод validate, который должен быть реализован в подклассах.

Затем мы переписываем Quantity и реализуем NonBlank, наследуя классу Validated, так что остается лишь написать методы validate. Описанная схема изображена на рис. 20.5.

![Иерархия дескрипторных классов](https://i.imgur.com/3Q5z5QG.png)

Рис. 20.5. Иерархия дескрипторных классов. Базовый класс AutoStorage автоматически управляет атрибутами хранения, а Validated производит проверку, делегируя работу абстрактному методу validate. Quantity и NonBlank — конкретные подклассы Validated