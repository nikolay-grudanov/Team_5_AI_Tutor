---
source_image: page_392.png
page_number: 392
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 46.36
tokens: 12024
characters: 2873
timestamp: 2025-12-24T01:52:54.787874
finish_reason: stop
---

ность классов View и MultipleObjectMixin, но без накладных расходов, обусловленных механизмом шаблонов.

Основанный на классах API представлений в Django — пример более правильного, чем в Tkinter использования множественного наследования. В частности, разобраться в классах-примесях здесь очень просто: у каждого свое четко определенное назначение и имя, оканчивающееся суффиксом mixin.

Основанные на классах представления не все пользователи Django приняли на ура. Многие пользуются ими как черными ящиками, но если необходимо создать что-то новое, то по-прежнему пишут монолитные функции, которые берут на себя все обязанности, — вместо того чтобы попытаться повторно использовать классы представлений и примеси.

Чтобы в полной мере понять, как использовать представления, основанные на классах, и как расширять их для решения задач конкретного приложения, нужно время, но я пришел к выводу, что это время будет потрачено не зря: они позволяют устранить стереотипный код, упрощают повторное использование и даже улучшают взаимодействие между членами команды — например, за счет стандартизации имен шаблонов и переменных, передаваемых к контекст шаблона. Представления, основанные на классах, — это представления «on rails» — как в Ruby.

На этом мы завершаем обзор множественного наследования и классов-примесей.

Резюме

Мы начали рассказ о наследовании описанием проблемы наследования встроенными типами: их методы, реализованные на C, не вызывают методы, переопределеные в подклассах, за исключением немногих частных случаев. Именно поэтому в тех случаях, когда нам нужен специальный список, словарь или строка, проще наследовать не классам list, dict или str, а классам UserList, UserDict или UserString — все они определены в модуле collections (https://docs.python.org/3/library/collections.html) и фактически обертывают встроенные типы, делегируя им работу, — это три примера использования композиции вместо наследования в стандартной библиотеке. Если требуемое поведение очень сильно отличается от поведения встроенных классов, то, быть может, проще унаследовать подходящему ABC из модуля collections.abc (https://docs.python.org/3/library/collections.abc.html) и написать собственную реализацию.

Остаток главы был посвящен обоюдоострому мечу множественного наследования. Сначала мы познакомились с порядком разрешения методов, который закодирован в атрибуте классе __mro__ и решает проблему потенциального конфликта имен в унаследованных методах. Мы также видели, как встроенная функция super() консультируется с __mro__ при вызове метода суперкласса. Затем мы изучили, как множественное наследование используется в пакете ГИП Tkinter, который входит в состав стандартной библиотеки Python. Tkinter нельзя назвать образцом хорошего проектирования, если судить с позиций сегодняшнего дня, поэтому мы обсудили несколько способов применения множественного насле-