---
source_image: page_316.png
page_number: 316
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 42.43
tokens: 11851
characters: 2141
timestamp: 2025-12-24T01:49:09.691888
finish_reason: stop
---

На шаге отображения (map) порождается один хэш для каждого компонента, а на шаге редукции (reduce) все хэши агрегируются с помощью оператора xor. Если использовать функцию map вместо генераторного выражения, то шаг отображения станет даже более наглядным:

def __hash__(self):
    hashes = map(hash, self._components)
    return functools.reduce(operator.xor, hashes)

Решение на основе map не так эффективно в Python 2, где функция map строит список, содержащий результаты. Однако в Python 3 map откладывает вычисления: она порождает генератор, который отдает результаты по требованию, экономя тем самым память, — точно так же, как генераторное выражение в методе __hash__ из примера 10.8.

Раз уж мы заговорили о редуцирующих функциях, то почему бы не заменить нашу написанную на скорую руку реализацию оператора __eq__ другой, которая и работать будет быстрее, и памяти потреблять меньше, по крайней мере, для больших векторов. В примере 9.2 приведена такая лаконичная реализация __eq__:

def __eq__(self, other):
    return tuple(self) == tuple(other)

Она работает для Vector2d и для Vector — и даже считает, что Vector([1, 2]) равен (1, 2); это может оказаться проблемой, но пока закроем на нее глаза5. Но для векторов с тысячами компонент эта реализация крайне неэффективна. Она строит два кортежа, полностью копируя оба операнда, только для того, чтобы воспользоваться оператором __eq__ из типа tuple. Такая экономия усилий вполне оправдана для класса Vector2d (всего с двумя компонентами), но не для многомерных векторов. Более эффективный способ сравнения объекта Vector с другим объектом Vector или с итерируемым объектом показан в примере 10.13.

Пример 10.13. Метод Vector.eq, в котором используется функция zip в цикле for для более эффективного сравнения

def __eq__(self, other):
    if len(self) != len(other): # ①
        return False
    for a, b in zip(self, other): # ②
        if a != b: # ③
            return False
    return True # ④

① Если длины объектов различны, то они не равны.

5 К вопросу о разумности равенства Vector([1, 2]) == (1, 2) мы серьезно подойдем в разделе «Основы перегрузки операторов» главы 13.