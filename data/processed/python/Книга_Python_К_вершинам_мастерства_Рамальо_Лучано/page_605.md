---
source_image: page_605.png
page_number: 605
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 49.18
tokens: 11935
characters: 2542
timestamp: 2025-12-24T02:02:59.963257
finish_reason: stop
---

Должен существовать один — и, желательно, только один — очевидный способ сделать это.
Хотя он поначалу может быть и не очевиден, если вы не голландец.
Наверное, для того чтобы счесть конструкцию yield from очевидной, действительно нужен голландский паспорт. Данному конкретному бразильцу она поначалу вовсе не показалось очевидной, но со временем я освоился.
Очень важно, что asyncio спроектирован так, чтобы встроенный цикл обработки событий можно было заменить внешним пакетом. Именно по этой причине существуют функции asyncio.get_event_loop и set_event_loop; они являются частью абстрактного API стратегии цикла обработки событий (http://bit.ly/1HGuUTy).
В Tornado уже имеется класс AsyncIOMainLoop (http://tornado.readthedocs.org/en/latest/asyncio.html), реализующий интерфейс asyncio.AbstractEventLoop, так что можно исполнять асинхронный код, применяя обе библиотеки в одном и том же цикле обработки событий. Существует также многообещающий проект Quamash (https://pypi.python.org/pypi/Quamash/), в котором asyncio интегрируется с циклом обработки событий Qt с целью разработки приложений с графическим интерфейсом на основе PyQt или PySide. И это только два из постоянно растущего множества интероперабельных событийно-ориентированных пакетов, появление которых стало возможно благодаря asyncio.
Интеллектуальные HTTP-клиенты, в частности одностраничные веб-приложения (типа Gmail), и приложения для смартфонов нуждаются в быстром получении коротких ответов и проталкивании обновлений. Для удовлетворения таких потребностей лучше подходят асинхронные каркасы, а не традиционные веб-каркасы типа Django, которые проектировались для возврата полностью отрисованных HTML-страниц и не поддерживают асинхронный доступ к базе данных.
Протокол WebSockets разрабатывался, чтобы можно было в реальном времени обновлять постоянно подключенные клиенты — от игр до потоковых приложений. Для этого необходимы серверы с высочайшей степенью параллелизма, способные поддерживать постоянное взаимодействие с сотнями и тысячами клиентов. WebSockets отлично поддерживается архитектурой на базе asyncio, и существуют по крайней мере две библиотеки такого рода, реализованные поверх asyncio: Autobahn|Python (http://autobahn.ws/python/) и WebSockets (http://aaugustin.github.io/websockets/).
Эта превалирующая тенденция, получившая название «веб реального времени», — основной фактор спроса на Node.js и причина, по которой консолидация вокруг asyncio так важна для экосистемы Python. Еще многое предстоит сделать. Прежде всего, нам нужны асинхронные кли-