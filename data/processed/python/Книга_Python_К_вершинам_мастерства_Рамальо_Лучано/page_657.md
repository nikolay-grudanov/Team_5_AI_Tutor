---
source_image: page_657.png
page_number: 657
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 43.65
tokens: 11732
characters: 1778
timestamp: 2025-12-24T02:05:15.953495
finish_reason: stop
---

Пример дескриптора: проверка значений атрибутов

С учетом этого пример 20.4 дает более точную картину типичного применения дескриптора.

Пример 20.4. bulkfood_v4c.py: ничем не загроможденное определение LineItem; дескрипторный класс Quantity теперь находится в импортируемом модуле model_v4c

import model_v4c as model ①

class LineItem:
    weight = model.Quantity() ②
    price = model.Quantity()

    def __init__(self, description, weight, price):
        self.description = description
        self.weight = weight
        self.price = price

    def subtotal(self):
        return self.weight * self.price

① Импортируем модуль model_v4c и попутно сопоставляем ему более симпатичное имя.
② Используем model.Quantity.

Пользователи Django, наверное, заметили, что пример 20.4 выглядит в точности как определение модели. И это не случайность: поля моделей Django являются дескрипторами.

Реализованный в настоящий момент дескриптор Quantity работает вполне прилично. Единственный его недостаток — использование сгенерированных имен атрибутов хранения (например, _Quantity#0), что затрудняет отладку. Однако для автоматического назначения атрибутам хранения имен, похожих на имена управляемых атрибутов, потребуется декоратор класса или метакласс, а эти темы мы отложим до главы 21.

Поскольку дескрипторы определяются в классах, мы можем воспользоваться наследованием, чтобы повторно использовать уже написанный код в новых дескрипторах. Этим мы и займемся в следующем разделе.

Фабрика свойств и дескрипторный класс

Нетрудно по-другому реализовать функциональность улучшенного дескрипторного класса из примера 20.2, добавив несколько строк в фабрику свойств, показанную в примере 19.24. Некоторую сложность представляет переменная __counter, но мы можем сохранять значение