---
source_image: page_420.png
page_number: 420
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 54.82
tokens: 12063
characters: 2985
timestamp: 2025-12-24T01:54:25.966914
finish_reason: stop
---

Глава 13. Перегрузка операторов: как правильно?

Потому что интерпретатор в качестве последнего средства сравнивает идентификаторы объектов.

Последний раздел был посвящен операторам составного присваивания. Мы видели, что Python по умолчанию рассматривает их как комбинацию обычного оператора и присваивания, то есть \( a += b \) вычисляется точно так же, как \( a = a + b \). При этом всегда создается новый объект, так что оператор одинаково хорошо работает для изменяемых и неизменяемых типов. Но для изменяемых типов мы можем реализовать специальные методы, вычисляемые на месте, например __iadd__ для оператора +=, и модифицировать значение левого операнда. Чтобы продемонстрировать эту возможность, мы расстались с неизменяемым классом Vector и занялись реализацией подкласса BingoCage, поддерживающего оператор += для добавления элементов в случайный пул — по аналогии с тем, как встроенный тип list поддерживает оператор +=, являющийся сокращенной записью метода list.extend(). Попутно мы обсудили, почему оператор + ведет себя более разборчиво, чем +=, в том, что касается допустимых типов операндов. Для типов последовательностей + обычно требуется, чтобы оба операнда имели одинаковый тип, тогда как += зачастую принимает произвольный итерируемый объект в качестве правого операнда.

Дополнительная литература

Перегрузка операторов — одна из областей программирования на Python, где проверки с помощью isinstance — обычное дело. Вообще говоря, в библиотеках следует отдавать предпочтение динамической типизации — во имя большей гибкости: избегать явной проверки типов, а просто попытаться выполнить операцию и обработать исключение, если оно произойдет. Это открывает возможность работать с объектами независимо от их типов при условии, что они поддерживают необходимые операции. Но ABC в Python допускают более строгую форму динамической типизации, которая с легкой руки Алекса Мартелли получила название «гусиной типизации». Этот подход нередко оказывается полезным в коде перегруженных операторов. Поэтому, если вы пропустили главу 11, прочитайте ее сейчас.

Основным источником информации о специальных методах операторов является глава «Модель данных» (https://docs.python.org/3/reference/datamodel.html) справочного руководства. Но на момент написания книги в этот канонический источник вкрались досадная ошибка, упомянутая в примечании «Ошибки в документации по Python 3» выше, — написано, что «при определении метода __eq__() следует также определять метод __ne__()». На самом деле, метод __ne__, который в Python 3 наследуется от класса object, покрывает большинство потребностей, так что на практике реализовывать __ne__ приходится редко. Еще одна относящаяся к теме часть документации — раздел 9.1.2.2 «Реализация арифметических операций» (http://bit.ly/1JHWP8W) в описании модуля numbers стандартной библиотеки Python.

К рассматриваемому вопросу примыкают также обобщенные функции, поддерживаемые декоратором @singledispatch в Python 3 (см. раздел «Обобщенные