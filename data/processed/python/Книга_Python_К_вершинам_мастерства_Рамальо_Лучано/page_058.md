---
source_image: page_058.png
page_number: 58
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 27.96
tokens: 11619
characters: 1410
timestamp: 2025-12-24T01:36:53.880892
finish_reason: stop
---

Проблема в том, что код в примере 2.13, по существу, ведет себя так же, как следующий код:

row = ['_'] * 3
board = []
for i in range(3):
    board.append(row) ①

① Один и тот же объект row трижды добавляется в список board.

С другой стороны, списковое включение из примера 2.12 эквивалентно такому коду:

>>> board = []
>>> for i in range(3):
...     row = ['_'] * 3 # ①
...     board.append(row)
...
>>> board
[['_', '_', '_'], ['_', '_', '_'], ['_', '_', '_']]
>>> board[2][0] = 'X'
>>> board # ②
[['_', '_', '_'], ['_', '_', '_'], ['X', '_', '_']]

① На каждой итерации строится новый список row, который добавляется в конец списка board.
② Как и положено, изменилась только строка 2.

Если проблема или ее решение, представленные в этом разделе, вам не вполне понятны, не огорчайтесь. Глава 8 специально написана, для того чтобы прояснить механизм работы ссылок и изменяемых объектов, а также связанные с ним подводные камни.

До сих пор мы говорили о простых операторах + и * в применении к последовательностям, но существуют также операторы += и *=, которые работают совершенно по-разному в зависимости от того, изменяема конечная последовательность или нет. Эти различия объясняены в следующем разделе.

Составное присваивание последовательностей

Поведение операторов составного присваивания += и *= существенно зависит от типа первого операнда. Для простоты мы рассмотрим составное сложение (+=), но