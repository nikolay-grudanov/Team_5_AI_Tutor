---
source_image: page_121.png
page_number: 121
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 45.99
tokens: 11963
characters: 2110
timestamp: 2025-12-24T01:40:20.317599
finish_reason: stop
---

О символах и не только

• символьные метаданные в базе данных Unicode;
• двухрежимные API для работы с типами str и bytes.

Начнем с символов, кодовых позиций и байтов.

О СИМВОЛАХ И НЕ ТОЛЬКО

Концепция «строки» достаточно проста: строка — это последовательность символов. Проблема — в определении понятия «символ».

В 2015 году под «символом» мы понимаем символ Unicode, и это лучшее определение на сегодняшний момент. Поэтому отдельными элементами объекта типа str в Python 3 являются символы Unicode (точно так же как обстоит дело с элементами объекта unicode в Python 2), — а не просто байты, из которых состоят объекты str в Python 2.

Стандарт Unicode явно разделяет идентификатор символа и конкретное байтовое представление.

Идентификатор символа — его кодовая позиция — это число от 0 1 114 111 (по основанию 10), которое в стандарте Unicode записывается шестнадцатеричными цифрами (в количестве от 4 до 6) с префиксом «U+». Например, кодовая позиция буквы А равна U+0041, знака евро — U+20AC, музыкального символа скрипичного ключа — U+1D11E. В версии Unicode 6.3 (используемой в Python) конкретные символы сопоставлены примерно 10 % допустимых кодовых позиций

Какими конкретно байтами представляется символ, зависит от используемой кодировки. Кодировкой называется алгоритм преобразования кодовых позиций в последовательности байтов и наоборот. Кодовая позиция буквы А (U+0041) кодируется одним байтом \x41 в кодировке UTF-8 и двумя байтами \x41\x00 в кодировке UTF-16LE. Другой пример: знак евро (U+20AC) преобразуется в три байта в UTF-8 — \xe2\x82\xac, но в UTF-16LE кодируется двумя байтами — \xac\x20.

Преобразование из кодовых позиций в байты называется кодированием, преобразование из байтов в кодовых позиции — декодированием. См. пример 4.1.

Пример 4.1. Кодирование и декодирование

```python
>>> s = 'café'
>>> len(s) # ①
4
>>> b = s.encode('utf8') # ②
>>> b
b'caf\xc3\xa9' # ③
>>> len(b) # ④
5
>>> b.decode('utf8') # ⑤
'café'
```

① Строка 'café' состоит из четырех символов Unicode.
② Преобразуем str в bytes, пользуясь кодировкой UTF-8.
③ Литералы типа bytes начинаются префиксом b.