---
source_image: page_540.png
page_number: 540
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 44.50
tokens: 11854
characters: 2338
timestamp: 2025-12-24T02:00:00.344638
finish_reason: stop
---

выполнении длительных задач. На самом деле, любая библиотека, написанная на C, может управлять GIL, запускать собственные потоки ОС и задействовать все имеющиеся процессорные ядра. Это, правда, заметно усложняет код библиотеки, и большинство авторов так не поступают.

Однако все стандартные библиотечные функции, которые выполняют блокирующий ввод-вывод, освобождают GIL, когда ждут результата от ОС. Это означает, что Python-программы с большим объемом ввода-вывода, могут получить выгоду от использования нескольких потоков на уровне Python: когда один поток Python ждет ответа из сети, блокированная функция ввода-вывода освобождает GIL, давая возможность работать другому потоку.

Потому-то Дэвид Бизли и говорит: «Потоки Python прекрасно умеют ничего не делать»4.

Все блокирующие функции ввода-вывода из стандартной библиотеки Python освобождают GIL, уступая процессор другим потокам. Также освобождает GIL функция time.sleep(). Поэтому потоки Python можно без опаски использовать в приложениях с большим объемом ввода-вывода, несмотря на GIL.

А теперь посмотрим, как с помощью concurrent.futures можно обойти GIL для счетных задач.

Запуск процессов с помощью concurrent.futures

Страница документации по пакету concurrent.futures (https://docs.python.org/3/library/concurrent.futures.html) имеет подзаголовок «Запуск параллельных задач». Этот пакет действительно поддерживает истинно параллельные вычисления, потому что умеет распределять работу между несколькими процессами Python благодаря классу ProcessPoolExecutor — и тем самым обходить GIL и задействовать все имеющиеся процессорные ядра для счетных (т. е. в основном занимающих процессор) задач.

И ProcessPoolExecutor, и ThreadPoolExecutor реализуют обобщенный интерфейс Executor, поэтому, работая с concurrent.futures, очень легко переходить от решения на основе потоков к решению на основе процессов и обратно.

Использование ProcessPoolExecutor не дает никакого преимущества в примере загрузки флагов или в любой другой программе, ограниченной скоростью ввода-вывода. И это легко проверить — просто измените следующие строки в примере 17.3:

def download_many(cc_list):
    workers = min(MAX_WORKERS, len(cc_list))
    with futures.ThreadPoolExecutor(workers) as executor:

4 Слайд 106 пособия «Generators: The Final Frontier» (http://www.dabeaz.com/finalgenerator/).