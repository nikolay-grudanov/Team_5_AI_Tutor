---
source_image: page_682.png
page_number: 682
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 45.63
tokens: 11819
characters: 2114
timestamp: 2025-12-24T02:06:21.485816
finish_reason: stop
---

attr.storage_name = '_{}#{}'.format(type_name, key)
return cls

1 Декоратор получает класс в качестве аргумента.
2 Обходим словарь, содержащий атрибуты класса.
3 Если встретился один из наших дескрипторов Validated ...
4 ... то формируем storage_name из имени дескрипторного класса и имени управляемого атрибута (например, _NonBlank#description).
5 Возвращаем модифицированный класс.

Doctest-скрипты в файле bulkfood_v6.py доказывают, что мы добились успеха. Так, в примере 21.5 видны имена атрибутов хранения в экземпляре LineItem.

Пример 21.5. bulkfood_v6.py: doctest-скрипты для проверки атрибутов дескрипторов storage_name

>>> raisins = LineItem('Golden raisins', 10, 6.95)
>>> dir(raisins)[:3]
['_NonBlank#description', '_Quantity#price', '_Quantity#weight']
>>> LineItem.description.storage_name
'_NonBlank#description'
>>> raisins.description
'Golden raisins'
>>> getattr(raisins, '_NonBlank#description')
'Golden raisins'

Не очень сложно. Декораторы классов — более простой способ решения задачи, для которой раньше приходилось использовать метакласс: настройки класса в момент создания.

Существенный недостаток декораторов класса заключается в том, они воздействуют только на класс, к которому применяются. То есть подклассы декорированного класса могут унаследовать внесенные декоратором изменения, а могут и не унаследовать — все зависит от характера изменений. В следующих разделах мы исследуем эту проблему и способы ее решения.

Что когда происходит: этап импорта и этап выполнения

Для успешного метапрограммирования необходимо знать, когда интерпретатор Python обрабатывает каждый блок кода. Программисты на Python употребляют термины «этап импорта» и «этап выполнения», но они определены нестрого, так что между ними существует ничейная земля. На этапе импорта интерпретатор производит синтаксический анализ исходного кода py-модуля сверху вниз за один проход и генерирует исполняемый байт-код. На этом этапе обнаруживаются синтаксические ошибки. Если в локальном кэше __pycache__ существует актуальный pyc-файл, то этот этап пропускается, поскольку уже имеется готовый к выполнению байт-код.