---
source_image: page_462.png
page_number: 462
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 42.03
tokens: 11785
characters: 2052
timestamp: 2025-12-24T01:56:12.084464
finish_reason: stop
---

Более пространное объяснение функции functools.reduce приведено в разделе «Vector, попытка № 4: хэширование и ускорение оператора ==» главы 10.

Встроенная функция sorted также принимает итерируемый объект и возвращает нечто иное. В отличие от генераторной функции reversed, sorted строит и возвращает настоящий список. В конце концов, каждый элемент входного итерируемого объекта можно прочитать, а, раз так, то их можно и отсортировать, причем сортировке подвергается список list, а, значит, его sorted и возвращает. Я упомянул sorted в этом месте, потому что она все-таки принимает произвольный итерируемый объект.

Конечно, sorted и редуцирующие функции работают только с конечными итерируемыми объектами. В противном случае они будут без конца получать элементы и никогда не вернут результат.

А теперь вернемся к встроенной функции iter(): у нее есть одно малоизвестное свойство, о котором мы пока не говорили.

Более пристальный взгляд на функцию iter

Мы видели, что Python вызывает iter(x), когда ему требуется обойти объект x.

Но у iter в запасе есть еще один трюк: ее можно вызывать с двумя аргументами для создания итератора из обычной функции или произвольного вызываемого объекта. При таком использовании первый аргумент должен быть вызываемым объектом, который будет повторно вызываться (без аргументов) для порождения значений, а второй аргумент является ограничителем — если вызываемый объект возвращает такое значение, то итератор не отдает его, а возбуждает исключение StopIteration.

В следующем примере показано, как использовать iter для бросания шестигранной кости до тех пор, пока не выпадет 1:

```python
>>> def d6():
...     return randint(1, 6)
...
>>> d6_iter = iter(d6, 1)
>>> d6_iter
<callable_iterator object at 0x0000000029BE6A0>
>>> for roll in d6_iter:
...     print(roll)
...
4
3
6
3
```

Отметим, что функция iter здесь возвращает вызываемый итератор (callable_iterator). Цикл for в этом примере может работать очень долго, но никогда не покажет 1, поскольку это значение-ограничитель. Как и любой итератор, объект