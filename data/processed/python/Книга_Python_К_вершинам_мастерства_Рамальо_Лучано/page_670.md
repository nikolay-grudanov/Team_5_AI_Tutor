---
source_image: page_670.png
page_number: 670
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 49.12
tokens: 11899
characters: 2381
timestamp: 2025-12-24T02:05:54.353632
finish_reason: stop
---

Разобравшись с тем, как работают дескрипторы и методы, дадим несколько практических советов по их использованию.

Советы по использованию дескрипторов

Ниже перечислены некоторые практические последствия только что описанных характеристик дескрипторов.

Для простоты пользуйтесь классом property
Встроенный класс property создает переопределяющие дескрипторы, в которых реализованы оба метода __set__ и __get__, даже если вы сами не задавали метод установки. Подразумеваемый по умолчанию метод __set__ возбуждает исключение AttributeError: can't set attribute, поэтому свойство — это простейший способ создать доступный только для чтения атрибут и избежать проблемы, описанной ниже.

В дескрипторах только для чтения необходим метод __set__
Если вы используете дескрипторный класс для реализации атрибута, доступного только для чтения, то не забывайте реализовывать оба метода __get__ и __set__, иначе одноименный атрибут экземпляра замаскирует дескриптор. Метод __set__ атрибута, доступного только для чтения, должен просто возбуждать исключение AttributeError с подходящим сообщением4.

Проверяющим дескрипторам достаточно одного метода __set__
Если дескриптор предназначен только для проверки значений, то метод __set__ должен проверять полученный аргумент value и, если он правильен, то устанавливать значение непосредственно в атрибуте __dict__ экземпляра, используя в качестве ключа имя экземпляра дескриптора. Тогда чтение атрибута с таким же именем из экземпляра будет производиться максимально быстро, т. к. не требует наличия метода __get__. Код см. в примере 20.1.

Кэширование можно эффективно реализовать при наличии одного лишь __get__
Если вы напишете только метод __get__, то получите непереопределяющий дескриптор. Они полезны, когда требуется выполнить накладные вычисления и кэшировать результат, установив атрибут экземпляра с таким же именем. Одноименный атрибут экземпляра маскирует дескриптор, поэтому при последующем доступе к этому атрибуту значение будет извлекаться непосредственно из атрибута __dict__ экземпляра в обход метода __get__ дескриптора.

4 Python не блещет единообразием в таких сообщениях. При попытке изменить атрибут с .real комплексного числа выдается сообщение AttributeError: read-only attribute, а при попытке изменить с.conjugate (метод класса complex) — сообщение AttributeError: 'complex' object attribute 'conjugate' is read-only.