---
source_image: page_534.png
page_number: 534
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 43.47
tokens: 11822
characters: 2241
timestamp: 2025-12-24T01:59:40.556628
finish_reason: stop
---

6 Зная код страны, строим URL-адрес и загружаем изображение; возвращаем двоичное содержимое ответа.
7 Отображаем строку и опустошаем буфер sys.stdout, чтобы видеть, как продвигается работа; это необходимо, потому что Python обычно не сбрасывает буфер stdout до перехода на новую строку.
8 download_many — основная функция, позволяющая провести сравнение с параллельными реализациями.
9 Обходим список стран в алфавитном порядке, чтобы порядок отображения на выходе был такой же, как на входе; возвращаем количество загруженных изображений.
10 main запоминает и выводит истекшее время после завершения download_many.
11 При вызове main необходимо указывать функцию, которая производит загрузку; мы передаем функцию download_many в качестве аргумента, чтобы main можно было использовать как библиотечную функцию, способную работать и с другими реализациями download_many.

Библиотека requests, которую написал Кеннет Рейц (Kenneth Reitz) имеется на сайте PyPI (https://pypi.python.org/pypi/requests). Она функционально богаче и проще в использовании, чем модуль urllib.request из стандартной библиотеки Python 3. На самом деле, библиотека requests считается образцом API в духе Python. Она также совместима с версиями, начиная с Python 2.6, тогда как библиотека urllib2 из Python 2 в Python 3 была переименована. Таким образом, использовать requests удобнее, на какую бы версию Python вы ни ориентировались.

Ничего особенного нового в скрипте flags.py нет. Он служит просто эталоном для сравнения с другими скриптами, а использую я его как библиотеку, чтобы не писать лишний код. Теперь рассмотрим другую реализацию — на основе библиотеки concurrent.futures.

Загрузка с применением библиотеки concurrent.futures

Основой пакета concurrent.futures являются классы ThreadPoolExecutor и ProcessPoolExecutor, которые реализуют интерфейс, позволяющий передавать вызываемые объекты соответственно потокам или процессам. Оба класса управляют внутренним пулом рабочих потоков или процессов и очередью подлежащих выполнению задач. Но поскольку интерфейс высокоуровневый, нам не нужно знать об этих деталях для такого простого дела, как загрузка флагов.

В примере 17.3 показан простейший способ параллельной загрузки — методом ThreadPoolExecutor.map.