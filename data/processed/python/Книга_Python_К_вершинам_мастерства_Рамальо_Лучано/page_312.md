---
source_image: page_312.png
page_number: 312
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 46.70
tokens: 11887
characters: 2370
timestamp: 2025-12-24T01:49:01.661603
finish_reason: stop
---

Глава 10. Рубим, перемешиваем и нарезаем последовательности

Функция super() — быстрый способ обратиться к методам суперкласса. Она необходима в динамических языках, поддерживающих множественное наследование, к числу которых относится и Python. Используется для делегирования некоторого действия в подклассе подходящему методу суперкласса. Мы еще вернемся к функции super в разделе «Множественное наследование и порядок разрешения методов» на стр. 384.

Решая, какое сообщение об ошибке вернуть в исключении AttributeError, я прежде всего сверился с поведением встроенного типа complex, поскольку он неизменяемый и имеет два атрибута: real и imag. Попытка изменить любой из них приводит к исключению AttributeError с сообщением «can't set attribute». С другой стороны, попытка изменить доступный только для чтения атрибут, который защищен, как в разделе «Хэшируемый класс Vector2d» главы 9, кончается сообщением «readonly attribute». Выбирая значение строки error в методе __setattr__, я руководствовался обоими образцами, но уточнил, какие именно атрибуты запрещены.

Отметим, что мы не запрещаем установку всех вообще атрибутов, а только таких, имя которых состоит из одной строчной буквы, — чтобы избежать путаницы с доступными только для чтения атрибутами x, y, z и t.

Мы знаем, что объявление атрибута __slots__ на уровне класса предотвращает создание новых атрибутов экземпляров, поэтому может возникнуть искушение воспользоваться этой возможностью и не реализовывать метод __setattr__. Но из-за различных подводных камней, которые обсуждались в разделе «Проблемы при использовании __slots__» главы 9, не рекомендуется объявлять __slots__ только ради запрета создавать новые атрибуты экземпляра. Этот механизм предназначен исключительно для экономии памяти, да и то лишь в случае, когда с этим возникают проблемы.

Но пусть мы и отказались от записи в компоненты Vector, все равно из этого примера можно вынести важный урок: часто вместе с методом __getattr__ приходится писать и метод __setattr__, чтобы избежать несогласованного поведения объекта. Если бы мы решили допустить изменение компонент, то могли бы реализовать метод __setitem__, чтобы можно было писать v[0] = 1.1, и (или) метод __setattr__, чтобы работала конструкция v.x = 1.1. Но сам класс Vector должен оставаться неизменяемым, потому что в следующем разделе мы собираемся сделать его хэшируемым.