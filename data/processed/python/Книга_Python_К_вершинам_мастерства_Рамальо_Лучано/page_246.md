---
source_image: page_246.png
page_number: 246
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 51.98
tokens: 11872
characters: 2284
timestamp: 2025-12-24T01:46:10.202023
finish_reason: stop
---

В разделе 3.1 «Объекты, значения и типы» руководства по языку Python (http://bit.ly/1Vm9gu4) написано:

У каждого объекта есть идентификатор, тип и значение. Идентификатор объекта после создания не изменяется, можете считать, что это адрес объекта в памяти. Оператор is сравнивает идентификаторы двух объектов; функция id() возвращает целое число, представляющее идентификатор объекта.

Истинный смысл идентификатора объекта зависит от реализации. В CPython функция id() возвращает адрес объекта в памяти, но в другом интерпретаторе это может быть что-то совсем иное. Главное — гарантируется, что идентификатор является уникальной числовой этикеткой и не изменяется в течение всего времени жизни объекта.

На практике мы редко пользуемся функцией id(). Проверка на тождество чаще производится с помощью оператора is, а не путем сравнения идентификаторов. Далее мы обсудим различия между операторами is и ==.

Выбор между == и is

Оператор == сравнивает значения объектов (хранящиеся в них данные), а оператор is — их идентификаторы.

Нас обычно интересуют значения, а не идентификаторы, поэтому == встречается в Python-программах чаще, is.

Однако при сравнении переменной с объектом-одиночкой (синглтоном) имеет смысл использовать is. Самый типичный случай — проверка того, что переменная связана с объектом None. Вот как это рекомендуется делать:

x is None

А вот как правильно записывать отрицание этого условия:

x is not None

Оператор is работает быстрее, чем ==, потому что его невозможно перегрузить, так что интерпретатору не приходится искать и вызывать специальные методы для его вычисления, а само вычисление сводится к сравнению двух целых чисел. Напротив, a == b — это синтаксическая глазурь поверх вызова метода a.__eq__(b). Метод __eq__, унаследованный от object, сравнивает идентификаторы объектов, поэтому дает тот же результат, что is. Но в большинстве встроенных типов метод __eq__ переопределен в соответствии с семантикой типа, т. е. с учетом значений других атрибутов. Для установления равенства может потребоваться большой объем обработки, например, сравнение больших коллекций или глубоко вложенных структур.

Завершая обсуждение тождественности и равенства, мы покажем, что знаменитый своей неизменяемостью тип tuple вовсе не такой несгибаемый, как кажется.