---
source_image: page_134.png
page_number: 134
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 55.21
tokens: 12111
characters: 2683
timestamp: 2025-12-24T01:41:04.758434
finish_reason: stop
---

>>> u16le = 'El Niño'.encode('utf_16le')
>>> list(u16le)
[69, 0, 108, 0, 32, 0, 78, 0, 105, 0, 241, 0, 111, 0]
>>> u16be = 'El Niño'.encode('utf_16be')
>>> list(u16be)
[0, 69, 0, 108, 0, 32, 0, 78, 0, 105, 0, 241, 0, 111]

Предполагается, что BOM, если он присутствует, будет отфильтрован кодеком UTF-16, так что останется только сам текст файла без НЕРАЗРЫВНОГО ПРОБЕЛА НУЛЕВОЙ ШИРИНЫ. Стандарт гласит, что для файла в кодировке UTF-16 без маркера BOM следует предполагать кодировку UTF-16BE (тупоконечную). Однако архитектура Intel x86 остроконечная, поэтому на практике в изобилии встречаются остроконечные файлы в кодировке UTF-16 без BOM.

Проблема порядка байтов возникает только для кодировок, в которых символы кодируются словами, состоящими из нескольких байтов, например UTF-16 и UTF-32. Существенное достоинство UTF-8 заключается в том, что эта кодировка порождает одни и те же последовательности байтов вне зависимости от машинной архитектуры, поэтому BOM не нужен. Тем не менее, некоторые приложения Windows (и, прежде всего, Блокнот) добавляют BOM и в файлы в кодировке UTF-8, а для Excel наличие BOM означает, что файл записан в UTF-8, иначе предполагается, что для его кодирования использовалась кодовая страница Windows. Символ U+FEFF в UTF-8 кодируется последовательностью из трех байтов b'\xef\xbb\xbf'. Поэтому файл, начинающийся такими байтами, скорее всего, закодирован в UTF-8 и содержит BOM. Однако Python не предполагает автоматически кодировку UTF-8, если файл начинается с b'\xef\xbb\xbf'.

Перейдем теперь к обработке текстовых файлов в Python 3.

Обработка текстовых файлов

На практике обрабатывать текстовые файлы лучше всего, применяя «сэндвич Unicode» (рис. 4.2)⁴. Это означает, что тип bytes следует декодировать в str на возможно более ранних стадиях ввода (например, при открытии файла для чтения). «Котлета» в сэндвиче — это бизнес-логика вашей программы, внутри которой обрабатываются только объекты str. Никогда не следует производить кодирование или декодирование в середине обработки. На этапе вывода объекты str кодируются в bytes как можно позже. Именно так работает большинство веб-каркасов, так что их пользователям редко приходится иметь дело с типом bytes. Например, в Django представления должны выводить строки str, а Django сам позаботится о кодировании ответа в bytes, применяя по умолчанию кодировку UTF-8.

Python 3 облегчает следование этой рекомендации, потому что встроенная функция open производит необходимое декодирование при чтении и кодирование

⁴ Впервые словосочетание «сэндвич Unicode» встретилось мне в замечательном выступлении Нэда Бэтчелдера «Pragmatic Unicode» (http://nedbatchelder.com/text/unipain/unipain.html).