---
source_image: page_013.png
page_number: 13
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 87.72
tokens: 11951
characters: 2551
timestamp: 2025-12-24T01:35:38.446217
finish_reason: stop
---

Предисловие

collections.deque. О создании пользовательских последовательностей речь пойдет только в части IV, где мы также узнаем об использовании абстрактных базовых классов (abstract base classes — ABC) из модуля collections.abc. Создание собственного ABC обсуждается еще позже, поскольку я считаю, что сначала нужно освоиться с использованием ABC, а уж потом писать свои.

У такого подхода несколько достоинств. Прежде всего, зная, что есть в вашем распоряжении, вы не станете заново изобретать велосипед. Мы пользуемся готовыми классами коллекций чаще, чем реализуем собственные, и можем уделять больше внимания нетривиальным способам работы с имеющимися средствами, отложив на потом разговор о разработке новых. И мы скорее унаследуем существующему абстрактному базовому классу, чем будем создавать новый с нуля. Наконец, я полагаю, что понять абстракцию проще после того, как видел ее в действии.

Недостаток же такой стратегии в том, что главы изобилуют ссылками на более поздние материалы. Надеюсь, узнав, почему я выбрал такой путь, вам будет проще с этим смириться.

Ниже описаны основные темы, рассматриваемые в каждой части книги.

Часть I

Содержит всего одну главу, посвященную модели данных в Python, где объясняется ключевая роль специальных методов (например, __repr__) для обеспечения единообразного поведения объектов любого типа — в языке, заслуженно считающемся образцом единообразия. Осмысление различных граней модели данных — сквозная тема книги, но именно в главе 1 дается общий обзор.

Часть II

В главах из этой части рассматриваются типы коллекций: последовательности, отображения и множества, а также сравниваются типы str и bytes. Это вещи, которые радостно приветствовали пользователи Python 3 и которых отчаянно не хватает пользователям Python 2, еще не модернизировавшим свой код. Основная цель — напомнить, что уже имеется, и объяснить некоторые особенности поведения, которые могут оказаться неожиданными, например, изменение порядка ключей словаря dict в то время, когда в нем никто ничего не ищет, или подводные камни, связанные с зависящей от локали сортировкой строки Unicode. Во имя достижения этой цели изложение временами становится широким и высокоуровневым (например, во время знакомства с многочисленными типами последовательностей и отображений), а временами — углубленным (например, при описании деталей хэш-таблиц, лежащих в основе типов dict и set).

Часть III

Здесь речь пойдет о функциях, как полноценных объектах языка: что под этим понимается, как это отражается на некоторых популярных паттернах