---
source_image: page_338.png
page_number: 338
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 45.50
tokens: 11965
characters: 2645
timestamp: 2025-12-24T01:50:16.469056
finish_reason: stop
---

Глава 11. Интерфейсы: от протоколов до абстрактных базовых...

Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File ".../python3.3/random.py", line 265, in shuffle
    x[i], x[j] = x[j], x[i]
TypeError: 'FrenchDeck' object does not support item assignment

В сообщении ясно говорится: «Объект 'FrenchDeck' не поддерживает присваивание элементу». Проблема в том, что shuffle должна иметь возможность переставить два элемента коллекции, а класс FrenchDeck реализует только протокол неизменяемой последовательности. Изменяемая последовательность должна также предоставлять метод __setitem__.

Поскольку Python — динамический язык, мы можем устранить проблему прямо во время выполнения, даже в интерактивной оболочке. В примере 11.6 показано, как это сделать.

Пример 11.6. Партизанское латание класса FrenchDeck с целью сделать его изменяемым и совместимым с функцией random.shuffle (продолжение примера 11.5)

>>> def set_card(deck, position, card):   ①
...     deck._cards[position] = card
...
>>> FrenchDeck.__setitem__ = set_card   ②
>>> shuffle(deck)   ③
>>> deck[:5]
[Card(rank='3', suit='hearts'), Card(rank='4', suit='diamonds'), Card(rank='4', suit='clubs'), Card(rank='7', suit='hearts'), Card(rank='9', suit='spades')]

① Создаем функцию, которая принимает аргументы deck, position и card.
② Присваиваем эту функцию атрибуту __setitem__ класса FrenchDeck.
③ Теперь объект deck можно перетасовать, потому что класс FrenchDeck поддерживает обязательный метод протокола изменяемой последовательности.

Сигнатура метода __setitem__ определена в разделе 3.3.6 «Эмуляция контейнерных типов» справочного руководства по языку Python (http://bit.ly/1QOyDQY). В данном случае мы назвали аргументы deck, position, card — а не self, key, value, как в руководстве, — чтобы показать, что любой метод Python изначально является простой функцией, а имя self для первого аргумента — не более чем соглашение. В сеансе оболочки это нормально, но в исходном файле Python гораздо лучше использовать предлагаемые в документации имена self, key и value.

Трюк состоит в том, что функция set_card знает о наличии в объекте deck атрибута с именем _cards, который должен быть изменяемой последовательностью. После этого мы присоединяем функцию set_card к классу FrenchDeck в качестве специального метода __setitem__. Это пример партизанского латания (monkey patching): изменения класса или модуля во время выполнения без модификации исходного кода. Техника весьма действенная, но код, в котором она используется, оказывается очень тесно связан с латаемой программой и зачастую даже вмешивается в ее закрытые и недокументированные части.