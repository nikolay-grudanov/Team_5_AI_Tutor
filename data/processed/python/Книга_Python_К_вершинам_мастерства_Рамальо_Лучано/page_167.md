---
source_image: page_167.png
page_number: 167
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 55.79
tokens: 11876
characters: 1999
timestamp: 2025-12-24T01:42:39.460465
finish_reason: stop
---

Функции высшего порядка

['banana', 'apple', 'fig', 'raspberry', 'strawberry', 'cherry']
>>>

В функциональной парадигме программирования хорошо известны следующие функции высшего порядка: map, filter, reduce, apply. Функция apply была объявлена нерекомендуемой в версии Python 2.3 и исключена из Python 3, потому что в ней отпала необходимость. Чтобы вызвать функцию с динамическим набором аргументов, достаточно написать fn(*args, **keywords) вместо apply(fn, args, kwargs).

Функции map, filter и reduce пока никуда не делись, но, как показано в следующем разделе, в большинстве случаев им есть лучшие альтернативы.

Современные альтернативы функциям map, filter и reduce

В функциональных языках программирования обычно имеются функции высшего порядка map, filter и reduce (иногда под другими именами). Функции map и filter по-прежнему встроены в Python 3, но с появлением списковых включений и генераторных выражений потеряли былую значимость. Как списковое включение, так и генераторное выражение могут сделать то же, что комбинация map и filter, только код будет выглядеть понятнее. Взгляните на пример 5.5.

Пример 5.5. Списки факториалов, порожденные функциями map и filter, а также альтернатива в виде спискового включения

>>> list(map(fact, range(6))) ①
[1, 1, 2, 6, 24, 120]
>>> [fact(n) for n in range(6)] ②
[1, 1, 2, 6, 24, 120]
>>> list(map(factorial, filter(lambda n: n % 2, range(6)))) ③
[1, 6, 120]
>>> [factorial(n) for n in range(6) if n % 2] ④
[1, 6, 120]

① Строим список факториалов от 0! до 5!.
② Та же операция с помощью спискового включения.
③ Список факториалов нечетных чисел до 5!, построенный с использованием map и filter.
④ Списковое включение делает то же самое, заменяя map и filter и делая нужным лямбда-выражение.

В Python 3 функции map и filter возвращают генераторы — вариант итератора — поэтому безо всяких проблем могут быть заменены генераторным выражением (в Python 2 эти функции возвращали списки, поэтому их ближайшим аналогом было списковое включение).