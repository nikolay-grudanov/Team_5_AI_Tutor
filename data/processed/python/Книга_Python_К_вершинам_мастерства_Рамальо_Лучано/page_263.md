---
source_image: page_263.png
page_number: 263
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 51.58
tokens: 11838
characters: 2010
timestamp: 2025-12-24T01:46:54.446086
finish_reason: stop
---

Как Python хитрит с неизменяемыми объектами

Экземпляр класса set может быть объектом ссылки, потому-то мы и использовали множество в примере 8.17. Пользовательские типы тоже не составляют проблемы, и это объясняет, почему в примере 8.19 понадобился дурацкий класс Cheese. Но экземпляры классов int и tuple нельзя сделать объектами слабых ссылок, и тут даже создание подкласса не поможет.

Большинство этих ограничений — детали реализации CPython, и к другим интерпретаторам Python они, возможно, и не относятся. Это результат внутренних оптимизаций, некоторые из которых обсуждаются в следующем разделе (совершенно необязательном).

Как Python хитрит с неизменяемыми объектами

Вы можете спокойно пропустить этот раздел. В нем обсуждаются некоторые детали реализации, которые пользователям Python не особенно интересны. Все это оптимизации и уловки, которые придумали разработчики ядра CPython; на работе с языком они не сказываются и к другим реализациям Python и даже к будущим версиям CPython могут быть неприменимы. Тем не менее, экспериментируя с синонимами и копированием, иногда можно наткнуться на следы этих трюков, поэтому мне показалось, что о них стоит сказать пару слов.

Я удивился, узнав, что для кортежа t конструкция t[:] не создает копию, а возвращает ссылку на сам объект. Ссылку на исходный кортеж мы получаем также, написав tuple(t)5. Это доказывает пример 8.20.

Пример 8.20. Кортеж, инициализированный другим кортежем, в точности совпадает с исходным

>>> t1 = (1, 2, 3)
>>> t2 = tuple(t1)
>>> t2 is t1  # 1
True
>>> t3 = t1[:]
>>> t3 is t1  # 2
True

1 t1 и t2 связаны с одним и тем же объектом.
2 И t3 тоже.

Такое же поведение свойственно экземплярам классов str, bytes и frozenset. Отметим, что frozenset — не последовательность, поэтому, когда fs является

5 Это поведение четко документировано. Набрав help(tuple) в оболочке Python, читаем: «Если аргумент является кортежем, то возвращается исходный объект». А я-то, садясь за написание этой книги, думал, что знаю о кортежах все.