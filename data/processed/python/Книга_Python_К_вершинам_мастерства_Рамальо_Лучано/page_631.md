---
source_image: page_631.png
page_number: 631
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 43.82
tokens: 11798
characters: 1778
timestamp: 2025-12-24T02:04:03.340533
finish_reason: stop
---

Правильный взгляд на свойства

В некоторых случаях классическая форма удобнее синтаксиса декораторов, одним из примеров является код фабрики свойств, который мы вскоре обсудим. С другой стороны, в теле класса, где много методов, декораторы позволяют сразу опознать методы чтения и установки, не полагаясь на соглашение о префиксах get и set в именах.

Наличие свойств в классе влияет на то, как можно искать атрибуты в экземплярах такого класса, и, на первый взгляд, это удивительно. Объясним, в чем здесь дело.

Свойства переопределяют атрибуты экземпляра

Свойства всегда являются атрибутами класса, но на самом деле они управляют доступом к атрибутам в экземплярах этого класса.

В разделе «Переопределение атрибутов класса» главы 9 мы видели, что если экземпляр и его класс оба имеют атрибут-данные с одним и тем же именем, то атрибут экземпляра переопределяет, или маскирует атрибут класса — по крайней мере, когда мы обращаемся к атрибуту от имени этого экземпляра. Проблема демонстрируется в примере 19.19.

Пример 19.19. Атрибут экземпляра маскирует атрибут-данные класса

```python
>>> class Class: # 1
...     data = 'the class data attr'
...     @property
...     def prop(self):
...         return 'the prop value'
...
>>> obj = Class()
>>> vars(obj) # 2
{}
>>> obj.data # 3
'the class data attr'
>>> obj.data = 'bar' # 4
>>> vars(obj) # 5
{'data': 'bar'}
>>> obj.data # 6
'bar'
>>> Class.data # 7
'the class data attr'
```

1 Определяем Class с двумя атрибутами класса: атрибутом-данными data и свойством prop.
2 vars возвращает атрибут __dict__ объекта obj; как видим, атрибутов экземпляра в нем нет.
3 Чтение из obj.data возвращает значение Class.data.
4 Запись в obj.data создает атрибут экземпляра.
5 Инспектируем экземпляр, чтобы узнать, какие у него атрибуты.