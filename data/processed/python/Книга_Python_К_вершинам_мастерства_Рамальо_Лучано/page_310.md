---
source_image: page_310.png
page_number: 310
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 35.28
tokens: 11758
characters: 1679
timestamp: 2025-12-24T01:48:49.491794
finish_reason: stop
---

Пример 10.8. Часть файла vector_v3.py: в класс Vector из файла vector_v2.py добавлен метод __getattr__

shortcut_names = 'xyzt'

def __getattr__(self, name):
    cls = type(self) ①
    if len(name) == 1: ②
        pos = cls.shortcut_names.find(name) ③
        if 0 <= pos < len(self._components): ④
            return self._components[pos]
        msg = '{.__name__!r} object has no attribute {!r}' ⑤
        raise AttributeError(msg.format(cls, name))

① Получить и запомнить класс Vector, он понадобится позже.
② Если имя состоит из одного символа, то этот символ может входить в строку shortcut_names.
③ Найти позицию символа, составляющего односимвольное имя; метод str.find нашел бы также строку 'yz', но нам это не нужно, отсюда и дополнительная проверка строчкой выше.
④ Если символ найден, вернуть элемент массива.
⑤ Если предыдущая проверка не прошла, возбудить исключение AttributeError со стандартным сообщением.

Реализовать метод __getattr__ просто, но в данном случае недостаточно. Рассмотрим странное взаимодействие в примере 10.9.

Пример 10.9. Неправильное поведение: присваивание v.x не приводит к ошибке, но результат получается несогласованным

>>> v = Vector(range(5))
>>> v
Vector([0.0, 1.0, 2.0, 3.0, 4.0])
>>> v.x # ①
0.0
>>> v.x = 10 # ②
>>> v.x # ③
10
>>> v
Vector([0.0, 1.0, 2.0, 3.0, 4.0]) # ④

① Доступ к элементу v[0] по имени v.x.
② Присваиваем v.x новое значение. При этом должно бы возникнуть исключение.
③ Чтение v.x показывает новое значение, 10.
④ Однако компоненты вектора не изменились.

Сможете объяснить, что здесь происходит? И главное — почему чтение v.x возвращает 10, если это значение не хранится в массиве компонент? Если сходу непо-