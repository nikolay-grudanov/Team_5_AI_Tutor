---
source_image: page_507.png
page_number: 507
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 45.75
tokens: 11875
characters: 2266
timestamp: 2025-12-24T01:58:27.717360
finish_reason: stop
---

Использование yield from

10 Инициализируем сопрограмму.
11 Отправляем каждое значение value объекту grouper. Оно будет получено в строке term = yield кода averager; grouper его никогда не увидит.
12 Отправка значения None объекту grouper приводит к завершению текущего экземпляра averager и дает возможность grouper возобновить выполнение и создать очередной объект averager для обработки следующей группы значений.

Последний маркер в примере 16.17 с комментарием «важно!» помечает критически важную строку кода: group.send(None) завершает работу одного объекта averager и запускает следующий. Если закомментировать эту строку, то скрипт ничего не напечатает. Раскомментировав строку print(results) в конце main, мы увидим, что словарь results пуст.

Попробуйте самостоятельно разобраться, почему не получено никаких результатов, — это прекрасное упражнение на понимание работы yield from. Скрипт coroaverager3.py имеется в репозитории кода книги (http://bit.ly/1JlofLL). Объяснение приведено ниже.

Разберемся, как работает пример 16.17, а заодно объясним, что произойдет, если исключить из main вызов group.send(None), помеченный комментарием «важно!».

• На каждой итерации внешнего цикла for создается новый экземпляр grouper, названный group; это делегирующий генератор.
• Вызов next(group) инициализирует делегирующий генератор grouper, который входит в цикл while True и приостанавливается, достигнув yield from, после вызова субгенератора averager.
• Во внутреннем цикле for вызывается group.send(value); отправленное значение поступает непосредственно субгенератору averager. Тем временем текущий экземпляр group приостановлен в точке yield from.
• Когда внутренний цикл for завершается, экземпляр group все еще приостановлен, поэтому присваивание results[key] в теле grouper еще не произошло.
• Без последнего вызова group.send(None) во внешнем цикле for субгенератор averager никогда не завершится, делегирующий генератор grouper никогда не активируется повторно, а присваивание results[key] так и не произойдет.
• Когда управление возвращается в начало внешнего цикла for, создается и связывается с переменной group новый экземпляр grouper. А предыдущий становится добычей сборщика мусора (вместе с его персональным экземпляром субгенератора averager).