---
source_image: page_221.png
page_number: 221
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 39.38
tokens: 11701
characters: 1659
timestamp: 2025-12-24T01:44:50.278075
finish_reason: stop
---

Жизнь без nonlocal в Python 2

Из-за отсутствия слова nonlocal в Python 2 приходится изобретать обходные пути, один из которых описан в третьем фрагменте кода в документе «PEP 3104 – Access to Names in Outer Scopes» (http://www.python.org/dev/peps/pep-3104/), где впервые вводится слово nonlocal. По существу, идея сводится к тому, чтобы хранить переменные, которые внутренняя функция должна изменять (например, count и total), в элементах или атрибутах какого-нибудь изменяемого объекта, скажем словаря или просто экземпляра класса, и связать этот объект со свободной переменной.

Теперь, познакомившись с замыканиями в Python, мы можем продемонстрировать эффективную реализацию декораторов с помощью вложенных функций.

Реализация простого декоратора

В примере 7.15 показан декоратор, который хронометрирует каждый вызов декорируемой функции и печатает затраченное время, переданные аргументы и результат.

Пример 7.15. Простой декоратор для вывода времени выполнения функции

import time

def clock(func):
    def clocked(*args): # 1
        t0 = time.perf_counter()
        result = func(*args) # 2
        elapsed = time.perf_counter() - t0
        name = func.__name__
        arg_str = ', '.join(repr(arg) for arg in args)
        print('[%0.8fs] %s(%s) -> %r' % (elapsed, name, arg_str, result))
        return result
    return clocked # 3

1 Определяем внутреннюю функцию clocked, принимающую произвольное число позиционных аргументов.
2 Эта функция работает только потому, что замыкание clocked включает свободную переменную func.
3 Возвращаем внутреннюю функцию взамен декорируемой.

В примере 7.16 демонстрируется использование декоратора clock.