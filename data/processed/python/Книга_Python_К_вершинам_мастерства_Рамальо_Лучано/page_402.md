---
source_image: page_402.png
page_number: 402
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 38.38
tokens: 11785
characters: 1734
timestamp: 2025-12-24T01:53:17.445958
finish_reason: stop
---

>>> v3 = Vector([1, 2])
>>> v1 + v3
Vector([4.0, 6.0, 5.0, 6.0])

При таких требованиях реализация __add__ получается красивой и лаконичной.

Пример 13.4. Метод Vector.add, попытка № 1

# Внутри класса Vector
def __add__(self, other):
    pairs = itertools.zip_longest(self, other, fillvalue=0.0) # ①
    return Vector(a + b for a, b in pairs) # ②

① pairs — генератор, который порождает кортежи (a, b), где a берется из self, и b — из other. Если длины self и other различаются, то более короткий вектор дополняется значениями fillvalue.
② Новый объект Vector инициализируется генераторным выражением, которое порождает по одной сумме для каждого элемента pairs.

Обратите внимание, что __add__ возвращает новый экземпляр Vector, не изменяя ни self, ни other.

Специальные методы, реализующие унарные или инфиксные операторы не должны изменять свои операнды. Предполагается, что выражения, содержащие такие операторы, вычисляют результаты, создавая новые объекты. И лишь операторы составного присваивания могут изменять свой первый operand (self), о чем речь пойдет ниже.

В примере 13.4 разрешено прибавлять Vector к Vector2d, а также к кортежу или любому другому итерируемому объекту, порождающему числа. Это доказывает пример 13.5.

Пример 13.5. Vector.__add__ из примера 13.4 поддерживает сложение с объектами, отличными от Vector

>>> v1 = Vector([3, 4, 5])
>>> v1 + (10, 20, 30)
Vector([13.0, 24.0, 35.0])
>>> from vector2d_v3 import Vector2d
>>> v2d = Vector2d(1, 2)
>>> v1 + v2d
Vector([4.0, 6.0, 5.0])

Оба сложения в примере 13.5 работают, потому что в методе __add__ используется функция zip_longest(...), готовая принимать любые итерируемые объекты, а генераторное выражение, которым инициализируется новый Vector, просто