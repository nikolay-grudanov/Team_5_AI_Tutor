---
source_image: page_126.png
page_number: 126
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 48.47
tokens: 11993
characters: 2361
timestamp: 2025-12-24T01:40:35.198084
finish_reason: stop
---

Глава 4. Текст и байты

память файла изображения. В этой книге я не рассматриваю модуль mmap, но если вам часто приходится читать и изменять двоичные файлы, то познакомиться с разделом документации «mmap — поддержка проецирования файлов на память» (https://docs.python.org/3/library/mmap.html) будет весьма полезно.)

Мы не станем дальше углубляться в детали класса memoryview и модуля struct, но всем, кто много работает с двоичными данными, рекомендуем изучить соответствующие разделы документации: «Встроенные типы — представления памяти» (http://bit.ly/1Vm7ZnI) и «struct — интерпретация байтов как упакованных двоичных данных» (http://bit.ly/1Vm7YjA).

После этого краткого введения в типы двоичных последовательностей посмотрим, как производится преобразование между ними и строками.

Базовые кодировщики и декодировщики

В дистрибутиве Python имеется свыше 100 кодеков (кодировщик-декодировщик) для преобразования текста в байты и обратно. У каждого кодека есть имя, например 'utf_8', а часто еще и синонимы, например 'utf8', 'utf-8' и 'U8'. Имя можно передать в качестве аргумента encoding таким функциям, как open(), str.encode(), bytes.decode() и т. д. В примере 4.5 показан один и тот же текст, закодированный как три разные последовательности байтов.

Пример 4.5. Строка «El Niño», закодированная тремя кодеками, дает совершенно разные последовательности байтов

```python
>>> for codec in ['latin_1', 'utf_8', 'utf_16']:
... print(codec, 'El Niño'.encode(codec), sep='\t')
...
latin_1 b'El Ni\xf1o'
utf_8 b'El Ni\xc3\xb1o'
utf_16 b'\xff\xfeE\x001\x00 \x00N\x00i\x00\xf1\x00o\x00'
```

На рис. 4.1 показано, какие байты различные кодеки генерируют для некоторых символов: от буквы «А» до символа скрипичного ключа. Отметим, что последние три кодировки многобайтовые, переменной длины.

Звездочки на рис. 4.1 ясно показывают, что некоторые кодировки, в частности ASCII и даже многобайтовая кодировка GB2312, не способны представить все символы Unicode. Однако кодировки семейства UTF спроектированы так, чтобы была возможность представить любую кодовую позицию Unicode.

Кодировки на рис. 4.1 образуют достаточно репрезентативную выборку.

latin1, или iso8859_1

Важна, потому что лежит в основе других кодировок, в частности cp1252, и самого Unicode (отметим, что значения байтов latin1 повторяются в столбце cp1252 и даже в самих кодовых позициях).