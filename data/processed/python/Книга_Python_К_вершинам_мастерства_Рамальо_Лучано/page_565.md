---
source_image: page_565.png
page_number: 565
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 41.17
tokens: 11744
characters: 1955
timestamp: 2025-12-24T02:01:03.189993
finish_reason: stop
---

Сравнение потока и сопрограммы

бождается, так что второй поток может работать дальше.
9 Эта функция настраивает второй поток, отображает объект потока, выполняет долгое вычисление и завершает поток.
10 Отображаем объект второго потока. Вывод имеет вид <Thread(Thread-1, initial)>.
11 Запускаем второй поток.
12 Вызываем slow_function; при этом главный поток блокируется. А тем временем индикатор анимируется вторым потоком.
13 Изменяем состояние signal; тем самым мы завершаем цикл for внутри функции spin.
14 Ждем завершения потока spinner.
15 Вызываем функцию supervisor.

Отметим, что в Python специально отсутствует API для завершения потока. Чтобы остановить поток, ему нужно послать сообщение. В данном случае я использовал для этой цели атрибут signal.go: если главный поток присвоит ему значение false, то поток spinner это рано или поздно заметит и корректно завершится.

Теперь посмотрим, как можно реализовать такое же поведение с помощью декоратора @asyncio.coroutine вместо создания потока.

В разделе «Резюме» главы 16 отмечалось, что в пакете asyncio применяется более строгое определение «сопрограммы». В теле сопрограммы, совместимой с asyncio, необходимо использовать yield from, а не yield. Кроме того, сопрограмма в asyncio должна управляться вызывающей стороной, которая активирует ее с помощью yield from или передает одной из функций asyncio, таких, как asyncio.async(...) и другие, рассматриваемые ниже. Наконец, к сопрограммам необходимо применять декоратор @asyncio.coroutine, как показано в примерах.

Пример 18.2. spinner_asyncio.py: анимация текстового индикатора с помощью сопрограммы

import asyncio
import itertools
import sys

@asyncio.coroutine
def spin(msg): ②
    write, flush = sys.stdout.write, sys.stdout.flush
    for char in itertools.cycle('|/-\'):
        status = char + ' ' + msg
        write(status)
        flush()
        write('\x08' * len(status))
        try:
            yield from asyncio.sleep(.1) ③