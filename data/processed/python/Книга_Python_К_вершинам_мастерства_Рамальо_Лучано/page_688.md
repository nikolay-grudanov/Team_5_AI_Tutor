---
source_image: page_688.png
page_number: 688
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 44.66
tokens: 11656
characters: 1591
timestamp: 2025-12-24T02:06:39.052787
finish_reason: stop
---

Глава 21. Метапрограммирование классов

В объектной модели Python классы являются объектами, поэтому каждый класс должен быть экземпляром какого-то другого класса. По умолчанию классы Python являются экземплярами класса type. Иными словами, type — метакласс для большинства встроенных и пользовательских классов:

```python
>>> 'spam'.__class__
<class 'str'>
>>> str.__class__
<class 'type'>
>>> from bulkfood_v6 import LineItem
>>> LineItem.__class__
<class 'type'>
>>> type.__class__
<class 'type'>
```

Чтобы избежать бесконечного спуска, type является экземпляром себя самого, как видно из последней строки. Обратите внимание — я не говорю, что str или LineItem наследуют классу type. Я утверждаю, что str и LineItem — экземпляры type. И все они являются подклассами object.

Возможно, рис. 21.2 поможет вам освоиться в этой странной реальности.

![Диаграммы наследования](https://i.imgur.com/3Q5z5QG.png)

Рис. 21.2. Обе диаграммы правильны. На левой показано, что str, type и LineItem — подклассы object. Из правой видно, что str, object и LineItem — экземпляры type, поскольку все они — классы

Между классами object и type имеется удивительная связь: object — экземпляр type, а type — подкласс object. Эта связь «магическая»: выразить ее средствами Python невозможно, потому что любой из этих классов должен существовать, прежде чем можно будет определить другой. И тот факт, что type является экземпляром самого себя, — тоже магия.

Помимо type, в стандартной библиотеке существует еще несколько метаклассов, например ABCMeta и Enum. В следующем фрагменте кода показано, что классом