---
source_image: page_253.png
page_number: 253
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 42.00
tokens: 11729
characters: 1685
timestamp: 2025-12-24T01:46:22.115845
finish_reason: stop
---

Параметры функций как ссылки

([1, 2, 3, 4], [3, 4])
>>> t = (10, 20)
>>> u = (30, 40)
>>> f(t, u)  # 3
(10, 20, 30, 40)
>>> t, u
((10, 20), (30, 40))

1 Число x не изменилось.
2 Список a изменился.
3 Кортеж t не изменился.

С параметрами функций связан также вопрос о том, что бывает, когда значение по умолчанию имеет изменяемый тип.

Значения по умолчанию изменяемого типа: неудачная мысль

Необязательные параметры, имеющие значения по умолчанию, — замечательная возможность, которую можно использовать в определениях функций для обеспечения обратной совместимости API. Однако не следует использовать в качестве значений по умолчанию изменяемые объекты.

Для иллюстрации возникающей проблемы мы в примере 8.12 взяли класс Bus из примера 8.8 и изменили в нем метод __init__, получив новый класс HauntedBus. Но решили поумничать и вместо значения по умолчанию passengers=None задать passengers=[], избавившись тем самым от предложения if в предыдущем варианте __init__. Такое «умничанье» приводит к беде.

Пример 8.12. Простой класс, иллюстрирующий опасности изменяемых значений по умолчанию

class HauntedBus:
    """Автобус, облюбованный пассажирами-призраками"""
    def __init__(self, passengers=[]):  # 1
        self.passengers = passengers  # 2
    def pick(self, name):
        self.passengers.append(name)  # 3
    def drop(self, name):
        self.passengers.remove(name)

1 Если аргумент passengers не передан, то этот параметр связывается с объектом списка по умолчанию, который первоначально пуст.
2 В результате этого присваивания self.passengers становится синонимом passengers, который сам является синонимом списка по умолчанию, если аргумент passengers не передан.