---
source_image: page_671.png
page_number: 671
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 55.46
tokens: 11962
characters: 2414
timestamp: 2025-12-24T02:06:01.402011
finish_reason: stop
---

Строка документации дескриптора и перехват удаления

Неспециальные методы можно замаскировать атрибутами экземпляра

Поскольку в функциях и методах реализован только метод __get__, они не перехватывают попытки установить одноименные атрибуты экземпляра, так что после простого присваивания my_obj.the_method = 7 последующий доступ к the_method через данный экземпляр вернет число 7, хотя на других экземплярах это никак не отразится. Однако на специальные методы это не распространяется. Интерпретатор ищет специальные методы только в самом классе, т. е. repr(x) всегда вычисляется как x.__class__.__repr__(x), так что установка атрибута __repr__, определенного в x, не влияет на результат repr(x). По той же причине существование атрибута с именем __getattr__ в экземпляре не испортит обычный алгоритм доступа к атрибутам.

Может показаться, что простота переопределения неспециальных методов в экземплярах влечет за собой хрупкость дизайна и ошибки, но в моей 15-летней практике программирования на Python это ни разу не приводило к проблемам. С другой стороны, если вы часто создаете динамические атрибуты, имена которых берутся из данных, не контролируемых вами (как в предыдущих главах этой книги), то об этом следует помнить и, наверное, включить какую-то фильтрацию или экранирование имен, чтобы динамические атрибуты имели смысл.

Класс FrozenJSON из примера 19.6 защищен от маскирования методов атрибутами экземпляра, потому что в нем есть только специальные методы и метод класса build. Методы класса безопасны, если обращение к ним производится только через класс, как в выражении FrozenJSON.build в примере 19.6 — которое я впоследствии заменил методом __new__ в примере 19.7. Класс Record (примеры 19.9 и 19.11) и его подклассы также безопасны: в них используются только специальные методы, методы класса, статические методы и свойства. Свойства являются переопределяющими дескрипторами, поэтому не могут быть замещены атрибутами экземпляра.

В заключение рассмотрим два особенности свойств, которые не были освещены в контексте дескрипторов: документирование и обработка попыток удалить управляемый атрибут.

Строка документации дескриптора и перехват удаления

Строка документации дескрипторного класса нужна для документирования экземпляров дескриптора в управляемом классе. На рис. 20.6 показано, как выглядит справка по классу LineItem с дескрипторами Quantity и NonBlank из примеров 20.6 и 20.7.