---
source_image: page_411.png
page_number: 411
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 53.26
tokens: 12085
characters: 2515
timestamp: 2025-12-24T01:53:59.926974
finish_reason: stop
---

Операторы сравнения

• Для прямых и инверсных вызовов служит один и тот же набор методов. Правила приведены в табл. 13.2. Например, в случае оператора == как прямой, так и инверсный вызов обращаются к методу __eq__, но изменяется порядок аргументов. А прямой вызов __gt__ сопровождается инверсным вызовом __lt__ с переставленными аргументами.
• В случае == и !=, если инверсный вызов завершается ошибкой, то Python сравнивает идентификаторы объектов, а не возбуждает исключение TypeError.

Таблица 13.2. Операторы сравнения: инверсные методы вызываются, когда первый вызов вернул NotImplemented

<table>
  <tr>
    <th>Группа</th>
    <th>Инфиксный оператор</th>
    <th>Прямой вызов метода</th>
    <th>Инверсный вызов метода</th>
    <th>Запасной вариант</th>
  </tr>
  <tr>
    <td rowspan="2">Равенство</td>
    <td>a == b</td>
    <td>a.__eq__(b)</td>
    <td>b.__eq__(a)</td>
    <td>Вернуть id(a) == id(b)</td>
  </tr>
  <tr>
    <td>a != b</td>
    <td>a.__ne__(b)</td>
    <td>b.__ne__(a)</td>
    <td>Вернуть not (a == b)</td>
  </tr>
  <tr>
    <td rowspan="4">Порядок</td>
    <td>a > b</td>
    <td>a.__gt__(b)</td>
    <td>a.__lt__(b)</td>
    <td>Возбудить TypeError</td>
  </tr>
  <tr>
    <td>a < b</td>
    <td>a.__lt__(b)</td>
    <td>a.__gt__(b)</td>
    <td>Возбудить TypeError</td>
  </tr>
  <tr>
    <td>a >= b</td>
    <td>a.__ge__(b)</td>
    <td>a.__le__(b)</td>
    <td>Возбудить TypeError</td>
  </tr>
  <tr>
    <td>a <= b</td>
    <td>a.__le__(b)</td>
    <td>a.__ge__(b)</td>
    <td>Возбудить TypeError</td>
  </tr>
</table>

Новое поведение в Python 3

Запасной вариант для всех операторов сравнения изменился по сравнению с Python 2. В случае __ne__ Python 3 теперь возвращает результат, противоположный __eq__. Для операторов сравнения на больше-меньше Python 3 возбуждает исключение TypeError с сообщением вида 'unorderable types: int() < tuple()'. В Python 2 эти операторы давали странные результаты, т. к принимали во внимание типы и идентификаторы объектов и делали это отнюдь не очевидным образом. Однако же сравнивать, к примеру, int и tuple вряд ли имеет смысл, поэтому возбуждение исключения TypeError в таких случаях, безусловно, улучшает язык.

Имея в виду эти правила, давайте улучшим поведение метода Vector.__eq__, которое в файле vector_v5.py (пример 10.16) было закодировано следующим образом:

class Vector:
    # много строк опущено
    def __eq__(self, other):
        return (len(self) == len(other) and
                all(a == b for a, b in zip(self, other)))