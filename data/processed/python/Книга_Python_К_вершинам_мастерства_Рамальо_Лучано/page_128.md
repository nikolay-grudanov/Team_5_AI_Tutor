---
source_image: page_128.png
page_number: 128
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 38.34
tokens: 11803
characters: 1978
timestamp: 2025-12-24T01:40:31.790332
finish_reason: stop
---

UTF-16 заменила первоначальную 16-разрядную кодировку в Unicode 1.0 – UCS-2 – еще в 1996 году. UCS-2 все еще развернута во многих системах, но поддерживает только кодовые позиции с номерами до U+FFFF. На момент выхода версии стандарта Unicode 6.3 более 50% распределенных кодовых позиций имеют номера больше U+10000, сюда относятся и столь популярные смайлики.

Завершив обзор распространенных кодировок, перейдем к проблемам, возникающим в процессе кодирования и декодирования.

Проблемы кодирования и декодирования

Существует общее исключение UnicodeError, но возникающая ошибка почти всегда более специфична: либо UnicodeEncodeError (в случае преобразования str в двоичную последовательность), либо UnicodeDecodeError (в случае чтения двоичной последовательности в str). При загрузке модулей Python может также возникать исключение SyntaxError в случае неожиданной кодировки исходного кода. В следующих разделах мы расскажем, как обрабатывать такие ошибки.

Первое, на что нужно обращать внимание, получив ошибку Unicode, — точный тип исключения. Это UnicodeEncodeError, UnicodeDecodeError или какая-то другая ошибка (например, SyntaxError), свидетельствующая об ошибке кодирования? Это главное, что нужно знать для решения проблемы.

Обработка UnicodeEncodeError

В большинстве кодеков, не входящих в семейство UTF, представлено только небольшое подмножество символов Unicode. Если в ходе преобразования текста в байты оказывается, что символ отсутствует в конечной кодировке, то возбуждается исключение UnicodeEncodeError, если только методу или функции кодировки не передан аргумент errors, обеспечивающий специальную обработку. Поведение обработчиков ошибок демонстрируется в примере 4.6.

Пример 4.6. Кодирование текста в байты: успешное завершение и обработка ошибок

```python
>>> city = 'São Paulo'
>>> city.encode('utf_8') ①
b'S\xc3\xa3o Paulo'
>>> city.encode('utf_16')
b'\xff\xfeS\x00\xe3\x00o\x00 \x00P\x00a\x00u\x00l\x00o\x00'
>>> city.encode('iso8859_1') ②
```