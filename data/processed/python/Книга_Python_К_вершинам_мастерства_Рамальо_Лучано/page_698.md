---
source_image: page_698.png
page_number: 698
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 54.37
tokens: 11858
characters: 2270
timestamp: 2025-12-24T02:07:15.557350
finish_reason: stop
---

cls.mro()

Интерпретатор вызывает этот метод при построении класса, чтобы получить кортеж суперклассов, который хранится в атрибуте класса __mro__. Метакласс может переопределить этот метод и задать другой порядок разрешения методов в конструируемом классе.

Ни один из упоминаемых в этом разделе атрибутов, не включается в список, возвращаемый функцией dir(...).

На этом мы завершаем изучение метапрограммирования классов. Это обширная тема, которую я смог лишь поверхностно затронуть. Но для того и существуют разделы «Дополнительная литература».

Резюме

Метапрограммирование классов — это техника динамического создания или изменения классов. Классы в Python являются полноценными объектами, поэтому в самом начале главы мы показали, как функция может создать класс, вызвав встроенный метакласс type.

В следующем разделе мы вернулись к классу LineItem с дескрипторами из главы 20, чтобы решить оставленную на потом проблему: как сгенерировать имена атрибутов хранения, чтобы они отражали имена управляемых атрибутов (например, _Quantity#price вместо _Quantity#1). Решение заключалось в том, чтобы использовать декоратор класса — функцию, которая получает только что построенный класс и имеет возможность инспектировать его, изменять и даже подменять другим классом.

Затем мы перешли к обсуждению вопроса о том, когда выполняются различные части исходного кода модуля. Мы видели, что существует перекрытие между так называемыми «этапом импорта» и «этапом выполнения», но в любом случае компиляция предложения import влечет за собой выполнение большого объема кода. Понимание того, что когда выполняется, критически важно, а для того чтобы проиллюстрировать некоторые тонкие правила, мы предложили проработать ряд упражнений.

Далее мы занялись темой метаклассов. Мы видели, что любой класс является экземпляром класса type или его подкласса, т. е. это «корневой метакласс» в языке. Одно из упражнений предназначалось для того, чтобы показать, как метакласс может модифицировать иерархию классов — в отличие от декоратора класса, который действует только на один класс и может неказать никакого влияния на его потомков.

Первым практическим применением метакласса стало решение проблемы имен атрибутов хранения в классе LineItem. Получившийся код оказался несколько