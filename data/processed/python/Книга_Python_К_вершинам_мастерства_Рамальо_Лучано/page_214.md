---
source_image: page_214.png
page_number: 214
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 38.45
tokens: 11763
characters: 1768
timestamp: 2025-12-24T01:44:33.226532
finish_reason: stop
---

Пример 7.4. Функция, читающая локальную и глобальную переменную

```python
>>> def f1(a):
...     print(a)
...     print(b)
...
>>> f1(3)
3
Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
    File "<stdin>", line 3, in f1
NameError: global name 'b' is not defined
```

Ошибка не должна вызывать удивления. Но если продолжить пример 7.4 и присвоить значение глобальной переменной b, а затем вызвать f1, то все заработает:

```python
>>> b = 6
>>> f1(3)
3
6
```

А теперь рассмотрим пример, который, возможно вас удивит.

Взгляните на функцию f2 в примере 7.5. Первые две строчки в ней такие же, как в f1 из примера 7.4, но затем мы присваиваем значение переменной b. Однако функция завершается с ошибкой на втором предложении print, до присваивания.

Пример 7.5. Переменная b локальна, потому что ей присваивается значение в теле функции

```python
>>> b = 6
>>> def f2(a):
...     print(a)
...     print(b)
...     b = 9
...
>>> f2(3)
3
Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
    File "<stdin>", line 3, in f2
UnboundLocalError: local variable 'b' referenced before assignment
```

Отметим, что число 3 все же напечатано, следовательно, предложение print(a) было выполнено. Но вот до print(b) дело так и не дошло. Впервые увидев этот пример, я очень удивился, так как думал, что 6 будет напечатано — ведь существует глобальная переменная b, а присваивание локальной b производится уже после print(b).

Однако же, компилируя тело этой функции, Python решает, что b — локальная переменная, т. к. ей присваивается значение внутри функции. Сгенерированный байт-код отражает это решение и пытается выбрать b из локального контекста. Позже, во время вызова f2(3) тело f2 успешно находит и печатает локальную пе-