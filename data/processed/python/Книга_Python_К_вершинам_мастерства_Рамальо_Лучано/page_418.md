---
source_image: page_418.png
page_number: 418
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 40.16
tokens: 11832
characters: 2180
timestamp: 2025-12-24T01:54:05.884390
finish_reason: stop
---

other_iterable = other.inspect() ⑤
else:
    try:
        other_iterable = iter(other) ⑥
    except TypeError: ⑦
        self_cls = type(self).__name__
        msg = "right operand in += must be {!r} or an iterable"
        raise TypeError(msg.format(self_cls))
    self.load(other_iterable) ⑧
return self ⑨

① В документе «PEP 8 – Style Guide for Python Code» (https://www.python.org/dev/peps/pep-0008/#imports) рекомендуется ставить импорт из стандартной библиотеки раньше импорта собственных модулей.
② AddableBingoCage расширяет BingoCage.
③ Наш метод __add__ работает, только когда вторым операндом является объект класса Tombola.
④ Получаем элементы из other, если это экземпляр Tombola
⑤ В противном случае пытаемся получить итератор для other.5
⑥ В случае ошибки возбуждаем исключение, объясняя пользователю, что делать. По возможности сообщения об ошибках должны содержать ясное указание, как решить проблему.
⑦ Если мы дошли до этого места, то можем загрузить объект other_iterable в self.
⑧ Очень важно: специальные методы операторов составного присваивания должны возвращать self.

Резюмировать идею операторов «на месте» можно, сравнив предложения return, которые возвращают результаты в методах __add__ и __iadd__ из примера 13.18:

__add__
Результат порождается путем вызова конструктора AddableBingoCage для создания нового экземпляра.

__iadd__
Результат порождается путем возврата self после модификации.

И последнее замечание к примеру 13.18: в классе AddableBingoCage я сознательно не стал реализовывать метод __radd__, т. к. в нем нет необходимости. Прямой метод __add__ работает, только когда правый операнд имеет тот же тип, что левый, поэтому если Python попытается вычислить a + b, где a принадлежит типу AddableBingoCage, а b — нет, то получит в ответ NotImplemented — быть может, сумеет справиться класс объекта b. Но при вычислении выражения b + a, когда b не принадлежит типу AddableBingoCage и возвращает NotImplemented, лучше позволить

5 Встроенная функция iter рассматривается в следующей главе. Здесь я мог бы написать tuple(other), и это работало бы, но ценой построения нового кортежа, хотя методу .load(...) нужно только обойти свой аргумент.