---
source_image: page_664.png
page_number: 664
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 69.84
tokens: 12065
characters: 2805
timestamp: 2025-12-24T02:06:01.767237
finish_reason: stop
---

он перехватывает все попытки присвоить значение атрибутам экземпляра. Именно так реализован дескриптор в примере 20.2. Свойства также являются переопределяющими дескрипторами: если мы не предоставим свою функцию установки, то по умолчанию будет использован метод __set__ из класса property, который возбуждает исключение AttributeError, показывающее, что атрибут можно только читать. Эксперименты с переопределяющим дескриптором показаны в примере 20.9.

Пример 20.9. Поведение переопределяющего дескриптора: obj.over — экземпляр класса Overriding (из примера 20.8)

```python
>>> obj = Managed()  # Создаем объект Managed для тестирования.
>>> obj.over  # obj.over активирует метод дескриптора __get__, передавая ему управляемый экземпляр obj во втором аргументе.
-> Overriding.__get__(<Overriding object>, <Managed object>, <class Managed>)
>>> Managed.over  # Managed.over активирует метод дескриптора __get__, передавая ему None во втором аргументе (instance).
-> Overriding.__get__(<Overriding object>, None, <class Managed>)
>>> obj.over = 7  # Присваивание obj.over активирует метод дескриптора __set__, передавая ему значение 7 в последнем аргументе.
-> Overriding.__set__(<Overriding object>, <Managed object>, 7)
>>> obj.over  # Чтение obj.over по-прежнему активирует метод дескриптора __get__.
-> Overriding.__get__(<Overriding object>, <Managed object>, <class Managed>)
>>> obj.__dict__['over'] = 8  # Установка значения непосредственно в obj.__dict__ в обход дескриптора.
>>> vars(obj)  # Проверяем, что значение попало в obj.__dict__ и ассоциировано с ключом over.
{'over': 8}
>>> obj.over  # Однако даже при наличии атрибута экземпляра с именем over дескриптор Managed.over все равно переопределяет попытки читать obj.over.
```

1 Создаем объект Managed для тестирования.
2 obj.over активирует метод дескриптора __get__, передавая ему управляемый экземпляр obj во втором аргументе.
3 Managed.over активирует метод дескриптора __get__, передавая ему None во втором аргументе (instance).
4 Присваивание obj.over активирует метод дескриптора __set__, передавая ему значение 7 в последнем аргументе.
5 Чтение obj.over по-прежнему активирует метод дескриптора __get__.
6 Установка значения непосредственно в obj.__dict__ в обход дескриптора.
7 Проверяем, что значение попало в obj.__dict__ и ассоциировано с ключом over.
8 Однако даже при наличии атрибута экземпляра с именем over дескриптор Managed.over все равно переопределяет попытки читать obj.over.

Переопределяющий дескриптор без __get__

Обычно в переопределяющих дескрипторах реализованы оба метода __set__ и __get__, но, как мы видели в примере 20.1, можно также реализовать только __set__. В таком случае дескриптор обрабатывает только операцию записи. Чтение дескриптора через экземпляр вернет сам объект дескриптора, потому что не