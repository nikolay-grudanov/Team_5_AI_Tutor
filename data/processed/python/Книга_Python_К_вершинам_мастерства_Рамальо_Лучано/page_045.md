---
source_image: page_045.png
page_number: 45
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 48.26
tokens: 11840
characters: 2014
timestamp: 2025-12-24T01:36:44.682689
finish_reason: stop
---

Списковое включение и генераторные выражения

Пример 2.5. Инициализация кортежа и массива с помощью генераторного выражения

>>> symbols = '§¢£¥€¤'
>>> tuple(ord(symbol) for symbol in symbols)
(36, 162, 163, 165, 8364, 164)
>>> import array
>>> array.array('I', (ord(symbol) for symbol in symbols))
array('I', [36, 162, 163, 165, 8364, 164])

1 Если генераторное выражение — единственный аргумент функции, то дублировать круглые скобки необязательно.
2 Конструктор массива принимает два аргумента, поэтому скобки вокруг генераторного выражения обязательны. Первый аргумент конструктора array определяет тип хранения чисел в массив, мы вернемся к этому вопросу в разделе «Массивы» ниже.

В примере 2.6 генераторное выражение используется для порождения декартова произведения и последующей распечатки ассортимента футболок двух цветов и трех размеров. В отличие от примера 2.4, этот список футболок ни в какой момент не находится в памяти: генераторное выражение отдает циклу for по одному элементу. Если бы списки, являющиеся сомножителями декартова произведения, содержали по 1000 элементов, то применение генераторного выражения позволило бы сэкономить память за счет отказа от построения списка из миллиона элементов с единственной целью его обхода в цикле for.

Пример 2.6. Порождение декартова произведения генераторным выражением

>>> colors = ['black', 'white']
>>> sizes = ['S', 'M', 'L']
>>> for tshirt in ('%s %s' % (c, s) for c in colors for s in sizes):
...     print(tshirt)
...
black S
black M
black L
white S
white M
white L

1 Генераторное выражение отдает по одному элементу за раз; список, содержащий все шесть вариаций футболки, не создается.

В главе 14 подробно объясняется, как работают генераторы. Здесь же мы только хотели показать использование генераторных выражений для инициализации последовательностей, отличных от списков, а также для вывода последовательности, не хранящейся целиком в памяти.

Перейдем теперь к следующему фундаментальному типу последовательностей в Python: кортежу.