---
source_image: page_674.png
page_number: 674
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 59.02
tokens: 11936
characters: 2329
timestamp: 2025-12-24T02:06:15.140419
finish_reason: stop
---

Версия Python 3 с практическими примерами рассматривается в книге Дэвида Бизли и Брайана К. Джонса «Python Cookbook», издание 3 (O'Reilly), где есть много рецептов, иллюстрирующих дескрипторы. Особо мне хочется отметить рецепты 6.12 «Чтение вложенных структур и имеющих переменную длину двоичных структур», 8.10 «Свойства с отложенным вычислением», 8.13 «Реализация модели данных или системы типов» и 9.9 «Определение декораторов как классов». В последнем рецепте глубоко освещаются вопросы взаимодействия между декораторами функций, дескрипторами и методами и объясняется, почему декоратор функции, реализованный в виде класса с методом __call__, должен также реализовывать метод __get__, если его предполагается применять для декорирования не только функций, но и методов.

Поговорим

Проблема self

«Чем хуже, тем лучше» — философия проектирования, описанная Ричардом П. Гэбриелом в работе «The Rise of Worse is Better» (http://bit.ly/1HGwvIZ). Важнейший приоритет в этой философии — «простота». Вот как это звучит в изложении Гэбриела:

Реализация и интерфейс должны быть простыми. Простота реализации даже важнее простоты интерфейса. Простота — самое важное требование при выборе дизайна.

Я полагаю, что требование явно задавать self первым аргументом метода — применение принципа «чем хуже, тем лучше» в Python. Простота — даже элегантность — реализации достигается за счет пользовательского интерфейса: сигнатура метода — def zfill(self, width) — визуально не соответствует его вызову — pobox.zfill(8).

Это соглашение — и использование идентификатора self — впервые появилось в языке Modula-3, но есть и отличие: в Modula-3 интерфейсы объявляются отдельно от реализации, и в объявлении интерфейса аргумент self опущен, поэтому, с точки зрения пользователя, у метода в объявлении интерфейса ровно столько же аргументов, сколько задается при его вызове.

В этом отношении были улучшены хотя бы сообщения об ошибках: если вызывается определенный пользователем метод с одним аргументом, кроме self, — obj.meth() — то в Python 2.7 возбуждается исключение TypeError с сообщением meth() takes exactly 2 arguments (1 given) (meth() принимает ровно 2 аргумента (здан 1)), тогда как в Python 3.4 текст сообщения более вразумителен, т. к. количество аргументов в нем не упоминается, а указывается имя недостающего аргумента: meth()