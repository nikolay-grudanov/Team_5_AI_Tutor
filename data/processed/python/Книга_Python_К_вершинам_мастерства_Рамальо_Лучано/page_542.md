---
source_image: page_542.png
page_number: 542
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 55.37
tokens: 11993
characters: 2062
timestamp: 2025-12-24T02:00:15.903922
finish_reason: stop
---

тором PyPy. По сравнению с эталоном — один рабочий процесс и интерпретатор CPython — получается ускорение в 7,8 раз.

Таблица 17.1. Время и коэффициент ускорения для примеров вычисления RC4 и SHA при количестве рабочих процессов от 1 до 4 на четырехъядерной машине с процессором Intel Core i7 2.7 ГГц. Использовалась версия Python 3.4

<table>
  <tr>
    <th>Рабочих процессов</th>
    <th>Время работы RC4</th>
    <th>Коэффициент для RC4</th>
    <th>Время работы SHA</th>
    <th>Коэффициент для SHA</th>
  </tr>
  <tr>
    <td>1</td>
    <td>11.48 с</td>
    <td>1.00</td>
    <td>22.66 с</td>
    <td>1.00</td>
  </tr>
  <tr>
    <td>2</td>
    <td>8.65 с</td>
    <td>1.33</td>
    <td>14.90 с</td>
    <td>1.52</td>
  </tr>
  <tr>
    <td>3</td>
    <td>6.04 с</td>
    <td>1.90</td>
    <td>11.91 с</td>
    <td>1.90</td>
  </tr>
  <tr>
    <td>4</td>
    <td>5.58 с</td>
    <td>2.06</td>
    <td>10.89 с</td>
    <td>2.08</td>
  </tr>
</table>

Если вы решаете счетные задачи на Python, то обязательно по-пробуйте интерпретатор PyPy (http://pypy.org/). При использовании PyPy скрипт arcfour_futures.py работал от 3,8 до 5,1 раз быстрее, в зависимости от числа рабочих процессов. Я проводил тестирование на версии PyPy 2.4.0, совместимой с Python 3.2.5, так что в ее стандартной библиотеке пакет concurrent.futures имеется.

Теперь давайте исследуем поведение пула потоков на демонстрационной программе, которая создает пул с тремя потоками, выполняющими пять вызываемых объектов, которые выводят сообщения с временными метками.

Эксперименты с Executor.map

Запустить несколько вызываемых объектов параллельно проще всего с помощью функции Executor.map, которую мы уже видели в примере 17.3. Скрипт в примере 17.6 демонстрирует детали работы Executor.map. Его результаты показаны в примере 17.7.

Пример 17.6. demo_executor_map.py: простая демонстрация метода map объекта ThreadPoolExecutor

from time import sleep, strftime
from concurrent import futures

def display(*args):
    print(strftime('[%H:%M:%S]'), end=' ')
    print(*args)

def loiter(n):