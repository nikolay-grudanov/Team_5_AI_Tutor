---
source_image: page_465.png
page_number: 465
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 59.52
tokens: 12007
characters: 2649
timestamp: 2025-12-24T01:56:49.792670
finish_reason: stop
---

Генераторы как сопрограммы

А если скрипту isis2json.py понадобится поддержать еще один формат ввода — скажем, MARCXML, который используется в Библиотеке конгресса США для представления данных в формате ISO-2709, — то можно будет без труда добавить третью генераторную функцию, которая реализует логику его чтения, ничего не меняя в сложной функции write_json.

Это, конечно, не высшая математика, но реальный пример, когда с помощью генераторов удалось построить гибкое решение для обработки базы данных в виде потока записей, так что потребление памяти остается низким вне зависимости от объема данных. Любой программист, работающий с большими наборами данных, найдет много возможностей использовать генераторы на практике.

В следующем разделе речь пойдет об аспекте генераторов, который мы до сих пор не затрагивали. Читайте дальше, если хотите узнать, почему.

Генераторы как сопрограммы

Примерно через пять лет после появления в версии Python 2.2 генераторных функций с ключевым словом yield в версии 2.5 был реализован документ «PEP 342 – Coroutines via Enhanced Generators» (https://www.python.org/dev/peps/pep-0342/). В этом предложении были описаны дополнительные методы и функциональность объектов-генераторов и, в первую очередь, метод .send().

Как и __next__() , метод .send() продолжает выполнение генератора до следующего ключевого слова yield, но еще позволяет клиенту посылать генератору данные: аргумент, переданный .send(), становится значением, которое отдает выражение yield внутри тела генераторной функции. Другими словами, .send() обеспечивает двусторонний обмен между генератором и клиентским кодом — в противоположность __next__() , который позволяет клиенту только получать данные от генератора.

Это «усовершенствование» настолько кардинально, что фактически изменяет природу генераторов: при таком использовании они становятся сопрограммами. Дэвид Бизли — пожалуй, самый плодовитый член сообщества Python во всем, что касается сопрограмм, — предупреждал в знаменитом пособии, представленном на конференции PyCon US 2009 (http://www.dabeaz.com/coroutines/):

• генераторы порождают данные для итерирования;
• сопрограммы являются потребителями данных;
• если не хотите, чтобы сорвало крышу, не путайте эти две концепции;
• сопрограммы не имеют никакого отношения к итерированию;
• Примечание: у применения yield для порождения значения в сопрограмме есть свои резоны, но с итерированием они не связаны12.

— Дэвид Бизли

«A Curious Course on Coroutines and Concurrency»

12 Слайд 33 «Keeping It Straight» из презентации «A Curious Course on Coroutines and Concurrency» (http://www.dabeaz.com/coroutines/Coroutines.pdf).