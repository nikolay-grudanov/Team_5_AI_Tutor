---
source_image: page_337.png
page_number: 337
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 36.40
tokens: 11679
characters: 1715
timestamp: 2025-12-24T01:50:07.288729
finish_reason: stop
---

Партизанское латание как средство реализации протокола...

return len(self._cards)

def __getitem__(self, position):
    return self._cards[position]

Добрая часть демонстраций в главе 1 работает, потому что Python специальным образом обрабатывает все, что хотя бы отдаленно напоминает последовательность. Итерирование в Python — это крайняя форма динамической типизации: интерпретатор пробует разные методы, чтобы выполнить обход объекта.

Теперь изучим еще один пример, подчеркивающий динамическую природу протоколов.

Партизанское латание как средство реализации протокола во время выполнения.

У класса FrenchDeck из примера 11.4 есть существенный изъян: колоду нельзя перетасовать. Много лет назад, впервые написав этот пример, я реализовал метод shuffle. Позже меня посетило питоническое озарение: если FrenchDeck ведет себя как последовательность, то ему не нужен собственный метод shuffle, потому что уже имеется функция random.shuffle, в документации по которой (https://docs.python.org/3/library/random.html#random.shuffle) написано: «Перетасовывает последовательность x на месте».

Если следовать устоявшимся протоколам, то будет больше шансов воспользоваться кодом, уже имеющимся в стандартной библиотеке или написанным кем-то еще, — благодаря динамической типизации.

Стандартная функция random.shuffle используется следующим образом:

>>> from random import shuffle
>>> l = list(range(10))
>>> shuffle(l)
[5, 2, 9, 7, 8, 3, 1, 4, 0, 6]

Но попытавшись перетасовать объект FrenchDeck, мы получим исключение (пример 11.5).

Пример 11.5. random.shuffle не может работать с объектом FrenchDeck

>>> from random import shuffle
>>> from frenchdeck import FrenchDeck
>>> deck = FrenchDeck()
>>> shuffle(deck)