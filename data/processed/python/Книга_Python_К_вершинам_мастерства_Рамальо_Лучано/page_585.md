---
source_image: page_585.png
page_number: 585
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 47.87
tokens: 11841
characters: 2309
timestamp: 2025-12-24T02:01:57.042579
finish_reason: stop
---

Улучшение скрипта загрузки на основе asyncio

Использование исполнителя для предотвращения блокировки цикла обработки событий

В сообществе Python как-то не обращают внимания на тот факт, что доступ к локальной файловой системе — блокирующая операция, оправдываясь тем, что задержки в этом случае несравнимы с возникающими при доступе к сети (которые к тому же опасно непредсказуемы). Напротив, программирующим в среде Node.js постоянно напоминают, что все функции доступа к файловой системе блокирующие, — поскольку в их сигнатурах указан обратный вызов. В табл. 18.1 было показано, что блокировка при дисковом вводе-выводе обходится в миллионы впустую растраченных тактов процессора, и это вполне может оказать заметное влияние на производительность приложения.

В примере 18.7 блокирующей является функция save_flag. В многопоточной версии скрипта (пример 17.14) save_flag блокирует функцию download_one, но это лишь один из нескольких рабочих потоков. За кулисами блокирующий вызов ввода-вывода освобождает GIL, так что другой поток получает возможность поработать. Однако в скрипте flags2_asyncio.py функция save_flag блокирует единственный поток, который наш код разделяет с циклом обработки событий asyncio, т. е. на время сохранения файла все приложение «зависает». Решить проблему позволяет метод run_in_executor объекта, представляющего цикл обработки событий.

В реализации цикла обработки событий asyncio есть исполнитель на основе пула потоков, а метод run_in_executor дает возможность передать ему вызываемые объекты, подлежащие выполнению. Чтобы применить эту идею к нашему примеру, достаточно изменить всего несколько строк в сопрограмме download_one.

Пример 18.9. flags2_asyncio_executor.py: использование исполнителя по умолчанию на основе пула потоков для выполнения функции save_flag

@asyncio.coroutine
def download_one(cc, base_url, semaphore, verbose):
    try:
        with (yield from semaphore):
            image = yield from get_flag(base_url, cc)
    except web.HTTPNotFound:
        status = HTTPStatus.not_found
        msg = 'not found'
    except Exception as exc:
        raise FetchError(cc) from exc
    else:
        loop = asyncio.get_event_loop() ①
        loop.run_in_executor(None, ②
            save_flag, image, cc.lower() + '.gif') ③
        status = HTTPStatus.ok