---
source_image: page_536.png
page_number: 536
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 52.91
tokens: 12005
characters: 2976
timestamp: 2025-12-24T01:59:54.686050
finish_reason: stop
---

Глава 17. Параллелизм и будущие объекты

торинг, встречающийся при написании параллельного кода: преобразовать тело последовательного цикла for в функцию, которая будет вызываться параллельно.

Библиотека называется concurrency.futures, но пока мы никаких «futures» не видели. Возникает законный вопрос: где же они? Ответ дан в следующем разделе.

Где находятся будущие объекты?

Будущие объекты — важнейшие компоненты внутреннего механизма пакетов concurrent.futures и asyncio, но не всегда они видны пользователям этих библиотек. В примере 17.3 будущие объекты используются за кулисами, но мой код напрямую к ним не обращается. В этом разделе сообщаются общие сведения о будущих объектах, с примером их практического применения.

В стандартной библиотеке для Python 3.4 есть два класса с именем Future: concurrent.futures.Future и asyncio.Future. Они служат одной и той же цели: экземпляр класса Future представляет некое отложенное вычисление, завершившееся или нет. Это аналог класса Deferred в Twisted, класса Future в Tornado и объектов Promise в различных библиотеках на JavaScript.

Будущие объекты инкапсулируют ожидающие операции, так что их можно помещать в очередь, опрашивать состояние завершения и получать результаты (или исключения), когда они станут доступны.

Важно понимать, что ни вы, ни я не должны создавать будущие объекты: предполагается, что их создает исключительно используемая библиотека, будь то concurrent.futures или asyncio. Легко понять, почему это так: объект Future представляет нечто, что должно случиться когда-то в будущем, а единственный способ гарантировать, что это действительно случится, — запланировать выполнение объекта. Поэтому экземпляры класса concurrent.futures.Future создаются только в результате планирования выполнения какой-то операции с помощью одного из подклассов concurrent.futures.Executor. Например, метод Executor.submit() принимает вызываемый объект, планирует его выполнение и возвращает будущий объект.

Клиентский код не должен изменять состояние будущего объекта: его изменяет каркас распараллеливания, когда представляемое этим объектом вычисление завершится, а мы не можем управлять тем, когда это произойдет.

Оба класса Future имеют неблокирующий метод .done(), который возвращает булево значение, показывающее завершился вызываемый объект, связанный с экземпляром этого класса, или нет. Но вместо того чтобы самому проверять состояние, клиент обычно просит, чтобы его уведомили. Поэтому в обоих классах Future имеется метод .add_done_callback(): если передать ему вызываемый объект, то он будет вызван, когда будущий объект завершится, а в качестве единственного аргумента будет передан сам этот будущий объект.

Существует также метод .result(), который одинаково работает в обоих классах в ситуации, когда выполнение будущего объекта завершено: либо возвращает результат вызываемого объекта, либо повторно возбуждает исключение, возникшее во время выполнения. Но если выполнение будущего объекта еще не