---
source_image: page_376.png
page_number: 376
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 29.62
tokens: 11727
characters: 1767
timestamp: 2025-12-24T01:51:50.472882
finish_reason: stop
---

Глава 12. Наследование: хорошо или плохо

работает в соответствии с документацией только потому, что рассматривается как особый случай.

Проблема не ограничивается вызовами изнутри объекта — когда self.get() вызывает self.__getitem__() — но возникает и для переопределенных методов других классов, которые должны вызываться из встроенных методов. Пример 12.2 основан на примере из документации по PyPy (http://bit.ly/1JHNmhX).

Пример 12.2. Метод __getitem__ из класса AnswerDict игнорируется методом dict.update

```python
>>> class AnswerDict(dict):
...     def __getitem__(self, key): # 1
...         return 42
...
>>> ad = AnswerDict(a='foo') # 2
>>> ad['a'] # 3
42
>>> d = {}
>>> d.update(ad) # 4
>>> d['a'] # 5
'foo'
>>> d
{'a': 'foo'}
```

1 Метод AnswerDict.__getitem__ для любого ключа возвращает 42.
2 ad — экземпляр AnswerDict, инициализированный парой ('a', 'foo').
3 ad['a'] возвращает 42, как и ожидалось.
4 d — экземпляр класса dict, обновленный объектом ad.
5 Метод dict.update игнорирует наш метод AnswerDict.__getitem__.

Прямое наследование таким встроенными типам, как dict, list или str, чревато ошибками, потому что встроенные методы, как правило, игнорируют написанные пользователем переопределенные методы. Вместо создания подклассов встроенных объектов наследуйте свои классы от классов в модуле collections (http://docs.python.org/3/library/collections.html) — UserDict, UserList и UserString, которые специально предназначены для беспроблемного наследования.

Если наследовать подклассу collections.UserDict, а не dict, то проблемы, продемонстрированные в примерах 12.1 и 12.2, исчезают.

Пример 12.3. Классы DoppelDict2 и AnswerDict2 работают, как и ожидалось, потому что расширяют UserDict, а не dict

```python
>>> import collections
>>>