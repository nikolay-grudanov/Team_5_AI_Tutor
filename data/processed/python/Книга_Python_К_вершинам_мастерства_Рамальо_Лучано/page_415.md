---
source_image: page_415.png
page_number: 415
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 34.78
tokens: 11818
characters: 1687
timestamp: 2025-12-24T01:53:52.186215
finish_reason: stop
---

Операторы составного присваивания

Пример 13.15. Когда в левой части оператора составного присваивания находится неизменяемый объект, оператор создает новый экземпляр и производит перепривязку

```python
>>> v1 = Vector([1, 2, 3]) # 1
>>> v1_alias = v1 # 1
>>> id(v1) # 2
4302860128
>>> v1 += Vector([4, 5, 6]) # 3
>>> v1 # 4
Vector([5.0, 7.0, 9.0])
>>> id(v1) # 5
4302859904
>>> v1_alias # 6
Vector([1.0, 2.0, 3.0])
>>> v1 *= 11 # 7
>>> v1 # 8
Vector([55.0, 77.0, 99.0])
>>> id(v1)
4302858336
```

1 Создаем синоним, чтобы можно было проинспектировать объект Vector([1, 2, 3]) позже.
2 Запоминаем идентификатор исходного объекта vector, связанного с v1.
3 Производим составное сложение.
4 Результат ожидаемый...
5 ...но создан новый Vector.
6 Инспектируем v1_alias, чтобы убедиться, что исходный Vector не изменился.
7 Производим составное умножение.
8 Результат снова ожидаемый, но создан новый Vector.

Если в классе не реализованы операторы «на месте», перечисленные в табл. 13.1, то операторы составного присваивания — не более чем синтаксическая глазурь: a += b вычисляется точно так же, как a = a + b. Это ожидаемое поведение для неизменяемых типов и, если добавить метод __add__, то += будет работать безо всякого дополнительного кода.

Однако если все-таки реализовать метод оператора «на месте», например __iadd__, то он и будет вызван для вычисления выражения a += b. Как следует из названия, такие операторы изменяют сам левый операнд, а не создают новый объект-результат.

Специальные методы, вычисляемые на месте, никогда не следует реализовывать для неизменяемых типов и, в частности, нашего класса Vector. Это, в общем-то, очевидно, но лишний раз подчеркнуть не помешает.