---
source_image: page_278.png
page_number: 278
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 40.28
tokens: 11739
characters: 1719
timestamp: 2025-12-24T01:47:25.771912
finish_reason: stop
---

Если в классе не реализован метод __format__, то используется метод, унаследованный от object, который возвращает значение str(my_object). Поскольку в классе Vector2d есть метод __str__, это работает следующим образом:

```python
>>> v1 = Vector2d(3, 4)
>>> format(v1)
'(3.0, 4.0)'
```

Но если передать спецификатор формата, то object.__format__ возбудит исключение TypeError:

```python
>>> format(v1, '.3f')
Traceback (most recent call last):
    ...
TypeError: non-empty format string passed to object.__format__
```

Исправим это, реализовав собственный миниязык форматирования. Для начала предположим, что спецификатор формата, заданный пользователем, служит для форматирования каждой компоненты вектора. Вот какой результат мы хотим получить:

```python
>>> v1 = Vector2d(3, 4)
>>> format(v1)
'(3.0, 4.0)'
>>> format(v1, '.2f')
'(3.00, 4.00)'
>>> format(v1, '.3e')
'(3.000e+00, 4.000e+00)'
```

В примере 9.5 реализован метод __format__, дающий именно такой результат.

Пример 9.5. Метод Vector2d.format, попытка №1

```python
# inside the Vector2d class
def __format__(self, fmt_spec=''):
    components = (format(c, fmt_spec) for c in self) # 1
    return '({}, {})'.format(*components) # 2
```

1 Используем встроенную функцию format, чтобы применить fmt_spec к каждой компоненте вектора и построить итерируемый объект, порождающий отформатированные строки.
2 Подставляем отформатированные строки в шаблон '(x, y)'.

Теперь добавим в наш миниязык специальный форматный код: если спецификатор формата заканчивается буквой 'p', то будем отображать вектор в полярных координатах: <r, θ>, где r — модуль, а θ — угол в радианах. Остаток спецификатора формата (все, что предшествует 'p') используется, как и раньше.