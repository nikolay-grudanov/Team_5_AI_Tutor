---
source_image: page_305.png
page_number: 305
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 37.84
tokens: 11703
characters: 1687
timestamp: 2025-12-24T01:48:39.359150
finish_reason: stop
---

Vector, попытка № 2: последовательность, допускающая срезку

является последовательностью, в нашем случае таким атрибутом будет массив self._components. Для начала нас вполне устроят такие однолинейные методы __len__ и __getitem__:

class Vector:
    # много строк опущено
    # ...

    def __len__(self):
        return len(self._components)

    def __getitem__(self, index):
        return self._components[index]

После этих добавлений все показанные ниже операции работают:

>>> v1 = Vector([3, 4, 5])
>>> len(v1)
3
>>> v1[0], v1[-1]
(3.0, 5.0)
>>> v7 = Vector(range(7))
>>> v7[1:4]
array('d', [1.0, 2.0, 3.0])

Как видите, даже срезы поддерживаются — но не очень хорошо. Было бы лучше, если бы срез вектора также был экземпляром класса Vector, а не массивом. В старом классе FrenchDeck была такая же проблема: срез оказывался объектом класса list. Но в случае Vector мы утрачиваем значительную часть функциональности, если операция среза возвращает простой массив.

Рассмотрим встроенные типы последовательностей: для каждого из них операция среза порождает объект того же, а не какого-то другого типа.

Если мы хотим, чтобы срезы Vector тоже были объектами класса Vector, то не должны делегировать получение среза классу array. В методе __getitem__ мы должны проанализировать полученные аргументы и выполнить подходящее действие.

Теперь посмотрим, как Python преобразует конструкцию my_seq[1:3] в аргументы вызова my_seq.__getitem__(...).

Как работает срезка

Код заменяет тысячу слов, поэтому обратимся к примеру 10.4

Пример 10.4. Изучение поведения __getitem__ и срезов

>>> class MySeq:
...     def __getitem__(self, index):
...         return index # 1
...
>>> s = MySeq()