---
source_image: page_434.png
page_number: 434
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 44.40
tokens: 11793
characters: 2132
timestamp: 2025-12-24T01:54:58.719545
finish_reason: stop
---

Traceback (most recent call last):
    ...
StopIteration
>>> list(it) # 5
[]
>>> list(iter(s3)) # 6
['Pig', 'and', 'Pepper']

1 Создаем предложение s3, содержащее три слова.
2 Получаем от s3 итератор.
3 next(it) возвращает следующее слово.
4 Больше слов нет, поэтому итератор возбуждает исключение StopIteration.
5 После исчерпания итератор бесполезен.
6 Чтобы еще раз обойти предложение, нужно создать новый итератор.

Поскольку от итератора требуются только методы __next__ и __iter__, не существует другого способа узнать, остались ли еще элементы, как только вызвать next() и перехватить исключение StopIteration. И «сбросить» итератор тоже невозможно. Чтобы начать обход сначала, нужно вызвать функцию iter(...) для итерируемого объекта и получить от нее новый итератор. Вызов iter(...) для самого итератора не поможет, поскольку, как уже упоминалось, метод Iterator.__iter__ возвращает self, так что таким способом исчерпанный итератор не восстановить.
В заключение дадим определение итератора.

Итератор

Любой объект, реализующий метод __next__ без аргументов, который возвращает следующий элемент или возбуждает исключение StopIteration, если элементов не осталось. В Python итераторы реализуют также метод __iter__ и потому сами являются итерируемыми объектами.

Первая версия класса Sentence была итерируемой вследствие специальной обработки последовательностей встроенной функцией iter(...). Теперь реализуем стандартный протокол итерируемого объекта.

Класс Sentence, попытка № 2: классический вариант

Следующая версия класса Sentence строится согласно классическому паттерну проектирования Итератор, который описан в книге «банды четырех». Отметим, что это не идиоматический код на Python, что станет предельно понятно, когда мы займемся его рефакторингом. Но он проясняет связь между итерируемой коллекцией и объектом-итератором.

Показанная в примере 14.4 реализация класса sentence является итерируемой, потому что реализует специальный метод __iter__, который конструирует и возвращает объект SentenceIterator. Именно так работает паттерн проектирования Итератор, который описан в книге «Паттерны проектирования».