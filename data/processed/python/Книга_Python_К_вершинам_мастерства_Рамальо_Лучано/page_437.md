---
source_image: page_437.png
page_number: 437
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 31.10
tokens: 11626
characters: 1608
timestamp: 2025-12-24T01:54:50.172949
finish_reason: stop
---

Класс Sentence, попытка № 3: генераторная функция

Чтобы «поддержать несколько активных обходов», необходимо иметь возможность получить несколько независимых итераторов от одного итерируемого объекта, причем каждый итератор должен хранить собственное внутреннее состояние, поэтому для правильной реализации паттерна нужно всякий раз обращаться к функции iter(my_iterable) за новым независимым итератором. Вот почему нам был необходим класс SentenceIterator.

Итерируемый объект никогда не должен выступать в роли итератора для себя самого. Иными словами, итерируемые объекты должны реализовывать метод __iter__, но не __next__. С другой стороны, итераторы для удобства должны быть итерируемыми объектами. Просто метод __iter__ должен возвращать self.

Теперь, продемонстрировав реализацию классического паттерна Итератор, мы можем отложить ее в сторонку. В следующем разделе представлена идиоматическая реализация класса sentence.

Класс Sentence, попытка № 3: генераторная функция

Реализация той же функциональности в духе Python основана на использовании генераторной функции для замены класса SequenceIterator. Объяснение приведено после примера 14.5.

Пример 14.5. sentence_gen.py: реализация класса Sentence с помощью генераторной функции

import re
import reprlib

RE_WORD = re.compile(r'\w+')

class Sentence:

    def __init__(self, text):
        self.text = text
        self.words = RE_WORD.findall(text)

    def __repr__(self):
        return 'Sentence(%s)' % reprlib.repr(self.text)

    def __iter__(self):
        for word in self.words:
            yield word
        return

    # это всё!