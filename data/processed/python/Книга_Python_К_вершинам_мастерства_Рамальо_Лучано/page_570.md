---
source_image: page_570.png
page_number: 570
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 45.05
tokens: 11881
characters: 2543
timestamp: 2025-12-24T02:01:21.420880
finish_reason: stop
---

Глава 18. Применение пакета asyncio для организации...

событий, — потому что в asyncio выражение yield from уступает управление именно циклу обработки событий.

Отметим, что использование yield from с будущим объектом можно рассматривать как сопрограммный эквивалент функциональности метода add_done_callback: вместо активации обратного вызова по завершении отложенной операции цикл обработки событий устанавливает результат будущего объекта, а выражение yield from отдает возвращенное значение приостановленной сопрограмме, давая ей возможность возобновить выполнение.

Короче говоря, поскольку класс asyncio.Future спроектирован для работы совместно с yield from, следующие методы зачастую оказываются ненужными.

• Не нужен метод my_future.add_done_callback(...), потому что те действия, которые должны быть выполнены после завершения будущего объекта, можно просто поместить после yield from my_future в сопрограмме. Это и есть главное достоинство сопрограмм: возможность приостанавливать и возобновлять выполнение функций.
• Не нужен метод my_future.result(), потому что значение выражения yield from с будущим объектом есть результат выполнения последнего (т. е. result = yield from my_future).

Разумеется, есть ситуации, когда методы .done(), .add_done_callback(...) и .results() полезны. Но в типичной программе управление будущими объектами asyncio осуществляется с помощью yield from, а не путем вызова этих методов.

Обсудим теперь, как yield from и asyncio API соединяют вместе будущие объекты, задачи и сопрограммы.

Yield from из будущих объектов, задач и сопрограмм

В asyncio существует тесная связь между будущими объектами и сопрограммами, потому что получить результат объекта asyncio.Future можно, выполнив внутри него yield from. Это означает, что предложение res = yield from foo() работает как в случае, когда foo — сопрограммная функция (т. е. функция, возвращающая объект-сопрограмму), так и в случае, когда foo — обычная функция, возвращающая экземпляр Future или task. Это одна из причин, почему сопрограммы и будущие объекты во многих частях asyncio API взаимозаменяемы.

Для выполнения сопрограмма должна быть сначала запланирована, а затем она обертывается объектом asyncio.Task. Имея сопрограмму, получить объект Task можно двумя основными способами:

asyncio.async(coro_or_future, *, loop=None)

Эта функция унифицирует сопрограммы и будущие объекты: первый аргумент может быть как тем, так и другим. Если аргумент имеет тип Future или Task, то он возвращается без изменения. Если же это сопрограмма, то async