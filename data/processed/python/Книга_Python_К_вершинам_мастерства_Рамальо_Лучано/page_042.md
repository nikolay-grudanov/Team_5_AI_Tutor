---
source_image: page_042.png
page_number: 42
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 41.92
tokens: 11709
characters: 1574
timestamp: 2025-12-24T01:36:25.169471
finish_reason: stop
---

>>> dummy = [x for x in 'ABC']
>>> x
'C'

Как видите, начальное значение x затерто. В Python 3 такого больше не происходит.

У списковых включений, генераторных выражений, а также у родственных им словарных и множественных включений теперь имеется собственная локальная область видимости, как у функций. Переменные, которым присвоено значение внутри такого выражения, остаются локальными, но на переменные из объемлющей области видимости можно ссылаться. Более того, локальные переменные не маскируют переменные из объемлющей области видимости. Следующий сеанс был записан в Python 3:

>>> x = 'ABC'
>>> dummy = [ord(x) for x in x]
>>> x ①
'ABC'
>>> dummy ②
[65, 66, 67]

① Значение x сохранено.
② Списковое включение порождает ожидаемый список.

Списковое включение строит список из последовательности или любого другого итерируемого типа путем фильтрации и трансформации элементов. То же самое можно было бы сделать с помощью встроенных функций filter и map, но, как мы увидим ниже, удобочитаемость при этом пострадает.

Сравнение спискового включения с map и filter

Списковое включение может делать все, что умеют функции map и filter, без дополнительных выкрутасов, связанных с использование лямбда-выражений. Взгляните на пример 2.3.

Пример 2.3. Один и тот же список, построенный с помощью listcomp и композиции map и filter

>>> symbols = '$€£¥€¤'
>>> beyond_ascii = [ord(s) for s in symbols if ord(s) > 127]
>>> beyond_ascii
[162, 163, 165, 8364, 164]
>>> beyond_ascii = list(filter(lambda c: c > 127, map(ord, symbols)))
>>> beyond_ascii
[162, 163, 165, 8364, 164]