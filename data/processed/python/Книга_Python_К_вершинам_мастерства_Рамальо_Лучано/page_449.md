---
source_image: page_449.png
page_number: 449
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 42.76
tokens: 11920
characters: 2318
timestamp: 2025-12-24T01:55:41.589064
finish_reason: stop
---

Генераторные функции в стандартной библиотеке

ly/1HGqqwh), которая обходит дерево каталогов и отдает имена файлов, в результате чего рекурсивный поиск оказывается не сложнее обычного цикла for.

Генераторная функция os.walk впечатляет, но в этом разделе я сконцентрируюсь на функциях общего назначения, которые принимают произвольные итерируемые объекты в качестве аргументов и возвращают генераторы, порождающие выборку, результаты вычислений и элементы в другом порядке. В следующих таблицах я перечислил два десятка таких функций, встроенных и находящихся в модулях itertools и functools. Для удобства они сгруппированы по общей функциональности вне зависимости от того, где находятся.

Быть может, вы знаете все упомянутые в этом разделе функции, но некоторые из них явно недооценены, поэтому краткий обзор поможет вспомнить, что есть в нашем распоряжении.

Первая группа — фильтрующие генераторные функции: они отдают подмножество элементов, порождаемых входным итерируемым объектом, не изменяя сами элементы. Ранее в этой главе, в разделе «Построение арифметической прогрессии с помощью itertools», мы уже использовали функцию itertools.takewhile. Как и takewhile, большинство перечисленных в табл. 14.1 функций принимают предикат — булеву функцию с одним аргументом, которая применяется к каждому входному элементу и определяет, нужно ли отдавать его на выходе.

Таблица 14.1. Фильтрующие генераторные функции

<table>
  <tr>
    <th>Модуль</th>
    <th>Функция</th>
    <th>Описание</th>
  </tr>
  <tr>
    <td>itertools</td>
    <td>compress(it, selector_it)</td>
    <td>Потребляет параллельно два итерируемых объекта; отдает элемент it, когда соответствующий элемент selector_it принимает похожее на истину значение</td>
  </tr>
  <tr>
    <td>itertools</td>
    <td>dropwhile(predicate, it)</td>
    <td>Потребляет it, пропуская элементы, пока predicate принимает похожее на истину значение, а затем отдает все оставшиеся элементы (больше никаких проверок не делается)</td>
  </tr>
  <tr>
    <td>встроенная</td>
    <td>filter(predicate, it)</td>
    <td>Применяет предикат к каждому элементу итерируемого объекта, отдавая элемент, если predicate(item) принимает похожее на истину значение; если predicate равен None, отдаются только элементы, принимающие похожее на истину значение</td>
  </tr>
</table>