---
source_image: page_687.png
page_number: 687
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 35.55
tokens: 11726
characters: 1696
timestamp: 2025-12-24T02:06:21.850611
finish_reason: stop
---

Основы метаклассов

< [11] > ClassOne tests .............................................
< [3] > ClassOne.__init__ ②
< [5] > ClassOne.method_x
< [12] > ClassThree tests ..........................................
< [300] > deco_alpha:inner_1 ③
< [13] > ClassFour tests ............................................
< [10] > ClassFour.method_y
< [14] > evaltime module end
< [4] > ClassOne.__del__ ④

① До сих пор все, как примере 21.8.
② Стандартное поведение класса.
③ Метод ClassThree.method_y был изменен декоратором deco_alpha, поэтому при вызове three.method_y() выполняется тело функции inner_1.
④ Экземпляр ClassOne, связанный с глобальной переменной one, убирается в мусор только по завершении программы.

Основная цель упражнения 2 — показать, что действие декоратора класса может не распространяться на подклассы. В примере 21.6 ClassFour определен как подкласс ClassThree. Декоратор @deco_alpha применяется к ClassThree и заменяет в нем метод method_y, но это никак не отражается на ClassFour. Разумеется, если бы метод ClassFour.method_y вызывал ClassThree.method_y with super(...), то мы увидели бы эффект декоратора, поскольку выполнялась бы функция inner_1.

В следующем разделе мы покажем, что метаклассы больше подходят, когда нужно настроить целую иерархию классов, а не один класс.

Основы метаклассов

Метакласс — это фабрика классов, но, в отличие от функции наподобие record_factory из примера 21.2, метакласс записывается в виде класса. На рис. 21.2 изображен метакласс в нотации хреновин и штуковин: одна хреновина порождает другую.

![Метакласс — это класс, который создает классы](https://i.imgur.com/3Q5z5QG.png)

Рис. 21.1. Метакласс — это класс, который создает классы