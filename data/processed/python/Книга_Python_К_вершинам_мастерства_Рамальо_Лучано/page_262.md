---
source_image: page_262.png
page_number: 262
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 43.14
tokens: 11789
characters: 2132
timestamp: 2025-12-24T01:46:45.820561
finish_reason: stop
---

4 После удаления catalog большинство сыров исчезло из stock, как и следовало ожидать от WeakValueDictionary. Но почему не все?

Из-за временной переменной, в которой хранится ссылка, жизнь объекта может продлиться дольше ожидаемого. Для локальных переменных это обычно не составляет проблемы, т. к. они уничтожаются при выходе из функции. Но в примере 8.19 cheese — переменная цикла for — глобальна и никогда не будет уничтожена, если не удалить ее явно.

Дополнением к WeakValueDictionary служит класс WeakKeyDictionary, в котором слабыми ссылками являются ключи. В документации по нему (http://bit.ly/1GsXB6Z) имеются предложения о том, как его можно использовать:

[Класс WeakKeyDictionary] можно использовать для ассоциирования дополнительных данных с объектом, который принадлежит другим частям программы, без добавления в этот объект новых атрибутов. Это особенно полезно в случае объектов, перехватывающих доступ к атрибутам.

В модуле weakref есть еще класс WeakSet, который в документации описывается просто: «Класс множества, в котором хранятся слабые ссылки на элементы. Элемент уничтожается, когда не остается ни одной указывающей на него сильной ссылки». Если требуется создать класс, который знает обо всех своих экземплярах, то можно завести атрибут класса WeakSet для хранения ссылок на экземпляры. Если бы для этой цели использовалось обычное множество set, то экземпляры никогда не уничтожались бы сборщиком мусора, потому что сам класс хранил бы сильные ссылки на них, а классы живут столько же, сколько сам процесс интерпретатора Python, если только вы специально их не удалите.

Но не для всякого объекта можно создать слабую ссылку. В следующем разделе мы рассмотрим вопрос об их ограничениях.

Ограничения слабых ссылок

Не всякий объект в Python может быть объектом слабой ссылки. Экземпляры классов list и dict не могут быть объектами таких ссылок, но проблему легко решить созданием простого подкласса:

class MyList(list):
    """Подкласс list, на экземпляр которого можно создать слабую ссылку"""
a_list = MyList(range(10))

# a_list может быть объектом слабой ссылки
wref_to_a_list = weakref.ref(a_list)