---
source_image: page_523.png
page_number: 523
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 48.30
tokens: 11919
characters: 2322
timestamp: 2025-12-24T01:59:15.729355
finish_reason: stop
---

Резюме

13 Отправляем time сопрограмме такси. Сопрограмма отдаст next_event или возбудит исключение StopIteration по завершении.
14 Если возникло исключение StopIteration, удаляем сопрограмму из словаря self.procs.
15 В противном случае помещаем next_event в очередь.
16 Если произошел выход из цикла в связи с истечением времени, печатаем количество оставшихся в очереди событий (иногда, по чистому совпадению, оно может оказаться равным нулю).

Обратите внимание, что в методе Simulator.run в двух местах используются блоки else, не имеющие отношения к предложению if; мы рассматривали этот вопрос в главе 15.

• В главном цикле while часть else выполняется, когда моделирование завершилось из-за превышения end_time, а не потому, что в очереди не осталось событий.
• В предложении try в конце цикла while мы пытаемся получить next_event, отправляя next_time процессу текущего такси, и если не возникло ошибки, то в блоке else помещаем next_event в очередь self.events.

Я полагаю, что читать код метода Simulator.run без этих блоков else было бы несколько труднее.

Целью этого примера было показать главный цикл обработки событий, который управляет сопрограммами, отправляя им данные. Это основная идея пакета asyncio, являющегося темой главы 18.

Резюме

Гвидо ван Россум писал, что существует три разных стиля кодирования с использованием генераторов:

Есть традиционный стиль на основе «вытягивания» (итераторы), стиль на основе «выталкивания» (как в примере с вычислением среднего) и «задачи» (вы еще не читали пособие Дэвида Бизли по сопрограммам?)16.

Итераторам была посвящена глава 14. В этой главе мы познакомились с сопрограммами, используемыми в стиле «выталкивания», а также с очень простыми «задачами» — процессами такси в примере моделирования. В главе 18 мы превратим их в асинхронные задачи в параллельном программировании.

В примере вычисления накопительного среднего было продемонстрировано типичное применение сопрограммы: в качестве аккумулятора, обрабатывающего отправляемые ему данные. Мы видели, как можно инициализировать сопрограм-

16 Сообщение в ветви «Yield-From: Finalization guarantees» (http://bit.ly/1Jlqjn6) списка рассылки Python-ideas. Пособие Дэвида Бизли, на которое ссылается Гвидо, называется «A Curious Course on Coroutines and Concurrency» (http://www.dabeaz.com/coroutines/).