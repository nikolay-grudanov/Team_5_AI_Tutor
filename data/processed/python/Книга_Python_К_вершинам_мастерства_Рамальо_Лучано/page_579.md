---
source_image: page_579.png
page_number: 579
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 41.83
tokens: 11825
characters: 2004
timestamp: 2025-12-24T02:01:45.132393
finish_reason: stop
---

Улучшение скрипта загрузки на основе asyncio

В разделе «Загрузка с индикацией хода выполнения и обработкой ошибок» главы 17 упоминалось, что у всех скриптов из серии flags2 одинаковый интерфейс командной строки. Это относится и к скрипту flags2_asyncio.py из этого раздела. Так, в примере 18.6 показано, как получить 100 флагов (-al 100) от сервера ERROR, отправив 100 одновременных запросов (-m 100).

Пример 18.6. Запуск скрипта flags2_asyncio.py

$ python3 flags2_asyncio.py -s ERROR -al 100 -m 100
ERROR site: http://localhost:8003/flags
Searching for 100 flags: from AD to LK
100 concurrent connections will be used.
----------------------
73 flags downloaded.
27 errors.
Elapsed time: 0.64s

Ведите себя ответственно при тестировании параллельных клиентов

Хотя общее время загрузки для многопоточных и асинхронных HTTP-клиентов одинаково, asyncio способен посылать запросы быстрее, поэтому сервер с большей вероятностью заподозрит DoS-атаку. Если вы хотите тестировать параллельные клиентов на полной скорости, то поднимите локальный HTTP-сервер. Соответствующие инструкции есть в файле README.rst (http://bit.ly/1Jlsg2L) в каталоге 17-futures/countries/ (http://bit.ly/1f6ChKk) репозитория кода к этой книге (http://bit.ly/1JltSti).

Познакомимся с реализацией flags2_asyncio.py.

Использование asyncio.as_completed

В примере 18.5 я передавал функции asyncio.wait список сопрограмм, которые — под управлением метода loop.run_until_complete — должны возвращать результаты загрузки, но только когда завершатся все. Однако чтобы обновить индикатор хода выполнения, нам нужно получать результаты по мере готовности. К счастью, в пакете asyncio есть эквивалент генераторной функции as_completed, которой мы пользовались в скрипте на основе пула потоков (пример 17.14).

Для кодирования flags2-примера на основе asyncio нам придется переписать несколько функций, которые в версии на базе concurrent.futures можно было использовать повторно. Дело в том, что в программе на основе asyncio имеется всего