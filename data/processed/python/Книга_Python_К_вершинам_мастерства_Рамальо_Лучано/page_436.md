---
source_image: page_436.png
page_number: 436
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 43.61
tokens: 11848
characters: 2212
timestamp: 2025-12-24T01:55:01.923222
finish_reason: stop
---

Глава 14. Итерируемые объекты, итераторы и генераторы

7 Увеличиваем self.index.
8 Возвращаем слово.
9 Реализуем метод self.__iter__.

Код из примера 14.4 проходит тесты из примера 14.2.
Отметим, что этот пример работал бы и без реализации метода __iter__ в классе SentenceIterator, но лучше все делать правильно: предполагается, что итератор реализует оба метода __next__ и __iter__, и если мы так сделаем, то наш итератор пройдет проверку issubclass(SentenceIterator, abc.Iterator). Если бы мы унаследовали SentenceIterator от abc.Iterator, то получили бы и конкретный метод abc.Iterator.__iter__.

Что-то многовато работы (по крайней мере, для нас, ленивых программистов на Python). Обратите внимание, что большая часть кода SentenceIterator занимается управлением внутренним состоянием итератора. Вскоре мы увидим, как сократить эту часть. Но сначала небольшое отступление, в котором мы опишем один соблазнительный способ срезать угол, который на самом деле никуда не годится.

Почему идея сделать Sentence итератором плоха

Типичный источник ошибок при создании итерируемых объектов и итераторов — путаница понятий. Поясним: у итерируемого объекта есть метод __iter__, который при каждом обращении создает новый итератор. Итератор реализует метод __next__, который возвращает элементы один за другим, и метод __iter__, который возвращает self.

Следовательно, итератор является итерируемым объектом, но итерируемый объект не является итератором.

Возникает соблазн реализовать в классе Sentence метод __next__ в дополнение к __iter__, и тем самым сделать экземпляр Sentence одновременно итерируемым объектом и итератором над самим собой. Но это кошмарная идея. Типичный антипаттерн, по словам Алекса Мартелли, у которого огромный опыт рецензирования кода на Python.

В разделе «Применимость» главы о паттерне Итератор в книге «банды четверех» написано:

Используйте паттерн Итератор:
• для доступа к содержимому агрегированных объектов без раскрытия их внутреннего представления;
• для поддержки нескольких активных обходов одного и того же агрегированного объекта;
• для предоставления единообразного интерфейса с целью обхода различных агрегированных структур (то есть для поддержки полиморфной итерации).