---
source_image: page_059.png
page_number: 59
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 44.56
tokens: 11835
characters: 1942
timestamp: 2025-12-24T01:37:11.804245
finish_reason: stop
---

Составное присваивание последовательностей

все сказанное равным образом относится также к оператору *= и другим операторам составного присваивания.

За оператором += стоит специальный метод __iadd__ (аббревиатура «in-place addition» — сложение на месте). Но если метод __iadd__ не реализован, то Python вызывает метод __add__. Рассмотрим следующее простое выражение:

```python
>>> a += b
```

Если объект a реализует метод __iadd__, то он и будет вызван. В случае изменяемых последовательностей (например, list, bytearray, array.array) a будет изменен на месте (результат получается такой же, как при вызове a.extend(b)). Если же a не реализует __iadd__, то выражение a += b вычисляется так же, как a = a + b, т. е. сначала вычисляется a + b и получившийся в результате новый объект связывается с переменной a. Иными словами, идентификатор объекта a остается тем же самым или становится другим в зависимости от наличия метода __iadd__.

Вообще говоря, если последовательность изменяемая, то можно ожидать, что метод __iadd__ реализован и оператор += выполняет сложение на месте. В случае неизменяемых последовательностей такое, очевидно, невозможно.

Сказанное об операторе += применимо также к оператору *=, который реализован с помощью метода __imul__. Специальные методы __iadd__ и __imul__ обсуждаются в главе 13.

Ниже демонстрируется применение оператора *= к изменяемой и неизменяемой последовательности:

```python
>>> l = [1, 2, 3]
>>> id(l)
4311953800 ①
>>> l *= 2
>>> l
[1, 2, 3, 1, 2, 3]
>>> id(l)
4311953800 ②
>>> t = (1, 2, 3)
>>> id(t)
4312681568 ③
>>> t *= 2
>>> id(t)
4301348296 ④
```

① Идентификатор исходного списка.
② После умножения список — тот же самый объект, в который добавлены новые элементы.
③ Идентификатор исходного кортежа.
④ В результате умножения создан новый кортеж

Кратная конкатенация неизменяемых последовательностей выполняется неэффективно, потому что вместо добавления новых элементов интерпретатор