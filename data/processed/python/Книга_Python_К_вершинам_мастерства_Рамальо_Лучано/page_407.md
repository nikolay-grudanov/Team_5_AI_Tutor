---
source_image: page_407.png
page_number: 407
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 45.00
tokens: 11908
characters: 2381
timestamp: 2025-12-24T01:53:39.894002
finish_reason: stop
---

Перегрузка оператора умножения на скаляр *

Vector([10.0, 20.0, 30.0])
>>> 11 * v1
Vector([11.0, 22.0, 33.0])

Над векторами определена и другая операция умножения: скалярное произведение; если представить один вектор как матрицу \(1 \times N\), а другой — как матрицу \(N \times 1\), то результат перемножения этих матриц и называется скалярным произведением. В NumPy и других подобных библиотеках принято не нагружать оператор * обеими семантиками, а оставить его только для умножения на скаляр. А для вычисления скалярного произведения в NumPy есть функция numpy.dot()\( ^3 \).

Но вернемся к операции умножения на скаляр. Как и раньше, начнем с простейших вариантов __mul__ и __rmul__:

# внутри класса Vector
def __mul__(self, scalar):
    return Vector(n * scalar for n in self)

def __rmul__(self, scalar):
    return self * scalar

Оба метода работают, если типы операндов совместимы. Аргумент scalar должен быть числом, которое при умножении на float дает float (поскольку во внутреннем представлении класса Vector используется массив чисел типа float). Поэтому число типа complex не подойдет, однако годятся типы int, bool (поскольку bool — подкласс int) и даже fractions.Fraction.

Можно было бы использовать ту же технику динамической типизации, что в примере 13.10: перехватить исключение TypeError в методе __mul__, но в этом случае существует и более явный способ навести порядок: гусиная типизация. Мы воспользуемся функцией isinstance() для проверки типа scalar, но сравнивать будем не с конкретными типами, а с абстрактным базовым классом numbers.Real, который охватывает все подходящие типы и оставляет реализацию открытой для будущих числовых типов, которые объявляют себя настоящими или виртуальными подклассами numbers.Real. В примере 13.11 показано использование гусиной типизации на практике — явное сравнение с абстрактным типом; полный листинг см. в репозитории кода по адресу https://github.com/fluentpython/example-code.

Напомним (см. раздел «ABC в стандартной библиотеке» главы 11), что класс decimal.Decimal не зарегистрирован как виртуальный подкласс numbers.Real. Поэтому объект нашего класса Vector нельзя умножить на число типа decimal.Decimal.

\( ^3 \) Начиная с версии Python 3.5, в качестве инфиксного оператора скалярного произведения можно использовать знак @. Подробнее об этом см. в разделе «Новый инфиксный оператор @ в Python 3.5» ниже.