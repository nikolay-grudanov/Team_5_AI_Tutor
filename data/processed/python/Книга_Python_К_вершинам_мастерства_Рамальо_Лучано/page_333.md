---
source_image: page_333.png
page_number: 333
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 42.58
tokens: 11876
characters: 2110
timestamp: 2025-12-24T01:49:59.060913
finish_reason: stop
---

Интерфейсы и протоколы в культуре Python

ABC, подобно дескрипторам и метаклассам, предназначены для разработки каркасов. Поэтому лишь малая часть пишущих на Python может создавать ABC, не налагая ненужных ограничений на своих коллег-программистов и не заставляя их делать бессмысленную работу.

Начнем с взгляда Python на интерфейсы.

Интерфейсы и протоколы в культуре Python

Python уже добился успеха, когда в нем появились ABC, и в самых замечательных программах они вообще не используются. Начиная с главы 1, мы говорим о динамической типизации и протоколах. В разделе «Протоколы и динамическая типизация» главы 10 протоколы были определены как неформальные интерфейсы, благодаря которым в языках с динамической типизацией, к каковым относится и Python, работает полиморфизм.

Как же работают интерфейсы в динамически типизированном языке? Начнем с основ: даже без ключевого слова interface и независимо от наличия ABC у каждого класса есть интерфейс: множество открытых членов (методов и атрибутов), реализованных в самом классе или унаследованных от родителя. Сюда входят и специальные методы, например __getitem__ или __add__.

По определению, закрытые и защищенные члены не являются частью интерфейса, даже если под «защищенным» понимается всего лишь соглашение об именовании (один начальный подчерк), а к закрытым атрибутам легко получить доступ (см. раздел «Закрытые и защищенные атрибуты в Python» главы 9). И нарушать эти соглашения — дурной тон.

С другой стороны, не считается грехом включать открытые атрибуты-данные в состав интерфейса объекта, потому что — при необходимости — такой атрибут можно преобразовать в свойство, реализующее логику чтения и установки, и это не приведет к «поломке» клиентского кода, в котором используется простая нотация obj.attr. Мы так поступали в классе Vector2d: в примере 11.1 повторена первая реализация с открытыми атрибутами x и y.

Пример 11.1. vector2d_v0.py: x и y — открытые атрибуты (повторение примера 9.2)

class Vector2d:
    typecode = 'd'

    def __init__(self, x, y):
        self.x = float(x)
        self.y = float(y)

    def __iter__(self):