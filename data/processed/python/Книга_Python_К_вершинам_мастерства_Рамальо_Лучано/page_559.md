---
source_image: page_559.png
page_number: 559
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 60.88
tokens: 12006
characters: 2710
timestamp: 2025-12-24T02:01:09.060412
finish_reason: stop
---

Поговорим

нимом управления потоками и блокировками, я пришел к выводу, что управлять потоками и блокировками самостоятельно я хочу ничуть не больше, чем заниматься выделением и освобождением памяти. Такие вещи лучше оставить системным программистам, которые знают, как это делать, любят с этим возиться и располагают временем, чтобы сделать все правильно, — по крайней мере, я надеюсь на это.

Потому-то я и считаю пакет concurrent.futures выдающимся достижением: в нем потоки, процессы и очереди рассматриваются как элементы инфраструктуры, а не как объекты, с которыми нужно работать напрямую. Конечно, этот пакет предназначен для сравнительно простых задач, которые принято называть «естественно параллельными» (http://bit.ly/1HGtGaR). Но это довольно большая часть всего множества проблем распараллеливания, с которыми приходится сталкиваться при разработке приложений — в противоположность операционным системам или серверам баз данных — о чем и говорит Симионато.

Для задач, не являющихся «естественно параллельными», потоки и блокировки — тоже не решение. На уровне ОС потоки никогда не исчезнут, но во всех языках программирования, которые мне кажутся интересными, за последние несколько лет появились более удобные высокоуровневые абстракции параллелизма, как показывает книга «Семь моделей конкуренции и параллелизма». К числу таких языков относятся Go, Elixir и Clojure. Erlang — язык, на котором написан Elixir, — блестящий пример языка, в который уже на этапе проектирования был заложен параллелизм. Мне, впрочем, он не нравится из-за уродливого синтаксиса. Это меня Python избаловал.

Хосе Валим (Jose Valim), хорошо известный как один из авторов ядра Ruby on Rails, спроектировал язык Elixir, наделив его приятным современным синтаксисом. Подобно Lisp и Clojure, в Elixir реализованы синтаксические макросы. Но это палка о двух концах. Синтаксические макросы позволяют строить мощные предметно-ориентированные языки (DSL), но чрезмерное изобилие подъязыков может привести к несовместимым кодовым базам и фрагментации сообщества. Lisp утонул в макросах, каждый поставщик Lisp предлагает свой собственный сокровенный диалект. Результатом стандартизации на основе Common Lisp стал язык, разбухший от функциональных возможностей. Надеюсь, Хосе Валим не даст сообществу Elixir пойти по тому же пути.

Как и Elixir, Go — современный язык со свежими идеями. Но в некоторых отношениях он по сравнению с Elixir консервативен. В Go нет макросов, а его синтаксис проще, чем в Python. Go не поддерживает ни наследование, ни перегрузку операторов и предлагает меньше средств для метапрограммирования, чем Python. Эти ограничения рассматриваются как достоинства. Они позволяют обеспечить более предсказуемые