---
source_image: page_114.png
page_number: 114
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 37.56
tokens: 11837
characters: 2113
timestamp: 2025-12-24T01:39:47.030799
finish_reason: stop
---

Глава 3. Словари и множества

Познакомившись с деталями реализации класса dict, мы можем объяснить сильные стороны и ограничения как этой структуры данных, так и всех производных от нее. Теперь мы готовы к разговору о том, почему словари в Python ведут себя именно так, а не иначе.

Практические последствия механизма работы dict

В следующих подразделах мы обсудим плюсы и минусы, которые несет с собой реализация словаря на основе хэш-таблицы.

Ключи должны быть хэшируемыми объектами

Объект является хэшируемым, если удовлетворяются все перечисленные ниже условия.

1. Он поддерживает функцию hash() благодаря наличию метода __hash__, который возвращает одно и то же значение на протяжении всей жизни объекта.
2. Он поддерживает сравнение на равенство с помощью метода __eq__.
3. Если выражение a == b равно True, то выражение hash(a) == hash(b) также должно быть равно True.

Пользовательские типы по умолчанию являются хэшируемыми, потому что их хэш-значение равно значению функции id() и ни один из них не равен другому.

Если в своем классе вы реализовали метод __eq__, то должны согласованным образом реализовать и метод __hash__, потому что необходимо гарантировать, что если a == b равно True, то и hash(a) == hash(b) также равно True. Иначе вы нарушите инвариант алгоритма хэш-таблицы, а уж тогда от словарей и множеств не стоит ожидать надежной работы. Если ваш метод __eq__ зависит от изменяемого состояния, то метод __hash__ должен возбуждать исключение TypeError с сообщением вроде unhashable type: 'MyClass'.

У словарей большие накладные расходы в части памяти

Поскольку в основе класса dict лежит хэш-таблица, а хэш-таблицы должны быть разреженными, то память, естественно, используется неэффективно. Например, при обработке большого числа записей лучше хранить их в списке кортежей или именованных кортежей, а не в списке словарей в духе JSON, с одним объектом dict на каждую запись. Замена словарей кортежами снижает потребление памяти по двум причинам: за счет устранения накладных расходов на хранение хэш-таблицы в каждой записи и в силу того, что имена полей вынесены за пределы записей.