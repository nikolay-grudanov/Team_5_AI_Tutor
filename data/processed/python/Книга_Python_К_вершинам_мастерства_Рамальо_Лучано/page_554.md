---
source_image: page_554.png
page_number: 554
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 47.62
tokens: 11911
characters: 2635
timestamp: 2025-12-24T02:00:42.429298
finish_reason: stop
---

8 Обходим список кодов стран в алфавитном порядке. Порядок результатов зависит, прежде всего, от времени получения HTTP-ответа, но если размер пула (определяемый величиной concureq) гораздо меньше len(cc_list), то может оказаться, что результаты возвращаются по алфавиту.

9 Каждое обращение к executor.submit планирует выполнение одного вызываемого объекта и возвращает экземпляр Future. Первый аргумент — сам вызываемый объект, остальные — передаваемые ему аргументы.

10 Сохраняем future и код страны в словаре.

11 Функция futures.as_completed возвращает итератор, который отдает будущие объекты по мере их завершения.

12 Если не установлен режим подробной информации, то обертываем результат as_completed функцией tqdm, которая отображает индикатор хода выполнения; поскольку у done_iter нет метода len, то мы должны сообщить tqdm ожидаемое количество элементов в виде аргумента total=, чтобы tqdm могла оценить объем оставшейся работы.

13 Обходим будущие объекты по мере их завершения.

14 Вызов метода result будущего объекта возвращает значение, полученное от вызываемого объекта, или возбуждает исключение, которое было перехвачено во время выполнения объекта. Этот метод может блокировать программу в ожидании разрешения ситуации, но не в данном примере, потому что as_completed возвращает только уже завершенные будущие объекты.

15 Обрабатываем потенциальные исключения; оставшаяся часть функции отличается от кода последовательной версии download_many (пример 17.13) только в месте следующей выноски.

16 Чтобы предоставить контекст для сообщения об ошибки, извлекаем код страны из словаря to_do_map, используя в качестве ключа текущий объект future. В последовательной версии это было необязательно, потому что мы обходили список кодов стран, так что текущий cc всегда был под рукой; здесь же мы обходим будущие объекты.

В примере 17.14 используется идиома, очень полезная при работе с функцией futures.as_completed: построить словарь, ставящий в соответствие каждому будущему объекту данные, которые можно будет использовать по завершении этого объекта. В данном случае словарь to_do_map сопоставляет с будущим объектом соответствующий ему код страны. Это упрощает последующую обработку будущих объектов, несмотря на то, что завершаться они могут не по порядку.

Потоки Python отлично приспособлены к приложениям с большим объемом ввода-вывода, а благодаря пакету concurrent.futures их использование в ряде случаев оказывается тривиальным. На этом мы завершаем введение в пакет concurrent.futures. А далее обсудим альтернативы в ситуации, когда ни один из классов ThreadPoolExecutor и ProcessPoolExecutor не подходит.