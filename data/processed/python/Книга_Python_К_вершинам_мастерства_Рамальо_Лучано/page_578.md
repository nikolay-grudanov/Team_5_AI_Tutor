---
source_image: page_578.png
page_number: 578
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 55.77
tokens: 11952
characters: 2691
timestamp: 2025-12-24T02:01:54.082334
finish_reason: stop
---

Глава 18. Применение пакета asyncio для организации...

Использование генераторов как сопрограмм открывает альтернативный способ асинхронного программирования. С точки зрения цикла обработки событий, активация обратного вызова и вызов метода .send() приостановленной сопрограммы — практически одно и то же. С каждой приостановленной сопрограммой сопряжены некоторые затраты памяти, но они на несколько порядков меньше, чем для потоков. И при этом удается избежать «ада обратных вызовов» — этот вопрос мы обсудим в разделе «От обратных вызовов к будущим объектам и сопрограммам» ниже.

Теперь пятикратное превосходство flags_asyncio.py над flags.py в скорости получает объяснение: flags.py тратит миллиарды тактов процессора на ожидание завершения каждой загрузки — поочередно. В это время процессор, конечно, работает, только не над вашей программой. С другой стороны, когда функция download_many в скрипте flags_asyncio.py вызывает loop_until_complete, цикл обработки событий управляет каждой сопрограммой download_one до первого выражения yield from, та, в свою очередь, управляет сопрограммой get_flag до первого yield from, где вызывается aiohttp.request(...). Ни один из этих вызовов не является блокирующим, поэтому все запросы завершаются за долю секунды.

Когда инфраструктура asyncio получает первый ответ, цикл обработки событий отправляет его ожидающей сопрограмме get_flag. Когда get_flag получает ответ, она продолжает выполнение до следующего yield from, где вызывает метод resp.read() и снова уступает управление главному циклу. Все остальные ответы приходят примерно в одно и то же время (поскольку все запросы были отправлены почти одновременно). Когда сопрограмма get_flag возвращает управление, соответствующий ей делегирующий генератор download_flag возобновляет работу и сохраняет файл с изображением флага.

Для достижения максимальной производительности операция save_flag тоже должна быть асинхронной, но в настоящее время asyncio не предоставляет асинхронного API для работы с файловой системой — в отличие от Node. Если это станет причиной «затыка» в приложении, можете воспользоваться функцией loop.run_in_executor(http://bit.ly/1HGtQzc) для выполнения save_flag в пуле потоков. Как это сделать, показано в примере 18.9.

Поскольку асинхронные операции чередуются, общее время параллельной загрузки многих изображений, оказывается намного меньше, чем в последовательном скрипте. На получение результатов 600 HTTP-запросов с помощью asyncio у меня ушло в 70 с лишним раз меньше времени по сравнению с последовательной загрузкой.

Теперь вернемся к примеру HTTP-клиента и посмотрим, как показать анимированный индикатор хода выполнения и корректно обработать ошибки.