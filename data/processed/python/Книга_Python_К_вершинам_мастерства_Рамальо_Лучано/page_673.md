---
source_image: page_673.png
page_number: 673
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 65.87
tokens: 12066
characters: 2799
timestamp: 2025-12-24T02:06:21.188634
finish_reason: stop
---

Дополнительная литература

В разделе «LineItem попытка № 4: автоматическая генерация имен атрибутов хранения» мы отказались от требования явно задавать в объявлениях дескриптора Quantity параметр storage_name; это избыточно и чревато ошибками, потому что имя всегда должно совпадать с именем атрибута в левой части того оператора присваивания, в котором создается дескриптор. Решение состоит в том, чтобы генерировать имена storage_name, комбинируя имя дескрипторного класса со счетчиком, определенным на уровне класса (например, '_Quantity#1').

Далее мы сравнили размер кода, а также сильные и слабые стороны дескрипторного класса и фабрики свойств, основанной на идиомах функционального программирования. Второй подход отлично работает и в некоторых отношениях даже проще, но первый обладает большей гибкостью и является стандартным. Главное преимущество дескрипторного класса нашло применение в разделе «LineItem попытка № 5: новый тип дескриптора»: наследование для повторного использования кода при построении специализированных дескрипторов с пересекающейся функциональностью.

Затем мы изучили поведение дескрипторов, включающих и не включающих метод __set__, отметив принципиальное различие между переопределяющими и непереопределяющими дескрипторами. Проведя детальное тестирование, мы поняли, когда дескрипторы перехватывают управление, а когда маскируются, обходятся или затираются.

После этого мы исследовали специальную категорию непереопределяющих дескрипторов: методы. Тестирование в оболочке показало, как благодаря протоколу дескрипторов присоединенная к классу функция становится методом при обращении через экземпляр.

В конце главы мы вкратце упомянули о том, как работает документирование и удаление дескрипторов.

В этой главе мы столкнулись с некоторыми проблемами, решить которые можно только с помощью метапрограммирования классов, но отложили их до главы 21.

Дополнительная литература

Помимо официального справочного материала в главе «Модель данных» (http://bit.ly/1GsZwss), ценным ресурсом является пособие Раймонда Хэттингера «Descriptor HowTo Guide» (http://bit.ly/1HGwls3), оно входит в подборку практических руководств (http://bit.ly/1HGwnsV), являющуюся частью официальной документации по Python.

Как и во всем, что касается объектной модели в Python, книга Алекса Мартелли «Python in a Nutshell», издание 2 (O'Reilly), является авторитетным и объективным источником, пусть и несколько устаревшим: основные обсуждавшиеся в этой главе механизмы появились в версии Python 2.2, задолго до версии 2.5, которая охвачена в этой книге. Мартелли также подготовил презентацию «Python's Object Model», в которой всесторонне рассматриваются свойства и дескрипторы (слайды — по адресу http://bit.ly/1HGwoxa, видео — по адресу http://bit.ly/1HGwp46) Настоятельно рекомендую.