---
source_image: page_511.png
page_number: 511
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 51.78
tokens: 11876
characters: 2255
timestamp: 2025-12-24T01:58:40.600318
finish_reason: stop
---

Семантика yield from

7 Если субгенератор возбудил исключение StopIteration, получить value, присвоить это значение переменной _r и выйти из цикла, возобновив тем самым делегирующий генератор.

8 _r становится результатом RESULT — значением всего выражения yield from.

В этом упрощенном псевдокоде я сохранил имена переменных из реального псевдокода, опубликованного в PEP 380, а именно:

_i (iterator)
Субгенератор.

_y (yielded)
Значение, отданное субгенератором.

_r (result)
Окончательный результат (т. е. значение выражения yield from по завершении субгенератора).

_s (sent)
Значение, отправленное вызывающей стороной делегирующему генератору, которое переправляется субгенератору.

_e (exception)
Исключение (в этом упрощенном псевдокоде всегда экземпляр класса StopIteration)

Мало того что в этом упрощенном псевдокоде не обрабатываются вызовы методов .throw(...) и .close(), так еще для перенаправления субгенератору вызовов next() и .send(...) со стороны клиента всегда используется метод .send(...). Но не «заморачивайтесь» этими тонкими различиями при первом чтении. Как уже было сказано, пример 16.17 отлично работал бы, даже если бы конструкция yield from умела делать только то, что показано в примере 16.18.

Однако жизнь сложнее, потому что нужно уметь обрабатывать вызовы .throw(...) и .close() со стороны клиента, передавая их субгенератору. Кроме того, субгенератор может оказаться простым итератором, не поддерживающим методы .throw(...) и .close(), и логика yield from должна это учитывать. А если субгенератор все-таки реализует эти методы, то внутри него они могут возбуждать исключения, которые механизм yield from тоже должен обрабатывать. Субгенератор может и сам возбуждать исключения, не спровоцированные вызывающей стороной, и реализация yield from не должна остаться к ним безучастной. Наконец, возможна оптимизация: если вызывающая сторона вызывает next(...) или .send(None), то оба вызова транслируются в вызов next(...) субгенератора, и лишь если вызывающая сторона отправляет значение, отличное от None, то для его перенаправления субгенератору применяется метод .send(...).

Для удобства ниже приведен полный псевдокод yield from из документа PEP 380 с аннотациями. Код скопирован буквально, я добавил только выноски.