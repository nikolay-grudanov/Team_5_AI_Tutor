---
source_image: page_281.png
page_number: 281
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 43.13
tokens: 11790
characters: 1797
timestamp: 2025-12-24T01:47:37.679108
finish_reason: stop
---

Хэшируемый класс Vector2d

self.__x = float(x) ①
self.__y = float(y)

@property ②
def x(self): ③
    return self.__x ④

@property ⑤
def y(self):
    return self.__y

def __iter__(self):
    return (i for i in (self.x, self.y)) ⑥

# прочие методы (в книге опущены)

1 Используем ровно два начальных подчерка (и нуль или один конечный), чтобы сделать атрибут закрытым⁶.
2 Декоратор @property помечает метод чтения свойства.
3 Просто возвращаем self.__x.
4 Повторяем то же самое для свойства y.
5 Все методы, которые просто читают компоненты x и y, не изменяются, только теперь self.x и self.y означает чтение открытых свойств, а не закрытых атрибутов. Поэтому оставшаяся часть класса не показана.

Vector.x и Vector.y — примеры свойств, доступных только для чтения. Свойства, доступные для чтения и записи, рассматриваются в главе 19, где мы детально изучим декоратор @property.

Теперь, когда векторы стали неизменяемыми, мы можем реализовать метод __hash__. Он должен возвращать int и в идеале учитывать хэши объектов-атрибутов, которые используются также в методе __eq__, потому что у равных объектов хэши также должны быть одинаковы. В документации по специальному методу __hash__ (https://docs.python.org/3/reference/datamodel.html) рекомендуется объединять хэши компонентов с помощью поразрядного оператора ИСКЛЮЧАЮЩЕЕ ИЛИ (^), так мы и поступим. Код метода Vector2d.__hash__, показанный в примере 9.8, совсем прост.

Пример 9.8. vector2d_v3.py: реализация хэширования

# в классе Vector2d:
def __hash__(self):
    return hash(self.x) ^ hash(self.y)

После добавления метода __hash__ мы получили хэшируемые векторы:

⁶ Ян Байкинг так бы делать не стал, смотрите эпиграф к этой главе. Плюсы и минусы закрытых атрибутов — тема раздела «Закрытые и защищенные атрибуты в Python» ниже в этой главе.