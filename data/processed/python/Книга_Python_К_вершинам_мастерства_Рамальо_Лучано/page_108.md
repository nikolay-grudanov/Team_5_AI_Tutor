---
source_image: page_108.png
page_number: 108
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 46.21
tokens: 12085
characters: 2346
timestamp: 2025-12-24T01:39:34.990911
finish_reason: stop
---

<table>
  <tr>
    <th>Мат. символ</th>
    <th>Оператор Python</th>
    <th>Метод</th>
    <th>Описание</th>
  </tr>
  <tr>
    <td>S ⊂ Z</td>
    <td>S &lt; z</td>
    <td>s.__lt__(z)</td>
    <td>s является собственным подмножеством z</td>
  </tr>
  <tr>
    <td>S ⊇ Z</td>
    <td>S ≥ z</td>
    <td>s.__ge__(z)<br>s.issuperset(it)</td>
    <td>s является надмножеством z<br>s является надмножеством множества z, построенного из итерируемого объекта it</td>
  </tr>
  <tr>
    <td>S ⊃ Z</td>
    <td>S &gt; z</td>
    <td>s.__gt__(z)</td>
    <td>s является собственным надмножеством z</td>
  </tr>
</table>

Помимо теоретико-множественных операторов и методов, типы множеств реализуют и другие методы, полезные на практике. Они сведены в табл. 3.4.

Таблица 3.4. Дополнительные методы множеств

<table>
  <tr>
    <th></th>
    <th>set</th>
    <th>frozenset</th>
  </tr>
  <tr>
    <td>s.add(e)</td>
    <td>•</td>
    <td>Добавить элемент e в s</td>
  </tr>
  <tr>
    <td>s.clear()</td>
    <td>•</td>
    <td>Удалить все элементы из s</td>
  </tr>
  <tr>
    <td>s.copy()</td>
    <td>•</td>
    <td>Поверхностная копия s</td>
  </tr>
  <tr>
    <td>s.discard(e)</td>
    <td>•</td>
    <td>Удалить элемент e из s, если он там присутствует</td>
  </tr>
  <tr>
    <td>s.__iter__()</td>
    <td>•</td>
    <td>Получить итератор для обхода s</td>
  </tr>
  <tr>
    <td>s.__len__()</td>
    <td>•</td>
    <td>len(s)</td>
  </tr>
  <tr>
    <td>s.pop()</td>
    <td>•</td>
    <td>Удалить и вернуть элемент s, возбудив исключение KeyError, если s пусто</td>
  </tr>
  <tr>
    <td>s.remove(e)</td>
    <td>•</td>
    <td>Удалить элемент e из s, возбудив исключение KeyError, если e отсутствует в s</td>
  </tr>
</table>

На это мы завершаем обзор множеств и их возможностей.
Теперь обратимся к обсуждению реализации словарей и множеств с помощью хэш-таблиц. Дочитав эту главу до конца, вы уже не будете удивляться непредсказуемому на первый взгляд поведению классов dict, set и их родственников.

Под капотом dict и set
Понимать, как реализованы словари и множества в Python, полезно для оценки их сильных сторон и ограничений.
В этом разделе мы ответим на следующие вопросы.
• Насколько эффективны классы dict и set в Python?
• Почему они не упорядочены?
• Почему не каждый объект Python может быть ключом словаря или элементом множества?