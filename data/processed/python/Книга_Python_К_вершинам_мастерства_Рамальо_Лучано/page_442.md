---
source_image: page_442.png
page_number: 442
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 30.49
tokens: 11715
characters: 1746
timestamp: 2025-12-24T01:55:05.755035
finish_reason: stop
---

Глава 14. Итерируемые объекты, итераторы и генераторы

третий — ленивый — вариант класса Sentence: он порождает следующее слово только тогда, когда это необходимо.

Пример 14.7. sentence_gen2.py: реализация класса Sentence с помощью генераторной функции, которая вызывает генераторную функцию re.finditer

import re
import reprlib

RE_WORD = re.compile(r'\w+')

class Sentence:

    def __init__(self, text):
        self.text = text

    def __repr__(self):
        return 'Sentence(%s)' % reprlib.repr(self.text)

    def __iter__(self):
        for match in RE_WORD.finditer(self.text):
            yield match.group()

1 Хранить список слов не нужно.
2 finditer строит итератор, который обходит все соответствия текста self. text регулярному выражению RE_WORD, порождая объекты MatchObject.
3 match.group() извлекает сопоставленный текст из объекта MatchObject.

Генераторные функции — замечательный способ сократить код, но генераторные выражения еще круче.

Класс Sentence, попытка № 5: генераторное выражение

Простые генераторные функции наподобие той, что использована в предыдущем варианте класса Sentence (пример 14.7), можно заменить генераторным выражением.

Можно считать, что генераторное выражение — ленивая версия спискового включения: она не строит список энергично, а возвращает генератор, который лениво порождает элементы по запросу. Иными словами, если списковое включение — это фабрика списков, то генераторное выражение — фабрика генераторов.

Пример 14.8 — простая демонстрация генераторного выражения в сравнении со списковым включением.

Пример 14.8. Генераторная функция gen_AB используется сначала в списковом включении, а затем в генераторном выражении

>>> def gen_AB(): # 1
...     print('start')
...     yield 'A'