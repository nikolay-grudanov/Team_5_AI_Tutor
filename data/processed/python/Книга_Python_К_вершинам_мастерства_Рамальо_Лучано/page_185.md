---
source_image: page_185.png
page_number: 185
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 42.55
tokens: 11816
characters: 2235
timestamp: 2025-12-24T01:43:14.712231
finish_reason: stop
---

Пакеты для функционального программирования

По большей части, назначение этих 52 функций очевидно. Функции, имена которых начинаются с i и далее содержат имя оператора — например, iadd, iand и т. д. — соответствуют составным операторам присваивания: +=, &= и т. д. Они изменяют свой первый аргумент на месте, если это изменяемый объект; в противном случае функция работает так же, как аналогичная без префикса i: просто возвращает результат операции.

Из прочих функций мы рассмотрим только methodcaller. Он похож на attrgetter и itemgetter в том смысле, что на лету создает функцию. Эта функция вызывает метод по имени для объекта, переданного в качестве аргумента (см. пример 5.25).

Пример 5.25. Демонстрация methodcaller: во втором тесте показано связывание дополнительных аргументов

```python
>>> from operator import methodcaller
>>> s = 'The time has come'
>>> upcase = methodcaller('upper')
>>> upcase(s)
'THE TIME HAS COME'
>>> hiphenate = methodcaller('replace', ' ', '-')
>>> hiphenate(s)
'The-time-has-come'
```

Первый тест в примере 5.25 просто показывает, как работает функция methodcaller, но вообще-то, если нужно использовать метод str.upper как функцию, то можно просто вызвать его от имени класса str, передав строку в качестве аргумента:

```python
>>> str.upper(s)
'THE TIME HAS COME'
```

Второй тест показывает, что methodcaller позволяет также фиксировать некоторые аргументы — так же, как функция functools.partial. Это и будет нашей следующей темой.

**Фиксация аргументов с помощью functools.partial**

В модуле functools собраны некоторые функции высшего порядка. Из них наиболее широко известна функция reduce, которую мы рассматривали в разделе «Современные альтернативы функциям map, filter и reduce» выше. Помимо нее, особенно полезна функция partial и ее вариация partialmethod.

Функция высшего порядка functools.partial позволяет применять функцию «частично». Получив на входе некоторую функцию, partial создает новый вызываемый объект, в котором некоторые аргументы исходной функции фиксированы. Это полезно для адаптации функции, принимающей один или несколько аргументов, к API, требующему обратного вызова функции с меньшим числом аргументов. Тривиальная демонстрация приведена в примере 5.26.