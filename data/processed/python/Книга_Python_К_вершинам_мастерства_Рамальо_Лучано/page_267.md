---
source_image: page_267.png
page_number: 267
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 53.38
tokens: 11921
characters: 2518
timestamp: 2025-12-24T01:47:03.785520
finish_reason: stop
---

Поговорим

ссылки, а не значения объектов. Даже такую базовую вещь, как сравнение строк, Java заставляет делать с применением метода .equals. Но в и этом случае есть подвох: если при вычислении выражения a.equals(b) окажется, что a равно null, то возникнет исключение из-за нулевого указателя. Проектировщики Java сочли необходимым переопределить для строк оператор +, так почему же не пошли дальше и не переопределили также оператор ==?

В Python это сделано правильно. Оператор == сравнивает значения объектов, а оператор is — ссылки. И поскольку в Python имеется механизм перегрузки операторов, то == разумно работает для всех объектов из стандартной библиотеки, включая None, каковой является обычным объектом в отличие от null в Java.

И разумеется, можно определить метод __eq__ в собственных классах, самостоятельно решив, что должен означать для них оператор ==. Если метод __eq__ не переопределен, то он наследуется от object и сравнивает идентификаторы объектов, так что все объекты пользовательского класса по умолчанию считаются различными.

Вот такие вещи побудили меня перейти с Java на Python, после того как в один прекрасный день в сентябре 1998 года я прочел «Учебное пособие по Python».

Изменяемость

Эта глава была бы излишней, если бы все объекты в Python были неизменяемы. Когда имеешь дело с неизменяемым объектом, неважно, хранятся ли в переменных сами объекты или ссылки на разделяемые объекты. Если a == b истинно, и ни тот, ни другой объект не может измениться, то они вполне могут быть одним и тем же объектом. Вот поэтому интернирование строк и безопасно. Тождественность объектов становится важна, только если объекты изменяемы.

В «чистом» функциональном программировании все данные неизменяемы: при добавлении элемента в коллекцию создается новая коллекция. Но Python — не функциональный язык программирования и уже тем более не чистый. Экземпляры пользовательских классов в Python по умолчанию изменяемы — как и в большинстве объектно-ориентированных языков. Если требуется создавать неизменяемые объекты, то следует проявлять особую осторожность. Каждый атрибут такого объекта тоже должен быть неизменяемым, иначе получится нечто, аналогичное кортежу: хотя с точки зрения идентификаторов объектов кортеж неизменяемый, его значение может измениться, если в нем хранятся изменяемые объекты.

Изменяемые объекты — также основная причина, из-за которой так трудно написать корректную многопоточную программу: если потоки изменяют объекты, не заботясь о синхронизации, то данные будут по-