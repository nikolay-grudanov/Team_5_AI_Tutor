---
source_image: page_448.png
page_number: 448
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 33.26
tokens: 11763
characters: 1765
timestamp: 2025-12-24T01:55:29.045900
finish_reason: stop
---

>>> next(gen)
1
>>> next(gen)
1.5
>>> next(gen)
2.0
>>> next(gen)
2.5

Однако itertools.count никогда не останавливается, поэтому, обрабатывая вызов list(count()), Python пытается построить список, не помещающийся в оперативную память, и ваша машина начнет сварливо брюзжать задолго до того, как вызов завершится ошибкой.

С другой стороны, существует функция itertools.takewhile: она порождает генератор, который потребляет другой генератор и останавливается, когда заданный предикат станет равен False. Объединив обе функции вместе, мы можем написать:

>>> gen = itertools.takewhile(lambda n: n < 3, itertools.count(1, .5))
>>> list(gen)
[1, 1.5, 2.0, 2.5]

Благодаря использованию takewhile и count мы получаем изящную и короткую реализацию, показанную в примере 14.13.

Пример 14.13. aritprog_v3.py: работает, как предыдущие варианты функции aritprog_gen

import itertools

def aritprog_gen(begin, step, end=None):
    first = type(begin + step)(begin)
    ap_gen = itertools.count(first, step)
    if end is not None:
        ap_gen = itertools.takewhile(lambda n: n < end, ap_gen)
    return ap_gen

Отметим, что функция aritprog_gen в примере 14.13 не является генераторной функцией: в ней нет слова yield. Но она возвращает генератор, поэтому работает как фабрика генераторов, т. е. точно так же, как генераторная функция.

Посыл, содержащийся в примере 14.13, прост: реализуя генераторы, нужно знать, что уже есть в стандартной библиотеке, иначе велики шансы изобрести велосипед. Вот почему в следующем разделе мы рассмотрим несколько готовых генераторных функций.

Генераторные функции в стандартной библиотеке

В стандартной библиотеке есть много генераторов: от объектов построчного чтения текстового файла до восхитительной функции os.walk (http://bit.