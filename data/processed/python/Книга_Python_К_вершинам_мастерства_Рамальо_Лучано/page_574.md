---
source_image: page_574.png
page_number: 574
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 57.10
tokens: 11996
characters: 2739
timestamp: 2025-12-24T02:01:44.924792
finish_reason: stop
---

Глава 18. Применение пакета asyncio для организации...

обработки событий. Второй элемент, возвращенный функцией run_until_complete, мы игнорируем. Почему — будет объяснено ниже.

Заканчиваем цикл обработки событий.

Было бы неплохо, если бы объекты цикла обработки событий были контекстными менеджерами, тогда мы могли воспользоваться блоком with, гарантирующим закрытие цикла. Однако ситуация осложняется тем фактом, что клиентский код никогда не создает цикл обработки событий напрямую, а получает ссылку на него от функции asyncio.get_event_loop(). Иногда наш код не является «владельцем» цикла обработки событий, поэтому и закрывать его не имеет права. Например, если используется внешний цикл обработки событий ГИП с пакетом типа Quamash (https://pypi.python.org/pypi/Quamash/), то за закрытие этого цикла отвечает библиотека Qt, и делается это непосредственно перед завершением приложения.

Сопрограмма asyncio.wait(...) принимает итерируемый объект, содержащий будущие объекты или сопрограммы; wait обертывает каждую сопрограмму объектом Task. В итоге все объекты, управляемые wait, так или иначе становятся экземплярами класса Future. Поскольку wait(...) — сопрограммная функция, то она возвращает объект-сопрограмму (генератор), этот объект хранится в переменной wait_coro. Для управления сопрограммой мы передаем ее функции loop.run_until_complete(...).

Функция loop.run_until_complete принимает будущий объект или сопрограмму. Получив сопрограмму, она обертывает ее объектом Task — так же, как wait. Сопрограммами, будущими объектами и задачами можно управлять с помощью yield from, именно это и делает функция run_until_complete с объектом wait_coro, полученным от wait. Когда выполнение wait_coro завершится, она вернет 2-кортеж, в котором первый элемент — это множество завершенных будущих объектов, а второй — множество тех, которые еще не завершились. В примере 18.5 второе множество всегда пусто, потому-то мы и проигнорировали его, присвоив переменной _. Однако wait принимает еще два чисто именованных аргумента, благодаря которым может вернуть управление, даже если некоторые будущие объекты не завершились: timeout и return_when. Подробности см. в документации по asyncio.wait (http://bit.ly/1JIwZS2).

Отметим, что в примере 18.5 нельзя было повторно использовать функцию get_flag из скрипта flags.py (пример 17.2), потому что она основана на библиотеке requests, в которой ввод-вывод блокирующий. Чтобы можно было воспользоваться пакетом asyncio, мы должны заменить все функции, обращающиеся к сети, асинхронными версиями, которые активируются с помощью yield from, так чтобы управление возвращалось циклу обработки событий. Использование yield from в get_flag означает, что она должна управляться как сопрограмма.