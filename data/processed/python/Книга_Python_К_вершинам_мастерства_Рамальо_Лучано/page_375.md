---
source_image: page_375.png
page_number: 375
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 35.06
tokens: 11832
characters: 2087
timestamp: 2025-12-24T01:51:50.533551
finish_reason: stop
---

Сложности наследования встроенным типам

воркой: код встроенного типа (написанный на C) не вызывает специальные методы, переопределенные в пользовательских классах.

Суть проблемы хорошо описано в документации по интерпретатору PyPy, в главе «Различия между PyPy и CPython», раздел «Подклассы встроенных типов» (http://bit.ly/1JHNmhX):

Официально в CPython нет никаких правил, определяющих, когда переопределенный в подклассе метод встроенного типа вызывается и вызывается ли он вообще. В качестве приближения к истине можно считать, что такие методы никогда не вызываются другими встроенными методами того же объекта. Например, метод __getitem__( ), переопределенный в подклассе dict, не будет вызываться из встроенного метода get( ).

Проблема иллюстрируется в примере 12.1.

Пример 12.1. Наш метод __setitem__ игнорируется методами __init__ и __update__ встроенного типа dict

```python
>>> class DoppelDict(dict):
... def __setitem__(self, key, value):
...     super().__setitem__(key, [value] * 2) # 1
...
>>> dd = DoppelDict(one=1) # 2
>>> dd
{'one': 1}
>>> dd['two'] = 2 # 3
>>> dd
{'one': 1, 'two': [2, 2]}
>>> dd.update(three=3) # 4
>>> dd
{'three': 3, 'one': 1, 'two': [2, 2]}
```

1 Метод DoppelDict.__setitem__ повторяет значение при сохранении (только для того, чтобы его эффект был наглядно виден). Свою работу он делегирует методу суперкласса.
2 Метод __init__, унаследованный от dict, очевидно, не знает, что __setitem__ переопределен: значение 'one' не повторено.
3 Оператор [ ] вызывает наш метод __setitem__ и работает, как и ожидалось: 'two' отображается на повторенное значение [2, 2].
4 Метод update класса dict также не пользуется нашей версией __setitem__: значение 'three' не повторено.

Поведение встроенных типов находится в явном противоречии с основным правилом объектно-ориентированного программирования: поиск методов всегда должен начинаться с класса самого объекта (self), даже если он вызывается из метода, реализованного в суперклассе. При столь печальном положении дел метод __missing__ — о котором мы говорили в разделе «Метод __missing__» главы 2 —