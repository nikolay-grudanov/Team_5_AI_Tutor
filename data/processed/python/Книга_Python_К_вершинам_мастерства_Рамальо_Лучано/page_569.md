---
source_image: page_569.png
page_number: 569
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 48.47
tokens: 11957
characters: 2749
timestamp: 2025-12-24T02:01:22.052374
finish_reason: stop
---

Сравнение потока и сопрограммы

Сопрограмма же по умолчанию защищена от прерывания. Мы должны явно уступить управление, чтобы другие части программы могли продолжить работу. Вместо удержания блокировок для синхронизации нескольких потоков мы имеем сопрограммы, которые «синхронизированы» по определению: в каждый момент времени может работать только одна из них. А когда мы захотим уступить управление планировщику, то воспользуемся выражением yield или yield from. Именно поэтому прерывание сопрограммы безопасно: по определению сопрограмму можно прервать, только когда она приостановлена в точке yield, а, значит, мы можем выполнить необходимую очистку, перехватив исключение CancelledError.

Теперь посмотрим, чем класс asyncio.Future отличается от класса concurrent.futures.Future, который мы рассматривали в главе 17.

asyncio.Future: не блокирует умышленно

Интерфейс классов asyncio.Future и concurrent.futures.Future в основном совпадает, но реализованы они по-разному и не являются взаимозаменяемыми. В документе «PEP-3156 – Asynchronous IO Support Rebooted: the "asyncio" Module» (https://www.python.org/dev/peps/pep-3156/) по поводу этой печальной ситуации написано следующее:

В будущем (игра слов не случайна) мы, возможно, унифицируем классы asyncio.Future и concurrent.futures.Future (например, добавив в последний метод __iter__, который будет работать с yield from).

Как отмечалось в разделе «Где находятся будущие объекты?» главы 17, будущие объекты создаются только в результате планирования какого-то действия. В пакете asyncio функция BaseEventLoop.create_task(...) принимает сопрограмму, планирует ее выполнение и возвращает экземпляр asyncio.Task, являющийся также экземпляром asyncio.Future, потому что Task — подкласс Future, который предназначен для обертывания сопрограммы. Это аналогично созданию экземпляров concurrent.futures.Future посредством вызова Executor.submit(...).

Как и concurrent.futures.Future, класс asyncio.Future предоставляет методы .done(), .add_done_callback(...), .results(), а также ряд других. Первые два метода работают так же, как описано в разделе «Где находятся будущие объекты?» главы 17, но вот метод .result() очень сильно отличается.

В классе asyncio.Future метод .result() не принимает аргументов, т. е. задать таймаут невозможно. Кроме того, если в момент вызова .result() выполнение будущего объекта еще не завершилось, то программа не блокируется в ожидании результата, а возбуждается исключение asyncio.InvalidStateError.

Однако обычно для получения результата asyncio.Future используется yield from, как мы увидим в примере 18.8.

Когда yield from используется с будущим объектом, система автоматически позаботится о том, чтобы дождаться его завершения, не блокируя цикл обработки