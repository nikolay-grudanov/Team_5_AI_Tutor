---
source_image: page_419.png
page_number: 419
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 43.26
tokens: 11962
characters: 2718
timestamp: 2025-12-24T01:54:14.211777
finish_reason: stop
---

Резюме

интерпретатору сдаться и возбудить исключение TypeError, поскольку мы не умеем обрабатывать b.

В общем случае, если прямой инфиксный оператор (например, __mul__) предназначен для работы только с операндами того же типа, что self, бесполезно реализовывать соответствующий инверсный метод (например, __rmul__), потому что он, по определению, вызывается, только когда второй операнд имеет другой тип.

На этом мы завершаем рассмотрение перегрузки операторов в Python.

Резюме

Мы начали эту главу с обзора ограничений, который Python налагает на перегрузку операторов: запрещается перегружать операторы встроенных типов, запрещается создавать новые операторы и перегружать операторы is, and, or и not.

Потом мы занялись унарными операторами и реализовали методы __neg__ и __pos__. Далее мы перешли к инфиксным операторам, начав с + и поддерживающего его метода __add__. Мы видели, что унарные и инфиксные операторы должны возвращать новый объект в качестве результата и не должны изменять свои операнды. Чтобы поддержать операции с разными типами, мы возвращаем специальное значение NotImplemented — не исключение, — давая интерпретатору возможность попробовать еще раз: поменять операнды местами и вызвать специальный инверсный метод, соответствующий тому же оператору (например, __radd__). Алгоритм работы с инфиксными операторами в Python показан на рис. 13.1.

Раз мы можем производить операции над объектами разных типов, то должны уметь определять, что нам подсунули операнд, который мы не способны обработать. Мы применяли для этого два способа: либо в духе динамической типизации пробовали выполнить операцию и перехватывали возможное исключение TypeError, либо — в методе __mul__ — явно проверяли тип с помощью isinstance. У обоих подходов есть свои плюсы и минусы: динамическая типизация обладает большей гибкостью, а явная проверка типов дает более предсказуемый результат. При использовании isinstance мы производили сравнение не с типом конкретного класса, а с абстрактным базовым классом numbers.Real: isinstance(scalar, numbers.Real). Это разумный компромисс между гибкостью и безопасностью, поскольку существующие или будущие пользовательские типы можно объявить как настоящие или виртуальные подклассы ABC, как было показано в главе 11.

Далее мы обсудили операторы сравнения. Мы реализовали оператор == с помощью метода __eq__ и выяснили, что Python предоставляет удобную реализацию оператора != в форме метода __ne__, унаследованного от базового класса object. Эти операторы, а также >, <, >= и <= Python вычисляет несколько иначе, применяя различную логику для выбора инверсного метода и специальный запасной вариант для операторов == и != — в этом случае исключение никогда не возбуждается,