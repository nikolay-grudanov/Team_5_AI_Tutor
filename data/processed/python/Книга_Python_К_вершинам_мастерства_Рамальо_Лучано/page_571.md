---
source_image: page_571.png
page_number: 571
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 46.07
tokens: 11828
characters: 2242
timestamp: 2025-12-24T02:01:28.613940
finish_reason: stop
---

Сравнение потока и сопрограммы

вызывает для него функцию loop.create_task(...), которая создает объект Task. Можно также передать необязательный именованный аргумент loop=, содержащий ссылку на цикл обработки событий; если он опущен, то async получает объект loop от функции asyncio.get_event_loop().

BaseEventLoop.create_task(coro)
Этот метод планирует выполнение сопрограммы и возвращает объект asyncio.Task. Если он переопределен в подклассе BaseEventLoop, то возвращенный объект может быть экземпляром другого совместимого с Task класса, предоставляемого внешней библиотекой (например, Tornado).

Метод BaseEventLoop.create_task(...) имеется только в версиях Python, начиная с 3.4.2. При работе с более ранними версиями Python 3.3 или 3.4 следует использовать asyncio.async(...) или установить более позднюю версию asyncio с сайта PyPI (https://pypi.python.org/pypi/asyncio).

Несколько функций из asyncio принимают сопрограмму и обертывают ее объектом asyncio.Task автоматически, вызывая для этой цели asyncio.async. Примером может служить BaseEventLoop.run_until_complete(...).

Если вы хотите поэкспериментировать с будущими объектами и сопрограммами в оболочке Python или в небольших тестах, то можете воспользоваться следующим фрагментом3:

>>> import asyncio
>>> def run_sync(coro_or_future):
...     loop = asyncio.get_event_loop()
...     return loop.run_until_complete(coro_or_future)
...
>>> a = run_sync(some_coroutine())

Связь между сопрограммами, будущими объектами и задачами документирована в разделе 18.5.3 «Задачи и сопрограммы» (https://docs.python.org/3/library/asyncio-task.html) документации по asyncio. Там, в частности, есть такое замечание:

В этой документации некоторые методы описаны как сопрограммы, хотя на самом деле являются обычными функциями Python, возвращающими объект Future. Это сделано специально, чтобы сохранить свободу изменения реализации в будущем.

Разобравшись с основами, изучим код асинхронного скрипта загрузки флагов flags_asyncio.py, результаты работы которого были показаны в примере 17.1 наряду с результатами последовательного и многопоточного скрипта.

3 Предложен Петром Викториным в сообщении, отправленном в список рассылки Python-ideas 11 сентября 2014 (http://bit.ly/1JIwJmc).