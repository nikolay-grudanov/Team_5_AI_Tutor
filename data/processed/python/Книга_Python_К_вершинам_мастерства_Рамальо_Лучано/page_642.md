---
source_image: page_642.png
page_number: 642
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 64.29
tokens: 12040
characters: 2725
timestamp: 2025-12-24T02:04:57.482422
finish_reason: stop
---

На этом завершается наше исследование свойств, специальных методов и других приемов программирования динамических атрибутов.

Резюме

Мы начали обсуждение динамических атрибутов с практических примеров классов, которые упрощают работу с набором данных в формате JSON. Первым примером был класс FrozenJSON, преобразующий вложенные словари и списки во вложенные экземпляры FrozenJSON и списки таких экземпляров. При этом мы продемонстрировали применение специального метода __getattr__ для преобразования структур данных на лету, в момент чтения их атрибутов. В последней версии FrozenJSON было показано, как использовать метод конструирования __new__, чтобы превратить класс в гибкую фабрику объектов, причем не только этого класса.

Затем мы преобразовали набор JSON-данных в базу данных shelve.Shelf, в которой хранятся сериализованные экземпляры класса Record. Первое воплощение Record содержало всего несколько строк, и в нем использовалась идиома self.__dict__.update(**kwargs) для создания произвольных атрибутов из именованных аргументов, переданных __init__. На второй итерации мы реализовали класс DbRecord, расширяющий Record в целях интеграции с базой данных, и класс Event, реализующий автоматический поиск связанных записей с помощью свойств.

Знакомство со свойствами продолжилось на примере класса LineItem, в котором свойство предотвращало присваивание атрибуту weight нулевого или отрицательного значения. Глубже разобравшись с синтаксисом и семантикой свойств, мы создали фабрику свойств, которая обеспечивала одинаковую проверку свойств weight и price, но без повторного кодирования методов чтения и установки. При реализации фабрики свойств использовались тонкие идеи — замыкание и переопределение атрибутов экземпляра свойствами — позволившие предложить элегантное общее решение, по количеству строк не превышающее определение одного свойства, написанное вручную.

Напоследок мы вкратце рассмотрели удаление атрибутов с помощью свойств, а затем перечислили специальные атрибуты, встроенные функции и специальные методы, которые поддерживают метапрограммирование атрибутов в Python.

Дополнительная литература

Официальной документацией по встроенными функциям для работы с атрибутами и интроспекции является глава 2 «Встроенные функции» (http://bit.ly/1cPOrps) руководства по стандартной библиотеке Python. Относящиеся к этой же теме специальные методы и специальный атрибут __slots__ документированы в разделе 3.3.2 «Настройка доступа к атрибутам» справочного руководства по языку Python (http://bit.ly/1cPOlxV). Семантика вызова специальных методов в обход экземпляров описана в разделе 3.3.9 «Поиск специальных методов» (http://bit.ly/1cPO3qP). В разделе 4.13 «Специальные атрибуты» главы 4 «Встроенные