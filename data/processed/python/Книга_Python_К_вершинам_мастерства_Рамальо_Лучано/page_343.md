---
source_image: page_343.png
page_number: 343
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 60.54
tokens: 12002
characters: 2917
timestamp: 2025-12-24T01:50:44.270460
finish_reason: stop
---

Алекс Мартелли о водоплавающих

тированной объектно-ориентированной программы. Обычно не должно быть цепочек предложений if/elif/elif, в которых с помощью isinstance определяется тип объекта и в зависимости от него выполняются те или иные действия; для этой цели следует использовать полиморфизм, т. е. проектировать классы, так чтобы интерпретатор сам вызывал правильные методы, а не «зашивать» логику диспетчеризации в блоки if/elif/elif.

Из этой рекомендации существует часто встречающееся на практике исключение: некоторые функции и методы в Python принимают либо одну строку str, либо последовательность строк. Если передана только одна строка, то для упрощения обработки имеет смысл обернуть ее списком list. Поскольку str — тип последовательности, отличить строку от других неизменяемых последовательностей проще всего при помощи явной проверки isinstance(x, str)⁴.

С другой стороны, обычно нет возражений против использования isinstance для сравнения с типом ABC, если требуется убедиться в соблюдении контракта: «Эй, чтобы меня вызывать, ты должен реализовать то-то и то-то», как выразился технический рецензент Леннарт Регебро. Особенно это полезно в системах, основанных на архитектуре подключаемых модулей. За пределами каркасов динамическая типизация обычно проще и дает большую гибкость, чем проверка типов.

Например, в этой книге встречаются классы, где мне нужно принять последовательность элементов и обработать как список list, а не проверять, что аргумент имеет тип list. В таких случаях я просто беру аргумент и сразу же строю из него список, это позволяет мне принять любой итерируемый объект, а если окажется, что объект таковым не является, то вызов завершится с ошибкой на ранней стадии, и будет выдано вполне понятное сообщение. Один пример такого рода — метод __init__ в примере 11.13 ниже. Конечно, такой подход не годится, если последовательность, переданную в аргументе, нельзя копировать, — то ли потому что она слишком велика, то ли потому что программа должна изменять ее на месте. Тогда больше подойдет проверка isinstance(x, abc.MutableSequence). Если допустим произвольный итерируемый объект, то можно пойти по пути получения итератора с помощью вызова iter(x), как мы увидим в разделе «Почему последовательности итерируемы: функция iter» на стр. 435.

Другой пример — имитация обработки аргумента field_names в классе collections.namedtuple (https://docs.python.org/3/library/collections.html#collections.

⁴ К сожалению, в Python 3.4 не существует ABC, помогающих отличить строку от кортежа и других неизменяемых последовательностей, поэтому приходится сравнивать с типом str. В Python 2 есть тип basestr, который позволяет выполнять такие проверки. Это не ABC, а класс, которому наследуют как str, так и unicode; однако в Python 3 класс basestr исключен. Любопытно, что в Python 3 имеется тип collections.abc.ByteString, но он позволяет выделить только типы bytes и bytearray.