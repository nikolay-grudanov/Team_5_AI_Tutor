---
source_image: page_537.png
page_number: 537
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 47.44
tokens: 11921
characters: 2676
timestamp: 2025-12-24T01:59:49.526003
finish_reason: stop
---

Пример: три способа загрузки из веба

завершено, то метод result ведет себя совершенно по-разному. В объекте класса concurrency.futures.Future вызов f.result() блокирует вызывающий поток до тех пор, пока не будет готов результат. Если передан необязательный аргумент timeout и выполнение будущего объекта не завершилось в отведенное время, то возбуждается исключение TimeoutError. В разделе «asyncio.Future: не блокирует умышленно» на стр. 575 мы увидим, что метод asyncio.Future.result не поддерживает задание таймаута, а рекомендуемый способ получения результата будущего объекта заключается в использовании yield from — к объектам класса concurrency.futures.Future этот подход неприменим.

Будущие объекты возвращаются несколькими функциями из обеих библиотек; другие пользуются ими внутри себя, невидимо для пользователя. Примером второго рода может служить функция Executor.map, с которой мы встречались в примере 17.3: она возвращает итератор, метод __next__ которого вызывает метод result каждого будущего объекта, так что мы получаем не сами будущие объекты, а результаты их выполнения.

Чтобы попрактиковаться в использовании будущих объектов, перепишем пример 17.3 с использованием функции concurrent.futures.as_completed (http://bit.ly/1JIsEOW), которая принимает итерируемый объект, содержащий будущие объекты, и возвращает итератор, который отдает будущие объекты по мере их выполнения.

Чтобы можно было воспользоваться функцией futures.as_completed, необходимо внести изменения только в функцию download_many. Вызов высокоуровневого метода executor.map заменяется двумя циклами for: один — для создания и планирования будущих объектов, другой — для получения их результатов. И заодно уже добавим несколько вызовов print для печати каждого будущего объекта до и после завершения. В примере 17.4 показан код новой функции download_many. Количество строк в ней увеличилось с 5 до 17, зато теперь можно присмотреться к таинственным будущим объектам. Все остальные функции такие же, как в примере 17.3.

Пример 17.4. flags_threadpool_ac.py: замена executor.map на executor.submit и futures.as_completed в функции download_many

def download_many(cc_list):
    cc_list = cc_list[:5] ①
    with futures.ThreadPoolExecutor(max_workers=3) as executor: ②
        to_do = []
        for cc in sorted(cc_list): ③
            future = executor.submit(download_one, cc) ④
            to_do.append(future)
            msg = 'Scheduled for {}: {}'
            print(msg.format(cc, future)) ⑥

        results = []
        for future in futures.as_completed(to_do): ⑦
            res = future.result() ⑧
            msg = '{} result: {!r}'
            print(msg.format(cc, res))