---
source_image: page_686.png
page_number: 686
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 39.23
tokens: 11741
characters: 1682
timestamp: 2025-12-24T02:06:25.247334
finish_reason: stop
---

692

< [2] > ClassOne body ③
< [6] > ClassTwo body ④
< [7] > ClassThree body
< [200] > deco_alpha ⑤
< [9] > ClassFour body
< [14] > evaltime module end ⑥

① Весь верхнеуровневый код в evalsupport выполняется на этапе импорта модуля; функция deco_alpha компилируется, но ее тело не выполняется.
② Тело функции MetaAleph выполняется.
③ Тело каждого класса выполняется ...
④ ... вложенные классы — не исключение.
⑤ Декораторная функция выполняется после обработки тела декорированного класса ClassThree.
⑥ В этом упражнении модуль evaltime импортируется, поэтому блок if __name__ == '__main__': никогда не выполняется.

Сделаем несколько замечаний по поводу упражнения 1:

1. Вся последовательность действий запускается одним лишь предложением import evaltime.
2. Интерпретатор выполняет тело каждого класса в импортированном модуле и в модуле evalsupport, от которого он зависит.
3. Не удивительно, что интерпретатор обрабатывает тело декорированного класса еще до вызова присоединенной к нему декораторной функции: декоратор должен получить объект класса, а, значит, этот объект нужно предварительно построить.
4. В этом случае выполняется только одна пользовательская функция: декоратор deco_alpha.

Теперь посмотрим, что происходит в упражнении 2.

Решение упражнения 2

В примере 21.9 показано, как выглядит экран после выполнения команды python evaltime.py.

Пример 21.9. Упражнение 2: запуск evaltime.py из оболочки ОС

$ python3 evaltime.py
< [100] > evalsupport module start
< [400] > MetaAleph body
< [700] > evalsupport module end
< [1] > evaltime module start
< [2] > ClassOne body
< [6] > ClassTwo body
< [7] > ClassThree body
< [200] > deco_alpha
< [9] > ClassFour body ①