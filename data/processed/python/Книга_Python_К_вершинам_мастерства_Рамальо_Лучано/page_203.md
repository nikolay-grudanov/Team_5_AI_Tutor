---
source_image: page_203.png
page_number: 203
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 33.75
tokens: 11680
characters: 1719
timestamp: 2025-12-24T01:43:59.701562
finish_reason: stop
---

Паттерн Команда

графическом редакторе, а получателями — редактируемый документ или само приложение.

![UML-диаграмма классов для управляемого меню текстового редактора](https://i.imgur.com/3Q5z5QG.png)

Рис. 6.2. UML-диаграмма классов для управляемого меню текстового редактора, реализованного с применением паттерна Команда. У каждой команды может быть свой получатель: объект, выполняющий действие. Для команды PasteCommand получателем является Document, а для OpenCommand — приложение.

Идея в том, чтобы поместить между инициатором и получателем объект Command, который реализует интерфейс с единственным методом execute, вызывающим какой-то метод Получателя для выполнения желаемой операции. Таким образом, Инициатор ничего не знает об интерфейсе Получателя, так что, написав подклассы Command, можно адаптировать различные получатели. Инициатор конфигурируется конкретной командой и вызывает ее метод execute. Отметим, что на рис. 6.2 показан, в частности, класс MacroCommand, который может хранить последовательность команд; его метод execute() вызывает одноименный метод каждой хранимой команды.

Авторы «Паттернов проектирования» пишут: «Команды — объектно-ориентированная замена обратным вызовам». Вопрос: а нужна ли нам объектно-ориентированная замена обратным вызовам? Иногда да, а иногда и нет.

Вместо того чтобы передавать Инициатору объект Command, мы можем передать ему обычную функцию. И вызывать Инициатор будет не метод command.execute(), а просто функцию command(). Класс MacroCommand можно реализовать с помощью класса, в котором реализован специальный метод __call__. Тогда экземпляры MacroCommand будут вызываемыми объектами, содержащими список функций для последующего вызова (см. пример 6.9).