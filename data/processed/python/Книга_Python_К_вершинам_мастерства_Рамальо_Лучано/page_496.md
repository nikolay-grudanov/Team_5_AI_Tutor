---
source_image: page_496.png
page_number: 496
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 29.79
tokens: 11706
characters: 1718
timestamp: 2025-12-24T01:57:39.284362
finish_reason: stop
---

20.0
    >>> coro_avg.send(5)
15.0

from coroutil import coroutine

@coroutine
def averager():
    total = 0.0
    count = 0
    average = None
    while True:
        term = yield average
        total += term
        count += 1
        average = total/count

1 Вызываем averager(), она создает объект-генератор, который инициализируется в функции primer декоратора coroutine.
2 getgeneratorstate возвращает GEN_SUSPENDED, т. е. сопрограмма готова к приему значения.
3 Мы можем сразу же начать отправку значений coro_avg, в этом и состоял смысл декоратора.
4 Импортируем декоратор coroutine.
5 Применяем его к функции averager.
6 Тело функции точно такое же, как в примере 16.3.

Ряд каркасов предлагает специальные декораторы для работы с сопрограммами. Не все они инициализируют сопрограмму, некоторые предоставляют другие сервисы, например, включение в цикл обработки событий. В качестве примера назовем декоратор tornado.gen (http://bit.ly/1MMcGBF) из библиотеки асинхронного сетевого программирования Tornado.

Конструкция yield from (см. раздел «Использование yield from» ниже) автоматически инициализирует вызываемую с ее помощью сопрограмму и потому несовместима с декоратором @coroutine и ему подобными. Декоратор asyncio.coroutine из стандартной библиотеки Python 3.4 предназначен для работы совместно с yield form, поэтому не инициализирует сопрограмму. Мы рассмотрим его в главе 18.

Теперь обратимся к важнейшим свойствам сопрограмм: методам, которые позволяют завершить сопрограмму и возбудить в ней исключение.

Завершение сопрограммы и обработка исключений

Необработанное исключение в сопрограмме распространяется в функцию, из которой был произведен вызов next или send, приведший к исключению. Ниже