---
source_image: page_230.png
page_number: 230
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 38.90
tokens: 11718
characters: 1680
timestamp: 2025-12-24T01:45:18.074182
finish_reason: stop
---

Декоратор @singledispatch задуман не для того, чтобы перенести в Python перегрузку методов в духе Java. Один класс с несколькими перегруженными вариантами метода лучше одной функции с длинной цепочкой предложений if/elif/elif/elif. Но оба решения грешат тем, что поручают слишком много обязанностей одной единице программы — классу или функции. Преимущество @singledispatch — в поддержке модульного расширения: каждый модуль может зарегистрировать специализированную функцию для того типа, который поддерживает.

Декораторы — это функции, а, значит, можно составлять их композиции (т. е. применять декоратор к уже декорированной функции, как показано в примере 7.21). В следующем разделе объясняется, как это работает.

Композиции декораторов

В примере 7.19 было продемонстрировано применение композиции декораторов: @lru_cache применяется к результату применения декоратора @clock к функции fibonacci. В примере 7.21 декоратор @htmlize.register дважды применяется к последней функции в модуле.

Когда два декоратора @d1 и @d2 применяются к одной функции f в указанном порядке, получается то же самое, что в результате композиции f = d1(d2(f)).

Иными словами, код:

@d1
@d2
def f():
    print('f')

эквивалентен следующему:

def f():
    print('f')

f = d1(d2(f))

Помимо композиции декораторов, в этой главе уже встречались декораторы, принимающие аргументы, например @lru_cache() и htmlize.register('type') в примере 7.21. В следующем разделе описано, как создавать декораторы с параметрами.

Параметризованные декораторы

Разбирая декоратор, встретившийся в исходном коде, Python берет декорируемую функцию и передает ее в качестве первого аргумента функции-декоратору. А как