---
source_image: page_645.png
page_number: 645
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 50.44
tokens: 11882
characters: 2338
timestamp: 2025-12-24T02:04:44.420692
finish_reason: stop
---

someInstance.widgetCounter += 1
# вместо...
someInstance.setWidgetCounter(someInstance.getWidgetCounter() + 1)

Иногда, проектируя API, я задавался вопросом, следует ли всякий метод, который не принимает аргументов (кроме self), возвращает значение (отличное от None) и является чистой функцией (т. е. не имеет побочных эффектов), заменять свойством, допускающим только чтение.
В этой главе метод LineItem.subtotal (см. пример 19.23) был бы неплохим кандидатом на преобразование в свойство. Конечно, речь не идет о методах, которые призваны изменять объект, например my_list.clear(). Было бы ужасной ошибкой преобразовать такой метод в свойство, потому что простое обращение my_list.clear стерло бы все содержимое списка!

В библиотеке Pingo.io (http://www.pingo.io/docs/), упоминавшейся в разделе «Метод __missing__» на стр. 103, значительная часть API пользовательского уровня основана на свойствах. Например, чтобы прочитать текущее значение аналогового контакта, нужно написать pin.value, а чтобы установить режим цифрового контакта — pin.mode = OUT. За кулисами то и другое может потребовать выполнения большого объема кода — в зависимости от драйвера платы. Мы решили использовать в Pingo свойства, потому что хотели, чтобы с API было удобно работать даже в интерактивных средах типа iPython Notebook (http://ipython.org/notebook.html), и полагали, что запись pin.mode = OUT приятнее и глазам, и пальцам, чем pin.set_mode(OUT).

Решение, принятое в Smalltalk и Ruby, мне кажется чище, но я полагаю, что подход Python лучше, чем в Java. Нам разрешено начать с простого — сделать данные-члены открытыми атрибутами — потому что мы знаем, что впоследствии всегда сможем обернуть их свойствами (или дескрипторами, о которых будем говорить в следующей главе).

__new__ лучше, чем new

Еще один пример принципа единообразного доступа (или вариации на его тему) — тот факт, что в Python синтаксис вызова функций и создания объектов одинаков: my_obj = foo(), где foo может быть классом или любым другим вызываемым объектом.

В других языках, позаимствовавших синтаксис C++, имеется оператор new, из-за которого создание объекта выглядит иначе, чем вызов. По большей части, пользователю API безразлично, является foo функцией или классом. До недавнего времени я и сам считал, что property — это функция. При обычном использовании это неважно.