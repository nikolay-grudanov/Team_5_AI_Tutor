---
source_image: page_285.png
page_number: 285
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 52.59
tokens: 11908
characters: 2273
timestamp: 2025-12-24T01:47:54.782170
finish_reason: stop
---

Закрытые и «защищенные» атрибуты в Python

if fmt_spec.endswith('p'):
    fmt_spec = fmt_spec[:-1]
    coords = (abs(self), self.angle())
    outer_fmt = '<{}, {}>'
else:
    coords = self
    outer_fmt = '({}, {})'
    components = (format(c, fmt_spec) for c in coords)
    return outer_fmt.format(*components)

@classmethod
def frombytes(cls, octets):
    typecode = chr(octets[0])
    memv = memoryview(octets[1:]).cast(typecode)
    return cls(*memv)

Подведем итоги. В этом и предыдущем разделах мы видели некоторые специальные методы, которые должен иметь полноценный объект. Разумеется, не стоит реализовывать все эти методы, если приложение в них не нуждается. Пользователям наплевать, соответствует ваш объект «духу Python» или нет.

Представленный в примере 9.6. класс Vector2d — это написанный в педагогических целях код, изобилующий специальными методами, относящимися к представлению объекта, а не образец для создания любого пользовательского класса.

В следующем разделе мы отвлечемся от класса Vector2d и обсудим дизайн и недостатки механизма закрытых атрибутов в Python — двойное подчеркивание в начале имени self.__x.

Закрытые и «защищенные» атрибуты в Python

В Python не существует способа создать закрытые переменные, как с помощью модификатора private в Java. Мы имеем лишь простой механизм, предотвращающий случайную модификацию «закрытого» атрибута в подклассе.

Рассмотрим такую ситуацию: кто-то написал класс Dog, в котором используется внутренний атрибут экземпляра mood, который автор не хотел раскрывать клиентам. Нам нужно написать подкласс Dog — Beagle. Если мы создадим свой атрибут экземпляра mood, не подозревая о конфликте имен, то затрем атрибут mood, используемый в методах, унаследованных от Dog. Отлаживать такую ошибку непросто.

Чтобы предотвратить это, мы можем назвать атрибут __mood (с двумя начальными подчерками и, возможно, одним — не более — конечным подчерком). Тогда Python сохранит имя в словаре экземпляра __dict__, добавив в начало один подчерк и имя класса, т. е. в классе Dog атрибут __mood будет называться _Dog__mood, а в классе Beagle — _Beagle__mood. Эта особенность языка имеет прелестное название — декорирование имен (name mangling).

В примере 9.10 показано, как это выглядит в классе Vector2d из примера 9.7.