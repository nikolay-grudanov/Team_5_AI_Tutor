---
source_image: page_694.png
page_number: 694
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 54.03
tokens: 11843
characters: 2192
timestamp: 2025-12-24T02:07:02.355360
finish_reason: stop
---

self.price = price

def subtotal(self):
    return self.weight * self.price

1 LineItem — подкласс model.Entity.

Пример 21.14 выглядит совершенно безобидно. Нет никаких странных синтаксических конструкций. Однако работает он лишь потому, что в файле model_v7.py определен метакласс, и model.Entity является экземпляром этого метакласса. В примере 21.15 показана реализация класса Entity в модуле model_v7.py.

Пример 21.15. model_v7.py: метакласс EntityMeta и один его экземпляр, Entity

class EntityMeta(type):
    """Метакласс для прикладных классов с контролируемыми полями"""

    def __init__(cls, name, bases, attr_dict):
        super().__init__(name, bases, attr_dict)
        for key, attr in attr_dict.items():
            if isinstance(attr, Validated):
                type_name = type(attr).__name__
                attr.storage_name = '_{}#{}'.format(type_name, key)

class Entity(metaclass=EntityMeta):
    """Прикладной класс с контролируемыми полями"""

1 Вызываем метод __init__ суперкласса (в данном случае type).
2 Та же логика, что в декораторе @entity из примера 21.4.
3 Этот класс существует только для удобства: пользователю модуля нужно просто унаследовать ему.

Код из примера 21.14 проходит все тесты из примера 21.3. Поддерживающий его модуль model_v7.py труднее понять, чем model_v6.py, зато пользовательский код проще: стоит унаследовать классу model_v7.entity, как мы получаем специализированные имена атрибутов хранения для полей типа Validated.

На рис. 21.4 изображена упрощенная картина того, что мы сейчас реализовали. Вся сложность скрыта внутри модуля model_v7. С точки зрения пользователя, LineItem — просто подкласс Entity, как показано в примере 21.14. Такова сила абстракции.

За исключением синтаксиса связывания класса с метаклассом5, все сказанное до сих пор о метаклассах применимо к версиям Python, начиная с 2.2, когда система типов Python была подвергнута значительной переработке. Но в следующем разделе мы рассмотрим механизм, имеющийся только в Python 3.

5 Напомним (см. раздел «Синтаксические детали ABC» главы 11), что в Python 2.7 используется атрибут __metaclass__, а аргумент metaclass= keyword в объявлении класса не поддерживается.