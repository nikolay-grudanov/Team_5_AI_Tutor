---
source_image: page_665.png
page_number: 665
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 61.66
tokens: 11961
characters: 2186
timestamp: 2025-12-24T02:05:54.284189
finish_reason: stop
---

Переопределяющие и непереопределяющие дескрипторы

существует метода __get__, который мог бы перехватить эту операцию доступа. Если путем прямой записи в атрибут экземпляра __dict__ был создан одноименный атрибут экземпляра с другим значением, то метод __set__ все равно будет перехватывать последующие попытки изменить этот атрибут, однако его чтение просто вернет новое значение атрибута, а не объект дескриптора. Другими словами, атрибут экземпляра маскирует дескриптор, но только при чтении. См. пример 20.10.

Пример 20.10. Переопределяющий дескриптор без __get__:
obj.over_no_get — экземпляр класса OverridingNoGet (из примера 20.8)

>>> obj.over_no_get ①
<__main__.OverridingNoGet object at 0x665bcc>
>>> Managed.over_no_get ②
<__main__.OverridingNoGet object at 0x665bcc>
>>> obj.over_no_get = 7 ③
-> OverridingNoGet.__set__(<OverridingNoGet object>, <Managed object>, 7)
>>> obj.over_no_get ④
<__main__.OverridingNoGet object at 0x665bcc>
>>> obj.__dict__['over_no_get'] = 9 ⑤
>>> obj.over_no_get ⑥
9
>>> obj.over_no_get = 7 ⑦
-> OverridingNoGet.__set__(<OverridingNoGet object>, <Managed object>, 7)
>>> obj.over_no_get ⑧
9

① В этом переопределяющем дескрипторе нет метода __get__, поэтому чтение obj.over_no_get извлекает экземпляр дескриптора из класса.
② То же происходит, если извлечь экземпляр дескриптора непосредственно из управляемого класса.
③ Попытка присвоить значение атрибуту obj.over_no_get активирует метод дескриптора __set__.
④ Поскольку наш метод __set__ не производит никаких изменений, повторное чтение obj.over_no_get извлекает все тот же экземпляр дескриптора из управляемого класса.
⑤ Устанавливаем атрибут экземпляра с именем over_no_get через атрибут __dict__ экземпляра.
⑥ Теперь новый атрибут экземпляра over_no_get маскирует дескриптор, но только при чтении.
⑦ Попытка присвоить значение атрибуту obj.over_no_get по-прежнему проходит через метод __set__ дескриптора.
⑧ Но при чтении дескриптор замаскирован до тех пор, пока существует одноименный атрибут экземпляра.

Непереопределяющий дескриптор

Дескриптор, в котором не реализован метод __set__, называется непереопределяющим. Установка атрибута экземпляра с таким же именем маскирует дескрип-