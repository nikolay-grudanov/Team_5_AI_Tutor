---
source_image: page_388.png
page_number: 388
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 54.12
tokens: 12116
characters: 2994
timestamp: 2025-12-24T01:52:51.155571
finish_reason: stop
---

Глава 12. Наследование: хорошо или плохо

Tkinter не следует большинству изложенных выше рекомендаций за исключением № 7. Но даже в этом отношении я бы не стал ставить ее в пример, потому что композиция, пожалуй, была бы уместнее для интеграции менеджеров компоновки с классом Widget, о чем было описано в рекомендации № 8.

Строка документации tkinter.Widget начинается словами «Internal class». Это наводит на мысль, что Widget, наверное, следовало бы сделать ABC. Хотя у класса Widget нет собственных методов, он, тем не менее, определяет интерфейс. Его посыл таков: «Можете рассчитывать, что каждый виджет Tkinter предоставляет основные методы виджета (__init__, destroy и десятки функций из Tk API) в дополнение к методам всех трех менеджеров компоновки». Можно согласиться, что такое определение интерфейса далеко от совершенства (слишком широкое), но все же это интерфейс, а Widget «определяет» его как объединение интерфейсов своих суперклассов.

Класс Tk, который инкапсулирует прикладную логику графического интерфейса пользователя (ГИП), наследует классам Wm и misc, не являющимся ни абстрактными, ни примесями (Wm — не совсем примесь, потому что ему наследует topLevel). От самого имени класса misc очень сильно отдает запашком. В misc больше 100 методов, и ему наследуют все виджеты. А разве каждому виджету нужны методы для работы с буфером обмена, для выделения текста, для управления таймером и т. д.? Ведь невозможно вставить что-то в кнопку из буфера обмена или выделить текст полосы прокрутки. Класс misc следовало бы разбить на несколько специализированных классов-примесей и не заставлять все виджеты наследовать каждому из этих классов.

Но будем справедливы — пользователю Tkinter вовсе необязательно знать о множественном наследовании. Эта деталь реализации скрыта за фасадом классов виджетов, которые вы инстанцируете или которым наследуете в своем коде. Однако пользователь почувствует последствия злоупотребления множественным наследованием, если наберет dir(tkinter.Button) и попытается найти нужный метод среди 214 перечисленных атрибутов.

Несмотря на все проблемы, Tkinter — стабильный, гибкий и совсем не уродливый пакет. Оригинальные (подразумеваемые по умолчанию) виджеты Tk не поддерживают темы — непременную характеристику современных графических интерфейсов, но есть пакет ttk, предлагающий элегантные, соответствующие платформе виджеты, благодаря которым, начиная с версии Python 3.1 (2009), можно разрабатывать профессиональные ГИП. Кроме того, некоторые унаследованные виджеты, например Canvas и Text, обладают поразительно богатыми возможностями. Добавив немного своего кода, вы можете превратить объект Canvas в простое приложение для рисования, поддерживающее перетаскивание. С Tkinter и Tcl/Tk определенно стоит познакомиться, если вы занимаетесь программированием ГИП.

Однако наша тема — не программирование ГИП, а использование множественного наследования на практике. Более современный пример — с явными классами-примесями — можно найти в Django.