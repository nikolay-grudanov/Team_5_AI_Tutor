---
source_image: page_364.png
page_number: 364
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 45.87
tokens: 11962
characters: 2632
timestamp: 2025-12-24T01:51:30.946457
finish_reason: stop
---

def __len__(self):
    return 0

@classmethod
def __subclasshook__(cls, C):
    if cls is Sized:
        if any("__len__" in B.__dict__ for B in C.__mro__): # 1
            return True # 2
        return NotImplemented # 3

1 Если в словаре __dict__ любого класса, перечисленного в C.__mro__ (т. е. C и его суперклассах), существует атрибут с именем __len__ ...
2 ... то возвращаем True, сигнализируя о том, что C — виртуальный подкласс Sized.
3 Иначе возвращаем NotImplemented, чтобы продолжить проверку подкласса.

Если вас интересуют детали проверки подкласса, загляните в исходный код метода ABCMeta.__subclasscheck__ в файле Lib/abc.py (https://hg.python.org/cpython/file/3.4/Lib/abc.py#l194). Предупреждение: в этом коде уйма if'ов и два рекурсивных вызова.

Метод __subclasshook__ добавляет ДНК утиной типизации к тому, что предлагаёт гусиная типизация. Несмотря на наличие формального определения интерфейса в АВС и скрупулезных проверок, осуществляемых функцией isinstance, в определённых контекстах вполне можно использовать никак не связанный с АВС класс, просто потому что в нем реализован определённый метод (или потому что он постарался убедить __subclasshook__, что за него можно поручиться). Разумеется, это работает только для тех АВС, в которых реализован метод __subclasshook__.

Следует ли реализовывать __subclasshook__ в своих собственных АВС? Пожалуй, нет. Все реализации __subclasshook__, которые я встречал в исходном коде Python, находятся в АВС типа Sized, где объявлен только один специальный метод, и они просто проверяют имя этого метода. Учитывая «специальный» статус таких методов, можно с некоторой долей уверенности предположить, что любой метод с именем __len__ делает именно то, что вы от него ожидаете. Но, даже не выходя за пределы специальных методов и фундаментальных АВС, делать такие предположения рискованно. Например, все отображения реализуют методы __len__, __getitem__ и __iter__, но они справедливо не считаются подтипами Sequence, поскольку не позволяют получить элемент по целочисленному смещению и не дают никаких гарантий относительно упорядочения элементов — за исключением, конечно, класса OrderedDict, который сохраняет порядок вставки, но все равно не поддерживает доступ по смещению элемента.

Для тех же АВС, которые могли бы написать вы или я, полагаться на метод __subclasshook__ еще более рискованно. Лично я не готов поверить, что любой класс с именем Spam, который реализует или наследует методы load, pick, inspect и loaded, гарантированно ведет себя как Tombola. Пусть уж лучше программист явно подтвердит это, сделав Spam подклассом Tombola или хотя бы зарегистриро-