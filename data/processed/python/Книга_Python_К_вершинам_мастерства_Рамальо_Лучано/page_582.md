---
source_image: page_582.png
page_number: 582
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 56.38
tokens: 11960
characters: 2750
timestamp: 2025-12-24T02:02:04.748249
finish_reason: stop
---

Глава 18. Применение пакета asyncio для организации...

В сетевых клиентах рассматриваемого сейчас типа всегда следует использовать какой-то механизм дросселирования, чтобы не перегружать сервер чрезмерно большим количеством одновременных запросов, что могло бы привести к снижению общей производительности системы. В скрипте flags2_threadpool.py (пример 17.14) для дросселирования использовался класс ThreadPoolExecutor, обязательный аргумент которого max_workers устанавливался равным значению concur_req в функции download_many; таким образом, пул включал не более concur_req потоков. В скрипте flags2_asyncio.py я использовал объект класса asyncio.Semaphore, созданный функцией downloader_coro (показана ниже, в примере 18.8) и переданный функции download_one в качестве аргумента semaphore.6

В объекте semaphore хранится счетчик, который уменьшается на единицу при каждом вызове сопрограммного метода .acquire() и увеличивается на единицу при вызове сопрограммного метода .release(). Начальное значение счетчика задается в момент создания семафора, как в следующей строке из функции downloader_coro:

semaphore = asyncio.Semaphore(concur_req)

Вызов .acquire() не приводит к блокировке программы, если счетчик больше нуля, но если он равен нулю, что .acquire() блокирует вызывающую сопрограмму до тех пор, пока какая-то другая сопрограмма не вызовет метод .release() того же объекта Semaphore, увеличив тем самым счетчик. В примере 18.7 я не вызываю ни .acquire(), ни .release() явно, а использую semaphore как контекстный менеджер в следующем фрагменте функции download_one:

with (yield from semaphore):
    image = yield from get_flag(base_url, cc)

Этот код гарантирует, что ни в какой момент времени не будет запущено более concur_req экземпляров сопрограммы get_flags.

Теперь посмотрим, что еще есть в скрипте из примера 18.8. Отметим, что большая часть функциональности прежней функции download_many теперь перемещена в сопрограмму downloader_coro. Это необходимо, потому что мы должны использовать yield from для получения результатов будущих объектов, которые отдает asyncio.as_completed, а, стало быть, as_completed должна вызываться из сопрограммы. Однако я не мог просто преобразовать download_many в сопрограмму, потому что должен передавать ее функции main из модуля flags2_common в последней строчке скрипта, а функция main ожидает не сопрограмму, а обычную функцию. Поэтому я написал функцию downloader_coro, которая обертывает as_completed, а на долю download_many остается инициализация цикла обработки событий и планирование downloader_coro — для этого нужно лишь передать ее методу loop.run_until_complete.

6 Спасибо Гуто Майа, который обратил внимание на отсутствие описания класса Semaphore в черновом варианте рукописи.