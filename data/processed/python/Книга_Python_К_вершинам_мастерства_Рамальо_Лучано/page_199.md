---
source_image: page_199.png
page_number: 199
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 55.34
tokens: 12010
characters: 2504
timestamp: 2025-12-24T01:44:10.168312
finish_reason: stop
---

Функционально-ориентированная стратегия

Пример 6.4. Пример использования класса Order, в котором стратегии скидки реализованы в виде функций

>>> joe = Customer('John Doe', 0) ①
>>> ann = Customer('Ann Smith', 1100)
>>> cart = [LineItem('banana', 4, .5),
...           LineItem('apple', 10, 1.5),
...           LineItem('watermelon', 5, 5.0)]
>>> Order(joe, cart, fidelity_promo) ②
<Order total: 42.00 due: 42.00>
>>> Order(ann, cart, fidelity_promo)
<Order total: 42.00 due: 39.90>
>>> banana_cart = [LineItem('banana', 30, .5),
...                 LineItem('apple', 10, 1.5)]
>>> Order(joe, banana_cart, bulk_item_promo) ③
<Order total: 30.00 due: 28.50>
>>> long_order = [LineItem(str(item_code), 1, 1.0)
...                for item_code in range(10)]
>>> Order(joe, long_order, large_order_promo)
<Order total: 10.00 due: 9.30>
>>> Order(joe, cart, large_order_promo)
<Order total: 42.00 due: 42.00>

① Те же тестовые фикстуры, что в примере 6.1.
② Для применения стратегии скидки к объекту Order нужно просто передать функцию скидки в качестве аргумента.
③ Здесь и в следующем тесте используются разные функции скидки.

По поводу выносок в примере 6.4: нет необходимости создавать новый объект скидки для каждого заказа — функции и так готовы к применению.

Интересно, что авторы «Паттернов проектирования» замечают: «в большинстве случаев объекты-стратегии подходят как приспособленцы»3. В другой части книги паттерн Приспособленец определяется так: «Приспособленец — это разделяемый объект, который можно использовать одновременно в нескольких контекстах».4 Разделение рекомендуется для того, чтобы сэкономить на стоимости создания экземпляров конкретных стратегий, которые многократно применяются в каждом новом контексте — в нашем примере к каждому объекту Order. Поэтому в целях преодоления недостатка паттерна Стратегия — высоких накладных расходов во время выполнения — авторы рекомендуют применять еще один паттерн. И тем самым увеличивается объем и сложность сопровождения кода.

В более сложном случае, когда у конкретных стратегий имеется внутреннее состояние, может оказаться необходимым как-то комбинировать части паттернов Стратегия и Приспособленец. Но часто у конкретных стратегий нет внутреннего состояния, они имеют дело только с данными из контекста. И тогда ничто не мешает использовать обычные функции вместо написания классов с единственным методом, которые реализуют интерфейс, объявленный еще в одном классе. Функ-

3 «Паттерны проектирования», стр. 309.
4 Там же, стр. 192.