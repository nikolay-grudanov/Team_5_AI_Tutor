---
source_image: page_342.png
page_number: 342
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 46.78
tokens: 11880
characters: 2375
timestamp: 2025-12-24T01:50:29.990974
finish_reason: stop
---

...
>>> from collections import abc
>>> isinstance(Struggle(), abc.Sized)
True

Как видим, abc.Sized распознал Struggle как свой «подкласс» безо всякой регистрации, просто потому что для этого необходимо только наличие специального метода __len__ (предполагается, что он реализован правильно с точки зрения синтаксиса — вызывается без аргументов — и семантики — возвращает неотрицательное целое число, интерпретируемое как «длина» объекта; программа, которая реализует специальный метод, например __len__ с какими-то другими, несогласованными, синтаксисом и семантикой, в любом случае обречена на куда более серьезные проблемы).

Итак, вот мое напутствие: реализуя класс, который воплощает концепции, представленные в ABC из модуля numbers, collections.abc или какого-то другого каркаса, либо делайте его подклассом ABC (если необходимо), либо регистрируйте. В начале программы, использующей библиотеку или каркас, где определяются классы, для которых это не сделано, выполняйте регистрацию самостоятельно. Затем, если потребуется проверить, что аргумент (чаще всего это необходимо как раз для аргументов) является, к примеру, «последовательностью», пишите:

isinstance(the_arg, collections.abc.Sequence)

И не определяйте свои ABC (или метаклассы) в производственном коде... Если вам кажется, что без этого не обойтись, держу пари, что это, скорее всего, желание поскорее забить гвоздь, раз уж в руках молоток, — вам (и тем, кому предстоит сопровождать вашу программу) будет куда комфортнее иметь дело с прямолинейным и простым кодом, где нет таких глубин. Valé!

Помимо изобретения термина «гусиная типизация», Алекс подчеркивает, что наследование ABC не сводится к реализации необходимых методов, это еще и четкое заявление о намерениях разработчика. Такое намерение можно сделать явным также путем регистрации виртуального подкласса.

Кроме того, использование функций isinstance и issubclass для проверки принадлежности ABC выглядит уже не столь одиозным. В прошлом эти функции концептуально противоречили динамической типизации, но с появлением ABC они становятся более гибкими. Ведь даже если компонент не является подклассом ABC, его всегда можно зарегистрировать постфактум, так что он пройдет эти явные проверки типа.

Однако и при использовании ABC нужно помнить, что злоупотребление функцией isinstance может быть признаком «дурно пахнувшего кода» — плохо спроек-