---
source_image: page_236.png
page_number: 236
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 59.27
tokens: 11980
characters: 2618
timestamp: 2025-12-24T01:45:49.660068
finish_reason: stop
---

Резюме

В этой главе мы рассмотрели обширный материал, но я старался сделать путешествие по возможности комфортабельным, хотя дорога была ухабистой. Ведь мы по существу вступили на территорию метапрограммирования.

Мы начали с простого декоратора @register без внутренней функции и закончили параметризованным декоратором @clock() с двумя уровнями вложенных функций.

Регистрационные декораторы, хотя и простые по существу, находят реальные применения в развитых каркасах на Python. Мы воспользовались идеей регистрации, чтобы улучшить реализацию паттерна проектирования Стратегия из главы 6.

Параметризованные декораторы почти всегда содержат по меньшей мере две вложенные функции, а иногда и больше, если мы хотим использовать @functools.wraps для создания декоратора, который лучше поддерживает некоторые продвинутые возможности. Одну такую возможность — композицию декораторов — мы вкратце рассмотрели.

Мы также познакомились с двумя впечатляющими декораторами функций из модуля стандартной библиотеки functools: @lru_cache() и @singledispatch.

Для понимания механизма работы декораторов понадобилось разобраться в различиях между этапом импорта и этапом выполнения, в областях действия переменных, в замыканиях и в новом ключевом слове nonlocal. Свободное владение замыканиями и объявлением nonlocal важно не только при написании декораторов, но и при разработке событийно-ориентированных программ с графическим интерфейсом, а также для асинхронного ввода-вывода без обратных вызовов.

Дополнительная литература

В главе 9 «Метапрограммирование» книги David Beazley, Brian K. Jones «Python Cookbook», издание 3 (O'Reilly), есть несколько рецептов — от элементарных декораторов до очень сложных, в том числе такого, который можно вызывать либо как обычный декоратор, либо как фабрику декораторов, например @clock или @clock(). Это рецепт 9.6 «Определение декоратора, принимающего необязательный аргумент».

Грэхем Дамплтон опубликовал в своем блоге (http://bit.ly/1DePPcl) серию статей о способах реализации корректно работающих декораторов, и первая из них называется «How You Implemented Your Python Decorator is Wrong» (Ваш способ реализации декоратора в Python неправильный) (http://bit.ly/1DePVRi). Его обширный опыт в этой области аккуратно инкапсулирован в модуль wrapt (http://wrapt.readthedocs.org/en/latest/), написанный с целью упростить реализацию декораторов и динамических функций-оберток, которые поддерживают интроспекцию и корректно ведут себя, если еще раз подвергаются декорированию, а также в случае применения к методам и использования в качестве дескрипторов (дескрипторы — тема главы 20).