---
source_image: page_221.png
page_number: 221
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 22.84
tokens: 7265
characters: 1298
timestamp: 2025-12-24T02:32:27.888740
finish_reason: stop
---

>>> next(iterator)
3

А теперь осторожно! Мы употребили все три имеющихся в списке элемента. Следите за тем, что произойдет, если еще раз вызвать метод next итератора:

>>> next(iterator)
StopIteration

Ага! Чтобы подать сигнал о том, что мы исчерпали все имеющиеся в итераторе значения, он вызывает исключение StopIteration.

Все верно: итераторы используют исключения для структуризации потока управления. Чтобы подать сигнал о завершении итераций, итератор Python просто вызывает встроенное исключение StopIteration.

Если я продолжу запрашивать значения из итератора, он продолжит вызывать исключения StopIteration, сигнализируя о том, что больше нет значений, доступных для итераций:

>>> next(iterator)
StopIteration
>>> next(iterator)
StopIteration
...

Итераторы Python обычно не могут быть «обнулены» — как только они исчерпаны, им полагается вызывать исключение StopIteration при каждом вызове их функции next(). Чтобы возобновить итерации, вам нужно запросить свежий объект-итератор при помощи функции iter().

Теперь мы знаем все, что нужно для написания нашего класса BoundedRepeater, который прекращает итерации после заданного количества повторений:

class BoundedRepeater:
    def __init__(self, value, max_repeats):
        self.value = value
        self.max_repeats = max_repeats