---
source_image: page_083.png
page_number: 83
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 22.42
tokens: 7318
characters: 1398
timestamp: 2025-12-24T02:29:14.472903
finish_reason: stop
---

Давайте его применим, чтобы декорировать (или обернуть) еще одну функцию:

def greet():
    return 'Привет!'

greet = null_decorator(greet)

>>> greet()
'Привет! '

В этом примере я определил функцию greet и сразу же ее декорировал, пропустив через функцию null_decorator. Понимаю, пока это все выглядит бесполезным. Я ведь о том, что мы намеренно спроектировали пустой декоратор бесполезным, верно? Но через мгновение этот пример разъяснит, как работает специальный синтаксис Python, предназначенный для декораторов.

Вместо того чтобы явным образом вызывать null_decorator с функцией greet и затем по-новому присваивать его переменной, удобнее воспользоваться синтаксисом Python @ для декорирования функции:

@null_decorator
def greet():
    return 'Привет! '

>>> greet()
'Привет! '

Размещение строки @null_decorator перед определением функции аналогично тому, что функция сначала определяется и затем уже прогоняется через декоратор. Синтаксис @ является всего лишь синтаксическим сахаром (syntactic sugar) и краткой формой для этого широко применяемого шаблона.

Обратите внимание: синтаксис @ декорирует функцию непосредственно во время ее определения. При этом становится трудно получить доступ к недекорированному оригиналу без хрупких хакерских фокусов. По этой причине вы можете решить вручную декорировать некоторые функции для сохранения способности вызвать и недекорированную функцию.