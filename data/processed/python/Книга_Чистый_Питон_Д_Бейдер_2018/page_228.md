---
source_image: page_228.png
page_number: 228
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 27.67
tokens: 7359
characters: 1530
timestamp: 2025-12-24T02:32:42.379011
finish_reason: stop
---

Напомним, что в нашем итераторе на основе класса мы смогли подать сигнал об окончании итераций путем вызова исключения StopIteration вручную. Поскольку генераторы полностью совместимы с итераторами на основе класса, за сценой будет по-прежнему происходить то же самое.

К счастью, на этот раз мы будем работать с более приятным интерфейсом. Генераторы прекращают порождать значения, как только поток управления возвращается из функции-генератора каким-либо иным способом, кроме инструкции yield. Это означает, что вам больше вообще не нужно заботиться о вызове исключения StopIteration!

Приведу пример:

def repeat_three_times(value):
    yield value
    yield value
    yield value

Обратите внимание: эта функция-генератор не содержит никакого цикла. В действительности она проста как божий день и состоит всего из трех инструкций yield. Если yield временно приостанавливает выполнение функции и передает значение назад источнику вызова, то что произойдет, когда мы достигнем конца этого генератора? Давайте узнаем:

>>> for x in repeat_three_times('Всем привет'):
...     print(x)
'Всем привет'
'Всем привет'
'Всем привет'

Как вы, возможно, и ожидали, этот генератор прекратил порождать новые значения после трех итераций. Можно предположить, что он это сделал путем вызова исключения StopIteration, когда исполнение достигло конца функции. Но чтобы быть до конца уверенными, давайте подтвердим это еще одним экспериментом:

>>> iterator = repeat_three_times('Всем привет')
>>> next(iterator)
'Всем привет'
>>> next(iterator)