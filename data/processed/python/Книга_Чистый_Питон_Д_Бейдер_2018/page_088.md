---
source_image: page_088.png
page_number: 88
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 24.26
tokens: 7374
characters: 1530
timestamp: 2025-12-24T02:29:24.774433
finish_reason: stop
---

проблем, но имейте это в виду, если работаете над вычислительно емким программным кодом, в котором декорирование применяется часто.

Декорирование функций, принимающих аргументы

Все примеры пока что декорировали только простую нулевую функцию greet, которая вообще не принимала никаких аргументов. Вплоть до этого момента декораторам, которые вы здесь видели, не было дела до переадресации аргументов во входную функцию.

Если применить один из этих декораторов к функции, которая принимает аргументы, то она не заработает правильно. Тогда как декорировать функцию, которая принимает произвольные аргументы?

Вот где на помощь приходят функциональные средства языка Python *args и **kwargs для работы с неизвестными количествами аргументов1. Ниже приведен декоратор proxy, в котором задействуется их преимущество:

def proxy(func):
    def wrapper(*args, **kwargs):
        return func(*args, **kwargs)
    return wrapper

С этим декоратором происходят две вещи, заслуживающие внимания:

□ В определении замыкания wrapper он использует операторы * и **, чтобы собрать все позиционные и именованные аргументы, и помещает их в переменные (args и kwargs).

□ Замыкание wrapper затем переадресует собранные аргументы в оригинальную входную функцию, используя операторы «распаковки аргументов» * и **.

К сожалению, в Python значение операторов «звездочка» и «двойная звездочка» перегружено и меняется в зависимости от контекста, в котором они используются, но надеюсь, вы уловили идею.

1 См. раздел 3.4 «Веселье с *args и **kwargs».