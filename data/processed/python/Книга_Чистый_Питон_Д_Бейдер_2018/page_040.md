---
source_image: page_040.png
page_number: 40
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 25.63
tokens: 7366
characters: 1660
timestamp: 2025-12-24T02:28:17.926993
finish_reason: stop
---

бежать ошибок или утечек, делая практически невозможными ситуации, когда по разным причинам забывают выполнить очистку или высвобождение ресурсов после того, как они стали больше ненужными.

Поддержка инструкции with в собственных объектах

Нужно сказать, что в функции open() или классе threading.Lock нет ничего особенного или чудесного, равно как и в том, что они могут применяться вместе с инструкцией with. Ту же самую функциональность можно обеспечить в собственных классах и функциях путем реализации так называемых менеджеров контекста (context managers)¹.

Что такое менеджер контекста? Это простой «протокол» (или интерфейс), который ваш объект должен соблюдать для того, чтобы поддерживать инструкцию with. В сущности, если вы хотите, чтобы объект функционировал как менеджер контекста, от вас требуется только одно — добавить в него методы __enter__ и __exit__. Python будет вызывать эти два метода в соответствующих случаях в цикле управления ресурсом.

Давайте посмотрим, как это выглядит на практике. Вот пример простой реализации контекстного менеджера open():

class ManagedFile:
    def __init__(self, name):
        self.name = name

    def __enter__(self):
        self.file = open(self.name, 'w')
        return self.file

    def __exit__(self, exc_type, exc_val, exc_tb):
        if self.file:
            self.file.close()

Наш класс ManagedFile подчиняется протоколу менеджера контекста и теперь поддерживает инструкцию with точно так же, как и первоначальный пример с функцией open():

¹ См. документацию Python «Менеджеры контекста инструкции with»: https://docs.python.org/3/reference/datamodel.html#with-statement-context-managers