---
source_image: page_097.png
page_number: 97
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 32.87
tokens: 7415
characters: 1636
timestamp: 2025-12-24T02:29:47.504047
finish_reason: stop
---

Обычный вызов функции с отдельными аргументами кажется излишне многословным и громоздким. Не лучше ли будет просто развернуть векторный объект на три его компонента и передать их все одним разом в функцию print_vector?

(Разумеется, вы могли бы просто переопределить функцию print_vector так, чтобы она принимала один-единственный параметр, представляющий векторный объект, но ради того, чтобы иметь простой пример, мы этот вариант пока проигнорируем.)

К счастью, в Python имеется более подходящий способ справиться с этой ситуацией — при помощи распаковки аргументов функции с использованием оператора *:

```python
>>> print_vector(*tuple_vec)
<1, 0, 1>
>>> print_vector(*list_vec)
<1, 0, 1>
```

Размещение звездочки * перед итерируемым объектом в вызове функции его распакует и передаст его элементы как отдельные позиционные аргументы в вызванную функцию.

Этот прием работает для любого итерируемого объекта, включая выражения-генераторы. В результате использования оператора * с генератором все поступающие из генератора элементы будут использованы и переданы в функцию:

```python
>>> genexpr = (x * x for x in range(3))
>>> print_vector(*genexpr)
```

Помимо оператора * для распаковки последовательностей, в частности кортежей, списков и генераторов, в позиционные аргументы, также имеется оператор ** для распаковки именованных аргументов, поступающих из словарей. Предположим, что наш вектор был представлен в виде следующего объекта dict:

```python
>>> dict_vec = {'y': 0, 'z': 1, 'x': 1}
```

Этот объект-словарь можно передать в функцию print_vector практически таким же образом, использовав оператор ** для распаковки: