---
source_image: page_131.png
page_number: 131
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 19.31
tokens: 7383
characters: 1548
timestamp: 2025-12-24T02:30:22.426268
finish_reason: stop
---

Имя класса используется в строке документации docstring и в реализации метода __repr__, которые функция namedtuple генерирует для нас автоматически.

В этом примере есть и другая синтаксическая диковинка — почему мы передаем поля в виде строки, в которой их имена закодированы как 'цвет пробег'?

Ответ заключается в том, что фабричная функция namedtuple вызывает функцию split() со строковым значением, содержащим имена полей, которая преобразовывает его в список имен полей. Так что в действительности это просто сокращенная запись для приведенных ниже двух шагов:

```python
>>> 'цвет пробег'.split()
['цвет', 'пробег']
>>> Car = namedtuple('Авто', ['цвет', 'пробег'])
```

Разумеется, вы также можете непосредственно передать список со строковыми именами полей, если вы предпочитаете, чтобы это выглядело именно так. Преимущество от использования списка как такового состоит в том, что этот код легче переформатировать, если есть необходимость разбить его на несколько строк кода:

```python
>>> Car = namedtuple('Авто', [
...     'цвет',
...     'пробег',
... ])
```

Что бы вы ни решили, теперь при помощи фабричной функции Car вы можете создавать новые объекты «car». Поведение будет таким же, как если бы вы создали класс Car вручную и определили в нем конструктор, принимающий значения «цвет» и «пробег»:

```python
>>> my_car = Car('красный', 3812.4)
>>> my_car.цвет
'красный'
>>> my_car.пробег
3812.4
```

Помимо получения доступа к значениям, хранящимся в именованном кортеже, по их идентификаторам, вы по-прежнему можете получать к ним