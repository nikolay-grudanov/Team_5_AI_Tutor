---
source_image: page_220.png
page_number: 220
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 30.20
tokens: 7387
characters: 1514
timestamp: 2025-12-24T02:32:31.319337
finish_reason: stop
---

numbers = [1, 2, 3]
for n in numbers:
    print(n)

Вы вправе ожидать, что этот код выведет числа 1, 2 и 3, а затем остановится. И вероятно, вы не ожидаете, что он захламит окно вашего терминала, без устали выводя «3», пока вы в дикой панике не начнете жать на Ctrl+C...

Пора узнать, как написать итератор, который в итоге прекращает генерировать новые значения вместо выполнения бесконечных итераций, потому что это именно то, что обычно делают объекты Python, когда мы используем их в цикле for...in.

Сейчас мы напишем еще один класс итератора, который назовем ограниченным повторителем BoundedRepeater. Он будет похож на наш предыдущий пример с повторителем Repeater, но на этот раз мы хотим, чтобы он останавливался после предопределенного количества повторений.

Давайте задумаемся. Как это сделать? Как итератор сигнализирует о том, что он пуст и исчерпал элементы, выдаваемые во время выполнения итераций? Возможно, вы думали: «Хм, можно вернуть None из метода __next__, и все».

И знаете, это неплохая идея, но проблема в следующем: что делать, если нам нужно, чтобы некий итератор был в состоянии возвращать None в качестве приемлемого значения?

Давайте посмотрим, что для решения этой проблемы делают другие итераторы Python. Я создам простой контейнер, список с несколькими элементами, а затем буду выполнять его итеративный обход до тех пор, пока он не исчерпает элементы, чтобы увидеть, что произойдет:

>>> my_list = [1, 2, 3]
>>> iterator = iter(my_list)
>>> next(iterator)
1
>>> next(iterator)
2