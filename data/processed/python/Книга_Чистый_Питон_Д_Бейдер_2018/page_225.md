---
source_image: page_225.png
page_number: 225
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 25.59
tokens: 7356
characters: 1459
timestamp: 2025-12-24T02:32:36.342650
finish_reason: stop
---

и эффективным... если бы только не существовало более удобного способа писать эти итераторы изначально.

Сюрприз! Вот же он! В который раз Python нас выручает, предлагая еще немного синтаксического сахара, чтобы облегчить написание итераторов. В этом разделе вы увидите, как писать итераторы быстрее и с меньшим объемом кода, используя генераторы и ключевое слово yield.

Бесконечные генераторы

Давайте начнем с того, что посмотрим еще раз на пример с классом Repeater, который я уже использовал, чтобы познакомить вас с идеей итераторов. В нем реализована итеративная обработка бесконечной последовательности значений на основе класса. Вот так этот класс выглядел в своей второй (упрощенной) версии:

class Repeater:
    def __init__(self, value):
        self.value = value
    def __iter__(self):
        return self
    def __next__(self):
        return self.value

Если вы думаете, что «для такого простого итератора тут довольно много исходного кода», то вы абсолютно правы. Некоторые части этого класса кажутся довольно стереотипными, как будто они переносились под копирку с одного итератора на основе класса на другой.

И вот где на сцену выходят генераторы Python. Если я перепишу этот класс итератора в качестве генератора, то он будет выглядеть так:

def repeater(value):
    while True:
        yield value

Мы только что перешли от семи строк кода к трем. Неплохо, правда? Как видите, генераторы похожи на обычные функции, но вместо инструкции