---
source_image: page_218.png
page_number: 218
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 31.63
tokens: 7425
characters: 1789
timestamp: 2025-12-24T02:32:32.585730
finish_reason: stop
---

лизующим протокол итератора. Это намного упрощает восприятие исходного кода.

Более простой класс-итератор

До этого момента наш пример итератора состоял из двух отдельных классов, Repeater и RepeaterIterator. Они соответствовали непосредственно двум фазам, используемым в протоколе итератора Python: сначала подготовке и получению объекта-итератора через вызов функции iter(), а затем неоднократной доставке из него значений через вызов функции next().

Во многих случаях обе эти функциональные обязанности можно взвалить на один-единственный класс. Это позволит сократить объем программного кода, необходимого для написания итератора, основанного на классах.

Я решил этого не делать с первым примером в данном разделе, потому что это внесло бы путаницу в чистоту ментальной модели в основе протокола итератора. Но теперь, когда вы увидели, как писать итератор на основе классов более долгим и более сложным способом, давайте потратим еще минуту, чтобы упростить то, что у нас есть на данный момент.

Помните, почему нам вновь потребовался класс RepeaterIterator? Он был нужен, чтобы принять метод __next__ для доставки новых значений из итератора. Но место определения метода __next__ вовсе не имеет никакого значения. В протоколе итератора имеет значение только то, что метод __iter__ возвращает любой объект с определенным на нем методом __next__.

Поэтому идея такая: RepeaterIterator без конца возвращает одинаковое значение, и он не должен отслеживать никакое внутреннее состояние. Что, если вместо этого добавить метод __next__ непосредственно в класс Repeater?

Тем самым мы смогли бы целиком избавиться от RepeaterIterator и реализовать итерируемый объект при помощи одного-единственного класса Python. Давайте попробуем! Наш пример с новым и упрощенным итератором выглядит так: