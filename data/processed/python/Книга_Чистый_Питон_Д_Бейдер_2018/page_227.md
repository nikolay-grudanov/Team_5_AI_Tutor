---
source_image: page_227.png
page_number: 227
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 27.73
tokens: 7363
characters: 1594
timestamp: 2025-12-24T02:32:42.384550
finish_reason: stop
---

def repeater(value):
    while True:
        yield value

И это вполне подходящая ментальная модель того, что здесь происходит. Дело в том, что, когда инструкция return вызывается внутри функции, она безвозвратно передает управление назад источнику вызова функции. Когда же вызывается инструкция yield, она тоже передает управление назад источнику вызова функции — но она это делает лишь временно.

В отличие от инструкции return, которая избавляется от локального состояния функции, инструкция yield приостанавливает функцию и сохраняет ее локальное состояние. На практике это означает, что локальные переменные и состояние исполнения функции-генератора лишь откладываются в сторону и не выбрасываются полностью. Исполнение может быть возобновлено в любое время вызовом функции next() с генератором в качестве аргумента:

>>> iterator = repeater('Привет')
>>> next(iterator)
'Привет'
>>> next(iterator)
'Привет'
>>> next(iterator)
'Привет'

Это делает генераторы полностью совместимыми с протоколом итератора. По этой причине мне нравится представлять их прежде всего как синтаксический сахар для реализации итераторов.

Вы убедитесь, что в отношении большинства типов итераторов написание функции-генератора будет проще, а восприятие легче, чем определение многословного итератора на основе класса.

Генераторы, которые прекращают генерацию

Этот раздел мы начали с того, что еще раз написали бесконечный генератор. Сейчас вы, вероятно, задаетесь вопросом, как написать генератор, который через некоторое время прекращает порождать значения вместо того, чтобы без конца продолжать это делать.