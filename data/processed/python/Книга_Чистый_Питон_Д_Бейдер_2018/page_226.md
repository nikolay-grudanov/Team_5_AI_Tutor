---
source_image: page_226.png
page_number: 226
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 26.63
tokens: 7365
characters: 1390
timestamp: 2025-12-24T02:32:39.196974
finish_reason: stop
---

возврата return в них для передачи данных назад источнику вызова используется инструкция yield.

Будет ли эта новая реализация генератора по-прежнему работать также, как и наш итератор на основе класса? Давайте стряхнем пыль с теста в цикле for...in, чтобы это выяснить:

>>> for x in repeater('Привет'):
...     print(x)
'Привет'
'Привет'
'Привет'
'Привет'
'Привет'
...

Да! Мы по-прежнему без конца прокручиваем в цикле наши приветствия. Эта намного более короткая реализация генератора, по всей видимости, выполняется таким же образом, что и класс Repeater. (Не забудьте нажать Ctrl+C, если хотите выйти из бесконечного цикла в сеансе интерпретатора.)

Итак, каким же образом эти генераторы работают? Они похожи на нормальные функции, но их поведение очень различается. Начнем с того, что вызов функции-генератора вообще не выполняет функцию. Он просто создает и возвращает объект-генератор:

>>> repeater('Эй')
<generator object repeater at 0x107bcdbf8>

Программный код в функции-генератора исполняется только тогда, когда функция next() вызывается с объектом-генератором в качестве аргумента:

>>> generator_obj = repeater('Эй')
>>> next(generator_obj)
'Эй'

Если вы еще раз прочитаете код функции repeater, то увидите, что, судя по всему, ключевое слово yield каким-то образом останавливает эту функцию-генератор посередине исполнения, а затем возобновляет ее на более позднем этапе: