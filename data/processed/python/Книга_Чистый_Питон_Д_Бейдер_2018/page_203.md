---
source_image: page_203.png
page_number: 203
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 27.21
tokens: 7386
characters: 1617
timestamp: 2025-12-24T02:32:01.073656
finish_reason: stop
---

ром для итеративного обхода контейнера используется range(len(...)), его, как правило, можно еще больше упростить и улучшить.

Как я уже отмечал, циклы for в Python в действительности являются циклами «for each», которые могут выполнять непосредственный перебор элементов контейнера или последовательности без необходимости искать их по индексу. И этот факт я могу задействовать для дальнейшего упрощения этого цикла:

for item in my_items:
    print(item)

Я считаю такое решение вполне питоновским. В нем применено несколько продвинутых функциональных средств Python, но при этом оно остается хорошим и чистым и читается почти как псевдокод из учебника по программированию. Обратите внимание, что в этом цикле больше не отслеживается размер контейнера, а для доступа к элементам не используется нарастающий индекс.

Теперь контейнер сам занимается раздачей элементов для их обработки. Если контейнер упорядочен, то и результирующая последовательность элементов будет такой же. Если контейнер не упорядочен, он будет возвращать свои элементы в произвольном порядке, но цикл по-прежнему охватит их все полностью.

Нужно сказать, что, конечно, вы не всегда будете в состоянии переписать свои циклы таким образом. А что, если, например, вам нужен индекс элемента?

Для таких случаев есть возможность писать циклы, которые поддерживают нарастающий индекс, избегая применения шаблона с range(len(...)), от которого я вас предостерег. Встроенная функция enumerate() поможет вам сделать подобного рода циклы безупречными и питоновскими:

>>> for i, item in enumerate(my_items):
...     print(f'{i}: {item}')

0: a
1: b
2: c