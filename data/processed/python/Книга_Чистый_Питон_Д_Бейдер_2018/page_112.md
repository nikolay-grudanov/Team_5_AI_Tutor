---
source_image: page_112.png
page_number: 112
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 29.05
tokens: 7397
characters: 1792
timestamp: 2025-12-24T02:30:03.007619
finish_reason: stop
---

Отличия Python 2.x: __unicode__

В Python 3 имеется один тип данных на все случаи жизни для представления текста: str. Он содержит символы Юникода и может представлять большинство систем письменности в мире.

В Python 2.x для строковых данных используется другая модель данных1. Для представления текста служат два типа: str, который ограничен набором символов ASCII, и unicode, который эквивалентен типу str Python 3.

Вследствие этой разницы в Python 2 существует еще один дандер-метод в составе методов управления преобразованием строк: __unicode__. В Python 2 __str__ возвращает байты, тогда как __unicode__ возвращает символы.

По своим замыслу и целям метод __unicode__ является более новым и предпочтительным методом управления преобразованием строк. Кроме того, имеется сопровождающая его встроенная функция unicode(). Она вызывает соответствующий дандер-метод подобно тому, как работают функции str() и repr().

Чем дальше, тем лучше. Но все станет намного причудливее, когда вы посмотрите на правила вызова методов __str__ и __unicode__ в Python 2.

Инструкция print и функция str() вызывают метод __str__. Встроенная в Python 2 функция unicode() вызывает метод __unicode__, если он существует; в противном случае отыгрывает назад к методу __str__ и декодирует результат в системную кодировку текста.

По сравнению с Python 3 эти особые случаи несколько усложняют правила преобразования текста. Но есть способ все снова упростить в практическом плане. Юникод является предпочтительным и перспективным способом работы с текстом в программах Python.

Поэтому в Python 2.x я в целом рекомендовал бы размещать весь свой код форматирования строк внутрь метода __unicode__, а затем создавать

1 См. документацию Python 2 «Модель данных»: https://docs.python.org/2/reference/datamodel.html