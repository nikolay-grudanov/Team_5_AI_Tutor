---
source_image: page_087.png
page_number: 87
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 24.41
tokens: 7361
characters: 1453
timestamp: 2025-12-24T02:29:24.468403
finish_reason: stop
---

таксис @ и просто «уложить» многочисленные декораторы вертикально поверх одной-единственной функции:

@strong
@emphasis
def greet():
    return 'Привет!'

Какой результат вы ожидаете увидеть, если выполнить декорированную функцию? Сначала декоратор @emphasis добавит тег <em>? Или же приоритет имеет тег @strong? Когда вы вызываете декорированную функцию, происходит вот что:

>>> greet()
'<strong><em>Привет!</em></strong>'

Этот результат ясно показывает, в каком порядке декораторы были применены: снизу вверх. Сначала входная функция была обернута декоратором @emphasis, и затем результирующая (декорированная) функция снова была обернута декоратором @strong.

Чтобы помочь себе запомнить порядок следования снизу-вверх, мне нравится называть такое поведение стековой укладкой декораторов. Стек начинают строить снизу и затем продолжают добавлять новые блоки поверх старых, поднимаясь все выше и выше.

Если разложить приведенный выше пример и избавиться от синтаксиса @, который применяют декораторы, то цепочка вызовов функций-декораторов выглядит так:

decorated_greet = strong(emphasis(greet))

И снова вы видите, что сначала применяется декоратор emphasis и затем результирующая обернутая функция снова обертывается декоратором strong.

Это также означает, что глубокие уровни стековой укладки декораторов в конечном счете скажутся на производительности, потому что они будут добавлять все новые вызовы вложенных функций. На практике в этом нет