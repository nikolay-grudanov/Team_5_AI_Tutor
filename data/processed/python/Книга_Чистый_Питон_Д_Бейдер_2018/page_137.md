---
source_image: page_137.png
page_number: 137
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 26.56
tokens: 7373
characters: 1455
timestamp: 2025-12-24T02:30:41.435470
finish_reason: stop
---

к другому. И поэтому модификация переменной экземпляра одновременно затрагивает только один экземпляр объекта.

Ладно, все это было довольно абстрактно — самое время рассмотреть немного исходного кода! Давайте потренируемся на собачках... В обучающих пособиях, посвященных ООП, для иллюстрации этого тезиса всегда используются автомобили или домашние животные, и мне сложно отказаться от этой традиции.

Что собаке для счастья нужно? Правильно! Четыре лапы да имя:

class Dog:
    num_legs = 4   # <- Переменная класса

    def __init__(self, name):
        self.name = name   # <- Переменная экземпляра

О’кей. У нас есть изящное объектно-ориентированное представление ситуации с собакой, которую я только что описал. Создание новых экземпляров Dog работает, как и ожидалось, и каждый из них получает переменную экземпляра с именем name:

>>> jack = Dog('Джек')
>>> jill = Dog('Джилл')
>>> jack.name, jill.name
('Джек', 'Джилл')

Во всем, что касается переменных класса, всегда есть чуть больше гибкости. Доступ к переменной класса num_legs можно получить либо непосредственно в каждом экземпляре Dog, либо в самом классе:

>>> jack.num_legs, jill.num_legs
(4, 4)
>>> Dog.num_legs
4

Однако попытка получить доступ к переменной экземпляра через класс потерпит неудачу с исключением AttributeError. Переменные экземпляра характерны для каждого экземпляра объекта и создаются, когда выполняется конструктор __init__ — они даже не существуют в самом классе.