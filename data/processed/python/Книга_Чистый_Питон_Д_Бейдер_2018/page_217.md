---
source_image: page_217.png
page_number: 217
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 27.62
tokens: 7384
characters: 1534
timestamp: 2025-12-24T02:32:24.273139
finish_reason: stop
---

Repeater, или другим типом последовательности — все это просто детали реализации. Эти объекты все до единого можно проходить таким же образом при помощи мощных возможностей итераторов.

Как вы убедились, в Python нет ничего особенного в циклах for...in. Если вы заглянете за кулисы, то увидите, что все сводится к вызову правильных дандер-методов в нужное время.

На самом деле в сеансе интерпретатора Python можно вручную «эмулировать» то, как цикл использует протокол итератора:

```python
>>> repeater = Repeater('Привет')
>>> iterator = iter(repeater)
>>> next(iterator)
'Привет'
>>> next(iterator)
'Привет'
>>> next(iterator)
'Привет'
...
```

Этот фрагмент кода дает тот же самый результат — бесконечный поток приветствий. Всякий раз, когда вы вызываете next(), итератор снова выдает то же самое приветствие.

Между прочим, здесь я воспользовался возможностью замены вызовов __iter__ и __next__ на вызовы встроенных в Python функций iter() и next().

На внутреннем уровне эти встроенные функции вызывают те же самые дандер-методы, но они делают программный код немного симпатичнее и более удобочитаемым, предоставляя протоколу итератора чистый «фасад».

Python предлагает эти фасады также и для другой функциональности. Например, len(x) является краткой формой для вызова x.__len__. Точно так же вызов функции iter(x) вызывает метод x.__iter__, а вызов функции next(x) вызывает метод x.__next__.

В целом неплохая идея использовать встроенные фасадные функции, вместо того чтобы непосредственно обращаться к дандер-методам, реа-