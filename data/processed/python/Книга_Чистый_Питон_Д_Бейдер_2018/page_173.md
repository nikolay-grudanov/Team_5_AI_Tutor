---
source_image: page_173.png
page_number: 173
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 33.05
tokens: 7433
characters: 1478
timestamp: 2025-12-24T02:31:27.140365
finish_reason: stop
---

>>> import dis
>>> dis.dis(compile("(23, 'a', 'b', 'c')", '', 'eval'))
    0 LOAD_CONST        4 ((23, 'a', 'b', 'c'))
    3 RETURN_VALUE

>>> dis.dis(compile("[23, 'a', 'b', 'c']", '', 'eval'))
    0 LOAD_CONST        0 (23)
    3 LOAD_CONS          1 ('a')
    6 LOAD_CONS          2 ('b')
    9 LOAD_CONST        3 ('c')
   12 BUILD_LIS         4
   15 RETURN_VALUE

Однако вам не стоит особенно налегать на эти различия. На практике разница в производительности часто будет незначительной, и попытка выжать из программы больше эффективности, переключаясь со списков на кортежи, вероятно, будет нерациональной.

Возможным недостатком простых кортежей является то, что данные, которые вы в них храните, извлекаются только путем доступа к кортежу через целочисленные индексы. У вас не получится назначить имена отдельным хранящимся в кортеже свойствам. А это может сказаться на удобочитаемости исходного кода.

Кроме того, кортеж всегда является ситуативной структурой: трудно гарантировать, что у двух кортежей будет одинаковое количество полей и одинаковые хранящиеся в них свойства.

А это — раздолье для ошибок «по недоразумению», например для разночтений порядка следования полей. Поэтому я рекомендую держать минимальное количество полей в кортеже.

# Поля: цвет, пробег, автомат
>>> car1 = ('красный', 3812.4, True)
>>> car2 = ('синий', 40231.0, False)

# Экземпляры кортежа имеют хороший метод repr:
>>> car1
('красный', 3812.4, True)
>>> car2
('синий', 40231.0, False)