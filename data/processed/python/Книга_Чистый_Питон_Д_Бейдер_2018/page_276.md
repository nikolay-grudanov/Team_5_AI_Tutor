---
source_image: page_276.png
page_number: 276
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 22.34
tokens: 7415
characters: 1578
timestamp: 2025-12-24T02:33:47.401993
finish_reason: stop
---

def greet(name):
    return 'Привет, ' + name + '!'

>>> greet('Гвидо')
'Привет, Гвидо!'

Если помните, я уже отмечал, что Python сначала транслирует наш исходный код в промежуточный язык, прежде чем он его «выполнит». Так вот, если это правда, то мы должны увидеть результаты этого шага компиляции. И мы можем.

Каждая функция имеет атрибут __code__ (в Python 3), который мы можем использовать, чтобы получить инструкции виртуальной машины, константы и переменные, используемые нашей функцией greet:

>>> greet.__code__.co_code
b'dx01|x00x17x00dx02x17x00Sx00'
>>> greet.__code__.co_consts
(None, 'Привет,', '!')
>>> greet.__code__.co_varnames
('name',)

Вы видите, что co_consts содержит части строки приветствия, которую собирает наша функция. Константы и код хранятся отдельно, чтобы экономить пространство памяти. Константы... как бы сказать... константны, то есть они не подлежат изменению и используются попеременно в разных местах.

Поэтому вместо того, чтобы повторять фактические постоянные величины в потоке команд co_code, Python хранит константы отдельно в поисковой таблице. Поток команд затем может ссылаться на константу по индексу в поисковой таблице. То же самое верно и для переменных, хранящихся в поле co_varnames.

Надеюсь, что этот общий принцип начинает проясняться. Но рассмотрение потока команд co_code по-прежнему заставляет меня чувствовать себя нехорошо. Этот промежуточный язык явно предназначен для того, чтобы с ним было легко работать виртуальной машине Python, а не людям. В конце концов, для этого существует текстоориентированный исходный код.