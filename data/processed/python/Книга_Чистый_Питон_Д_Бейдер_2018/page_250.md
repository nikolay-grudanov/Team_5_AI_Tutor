---
source_image: page_250.png
page_number: 250
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 24.59
tokens: 7368
characters: 1509
timestamp: 2025-12-24T02:33:11.151374
finish_reason: stop
---

зуем вызывной синтаксис «()», чтобы вызвать функцию и передать ей аргументы:

```python
>>> funcs[0](2, 3)
5
```

Итак, каким же образом мы собираемся использовать функции первого класса, чтобы подрезать нашу цепочечную инструкцию if по размеру? Центральная идея здесь — определить словарь, отображающий ключи по-иска входных условий на функции, которые выполнят предназначенные операции:

```python
>>> func_dict = {
...     'cond_a': handle_a,
...     'cond_b': handle_b
... }
```

Вместо прохождения сквозь инструкции if, проверяя по ходу каждое условие, мы можем выполнить поиск ключа по словарю, чтобы получить функцию-обработчик, а затем вызвать ее:

```python
>>> cond = 'cond_a'
>>> func_dict[cond]()
```

Эта реализация уже почти рабочая, по крайней мере, если условие cond можно найти в словаре. Если же его там нет, то мы получим исключение KeyError.

Давайте отыщем способ поддержки случая по умолчанию, который будет соответствовать исходному ответвлению else. К счастью, все словари Python располагают методом get(), который возвращает либо значение по заданному ключу, либо значение по умолчанию, если ключ не может быть найден. Это именно то, что нам здесь и нужно:

```python
>>> func_dict.get(cond, handle_default)()
```

Поначалу этот фрагмент кода, возможно, будет выглядеть синтаксически странным, но когда вы разложите его по полочкам, то поймете, что он работает в точности как предыдущий пример. Опять-таки, мы используем функции Python первого класса, чтобы передать в поисковый метод