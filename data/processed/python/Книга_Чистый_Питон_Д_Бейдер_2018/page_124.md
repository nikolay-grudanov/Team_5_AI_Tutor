---
source_image: page_124.png
page_number: 124
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 29.48
tokens: 7400
characters: 1351
timestamp: 2025-12-24T02:30:20.389413
finish_reason: stop
---

Если вы проинспектируете оригинальный прямоугольник и его копию, то увидите, что переопределение метода __repr__() прекрасно сработало и процесс мелкого копирования был выполнен, как мы и ждали:

>>> rect
Rectangle(Point(0, 1), Point(5, 6))
>>> srect
Rectangle(Point(0, 1), Point(5, 6))
>>> rect is srect
False

Помните, как в предыдущем примере со списком иллюстрировалась разница между глубокими и мелкими копиями? Здесь я собираюсь применить тот же самый подход. Я изменю объект, находящийся глубоко в иерархии объектов, и затем вы вновь увидите, как это изменение будет отражено в (мелкой) копии:

>>> rect.topleft.x = 999
>>> rect
Rectangle(Point(999, 1), Point(5, 6))
>>> srect
Rectangle(Point(999, 1), Point(5, 6))

Надеюсь, что этот пример показал то, что вы ожидали. Далее, я создам глубокую копию оригинального прямоугольника. Затем внесу в нее одно изменение, и вы увидите, какие объекты были затронуты:

>>> drect = copy.deepcopy(srect)
>>> drect.topleft.x = 222
>>> drect
Rectangle(Point(222, 1), Point(5, 6))
>>> rect
Rectangle(Point(999, 1), Point(5, 6))
>>> srect
Rectangle(Point(999, 1), Point(5, 6))

Вуаля! На этот раз глубокая копия (drect) полностью независима от оригинала (rect) и мелкой копии (srect).

В этом разделе мы рассмотрели многие вопросы, и при этом остались еще некоторые тонкости, связанные с копированием объектов.