---
source_image: page_232.png
page_number: 232
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 32.90
tokens: 7428
characters: 1689
timestamp: 2025-12-24T02:32:50.942539
finish_reason: stop
---

няют шаблоны проектирования в своих программах, у создателей языков растет стимул предлагать абстракции и укороченные пути их реализации.

Именно так происходит эволюция языков, и, как разработчики, мы получаем от этого выгоду. Мы приступаем к работе со все более и более мощными структурными блоками, которые сокращают бесполезную рутину и позволяют достигать большего за меньшее время.

Ранее в этой книге вы увидели, как генераторы предлагают синтаксический сахар для написания итераторов на основе класса. Выражения-генераторы (generator expressions), которые мы рассмотрим в этом разделе, добавят сверху еще один слой синтаксического сахара.

Выражения-генераторы представляют собой еще более эффективную краткую форму для создания итераторов. Благодаря простому и сжатому синтаксису, который похож на конструкцию включения в список, вы сможете определять итераторы в одной строке кода.

Приведу пример:

iterator = ('Привет' for i in range(3))

Во время выполнения итераций данное выражение-генератор порождает ту же самую последовательность значений, что и функция-генератор bounded_repeater, которую мы написали в предыдущем разделе. Ниже привожу ее снова, чтобы освежить вашу память:

def bounded_repeater(value, max_repeats):
    for i in range(max_repeats):
        yield value
iterator = bounded_repeater('Привет', 3)

Разве не удивительно, что односторочное выражение-генератор теперь делает работу, для выполнения которой ранее требовалась четырехстрочная функция-генератор или намного более длинный итератор на основе класса?

Но я бегу впереди паровоза. Давайте убедимся, что наш итератор, определенный при помощи выражения-генератора, действительно работает как ожидалось: