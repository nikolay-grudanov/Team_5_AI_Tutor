---
source_image: page_084.png
page_number: 84
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 25.03
tokens: 7364
characters: 1622
timestamp: 2025-12-24T02:29:17.060280
finish_reason: stop
---

Декораторы могут менять поведение

Теперь, когда вы чуть ближе познакомились с синтаксисом декораторов, давайте напишем еще один декоратор, который действительно что-то делает и изменяет поведение декорированной функции.

Вот чуть более сложный декоратор, который преобразовывает результат декорированной функции в буквы верхнего регистра:

def uppercase(func):
    def wrapper():
        original_result = func()
        modified_result = original_result.upper()
        return modified_result
    return wrapper

Вместо того чтобы просто возвратить входную функцию, как это делал пустой декоратор, декоратор uppercase на лету определяет новую функцию (замыкание) и использует ее в качестве обертки входной функции, чтобы изменить ее поведение во время вызова.

Замыкание wrapper имеет доступ к недекорированной входной функции, и оно свободно может выполнить дополнительный программный код до и после ее вызова. (Технически замыканию вообще не нужно вызывать входную функцию.)

Заметьте, что вплоть до настоящего момента декорированная функция ни разу не была исполнена. На самом деле, в вызове входной функции на данном этапе нет никакого смысла — потребность в том, чтобы декоратор был в состоянии изменить поведение своей входной функции, возникнет, только когда он наконец будет вызван.

Возможно, вам нужен минутный перерыв, чтобы переварить услышанное. Представляю, каким сложным для вас может казаться этот материал, но мы в нем разберемся вместе. Обещаю.

Самое время, чтобы взглянуть на декоратор uppercase в действии. Что произойдет, если продекорировать им оригинальную функцию greet?

@uppercase
def greet():