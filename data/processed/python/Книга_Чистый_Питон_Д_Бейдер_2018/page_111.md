---
source_image: page_111.png
page_number: 111
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 23.97
tokens: 7334
characters: 1457
timestamp: 2025-12-24T02:29:57.622006
finish_reason: stop
---

Оборотной стороной этой реализации является то, что форматная строка довольно длинная и громоздкая. Но при условии выверенного форматирования вы сможете сохранить свой исходный код аккуратным и соответствующим правилам PEP 8.

Во время инспектирования объекта или непосредственного вызова функции repr() с объектом при наличии приведенной выше реализации метода __repr__ мы получаем полезный результат:

```python
>>> repr(my_car)
'Car(red, 37281)'
```

Печать объекта или вызов функции str() с этим объектом возвращают то же самое строковое значение, потому что заданная по умолчанию реализация __str__ просто вызывает метод __repr__:

```python
>>> print(my_car)
'Car(red, 37281)'
>>> str(my_car)
'Car(red, 37281)'
```

Убежден, что этот подход обеспечивает наибольшую эффективность и скромный объем работы по его реализации. Более того, этот подход опирается на типовой шаблон в стиле формы для печенья, который можно применять, не особо задумываясь. По этой причине я всегда стремлюсь добавлять в свои классы элементарную реализацию метода __repr__.

Ниже показан законченный пример для Python 3 с дополнительной реализацией метода __str__:

```python
class Car:
    def __init__(self, color, mileage):
        self.color = color
        self.mileage = mileage
    def __repr__(self):
        return (f'{self.__class__.__name__}('
                f'{self.color!r}, {self.mileage!r})')
    def __str__(self):
        return f'{self.color} автомобиль'
```