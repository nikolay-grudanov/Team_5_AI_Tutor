---
source_image: page_046.png
page_number: 46
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 28.00
tokens: 7323
characters: 1358
timestamp: 2025-12-24T02:28:29.849726
finish_reason: stop
---

Взгляните на приведенный ниже пример:

class Test:
    def __init__(self):
        self.foo = 11
        self._bar = 23

Что случится, если создать экземпляр этого класса и попробовать получить доступ к атрибутам foo и _bar, определенным в его конструкторе __init__?

Давайте узнаем:

>>> t = Test() >>> t.foo
11
>>> t._bar
23

Как видите, одинарный начальный символ подчеркивания в _bar не помешал нам «залезть» в класс и получить доступ к значению этой переменной.

Все потому, что в Python префикс, состоящий из одинарного подчеркивания, представляет собой просто согласованную договоренность — по крайней мере в том, что касается имен переменных и методов. Вместе с тем начальные символы подчеркивания влияют на то, как имена импортируются из модулей. Предположим, что у вас есть модуль my_module и в нем есть следующий фрагмент кода:

# my_module.py:

def external_func():
    return 23

def _internal_func():
    return 42

Так вот, если для импорта всех имен из модуля вы будете использовать подстановочный импорт (wildcard import) (*), то Python не будет импортировать имена с начальным символом подчеркивания (если только в модуле не определен список __all__, который отменяет такое поведение¹):

¹ См. документацию Python «Импортирование с подстановочным знаком * из пакета»: https://docs.python.org/3/tutorial/modules.html#importing-from-a-package