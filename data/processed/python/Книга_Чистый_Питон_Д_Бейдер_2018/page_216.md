---
source_image: page_216.png
page_number: 216
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 27.90
tokens: 7404
characters: 1726
timestamp: 2025-12-24T02:32:24.497399
finish_reason: stop
---

Чтобы рассеять часть этого «волшебства», мы можем расширить цикл в слегка удлиненном фрагменте кода, который дает тот же самый результат:

repeater = Repeater('Привет')
iterator = repeater.__iter__()
while True:
    item = iterator.__next__()
    print(item)

Как видите, конструкция for...in была всего лишь синтаксическим сахаром для простого цикла while:

- Этот фрагмент кода сначала подготовил объект repeater к итерации, вызвав его метод __iter__. Он вернул фактический объект-итератор.
- После этого цикл неоднократно вызывал метод __next__ объекта-итератора, чтобы извлекать из него значения.

Если вы когда-либо работали с курсорами базы данных (database cursors), то эта ментальная модель будет выглядеть похожей: мы сначала инициализируем курсор и готовим его к чтению, а затем можем доставлять из него данные, один элемент за другим, в локальные переменные в нужном объеме.

Поскольку «в активном состоянии» никогда не находится более одного элемента, этот подход чрезвычайно эффективен с точки зрения потребляемой оперативной памяти. Наш класс Repeater обеспечивает бесконечную последовательность элементов, и мы можем без проблем выполнять по нему итерации. Имитация того же самого при помощи списка Python list была бы невозможной — прежде всего, нет никакой возможности создать список с бесконечным количеством элементов. И это превращает итераторы в очень мощную концепцию.

Говоря более абстрактно, итераторы обеспечивают единый интерфейс, который позволяет вам обрабатывать каждый элемент контейнера, оставаясь полностью изолированным от внутренней структуры последнего.

Имеете ли вы дело со списком элементов, словарем, бесконечной последовательностью, например такой, которая обеспечивается нашим классом