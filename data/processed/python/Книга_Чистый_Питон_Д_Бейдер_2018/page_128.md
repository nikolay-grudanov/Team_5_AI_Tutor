---
source_image: page_128.png
page_number: 128
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 22.53
tokens: 7401
characters: 1705
timestamp: 2025-12-24T02:30:21.684130
finish_reason: stop
---

Этот фрагмент кода по-прежнему ведет себя так, как нужно, и создает правильную иерархию классов:

assert issubclass(Concrete, Base)

С другой стороны, мы здесь получаем еще одно преимущество. Подклассы Base вызывают исключение TypeError во время создания экземпляра всякий раз, когда мы забываем реализовать какие-либо абстрактные методы. Вызванное исключение говорит о том, какой метод или методы отсутствуют:

>>> c = Concrete()
TypeError:
"Can't instantiate abstract class Concrete with abstract methods bar"

Без модуля abc мы получали бы только исключение NotImplementedError в случае фактического вызова отсутствующего метода. Возможность получать уведомления об отсутствующих методах во время создания экземпляра является большим преимуществом. В результате написание недопустимых подклассов в значительной степени блокируется. Возможно, этот факт не сыграет какой-то особой роли, если вы пишете новый код, но обещаю, что спустя несколько недель или месяцев он станет полезным.

Безусловно, этот шаблон не является полной заменой проверки типов во время компиляции. Однако я обнаружил, что он часто делает иерархии классов более прочными и более удобными в сопровождении. Использование абстрактных классов позволяет программисту четче формулировать свой замысел и таким образом делает код более коммуникативным. Я рекомендую вам почитать документацию по модулю abc и присмотреться к ситуациям, где применение этого шаблона имеет смысл.

Ключевые выводы

☐ Абстрактные классы (АК) следят за тем, чтобы производные классы реализовывали те или иные методы базового класса во время создания экземпляра.

☐ Применение АК помогает избежать ошибок и сделать иерархии классов более легкими в сопровождении.