---
source_image: page_202.png
page_number: 202
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 31.30
tokens: 7435
characters: 1733
timestamp: 2025-12-24T02:32:05.006878
finish_reason: stop
---

В Python можно писать циклы, которые справляются с этими двумя задачами автоматически. И будет просто замечательно, если вы возьмете это на вооружение. Например, если вашему коду не придется отслеживать нарастающий индекс, то будет намного труднее написать непреднамеренный бесконечный цикл. Это также сделает программный код более сжатым и поэтому удобочитаемым.

Чтобы рефакторизовать первый пример кода, я начну с того, что удалю фрагмент, который вручную обновляет индекс. В Python лучше всего для этого применить цикл for. При помощи встроенной фабричной функции range() я могу генерировать индексы автоматически:

```python
>>> range(len(my_items))
range(0, 3)

>>> list(range(0, 3))
[0, 1, 2]
```

Тип range представляет неизменяемую последовательность чисел. Его преимущество перед обычным списком list в том, что он всегда занимает одинаково небольшое количество оперативной памяти. Объекты-диапазоны в действительности не хранят отдельные значения, представляющие числовую последовательность, вместо этого они функционируют как итераторы и вычисляют значения последовательности на ходу¹.

Поэтому, вместо того чтобы на каждой итерации цикла вручную увеличивать индекс i, я смог воспользоваться функцией range() и написать что-то подобное:

```python
for i in range(len(my_items)):
    print(my_items[i])
```

Уже лучше. Однако этот вариант по-прежнему выглядит не совсем по-питоновски и ощущается больше как итеративная Java-конструкция, а не как настоящий цикл Python. Когда вы видите программный код, в кото-

¹ Чтобы получить такое экономное для оперативной памяти поведение в Python 2, вам придется использовать встроенную функцию xrange(), так как функция range() будет в действительности конструировать объект-список.