---
source_image: page_252.png
page_number: 252
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 26.14
tokens: 7398
characters: 1681
timestamp: 2025-12-24T02:33:16.735098
finish_reason: stop
---

Обратите внимание на то, что 'неизвестный' случай срабатывает, потому что Python добавляет в конец любой функции неявную инструкцию return None.

Пока все неплохо. Теперь преобразуем первоначальную функцию dispatch_if() в новую функцию, использующую словарь для отображения кодов операций в арифметические операции с функциями первого класса:

```python
>>> def dispatch_dict(operator, x, y):
...     return {
...         'add': lambda: x + y,
...         'sub': lambda: x - y,
...         'mul': lambda: x * y,
...         'div': lambda: x / y,
...     }.get(operator, lambda: None)()
```

Такая реализация на основе словаря дает те же самые результаты, что и первоначальная функция dispatch_if(). Мы можем вызвать обе функции точно таким же образом:

```python
>>> dispatch_dict('mul', 2, 8)
16
>>> dispatch_dict('неизвестно', 2, 8)
None
```

Есть пара способов, которыми этот код можно усовершенствовать еще больше, если бы он был реален и предназначался для эксплуатации.

Во-первых, всякий раз, когда мы вызываем dispatch_dict(), он создает временный словарь и кучу лямбд для поиска кода операции. С точки зрения производительности это не идеально. В случае, если программный код нуждается в быстродействии, имеет больше смысла единожды создать словарь в качестве константы и затем ссылаться на него во время вызова функции. Не стоит воссоздавать словарь всякий раз, когда мы должны выполнить по нему поиск.

Во-вторых, если бы мы и правда захотели выполнить несколько простых арифметических операций типа x + y, то вместо используемых в этом примере лямбда-функций было бы гораздо лучше использовать встроенный модуль Python operator. Модуль operator предоставляет реализации