---
source_image: page_239.png
page_number: 239
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 26.13
tokens: 7336
characters: 1351
timestamp: 2025-12-24T02:32:57.502682
finish_reason: stop
---

В то время как обычная функция производит одно-единственное возвращаемое значение, генераторы производят последовательность результатов. Можно сказать, что они генерируют поток значений на протяжении своего жизненного цикла.

Например, я могу определить следующий ниже генератор, который производит серию целочисленных значений от одного до восьми, поддерживая нарастающий счетчик и выдавая новое значение всякий раз, когда с ним вызывается функция next():

def integers():
    for i in range(1, 9):
        yield i

Вы можете подтвердить такое поведение, выполнив данный ниже фрагмент кода в интерпретаторе REPL Python:

>>> chain = integers()
>>> list(chain)
[1, 2, 3, 4, 5, 6, 7, 8]

Пока что не очень интересно. Но сейчас мы быстро это изменим. Дело в том, что генераторы могут быть «присоединены» друг к другу, благодаря чему можно строить эффективные алгоритмы обработки данных, которые работают как конвейер.

Вы можете взять «поток» значений, выходящих из генератора integers(), и направить их в еще один генератор. Например, такой, который принимает каждое число, возводит его в квадрат, а затем передает его дальше:

def squared(seq):
    for i in seq:
        yield i * i

Ниже показано, что будет теперь делать наш «конвейер данных», или «цепочка генераторов»:

>>> chain = squared(integers())
>>> list(chain)
[1, 4, 9, 16, 25, 36, 49, 64]