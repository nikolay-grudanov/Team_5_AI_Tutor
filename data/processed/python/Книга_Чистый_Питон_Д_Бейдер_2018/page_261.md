---
source_image: page_261.png
page_number: 261
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 24.76
tokens: 7382
characters: 1561
timestamp: 2025-12-24T02:33:28.420057
finish_reason: stop
---

И вы хотите создать новый словарь zs, который содержит все ключи и значения xs и все ключи и значения ys. Кроме того, если вы внимательно прочли этот пример, то вы заметили, что строка 'b' появляется в качестве ключа в обоих словарях, — нам также придется продумать стратегию разрешения конфликтов для повторяющихся ключей.

В Python классическое решение задачи «слияния многочисленных словарей» состоит в том, чтобы использовать встроенный в словарь метод update():

```python
>>> zs = {}
>>> zs.update(xs)
>>> zs.update(ys)
```

Если вам любопытно, то наивная реализация функции update() могла бы выглядеть примерно следующим образом. Мы просто перебираем в цикле все элементы словаря с правой стороны и добавляем каждую пару ключ-значение в словарь с левой стороны, по ходу переписывая существующие ключи:

```python
def update(dict1, dict2):
    for key, value in dict2.items():
        dict1[key] = value
```

В результате мы получим новый словарь zs, который теперь содержит ключи, определенные в xs и ys:

```python
>>> zs
>>> {'c': 4, 'a': 1, 'b': 3}
```

Вы также увидите, что порядок, в котором мы вызываем update(), определяет то, как будут разрешаться конфликты. Выигрывает последнее обновление, и повторяющийся ключ 'b' ассоциируется со значением 3, которое поступило из ys, то есть второго исходного словаря.

Разумеется, вы можете расширить эту цепочку вызовов update() настолько, насколько захотите, для того, чтобы объединить любое количество словарей в один словарь. Такое практическое и удобочитаемое решение работает в Python 2 и в Python 3.