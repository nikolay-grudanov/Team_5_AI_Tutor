---
source_image: page_107.png
page_number: 107
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 28.44
tokens: 7411
characters: 1687
timestamp: 2025-12-24T02:29:58.037930
finish_reason: stop
---

магическими не являются. То, что имена этих методов начинаются и оканчиваются символами двойного подчеркивания, является всего-навсего согласованным правилом именования, которое выделяет их как ключевые функциональные средства языка Python. Он также помогает избежать конфликтов из-за совпадения имен с вашими собственными методами и атрибутами. Конструктор объектов __init__ соблюдает то же самое правило, и в этом нет ничего волшебного или загадочного.

Не бойтесь использовать дандер-методы Python — они призваны вам помогать.

Метод __str__ против __repr__

Нужно сказать, что наша история преобразования строк на этом не заканчивается. Вы заметили, что осмотр объекта my_car в сеансе интерпретатора по-прежнему дает этот странный результат <Car object at 0x109ca24e0>?

Это произошло, потому что фактически имеется два дандер-метода, которые управляют тем, как объекты преобразовываются в строковые значения в Python 3. Первый, __str__, и вы только что с ним познакомились. Второй, __repr__, и характер его работы аналогичен методу __str__, но он используется в других ситуациях. (В Python 2.x также имеется метод __unicode__, которого я коснусь чуть позже.)

Ниже приведен простой эксперимент для «обкатки» ситуации, когда используется метод __str__ или __repr__. Давайте переопределим наш автомобильный класс таким образом, чтобы он содержал оба дандер-метода для преобразования в строковое значение с результатами, которые легко различить:

class Car:
    def __init__(self, color, mileage):
        self.color = color
        self.mileage = mileage
    def __repr__(self):
        return '__repr__ для объекта Car'
    def __str__(self):
        return '__str__ для объекта Car'