---
source_image: page_230.png
page_number: 230
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 32.68
tokens: 7410
characters: 1625
timestamp: 2025-12-24T02:32:50.642048
finish_reason: stop
---

Я преднамеренно сделал цикл while в этой функции несколько громоздким. Я хотел продемонстрировать, как вызов инструкции return из генератора приводит к остановке итераций с исключением StopIteration. Мы вскоре подчистим и еще немного упростим эту функцию-генератор, но сначала давайте испытаем то, что у нас есть сейчас:

>>> for x in bounded_repeater('Привет', 4):
...     print(x)
'Привет'
'Привет'
'Привет'
'Привет'

Великолепно! Теперь у нас есть генератор, который прекращает порождать значения после настраиваемого количества повторений. Он использует инструкцию yield, чтобы передавать значения назад до тех пор, пока он наконец не натолкнется на инструкцию return и итерации не прекратятся.

Как я вам обещал, мы можем упростить этот генератор еще больше. Мы воспользуемся тем, что в конец каждой функции Python добавляет невидимую инструкцию return None. И вот как будет выглядеть наша окончательная реализация:

def bounded_repeater(value, max_repeats):
    for i in range(max_repeats):
        yield value

Не стесняйтесь подтвердить, что этот упрощенный генератор по-прежнему работает таким же образом. Учитывая все обстоятельства, мы прошли путь от 12-строчной реализации в классе BoundedRepeater до трехстрочной реализации на основе генератора, обеспечив ту же самую функциональность. А это 75 %-ное сокращение количества строк кода — нехило!

Как вы только что убедились, генераторы помогают «абстрагироваться от» большей части шаблонного кода, который в других обстоятельствах был бы необходим во время написания итераторов на основе класса. Они способны очень облегчить вашу программистскую жизнь и позволяют