---
source_image: page_174.png
page_number: 174
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 30.13
tokens: 7388
characters: 1607
timestamp: 2025-12-24T02:31:24.563926
finish_reason: stop
---

# Получить пробег:
>>> car2[1]
40231.0

# Кортежи неизменяемы:
>>> car2[1] = 12
TypeError:
"'tuple' object does not support item assignment"

# Нет защиты от неверных имен полей
# или отсутствующих/лишних полей:
>>> car3 = (3431.5, 'зеленый', True, 'серебряный')

Написание собственного класса — больше работы, больше контроля

Классы позволяют определять «шаблоны» многократного использования для объектов данных, причем эти шаблоны гарантируют, что каждый объект предоставляет одинаковый набор полей.

Использование обычных классов Python в качестве типов данных запись вполне возможно, но это также влечет за собой ручную работу, связанную с получением удобных функциональных возможностей у других реализаций. Например, добавление новых полей в конструктор __init__ будет многословным и займет время.

Кроме того, принятое по умолчанию строковое представление объектов-экземпляров, создаваемых на основе собственных классов, не очень полезно. Чтобы это исправить, вам, вероятно, придется добавить свой собственный метод __repr__¹, который, как правило, довольно многословен и подлежит обновлению всякий раз, когда вы добавляете новое поле.

Хранящиеся в классах поля могут изменяться, и новые поля могут добавляться свободно, нравится вам это или нет. С помощью декоратора @property можно обеспечить себе большее управление и создавать поля с доступом только для чтения², но это требует написания большего количества связующего кода.

¹ См. раздел «Преобразование строк (каждому классу по __repr__)» главы 4.
² См. документацию Python «property»: https://docs.python.org/3/library/functions.html#property