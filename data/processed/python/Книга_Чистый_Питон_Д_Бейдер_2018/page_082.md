---
source_image: page_082.png
page_number: 82
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 23.06
tokens: 7356
characters: 1622
timestamp: 2025-12-24T02:29:14.910432
finish_reason: stop
---

класса в Python. В этой книге им посвящен целый раздел, и я рекомендую вам потратить несколько минут, чтобы его просмотреть. Самыми важными для понимания декораторов выводами относительно «функций первого класса» являются следующие:

□ функции являются объектами — их можно присваивать переменным, передавать в другие функции и возвращать из других функций;

□ функции могут быть определены внутри других функций — и дочерняя функция может захватывать локальное состояние родительской функции (лексические замыкания).

Готовы? Отлично! Тогда приступим.

Основы декораторов Python

Итак, что же такое декораторы на самом деле? Они «украшают», или «обертывают», другую функцию и позволяют исполнять программный код до и после того, как обернутая функция выполнится.

Декораторы позволяют определять конструктивные блоки многократного использования, которые могут изменять или расширять поведение других функций. И они позволяют это делать без необратимых изменений самой обернутой функции. Поведение функции изменяется, только когда оно декорировано.

Как могла бы выглядеть реализация простого декоратора? В общих чертах декоратор — это вызываемый объект, который на входе принимает один вызываемый объект, а на выходе возвращает другой вызываемый объект.

Приведенная ниже функция имеет это свойство и может считаться самым простым декоратором, который вы могли когда-либо написать:

def null_decorator(func):
    return func

Как вы видите, null_decorator является вызываемым объектом (это функция). На входе он принимает еще один вызываемый объект и на выходе возвращает тот же самый вызываемый объект без его изменения.