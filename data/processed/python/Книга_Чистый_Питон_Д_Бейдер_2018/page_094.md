---
source_image: page_094.png
page_number: 94
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 29.11
tokens: 7378
characters: 1634
timestamp: 2025-12-24T02:29:40.490592
finish_reason: stop
---

Это также дает вам возможность модифицировать аргументы перед тем, как вы передадите их дальше. Вот пример:

def foo(x, *args, **kwargs):
    kwargs['имя'] = 'Алиса'
    new_args = args + ('дополнительный', )
    bar(x, *new_args, **kwargs)

Данный прием может быть полезен для создания производных классов и написания оберточных функций. Например, он может применяться для расширения поведения родительского класса без необходимости повторять полную сигнатуру его конструктора в дочернем классе. Это может быть довольно удобно, если вы работаете с API, который может измениться за пределами вашего контроля:

class Car:
    def __init__(self, color, mileage):
        self.color = color
        self.mileage = mileage
class AlwaysBlueCar(Car):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.color = 'синий'
>>> AlwaysBlueCar('зеленый', 48392).color
'синий'

Конструктор класса AlwaysBlueCar просто передает все аргументы в свой родительский класс и затем переопределяет внутренний атрибут. Это означает, что если конструктор родительского класса изменится, то велика вероятность того, что AlwaysBlueCar будет по-прежнему функционировать как было задумано.

Оборотной стороной здесь является то, что конструктор AlwaysBlueCar теперь имеет довольно бесполезную сигнатуру, — мы не узнаем, какие аргументы он ожидает, не заглянув в родительский класс.

Как правило, вы не будете использовать этот прием со своими собственными иерархиями классов. Более вероятный сценарий будет такой, что вы захотите изменить или переопределить поведение в некотором внешнем классе, которым не управляете.