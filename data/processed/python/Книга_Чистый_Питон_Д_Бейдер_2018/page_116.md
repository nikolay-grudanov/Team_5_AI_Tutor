---
source_image: page_116.png
page_number: 116
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 26.91
tokens: 7375
characters: 1618
timestamp: 2025-12-24T02:30:07.511398
finish_reason: stop
---

File "<input>", line 1, in <module>
    validate('джейн')
File "<input>", line 3, in validate
    raise NameTooShortError(name)
NameTooShortError: джейн

Опять-таки, попытайтесь встать на место своего коллеги по команде. Собственные классы исключений существенно помогают понять, что именно происходит, когда дела идут не так, как надо (а рано или поздно это обязательно случится).

То же самое верно, даже если вы работаете над кодовой базой в полном одиночестве. Несколько недель или месяцев спустя вам будет намного проще выполнять сопроводительную работу, если ваш исходный код будет хорошо структурирован.

Потратив всего 30 секунд на определение простого класса-исключения, вы уже получили намного больший коммуникативный фрагмент кода. Но давайте пойдем дальше. Еще много чего нужно обследовать.

Всякий раз, когда вы выпускаете пакет Python в публичное пространство или создаете модуль многократного использования для своей компании, образцовая практика предусматривает создание для такого модуля собственного базового класса-исключения и затем создание производных от него всех других ваших исключений.

Ниже показано, как создать собственную иерархию исключений для всех исключений в модуле или пакете. Первый шаг состоит в объявлении базового класса, от которого наследуют все конкретные ошибки:

class BaseValidationError( ):
    pass

Далее, все наши «реальные» классы ошибок могут быть сделаны производными от базового класса ошибок. В результате мы получаем хорошую и чистую иерархию исключений, приложив лишь незначительные дополнительные усилия:

class NameTooShortError(BaseValidationError):
    pass