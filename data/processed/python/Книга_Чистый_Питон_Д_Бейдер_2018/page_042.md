---
source_image: page_042.png
page_number: 42
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 26.54
tokens: 7377
characters: 1609
timestamp: 2025-12-24T02:28:19.876415
finish_reason: stop
---

исполнение и передает ресурс инструкцией yield, чтобы его использовал источник вызова. Когда источник вызова покидает контекст with, генератор продолжает выполняться до тех пор, пока не произойдут любые оставшиеся шаги очистки, после чего ресурс будет высвобожден и возвращен системе.

Реализации на основе класса и на основе генератора по своей сути эквивалентны. Вы можете предпочесть тот или иной вариант в зависимости от того, какой подход вы считаете более удобочитаемым.

Оборотной стороной реализации на основе @contextmanager может являться то, что такая реализация требует некоторого вникания в продвинутые понятия языка Python, такие как декораторы и генераторы. Если чувствуете, что вам необходимо в них разобраться, то не стесняйтесь изменять маршрут и перейти к соответствующим главам книги.

Повторю еще раз: правильный выбор реализации здесь сводится к тому, с какой из них вы и ваша команда чувствуете себя комфортно и какую из них вы считаете наиболее удобочитаемой.

Написание красивых API с менеджерами контекста

Менеджеры контекста обладают достаточной гибкостью, и если к применению инструкции with подойти творчески, то для своих модулей и классов вы сможете определять удобные API.

Например, что, если «ресурсом», которым мы хотели бы управлять, являются уровни отступа текста в некоей программе — генераторе отчетов? Что, если бы для этого мы смогли написать исходный код, который выглядит вот так:

with Indenter() as indent:
    indent.print('привет!')
    with indent:
        indent.print('здорово')
        with indent:
            indent.print(' бонжур')
    indent.print('эй')