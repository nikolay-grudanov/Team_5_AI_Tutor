---
source_image: page_179.png
page_number: 179
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 30.99
tokens: 7391
characters: 1464
timestamp: 2025-12-24T02:31:31.416505
finish_reason: stop
---

хранение в других типах данных. Однако чаще всего такая работа будет довольно продвинутой (и, вероятно, ненужной) оптимизацией.

>>> from struct import Struct
>>> MyStruct = Struct('i?f')
>>> data = MyStruct.pack(23, False, 42.0)

# Вы получаете двоичный объект данных (blob):
>>> data
b'x17x00x00x00x00x00x00x00x00x00x00x00x00x00x00x00x00'

# BLOB-объекты можно снова распаковать:
>>> MyStruct.unpack(data)
(23, False, 42.0)

types.SimpleNamespace — причудливый атрибутивный доступ

А вот еще один «эзотерический» вариант реализации объектов данных в Python: types.SimpleNamespace¹. Этот класс был добавлен в Python 3.3, и он обеспечивает атрибутивный доступ к своему пространству имен.

Это означает, что экземпляры SimpleNamespace показывают все свои ключи как атрибуты класса. А значит, вы можете использовать «точечный» атрибутивный доступ объект.ключ вместо синтаксиса с индексацией в квадратных скобках объект['ключ'], который применяется обычными словарями. Все экземпляры также по умолчанию включают содержательный метод __repr__.

Как видно из его названия, тип SimpleNamespace прост в использовании! Это, в сущности, прославленный словарь, который предоставляет доступ по атрибуту и выдает приличную распечатку. Атрибуты могут свободно добавляться, изменяться и удаляться.

>>> from types import SimpleNamespace
>>> car1 = SimpleNamespace(цвет='красный',

¹ См. документацию Python «types.SimpleNamespace»: https://docs.python.org/3.3/library/types.html