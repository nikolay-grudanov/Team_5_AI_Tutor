---
source_image: page_240.png
page_number: 240
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 28.46
tokens: 7425
characters: 1584
timestamp: 2025-12-24T02:33:01.096618
finish_reason: stop
---

И мы можем продолжить добавлять в этот конвейер новые структурные блоки. Данные текут только в одном направлении, и каждый шаг обработки защищен от других четко определенным интерфейсом.

Это похоже на то, как работают конвейеры в UNIX. Мы состыковываем последовательность процессов в цепочку так, чтобы результат каждого процесса подавался непосредственно на вход следующего.

Почему бы в наш конвейер не добавить еще один шаг, который инвертирует каждое значение, а потом передает его на следующий шаг обработки в цепи:

def negated(seq):
    for i in seq:
        yield -i

Если мы перестроим нашу цепочку генераторов и добавим negated в конец, то вот что мы получим на выходе:

>>> chain = negated(squared(integers()))
>>> list(chain)
[-1, -4, -9, -16, -25, -36, -49, -64]

Моя любимая фишка формирования цепочки генераторов состоит в том, что обработка данных происходит по одному элементу за один раз. Буферизация между шагами обработки в цепочке отсутствует:

1. Генератор integers выдает одно-единственное значение, скажем, 3.
2. Это значение «активирует» генератор squared, который обрабатывает значение и передает его на следующую стадию как \(3 \times 3 = 9\).
3. Квадрат целого числа, выданный генератором squared, немедленно передается в генератор negated, который модифицирует его в \(-9\) и выдает его снова.

Вы можете продолжать расширять эту цепочку генераторов, чтобы отстроить конвейер обработки со многими шагами. Он по-прежнему будет выполняться эффективно и может легко быть модифицирован, потому что каждым шагом в цепочке является отдельная функция-генератор.