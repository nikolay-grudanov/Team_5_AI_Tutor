---
source_image: page_176.png
page_number: 176
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 29.88
tokens: 7413
characters: 1590
timestamp: 2025-12-24T02:31:24.967538
finish_reason: stop
---

Помимо этого, именованные кортежи являются, скажем так, именованными кортежами (named tuples). Доступ к каждому хранящемуся в них объекту можно получить по уникальному идентификатору. Это освобождает от необходимости запоминать целочисленные индексы или идти обходными методами, например определять индексы целочисленных констант в качестве мнемокодов.

На внутреннем уровне объекты namedtuple реализованы как обычные классы Python. В том, что касается использования оперативной памяти, они тоже «лучше» обычных классов и столь же эффективны с точки зрения потребляемой оперативной памяти, что и обычные кортежи:

>>> from collections import namedtuple
>>> from sys import getsizeof

>>> p1 = namedtuple('Point', 'x y z')(1, 2, 3)
>>> p2 = (1, 2, 3)

>>> getsizeof(p1)
72
>>> getsizeof(p2)
72

Именованные кортежи могут довольно просто привести в порядок исходный код и сделать его более удобочитаемым, обеспечив вашим данным более совершенную структуру.

По моему опыту, переход от ситуативных типов данных, таких как словари с фиксированным форматом, к именованным кортежам помогает яснее выражать свои намерения. Нередко, когда я применяю эту рефакторизацию, каким-то невообразимым образом я прихожу к более совершенному решению проблемы, с которой сталкиваюсь.

Использование именованных кортежей вместо неструктурированных кортежей и словарей может облегчить жизнь и моим коллегам, потому что именованные кортежи позволяют раздавать данные в «самодокументированном» виде (в известной степени).

>>> from collections import namedtuple
>>> Car = namedtuple('Авто', 'цвет пробег автомат')