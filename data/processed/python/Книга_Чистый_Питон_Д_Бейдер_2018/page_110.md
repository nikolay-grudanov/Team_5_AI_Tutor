---
source_image: page_110.png
page_number: 110
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 26.44
tokens: 7371
characters: 1582
timestamp: 2025-12-24T02:29:59.959081
finish_reason: stop
---

однозначными и полезными для разработчиков, но я не рассчитываю, что они смогут восстанавливать полное состояние объекта.

Почему каждый класс нуждается в __repr__

Если опустить метод __str__, то Python в поисках __str__ отыграет назад к результату __repr__. По этой причине я рекомендую добавлять в свои классы всегда, по крайней мере, метод __repr__. Это обеспечит полезный результат преобразования строк почти во всех случаях при минимуме работы по его реализации.

Ниже показано, как можно быстро и эффективно добавить в свои классы элементарную поддержку преобразования строк. Для нашего класса Car мы могли бы начать с приведенного ниже метода __repr__:

def __repr__(self):
    return f'Car({self.color!r}, {self.mileage!r})'

Обратите внимание на то, что я использую флаг преобразования !r, тем самым гарантируя, что в выводимом строковом значении вместо str(self.color) и str(self.mileage) будут использованы repr(self.color) и repr(self.mileage).

Это работает безупречно, но оборотной стороной является то, что мы повторили имя класса в форматной строке. Для того чтобы избежать этого повторения, здесь можно применить трюк с использованием атрибута __class__.__name__ объекта. Данный атрибут всегда будет зеркально отображать имя класса в виде строки.

Преимущество состоит в том, что вам не придется модифицировать реализацию метода __repr__, когда имя класса изменится. Это позволяет беспрепятственно придерживаться принципа DRY, то есть «не повторяйся»:

def __repr__(self):
    return (f'{self.__class__.__name__}('
            f'{self.color!r}, {self.mileage!r})')