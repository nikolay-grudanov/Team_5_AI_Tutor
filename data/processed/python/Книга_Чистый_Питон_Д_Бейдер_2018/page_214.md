---
source_image: page_214.png
page_number: 214
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 23.61
tokens: 7388
characters: 1625
timestamp: 2025-12-24T02:32:18.204457
finish_reason: stop
---

Что за объект RepeaterIterator мы создаем и возвращаем из дандер-метода __iter__? Это вспомогательный класс, который нам нужно определить, чтобы заработал наш пример итераций в цикле for...in:

class RepeaterIterator:
    def __init__(self, source):
        self.source = source
    def __next__(self):
        return self.source.value

И снова, RepeaterIterator похож на прямолинейный класс Python, но, возможно, вам стоит принять во внимание следующие две вещи:

1. В методе __init__ мы связываем каждый экземпляр класса RepeaterIterator с объектом Repeater, который его создал. Благодаря этому мы можем держаться за «исходный» объект, итерации по которому выполняются.

2. В RepeaterIterator.__next__ мы залезаем назад в «исходный» экземпляр класса Repeater и возвращаем связанное с ним значение.

В этом примере кода Repeater и RepeaterIterator работают вместе, чтобы поддерживать протокол итератора Python. Два определенных нами дандер-метода, __init__ и __next__, являются центральными в создании итерируемого объекта Python.

Мы рассмотрим ближе эти два метода и то, как они работают вместе, после того, как немного поэкспериментируем с кодом, который у нас есть сейчас.

Давайте подтвердим, что эта конфигурация с двумя классами действительно сделала объекты класса Repeater совместимыми с итерацией в цикле for...in. Для этого мы сначала создадим экземпляр класса Repeater, который будет бесконечно возвращать строковый литерал 'Привет':

>>> repeater = Repeater('Привет')

И теперь попробуем выполнить итерации по объекту repeater в цикле for...in. Что произойдет, когда вы выполните приведенный ниже фрагмент кода?