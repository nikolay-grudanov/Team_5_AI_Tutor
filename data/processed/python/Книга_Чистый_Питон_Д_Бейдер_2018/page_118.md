---
source_image: page_118.png
page_number: 118
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 27.07
tokens: 7398
characters: 1632
timestamp: 2025-12-24T02:30:12.677730
finish_reason: stop
---

Для определения логически сгруппированных иерархий исключений можно использовать наследование.

4.4. Клонирование объектов для дела и веселья

В Python инструкции присваивания не создают копии объектов, они лишь привязывают имена к объекту. Для неизменяемых объектов этот факт обычно не имеет значения.

Но для работы с изменяемыми объектами или коллекциями изменяемых объектов вам, возможно, стоит найти способ создания «реальных копий», или «клонов», этих объектов.

По существу, вам иногда будут требоваться копии, которые можно модифицировать без автоматической модификации оригинала. В этом разделе я кратко представлю то, как копировать, или «клонировать», объекты в Python, и покажу связанные с этим подводные камни.

Начнем с того, что обратимся к копированию встроенных в Python коллекций. Встроенные в Python изменяемые коллекции, такие как списки, словари и множества, могут быть скопированы путем вызова своих фабричных функций с существующей коллекцией в качестве аргумента:

new_list = list(original_list)
new_dict = dict(original_dict)
new_set = set(original_set)

Однако этот метод не будет работать с собственными объектами и, вдобавок ко всему, он создает только мелкие копии. Для составных объектов, таких как списки, словари и множества, между мелким и глубоким копированием имеется важное различие.

Мелкая копия (shallow copy) означает конструирование нового объекта-коллекции и затем его заполнение ссылками на дочерние объекты, найденные в оригинале. В сущности, мелкая копия имеет всего один уровень в глубину. Процесс копирования выполняется нерекурсивно и поэтому не создает копий самих дочерних объектов.