---
source_image: page_126.png
page_number: 126
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 18.83
tokens: 7278
characters: 1430
timestamp: 2025-12-24T02:30:16.497970
finish_reason: stop
---

У нас был класс BaseService, который определял общий интерфейс и несколько конкретных реализаций. Конкретные реализации делают разные вещи, но все они обеспечивают тот же самый интерфейс (MockService, RealService и т. д.). Чтобы более четко проявить взаимосвязи, все конкретные реализации были производными от класса BaseService.

Чтобы сделать этот программный код максимально удобным в обслуживании и благоприятным для программиста, мы хотели удостовериться, что

□ создание экземпляров базового класса невозможно,

□ упущение из виду реализации методов интерфейса в одном из подклассов вызывает ошибку на ранней стадии.

Итак, почему же может возникнуть потребность в использовании модуля Python abc для решения этой задачи? Названная выше конструкция довольно распространена в более сложных системах. Чтобы обеспечить реализацию ряда методов базового класса производным классом, как правило, используется примерно такая идиома Python:

class Base:
    def foo(self):
        raise NotImplementedError()

    def bar(self):
        raise NotImplementedError()

class Concrete(Base):
    def foo(self):
        return 'вызвана foo()'
    # О нет, мы забыли переопределить bar()...
    # def bar(self):
    #     return "вызвана bar()"

Итак, что же мы получаем из этой первой попытки решения задачи? Вызов методов экземпляра Base правильно вызывает исключения NotImplementedError:

>>> b = Base()
>>> b.foo()
NotImplementedError