---
source_image: page_068.png
page_number: 68
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 27.13
tokens: 7334
characters: 1319
timestamp: 2025-12-24T02:28:57.398446
finish_reason: stop
---

>>> del yell

    >>> yell('Привет?')
NameError: "name 'yell' is not defined"

>>> bark('эй')
'эй!'

Кстати, Python прикрепляет к каждой функции строковый идентификатор. Это делается для отладочных целей во время создания функции. К этому внутреннему идентификатору можно получить доступ посредством атрибута __name__¹:

>>> bark.__name__

Нужно сказать, что хотя атрибут __name__ функции по-прежнему «yell», это не влияет на то, каким образом вы получаете доступ к объекту-функции из вашего программного кода. Идентификатор имени является просто средством отладки. Указывающая на функцию переменная и сама функция обладают совершенно разными компетенциями.

Функции могут храниться в структурах данных

Поскольку функции — это объекты первого класса, их можно хранить в структурах данных точно так же, как это делается с другими объектами. Например, вы можете добавить функции в список:

>>> funcs = [bark, str.lower, str.capitalize]
>>> funcs
[<function yell at 0x10ff96510>,
 <method 'lower' of 'str' objects>,
 <method 'capitalize' of 'str' objects>]

¹ Начиная с Python 3.3, также имеется атрибут __qualname__, который служит для такой же цели и обеспечивает строку с квалифицированным именем для устранения неоднозначности между именами функций и классов (см. PEP 3155: https://www.python.org/dev/peps/pep-3155/).