---
source_image: page_089.png
page_number: 89
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 30.35
tokens: 7387
characters: 1469
timestamp: 2025-12-24T02:29:33.477428
finish_reason: stop
---

Давайте расширим прием, сформулированный декоратором proxy, в более полезный практический пример. Ниже приведен декоратор trace, который регистрирует аргументы функции и итоговые результаты, полученные во время исполнения:

def trace(func):
    def wrapper(*args, **kwargs):
        print(f'ТРАССИРОВКА: вызвана {func.__name__}() '
              f'с {args}, {kwargs}')

        original_result = func(*args, **kwargs)

        print(f'ТРАССИРОВКА: {func.__name__}() '
              f'вернула {original_result!r}')
        return original_result
    return wrapper

При декорировании функции с использованием декоратора trace и последующем ее вызове, будут выведены переданные в декорированную функцию аргументы и возвращаемое ею значение. Этот пример по-прежнему остается несколько «игрушечным» — но в случае крайней необходимости он становится отличным средством отладки:

@trace def say(name, line):
    return f'{name}: {line}'

>>> say('Джейн', 'Привет, Мир')
'TРАССИРОВКА: вызвана say() с ("Джейн", "Привет, Мир"), {}'
'TРАССИРОВКА: say() вернула "Джейн: Привет, Мир"'
'Джейн: Привет, Мир'

Если говорить об отладке, то существует две вещи, которые при отладке декораторов следует иметь в виду.

Как писать «отлаживаемые» декораторы

При использовании декоратора вы на самом деле только подменяете одну функцию другой. Оборотной стороной этого процесса является то, что он «скрывает» некоторые метаданные, закрепленные за оригинальной (не-декорированной) функцией.