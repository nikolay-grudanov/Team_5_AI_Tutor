---
source_image: page_117.png
page_number: 117
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 23.96
tokens: 7345
characters: 1579
timestamp: 2025-12-24T02:30:07.083443
finish_reason: stop
---

class NameTooLongError(BaseValidationError):
    pass

class NameTooCuteError(BaseValidationError):
    pass

Например, это позволяет пользователям вашего пакета писать инструкции try-except, которые могут обработать все ошибки, возникающие в результате работы этого пакета, без необходимости отлавливать их вручную:

try:
    validate(name)
except BaseValidationError as err:
    handle_validation_error(err)

Люди по-прежнему могут отлавливать более конкретные виды исключений этим способом, но если они этого не хотят, то, по крайней мере им не придется прибегать к захватыванию всех исключений при помощи всеобъемлющей инструкции except. Обычно такой подход считается антишаблоном проектирования — он может негласно поглотить и скрыть разрозненные ошибки и сделать ваши программы намного труднее для отладки.

Разумеется, вы можете развить эту идею и логически сгруппировать исключения в подробнейшие субдерархии. Но будьте осторожны — можно очень легко внести ненужную сложность, переборщив с этой работой.

Подводя итоги, следует отметить, что определение собственных классов-исключений облегчает принятие вашими пользователями стиля программирования «Легче попросить прощения, чем разрешения» (EAFP), который считается более питоновским.

Ключевые выводы

□ Определение ваших собственных типов исключений позволяет яснее сформулировать замысел вашего программного кода и облегчить его отладку.

□ Следует делать свои собственные исключения производными от встроенного в Python класса Exception или от более конкретных классов-исключений, таких как ValueError или KeyError.