---
source_image: page_254.png
page_number: 254
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 29.29
tokens: 7413
characters: 1513
timestamp: 2025-12-24T02:33:20.294905
finish_reason: stop
---

От этого односторочника я получаю такой кайф, что как-то раз я даже напечатал его на своем значке участника конференции по Python в качестве повода для беседы. Это привело к нескольким конструктивным диалогам с участниками моей электронной рассылки по Python.

Итак, без дальнейших церемоний, вот этот фрагмент кода. Возьмите паузу, чтобы поразмышлять над приведенным ниже выражением-словарем и тем, к чему его вычисление должно привести:

>>> {True: 'да', 1: 'нет', 1.0: 'возможно'}

Я подожду здесь...

О’кей, готовы?

Ниже показан результат, который мы получим при вычислении приведенного выше выражения-словаря в сеансе интерпретатора Python:

>>> {True: 'да', 1: 'нет', 1.0: 'возможно'}
{True: 'возможно'}

Признаюсь, когда увидел этот результат впервые, я был весьма ошарашен. Но все встанет на свои места, когда вы проведете неспешное пошаговое изучение того, что тут происходит. Давайте поразмыслим, почему мы получаем этот, надо сказать, весьма не интуитивный результат.

Когда Python обрабатывает наше выражение-словарь, он сначала строит новый пустой объект-словарь, а затем присваивает ему ключи и значения в том порядке, в каком они переданы в выражение-словарь.

Тогда, когда мы его разложим на части, наше выражение-словарь будет эквивалентно приведенной ниже последовательности инструкций, которые исполняются по порядку:

>>> xs = dict()
>>> xs[True] = 'да'
>>> xs[1] = 'нет'
>>> xs[1.0] = 'возможно'

Как ни странно, Python считает все ключи, используемые в этом примере словаря, эквивалентными: