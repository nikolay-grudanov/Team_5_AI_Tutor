---
source_image: page_091.png
page_number: 91
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 30.34
tokens: 7388
characters: 1550
timestamp: 2025-12-24T02:29:33.606483
finish_reason: stop
---

@uppercase def greet():
    """Вернуть дружеское приветствие."""
    return 'Привет!'

>>> greet.__name__
'greet'

>>> greet.__doc__
'Вернуть дружеское приветствие.'

В качестве оптимального практического приема я порекомендовал бы использовать декоратор functools.wraps во всех декораторах, которые вы пишете сами. Это не займет много времени и уменьшит головную боль вам (и другим) в будущем при отладке.

Да, и поздравляю — вы успешно добрались до самого конца этого сложного раздела и многое узнали о декораторах в Python. Отличная работа!

Ключевые выводы

□ Декораторы определяют структурные блоки многократного использования, которые можно применять к вызываемому объекту с целью модификации его поведения без необратимого изменения самого вызываемого объекта.

□ Синтаксис @ является всего-навсего сокращенной записью для вызова декоратора с входной функцией. Многочисленные декораторы, размещенные над одной-единственной функцией, применяются снизу-вверх (стековая укладка декораторов).

□ В качестве оптимального практического приема отладки используйте в своих собственных декораторах вспомогательный декоратор functools.wraps, чтобы переносить метаданные из недекорированного вызываемого объекта в декорированный.

□ Точно так же, как и любой другой инструмент в комплекте инструментов разработки программного обеспечения, декораторы не являются панацеей, и ими не стоит злоупотреблять. Важно уравновесить необходимость «довести дело до конца» с целевой установкой «не увязнуть в ужасной и неудобной в обслуживании мешанине кодовой базы».