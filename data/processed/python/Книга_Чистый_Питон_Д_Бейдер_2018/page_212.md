---
source_image: page_212.png
page_number: 212
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 26.28
tokens: 7414
characters: 1669
timestamp: 2025-12-24T02:32:17.968811
finish_reason: stop
---

❑ Но следует быть осторожным — для многих разработчиков Python эта функциональность граничит с черной магией. Ее применение может сделать исходный код менее легким в сопровождении для всех остальных коллег в вашей команде.

6.4. Красивые итераторы

Мне нравится то, как синтаксис Python отличается своей красотой и ясностью от других языков программирования. Например, давайте возьмем скромный цикл for-in. Красота Python говорит сама за себя — вы можете прочитать приведенный ниже питоновский цикл, как если бы это было английское предложение:

numbers = [1, 2, 3]
for n in numbers:
    print(n)

Но как элегантные циклические конструкции Python работают за кадром? Каким образом этот цикл достает отдельные элементы из объекта, итерации по которому он выполняет? И как можно поддерживать одинаковый стиль программирования в собственных объектах Python?

Ответы на эти вопросы можно найти в протоколе итератора Python: объекты, которые поддерживают дандер-методы __iter__ и __next__, автоматически работают с циклами for-in.

Однако вникнем во все шаг за шагом. Точно так же, как и декораторы, итераторы и связанные с ними методы на первый взгляд могут показаться довольно загадочными и сложными. Поэтому мы будем входить в курс дела постепенно.

В этом разделе вы увидите, как написать несколько классов Python, которые поддерживают протокол итератора. Они послужат в качестве «немагических» примеров и тестовых реализаций, на основе которых можно укрепить и углубить свое понимание.

Прежде всего мы сосредоточимся на ключевых механизмах итераторов в Python 3 и опустим любые ненужные сложности, чтобы вы четко увидели поведение итераторов на фундаментальном уровне.