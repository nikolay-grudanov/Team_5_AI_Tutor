---
source_image: page_255.png
page_number: 255
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 29.57
tokens: 7432
characters: 1618
timestamp: 2025-12-24T02:33:20.565872
finish_reason: stop
---

>>> True == 1 == 1.0
True

Ладно, но погодите минуточку. Уверен, вы сможете интуитивно признать, что \(1.0 == 1\), но вот почему True считается также эквивалентным и 1? В первый раз, когда я увидел это выражение-словарь, оно действительно меня озадачило.

Немного покопавшись в документации Python, я узнал, что Python рассматривает тип bool как подкласс типа int. Именно так обстоит дело в Python 2 и Python 3:

Булев тип — это подтип целочисленного типа, и булевы значения ведут себя, соответственно, как значения 0 и 1 почти во всех контекстах, при этом исключением является то, что при преобразовании в строковый тип, соответственно, возвращаются строковые значения 'False' или 'True'\(^1\).

И разумеется, это означает, что в Python булевы значения технически можно использовать в качестве индексов списка или кортежа:

>>> ['нет', 'да'][True]
'да'

Но вам, пожалуй, не следует использовать подобного рода логические переменные во имя ясности (и душевного здоровья ваших коллег).

Так или иначе, вернемся к нашему выражению-словарю.

Что касается языка Python, то все эти значения — True, 1 и 1.0 — представляют одинаковый ключ словаря. Когда интерпретатор вычисляет выражение-словарь, он неоднократно переписывает значение ключа True. Это объясняет, почему в самом конце результирующий словарь содержит всего один ключ.

Прежде чем мы пойдем дальше, взглянем еще раз на исходное выражение-словарь:

>>> {True: 'да', 1: 'нет', 1.0: 'возможно'}
{True: 'возможно'}

\footnotetext{1 См. документацию Python «Иерархия стандартных типов»: https://docs.python.org/3/reference/datamodel.html#the-standard-type-hierarchy}