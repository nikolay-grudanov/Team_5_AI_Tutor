---
source_image: page_198.png
page_number: 198
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 28.08
tokens: 7366
characters: 1424
timestamp: 2025-12-24T02:31:56.550097
finish_reason: stop
---

Несмотря на то что точка вставки может быть найдена за \( O(log\ n) \) время с помощью алгоритма bisect.insort¹ стандартной библиотеки, это решение всегда находится во власти медленного шага вставки.

Поддержание упорядоченности путем добавления в конец списка и пересортировки также занимает минимум \( O(n\ log\ n) \) времени. Еще один недостаток — вам придется вручную заботиться о пересортировке списка во время вставки новых элементов. Пропустив этот шаг, можно легко внести ошибки, и ответственность за них всегда будет на вас как на разработчике.

Поэтому я убежден, что сортированные списки подходят как очереди с приоритетом только в тех случаях, когда вставок немного.

q = []
q.append((2, 'программировать'))
q.append((1, 'есть'))
q.append((3, 'спать'))

ПРИМЕЧАНИЕ: Не забудьте выполнить пересортировку всякий раз,
# когда добавляется новый элемент, либо используйте
# bisect.insort().
q.sort(reverse=True)
while q:
    next_item = q.pop()
    print(next_item)

# Результат:
#   (1, 'есть')
#   (2, 'программировать')
#   (3, 'спать')

heapq — двоичные кучи на основе списка

Данная реализация двоичной кучи обычно подкрепляется обыкновенным списком, и она поддерживает вставку и извлечение наименьшего элемента за \( O(log\ n) \) время².

¹ См. документацию Python «bisect.insort»: https://docs.python.org/3.6/library/bisect.html
² См. документацию Python «heapq»: https://docs.python.org/3.6/library/hearq.html