---
source_image: page_072.png
page_number: 72
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 27.01
tokens: 7326
characters: 1411
timestamp: 2025-12-24T02:29:03.223003
finish_reason: stop
---

return yell
else:
    return whisper

Обратите внимание на то, как функция get_speak_func фактически не вызывает ни одну из своих внутренних функций — она просто выбирает соответствующую внутреннюю функцию на основе аргумента volume и затем возвращает объект-функцию:

>>> get_speak_func(0.3)
<function get_speak_func.<locals>.whisper at 0x10ae18>

>>> get_speak_func(0.7)
<function get_speak_func.<locals>.yell at 0x1008c8>

Разумеется, вы можете продолжить и вызвать возвращенную функцию непосредственно, либо сначала присвоив ее переменной:

>>> speak_func = get_speak_func(0.7)
>>> speak_func('Привет')
'ПРИВЕТ! '

Только подумайте... Это означает, что функции не только могут принимать линии поведения через аргументы, но и возвращать линии поведения. Здорово, правда?

И знаете что? С этого места дела приобретают несколько безумный характер. И прежде чем я продолжу писать, мне срочно требуется перерыв на кофе (я предлагаю вам сделать то же самое).

Функции могут захватывать локальное состояние

Вы только что увидели, что функции могут содержать внутренние функции и что даже существует возможность возвращать эти (в других ситуациях скрытые) внутренние функции из родительской функции.

Сейчас лучше всего пристегнуть ремень безопасности, потому что все становится еще безумнее — мы собираемся зайти на территорию функционального программирования еще дальше. (У вас ведь был перерыв на кофе, правда?)