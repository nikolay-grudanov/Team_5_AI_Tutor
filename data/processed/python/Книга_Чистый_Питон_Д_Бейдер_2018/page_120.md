---
source_image: page_120.png
page_number: 120
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 32.30
tokens: 7467
characters: 1593
timestamp: 2025-12-24T02:30:20.117623
finish_reason: stop
---

Как видите, эффект был ожидаем. С изменением скопированного списка на «поверхностном» уровне никаких проблем не возникло.

Однако поскольку мы создали лишь мелкую копию оригинального списка, список ys по-прежнему содержит ссылки на оригинальные дочерние объекты, хранящиеся в xs.

Эти дочерние элементы не были скопированы. Все свелось к тому, что в скопированном списке на них снова содержатся ссылки.

Поэтому, когда вы модифицируете один из дочерних объектов в списке xs, эта модификация также будет отражена в списке ys — таким образом, оба списка совместно используют одинаковые дочерние объекты. Эта копия представляет собой всего лишь мелкую копию с одним уровнем в глубину:

>>> xs[1][0] = 'X'
>>> xs
[[1, 2, 3], ['X', 5, 6], [7, 8, 9], ['новый подсписок']]
>>> ys
[[1, 2, 3], ['X', 5, 6], [7, 8, 9]]

В примере выше мы (казалось бы) изменили только список xs. Но оказывается, что в индексе 1 списков xs и ys были изменены оба подсписка. Опять-таки, это произошло, потому что мы создали всего-навсего мелкую копию оригинального списка.

Если бы на первом шаге мы создали глубокую копию списка xs, то оба объекта были бы полностью независимы. В этом и заключается практическая разница между мелкими и глубокими копиями объектов.

Теперь вы знаете, как создавать мелкие копии некоторых встроенных классов коллекций, и знаете разницу между мелким и глубоким копированием. Вопросы, ответы на которые мы по-прежнему хотим получить, следующие:

☐ Как создавать глубокие копии встроенных коллекций?

☐ Как создавать копии (мелкие и глубокие) произвольных объектов, включая собственные классы?