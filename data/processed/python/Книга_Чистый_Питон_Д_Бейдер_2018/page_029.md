---
source_image: page_029.png
page_number: 29
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 26.34
tokens: 7416
characters: 1739
timestamp: 2025-12-24T02:28:01.998660
finish_reason: stop
---

В данном случае выражение1 — это условие, которое мы проверяем, а необязательное выражение2 — это сообщение об ошибке, которое выводится на экран, если утверждение дает сбой. Во время исполнения программы интерпретатор Python преобразовывает каждую инструкцию assert примерно в следующую ниже последовательность инструкций:

if __debug__:
    if not выражение1:
        raise AssertionError(выражение2)

В этом фрагменте кода есть две интересные детали.

Перед тем как данное условие инструкции assert будет проверено, проводится дополнительная проверка глобальной переменной __debug__. Это встроенный булев флажок, который при нормальных обстоятельствах имеет значение True, — и значение False, если запрашивается оптимизация. Мы поговорим об этом подробнее чуть позже в разделе, посвященном «распространенным ловушкам».

Кроме того, вы можете применить выражение2, чтобы передать необязательное сообщение об ошибке, которое будет показано в отчете об обратной трассировке вместе с исключением AssertionError. Это может еще больше упростить отладку. Например, я встречал исходный код такого плана:

>>> if cond == 'x':
...     do_x()
... elif cond == 'y':
...     do_y()
... else:
...     assert False, (
...         'Это никогда не должно произойти, и тем не менее это '
...         'временами происходит. Сейчас мы пытаемся выяснить'
...         'причину. Если вы столкнетесь с этим на практике, то '
...         'просим связаться по электронной почте с dbader. Спасибо!' )

Разве это не ужасно? Конечно, да. Но этот прием определенно допустим и полезен, если в одном из своих приложений вы сталкиваетесь с плавающей ошибкой Гейзенбаг¹.

¹ См. Википедию: https://en.wikipedia.org/wiki/Heisenbug и https://ru.wikipedia.org/wiki/Гейзенбаг