---
source_image: page_219.png
page_number: 219
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 23.45
tokens: 7294
characters: 1330
timestamp: 2025-12-24T02:32:24.444367
finish_reason: stop
---

class Repeater:

    def __init__(self, value):
        self.value = value
    def __iter__(self):
        return self
    def __next__(self):
        return self.value

Мы только что перешли от двух отдельных классов и десяти строк кода всего к одному классу и семи строкам кода. Наша упрощенная реализация по-прежнему без проблем поддерживает протокол итератора:

>>> repeater = Repeater('Привет')
>>> for item in repeater:
...     print(item)

Привет
Привет
Привет
...

В подобной оптимизации итератора на основе класса часто есть смысл. По сути, большинство пособий Python по итераторам начинается именно так. Но я всегда чувствовал, что объяснять итераторы одним-единственным классом с самого начала — значит скрывать основные принципы протокола итератора и по этой причине еще больше затруднять его понимание.

Кто же захочет без конца выполнять итерации

На этом этапе у вас уже должно сложиться довольно хорошее понимание того, как итератор работает в Python. Но пока что мы реализовывали только такие итераторы, которые продолжают выполнять итерации бесконечно.

Очевидно, бесконечное повторение не является главным вариантом использования итераторов в Python. На самом деле, когда вы обратитесь к самому началу этого раздела, то увидите, что в качестве мотивирующего примера я использовал приведенный ниже фрагмент кода: