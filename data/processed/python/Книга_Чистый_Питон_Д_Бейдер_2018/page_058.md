---
source_image: page_058.png
page_number: 58
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 32.29
tokens: 7473
characters: 1813
timestamp: 2025-12-24T02:28:49.743129
finish_reason: stop
---

Синтаксис «классического» форматирования строк слегка изменится, если вы захотите выполнить многочисленные подстановки в одном-единственном строковом значении. Поскольку оператор % принимает всего один аргумент, вам необходимо обернуть правую часть в кортеж, как здесь:

```python
>>> 'Эй, %s! Вот ошибка 0x%x!' % (name, errno)
'Эй, Боб! Вот ошибка 0xbadc0ffee!'
```

Кроме того, к подстановкам переменных в своей форматной строке можно обращаться по имени. В этом случае в оператор % следует передать словарь с отображением имен на соответствующие им значения:

```python
>>> 'Эй, %(name)s! Вот ошибка 0x%(errno)x!' % {
...     "name": name, "errno": errno }
'Эй, Боб! Вот ошибка 0xbadc0ffee!'
```

Это облегчает поддержку ваших строк и их модификацию в будущем. Вам не нужно волноваться о том, что порядок, в котором вы передаете значения, совпадает с порядком, на который ссылаются значения в форматной строке. Разумеется, оборотной стороной этого приема является то, что он требует набирать чуть больше текста.

Я уверен, вы спросите, почему такое форматирование в стиле printf называется «классическим» форматированием строк. Что ж, давайте расскажу. Дело в том, что оно технически было заменено на «современное» форматирование, о котором мы собираемся поговорить уже через минуту. Но несмотря на то что «классическому» форматированию стали придавать меньшее значение, оно не было объявлено нерекомендуемым для использования. И в последних версиях Python оно по-прежнему поддерживается.

№ 2. «Современное» форматирование строковых значений

Python 3 ввел новый способ форматирования строк, который позднее был также перенесен в Python 2.7. Это «современное» форматирование строк избавляется от специального синтаксиса с использованием оператора % и делает синтаксис форматирования строк более упорядоченным.