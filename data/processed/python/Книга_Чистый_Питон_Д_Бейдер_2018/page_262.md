---
source_image: page_262.png
page_number: 262
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 28.49
tokens: 7437
characters: 1624
timestamp: 2025-12-24T02:33:32.579552
finish_reason: stop
---

Еще один прием, который работает в Python 2 и в Python 3, использует встроенную функцию dict() совместно с оператором ** для «распаковки» объектов:

```python
>>> zs = dict(xs, **ys)
>>> zs
{'a': 1, 'c': 4, 'b': 3}
```

Однако, как и в случае с повторными вызовами update(), этот подход работает только для слияния исключительно двух словарей и не может быть обобщен для объединения произвольного количества словарей за один шаг.

Начиная с Python 3.5, оператор ** стал гибче¹. Поэтому в Python 3.5+ есть еще один — и, пожалуй, более приятный — способ объединения произвольного количества словарей:

```python
>>> zs = {**xs, **ys}
```

У этого выражения в точности такой же результат, что и у цепочки вызовов update(). Ключи и значения задаются в порядке слева направо, поэтому мы получаем ту же самую стратегию разрешения конфликтов: правая сторона имеет приоритет, а значение в ys переопределяет любое существующее значение под тем же самым ключом в xs. Это станет понятным, когда мы посмотрим на словарь, который является результатом этой операции слияния:

```python
>>> zs
>>> {'c': 4, 'a': 1, 'b': 3}
```

Лично мне нравится краткость этой новой синтаксической конструкции и то, как она по-прежнему остается достаточно удобочитаемой. Всегда приходится находить равновесие между многословностью и краткостью, сохраняя программный код максимально удобочитаемым и легким в сопровождении.

В данном случае я склоняюсь к использованию нового синтаксиса при условии, что работаю с Python 3. Более того, при использовании опера-

¹ См. PEP 448 «Дополнительные обобщения распаковки»: https://www.python.org/dev/peps/pep-0448/