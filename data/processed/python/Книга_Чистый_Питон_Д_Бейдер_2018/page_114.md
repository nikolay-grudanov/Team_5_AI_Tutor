---
source_image: page_114.png
page_number: 114
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 27.00
tokens: 7377
characters: 1643
timestamp: 2025-12-24T02:30:07.511478
finish_reason: stop
---

4.3. Определение своих собственных классов-исключений

Когда я начал использовать Python, то не решался в своем программном коде писать собственные классы-исключения. Вместе с тем определение собственных типов ошибок может быть очень ценным. Вы четко выделите потенциальные случаи ошибок, и, как результат, ваши функции и модули станут более удобными в сопровождении. Вы также сможете использовать собственные типы ошибок, которые обеспечат дополнительную отладочную информацию.

Все это улучшит ваш программный код и облегчит его понимание. Он станет легче для отладки и удобнее в сопровождении. Задача определения ваших собственных классов-исключений не будет такой сложной, когда вы разобьете ее на несколько простых примеров. В этой главе я проведу вас по основным пунктам, которые необходимо помнить.

Допустим, что вы хотели бы выполнить валидацию входного строкового значения, которое в вашем приложении представляет имя человека. Игрушечный пример функции валидации имени может выглядеть следующим образом:

def validate(name):
    if len(name) < 10:
        raise

Если валидация терпит неудачу, она вызывает исключение ValueError. Это кажется вполне уместным и выглядит по-питоновски. Пока что все идет неплохо.

Вместе с тем в использовании универсального класса-исключения «высокого уровня» типа ValueError есть оборотная сторона. Предположим, что один из ваших коллег вызывает эту функцию как составную часть библиотеки и не очень разбирается в ее внутреннем устройстве. Когда не удается выполнить валидацию имени, отчет об обратной трассировке будет выглядеть примерно так:

>>> validate('джо')
Traceback (most recent call last):