---
source_image: page_032.png
page_number: 32
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 21.59
tokens: 7338
characters: 1570
timestamp: 2025-12-24T02:28:01.615406
finish_reason: stop
---

Например, если приложение магазина аварийно завершается при попытке стороннего лица удалить неизвестный товар, то, скорее всего, это произошло потому, что взломщик смог завалить его недопустимыми запросами на удаление и вызвать сбой в работе сервера.

Каким образом можно избежать этих проблем? Ответ таков: никогда не использовать утверждения assert для выполнения валидации данных. Вместо этого можно выполнять проверку обычными инструкциями if и при необходимости вызывать исключения валидации данных, как показано ниже:

def delete_product(product_id, user):
    if not user.is_admin():
        raise AuthError('Для удаления необходимы права админа')
    if not store.has_product(product_id):
        raise ('Идентификатор неизвестного товара')
    store.get_product(product_id).delete()

Этот обновленный пример также обладает тем преимуществом, что вместо того, чтобы вызывать неопределенные исключения AssertionError, он теперь вызывает семантически правильные исключения, а именно ValueError или AuthError (которые мы должны были определить сами).

Предостережение № 2: инструкции assert, которые никогда не дают сбоя

Удивительно легко случайно написать инструкцию assert, которая всегда при вычислении возвращает истину. Мне самому в прошлом довелось понести ощутимый ущерб. Вкратце проблема в следующем.

Когда в инструкцию assert в качестве первого аргумента передается кортеж, assert всегда возвращает True и по этой причине выполняется успешно.

Например, это утверждение никогда не будет давать сбой:

assert(1 == 2, 'Это утверждение должно вызвать сбой')