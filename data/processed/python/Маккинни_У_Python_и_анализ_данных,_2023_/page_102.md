---
source_image: page_102.png
page_number: 102
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 26.77
tokens: 7587
characters: 1595
timestamp: 2025-12-24T02:42:35.882183
finish_reason: stop
---

4.1. NumPy ndarray: объект многомерного массива

Умножим каждую последовательность на 2:

In [10]: %timeit my_arr2 = my_arr * 2
715 us +- 13.2 us per loop (mean +- std. dev. of 7 runs, 1000 loops each)

In [11]: %timeit my_list2 = [x * 2 for x in my_list]
48.8 ms +- 298 us per loop (mean +- std. dev. of 7 runs, 10 loops each)

Алгоритмы, основанные на NumPy, в общем случае оказываются в 10–100 раз (а то и больше) быстрее аналогов, написанных на чистом Python, и потребляют гораздо меньше памяти.

4.1. NumPy ndarray: объект многомерного массива

Одна из ключевых особенностей NumPy — объект ndarray для представления N-мерного массива; это быстрый и гибкий контейнер для хранения больших наборов данных в Python. Массивы позволяют выполнять математические операции над целыми блоками данных, применяя такой же синтаксис, как для соответствующих операций над скалярами.

Чтобы показать, как NumPy позволяет производить пакетные вычисления, применяя такой же синтаксис, как для встроенных в Python скалярных объектов, я начну с импорта NumPy и генерации небольшого массива случайных данных:

In [12]: import numpy as np

In [13]: data = np.array([[1.5, -0.1, 3], [0, -3, 6.5]])

In [14]: data
Out[14]:
array([[ 1.5, -0.1, 3. ],
       [ 0. , -3. , 6.5]])

Затем я произведу математические операции над data:

In [15]: data * 10
Out[15]:
array([[ 15., -1., 30.],
       [ 0., -30., 65.]]

In [16]: data + data
Out[16]:
array([[ 3. , -0.2, 6. ],
       [ 0. , -6. , 13. ]])

В первом примере все элементы умножены на 10. Во втором примере соответственные элементы в каждой «ячейке» складываются.