---
source_image: page_362.png
page_number: 362
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 23.40
tokens: 7691
characters: 1570
timestamp: 2025-12-24T02:49:57.465020
finish_reason: stop
---

In [66]: dup_ts["2000-01-03"] # метка уникальна
Out[66]: 4

In [67]: dup_ts["2000-01-02"] # метка повторяется
Out[67]:
2000-01-02    1
2000-01-02    2
2000-01-02    3
dtype: int64

Пусть требуется агрегировать данные с неуникальными временными метками. Одно из возможных решений — воспользоваться методом groupby с параметром level=0 (один-единственный уровень):

In [68]: grouped = dup_ts.groupby(level=0)
In [69]: grouped.mean()
Out[69]:
2000-01-01    0.0
2000-01-02    2.0
2000-01-03    4.0
dtype: float64

In [70]: grouped.count()
Out[70]:
2000-01-01    1
2000-01-02    3
2000-01-03    1
dtype: int64

11.3. Диапазоны дат, частоты и сдвиг

Вообще говоря, временные ряды pandas не предполагаются регулярными, т. е. частота в них не фиксирована. Для многих приложений это вполне приемлемо. Но иногда желательно работать с постоянной частотой, например день, месяц, 15 минут, даже если для этого приходится вставлять в ряд отсутствующие значения. По счастью, pandas поддерживает полный набор частот и средства для передискретизации (подробно обсуждается в разделе 11.6), выведения частот и генерации диапазонов дат с фиксированной частотой. Например, временной ряд из нашего примера можно преобразовать в ряд с частотой один день с помощью метода resample:

In [71]: ts
Out[71]:
2011-01-02   -0.204708
2011-01-05    0.478943
2011-01-07   -0.519439
2011-01-08   -0.555730
2011-01-10    1.965781
2011-01-12    1.393406
dtype: float64

In [72]: resampler = ts.resample("D")
In [73]: resampler
Out[73]: <pandas.core.resample.DatetimeIndexResampler object at 0x7febd896bc40>