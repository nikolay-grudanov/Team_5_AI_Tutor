---
source_image: page_383.png
page_number: 383
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 39.13
tokens: 7897
characters: 2209
timestamp: 2025-12-24T02:50:57.132168
finish_reason: stop
---

<table>
  <tr>
    <th>Аргумент</th>
    <th>Описание</th>
  </tr>
  <tr>
    <td>kind</td>
    <td>Агрегировать в периоды ("period") или временные метки ("timestamp"); по умолчанию определяется видом индекса, связанного с данным временным рядом</td>
  </tr>
  <tr>
    <td>convention</td>
    <td>При передискретизации периодов соглашение ("start" или "end") о преобразовании периода низкой частоты в период высокой частоты. По умолчанию "start"</td>
  </tr>
  <tr>
    <td>origin</td>
    <td>«Базовая» временная метка, от которой отсчитываются границы интервала передискретизации; может также принимать значения "epoch", "start", "start_day", "end", "end_day"; полное описание см. в строке документации для resample</td>
  </tr>
  <tr>
    <td>offset</td>
    <td>Смещение (объект timedelta), прибавляемое к начальному моменту; по умолчанию None</td>
  </tr>
</table>

Понижающая передискретизация

Понижающей передискретизацией называется агрегирование данных с целью понижения и регуляризации частоты. Агрегируемые данные необязательно исправлять часто; желаемая частота определяет границы интервалов, разбивающих агрегируемые данные на порции. Например, для преобразования к месячному периоду, "M" или "BM", данные нужно разбить на интервалы продолжительностью один месяц. Говорят, что каждый интервал полуоткрыт; любая точка может принадлежать только одному интервалу, а их объединение должно покрывать всю протяженность временного ряда. Перед тем как выполнять понижающую передискретизацию данных методом resample, нужно решить для себя следующие вопросы:

○ какой конец интервала будет включаться;
○ помечать ли агрегированный интервал меткой его начала или конца.

Для иллюстрации рассмотрим данные с частотой одна минута:

In [213]: dates = pd.date_range("2000-01-01", periods=12, freq="T")

In [214]: ts = pd.Series(np.arange(len(dates)), index=dates)

In [215]: ts
Out[215]:
2000-01-01 00:00:00    0
2000-01-01 00:01:00    1
2000-01-01 00:02:00    2
2000-01-01 00:03:00    3
2000-01-01 00:04:00    4
2000-01-01 00:05:00    5
2000-01-01 00:06:00    6
2000-01-01 00:07:00    7
2000-01-01 00:08:00    8
2000-01-01 00:09:00    9
2000-01-01 00:10:00   10
2000-01-01 00:11:00   11
Freq: T, dtype: int64