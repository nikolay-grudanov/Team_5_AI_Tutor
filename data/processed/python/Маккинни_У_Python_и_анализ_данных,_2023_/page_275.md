---
source_image: page_275.png
page_number: 275
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 38.96
tokens: 7855
characters: 2332
timestamp: 2025-12-24T02:47:45.832437
finish_reason: stop
---

Таблица 8.3. Аргументы функции concat

<table>
  <tr>
    <th>Аргумент</th>
    <th>Описание</th>
  </tr>
  <tr>
    <td>objs</td>
    <td>Список или словарь конкатенируемых объектов pandas. Единственный обязательный аргумент</td>
  </tr>
  <tr>
    <td>axis</td>
    <td>Ось, вдоль которой производится конкатенация; по умолчанию по строкам (<code>axis="index"</code>)</td>
  </tr>
  <tr>
    <td>join</td>
    <td>Допустимые значения: 'inner', 'outer' (по умолчанию); следует ли пересекать (<code>inner</code>) или объединять (<code>outer</code>) индексы вдоль других осей</td>
  </tr>
  <tr>
    <td>keys</td>
    <td>Значения, которые ассоциируются с конкатенируемыми объектами и образуют иерархический индекс вдоль оси конкатенации. Может быть список или массив произвольных значений, а также массив кортежей или список массивов (если в параметре <code>levels</code> передаются массивы для нескольких уровней)</td>
  </tr>
  <tr>
    <td>levels</td>
    <td>Конкретные индексы, которые используются на одном или нескольких уровнях иерархического индекса, если задан параметр <code>keys</code></td>
  </tr>
  <tr>
    <td>names</td>
    <td>Имена создаваемых уровней иерархического индекса, если заданы параметры <code>keys</code> и (или) <code>levels</code></td>
  </tr>
  <tr>
    <td>verify_integrity</td>
    <td>Проверить новую ось в конкатенированном объекте на наличие дубликатов и, если они имеются, возбудить исключение. По умолчанию <code>False</code> — дубликаты разрешены</td>
  </tr>
  <tr>
    <td>ignore_index</td>
    <td>Не сохранять индексы вдоль оси конкатенации, а вместо этого создать новый индекс <code>range(total_length)</code></td>
  </tr>
</table>

Комбинирование перекрывающихся данных

Есть еще одна ситуация, которую нельзя выразить как слияние или конкатенацию. Речь идет о двух наборах данных, индексы которых полностью или частично пересекаются. В качестве пояснительного примера рассмотрим функцию NumPy <code>where</code>, которая выполняет эквивалент выражения if-else для массивов:

In [115]: a = pd.Series([np.nan, 2.5, 0.0, 3.5, 4.5, np.nan], index=["f", "e", "d", "c", "b", "a"])

In [116]: b = pd.Series([0., np.nan, 2., np.nan, np.nan, 5.], index=["a", "b", "c", "d", "e", "f"])

In [117]: a
Out[117]:
f   NaN
e   2.5
d   0.0
c   3.5
b   4.5
a   NaN
dtype: float64

In [118]: b
Out[118]: