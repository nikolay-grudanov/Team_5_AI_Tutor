---
source_image: page_492.png
page_number: 492
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 26.18
tokens: 7688
characters: 2359
timestamp: 2025-12-24T02:53:52.493616
finish_reason: stop
---

Отображение на память работает также со структурными и вложенными типами dtype, описанными в предыдущем разделе.
После запуска этого примера на своем компьютере вы, наверное, захотите удалить созданный большой файл:

In [226]: %xdel mmap
In [227]: !rm mymap

HDF5 и другие варианты хранения массива
PyTables и h5py – написанные на Python проекты, в которых реализован ориентированный на NumPy интерфейс для хранения массива в эффективном, допускающем сжатие формате HDF5 (HDF означает hierarchical data format – иерархический формат данных). В формате HDF5 можно без опаски хранить сотни гигабайтов и даже терабайты данных. Для получения дополнительных сведений о работе с HDF5 в Python обратитесь к документации по pandas.

A.9. Замечания о производительности
Адаптация кода обработки данных к NumPy обычно значительно ускоряет программу, поскольку операции над массивами, как правило, заменяют медленные по сравнению с ними циклы на чистом Python. Приведенные ниже советы позволят получить максимальную отдачу от использования библиотеки.
○ Преобразуйте циклы и условную логику Python с операции с массивами и булевыми массивами.
○ Всюду, где только можно, применяйте укладывание.
○ Избегайте копирования данных с помощью представлений массивов (вырезание).
○ Используйте u-функции и их методы.
Если с помощью одних лишь средств NumPy все же никак не удается добиться требуемой производительности, то, возможно, имеет смысл написать часть кода на C, Fortran и особенно на Cython (подробнее об этом ниже). Лично я очень активно использую Cython (http://cython.org) в собственной работе как простой способ получить производительность, сравнимую с C, затратив минимум усилий.

Важность непрерывной памяти
Хотя полное рассмотрение заявленной темы выходит за рамки этой книги, в некоторых приложениях расположение массива в памяти может оказывать существенное влияние на скорость вычислений. Отчасти это связано с иерархией процессорных кешей; операции, в которых осуществляется доступ к соседним адресам в памяти (например, суммирование по строкам в массиве, организованном как в C), обычно выполняются быстрее всего, потому что подсистема памяти буферизует соответствующие участки в кешах уровня L1 или L2 с низкой задержкой. Кроме того, некоторые ветви написанного на С кода NumPy оптимизированы для непрерывного случая, когда шагового доступа можно избежать.