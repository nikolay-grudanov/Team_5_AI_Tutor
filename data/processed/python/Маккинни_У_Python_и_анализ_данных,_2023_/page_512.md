---
source_image: page_512.png
page_number: 512
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 33.89
tokens: 7802
characters: 2230
timestamp: 2025-12-24T02:54:37.310834
finish_reason: stop
---

Показаны только первые 15 строк отчета. Читать его проще всего, просматривая сверху вниз столбец cumtime, чтобы понять, сколько времени было проведено внутри каждой функции. Отметим, что если одна функция вызывает другую, то таймер не останавливается. cProfile запоминает моменты начала и конца каждого вызова функции и на основе этих данных создает отчет о затраченном времени.

cProfile можно запускать не только из командной строки, но и программно для профилирования работы произвольных блоков кода без порождения нового процесса. В IPython имеется удобный интерфейс к этой функциональности в виде команды %prun и команды %run с флагом -p. Команда %prun принимает те же «аргументы командной строки», что и cProfile, но профилирует произвольное предложение Python, а не py-файл:

In [4]: %prun -l 7 -s cumulative run_experiment()
    4203 function calls in 0.643 seconds

Ordered by: cumulative time
List reduced from 32 to 7 due to restriction <7>

ncalls  tottime  percall  cumtime  percall  filename:lineno(function)
      1   0.000    0.000    0.643    0.643  <string>:1(<module>)
      1   0.001    0.001    0.643    0.643  cprof_example.py:4(run_experiment)
     100   0.003    0.000    0.583    0.006  linalg.py:702(eigvals)
    200   0.569    0.003    0.569    0.003  {numpy.linalg.lapack_lite.dgeev}
    100   0.058    0.001    0.058    0.001  {method 'randn'}
    100   0.003    0.000    0.005    0.000  linalg.py:162(_assertFinite)
    200   0.002    0.000    0.002    0.000  {method 'all' of 'numpy.ndarray'}

Аналогично команда %run -p -s cumulative cprof_example.py дает тот же результат, что рассмотренный выше запуск из командной строки, только не приходится выходить из IPython.

В Jupyter-блокноте для профилирования целого блока кода можно использовать магическую команду %%prun (два знака %). Она открывает отдельное окно, в которое выводится профиль. Это полезно для быстрого ответа на вопросы типа «Почему этот блок так долго работает?».

Существуют и другие инструменты, которые помогают интерпретировать профиль при работе с IPython или Jupyter. Один из них – SnakeViz (https://github.com/jiffyclub/snakeviz/) – порождает интерактивную визуализацию результатов профилирования с помощью библиотеки D3.js.