---
source_image: page_071.png
page_number: 71
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 29.60
tokens: 7552
characters: 1810
timestamp: 2025-12-24T02:41:47.680255
finish_reason: stop
---

Элементы можно удалять также методом remove, который находит и удаляет из списка первый элемент с указанным значением:

In [57]: b_list.append("foo")

In [58]: b_list
Out[58]: ['foo', 'red', 'baz', 'dwarf', 'foo']

In [59]: b_list.remove("foo")

In [60]: b_list
Out[60]: ['red', 'baz', 'dwarf', 'foo']

Если снижение производительности из-за использования методов append и remove не составляет проблемы, то список Python можно использовать в качестве структуры данных, подобной множеству (хотя в Python есть настоящие множества, которые будут описаны ниже).

Чтобы проверить, содержит ли список некоторое значение, используется ключевое слово in:

In [61]: "dwarf" in b_list
Out[61]: True

Проверка вхождения значения в случае списка занимает гораздо больше времени, чем в случае словаря или множества (рассматриваются ниже), потому что Python должен просматривать список от начала до конца, а это требует линейного времени, тогда как поиск в других структурах (основанных на хеш-таблицах) занимает постоянное время.

Конкатенация и комбинирование списков
Как и в случае кортежей, операция сложения конкатенирует списки:

In [63]: [4, None, "foo"] + [7, 8, (2, 3)]
Out[63]: [4, None, 'foo', 7, 8, (2, 3)]

Если уже имеется список, то добавить в его конец несколько элементов позволяет метод extend:

In [64]: x = [4, None, "foo"]

In [65]: x.extend([7, 8, (2, 3)])

In [66]: x
Out[66]: [4, None, 'foo', 7, 8, (2, 3)]

Отметим, что конкатенация — сравнительно дорогая операция, потому что нужно создать новый список и скопировать в него все объекты. Обычно предпочтительнее использовать extend для добавления элементов в существующий список, особенно если строится длинный список. Таким образом,

everything = []
for chunk in list_of_lists:
    everything.extend(chunk)

быстрее, чем эквивалентная конкатенация: