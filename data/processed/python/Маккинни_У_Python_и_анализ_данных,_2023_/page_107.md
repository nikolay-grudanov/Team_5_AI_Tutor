---
source_image: page_107.png
page_number: 107
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 32.52
tokens: 7715
characters: 1955
timestamp: 2025-12-24T02:42:46.529759
finish_reason: stop
---

Существуют целые типы со знаком и без знака, и многие читатели, скорее всего, незнакомы с этой терминологией. Целое со знаком может представлять как положительные, так и отрицательные целые числа, а целое без знака — только неотрицательные. Например, типом int8 (8-разрядное целое со знаком) можно представить целые числа от −128 до 127 (включительно), а типом uint8 (8-разрядное целое без знака) — числа от 0 до 255.

Можно явно преобразовать, или привести, массив одного типа к другому, воспользовавшись методом astype:

In [37]: arr = np.array([1, 2, 3, 4, 5])

In [38]: arr.dtype
Out[38]: dtype('int64')

In [39]: float_arr = arr.astype(np.float64)

In [40]: float_arr
Out[40]: array([1., 2., 3., 4., 5.])

In [41]: float_arr.dtype
Out[41]: dtype('float64')

Здесь целые были приведены к типу с плавающей точкой. Если бы я попытался привести числа с плавающей точкой к целому типу, то дробная часть была бы отброшена:

In [42]: arr = np.array([3.7, -1.2, -2.6, 0.5, 12.9, 10.1])

In [43]: arr
Out[43]: array([ 3.7, -1.2, -2.6, 0.5, 12.9, 10.1])

In [44]: arr.astype(np.int32)
Out[44]: array([ 3, -1, -2, 0, 12, 10], dtype=int32)

Если имеется массив строк, представляющих целые числа, то astype позволит преобразовать их в числовую форму:

In [45]: numeric_strings = np.array(["1.25", "-9.6", "42"], dtype=np.string_)

In [46]: numeric_strings.astype(float)
Out[46]: array([ 1.25, -9.6 , 42. ])

Будьте осторожнее при работе с типом numpy.string_, поскольку в NumPy размер строковых данных фиксирован и входные данные могут быть обрезаны без предупреждения. Поведение pandas для нечисловых данных лучше согласуется с интуицией.

Если по какой-то причине выполнить приведение не удастся (например, если строку нельзя преобразовать в тип float64), то будет возбуждено исключение ValueError. В примере выше я поленился и написал float вместо np.float64, но NumPy оказалась достаточно «умной» — она умеет подменять типы Python эквивалентными собственными.