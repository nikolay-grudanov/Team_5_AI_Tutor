---
source_image: page_110.png
page_number: 110
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 26.58
tokens: 7598
characters: 1619
timestamp: 2025-12-24T02:42:46.745922
finish_reason: stop
---

Если теперь изменить значения в arr_slice, то изменения отразятся и на исходном массиве arr:

In [69]: arr_slice[1] = 12345

In [70]: arr
Out[70]:
array([   0,    1,    2,    3,    4,   12, 12345,   12,    8,    9])

Присваивание неуточненному срезу [:] приводит к записи значения во все элементы массива:

In [71]: arr_slice[:] = 64

In [72]: arr
Out[72]: array([   0,    1,    2,    3,    4,  64,  64,  64,    8,    9])

При первом знакомстве с NumPy это может стать неожиданностью, особенно если вы привыкли к программированию массивов в других языках, где копирование данных применяется чаще. Но NumPy проектировался для работы с большими массивами данных, поэтому при безудержном копировании данных неизбежно возникли бы проблемы с быстродействием и памятью.

Чтобы получить копию, а не представление среза массива, нужно выполнить операцию копирования явно, например arr[5:8].copy(). Ниже мы увидим, что pandas работает так же.

Для массивов большей размерности и вариантов тоже больше. В случае двумерного массива элемент с заданным индексом является не скаляром, а одномерным массивом:

In [73]: arr2d = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])

In [74]: arr2d[2]
Out[74]: array([7, 8, 9])

К отдельным элементам можно обращаться рекурсивно. Но это слишком громоздко, поэтому для выбора одного элемента можно указать список индексов через запятую. Таким образом, следующие две конструкции эквивалентны:

In [75]: arr2d[0][2]
Out[75]: 3

In [76]: arr2d[0, 2]
Out[76]: 3

На рис. 4.1 показано индексирование двумерного массива. Лично мне удобно представлять ось 0 как «строки» массива, а ось 1 — как «столбцы».