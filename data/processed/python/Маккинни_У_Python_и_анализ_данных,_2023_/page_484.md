---
source_image: page_484.png
page_number: 484
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 43.14
tokens: 7995
characters: 2216
timestamp: 2025-12-24T02:53:58.132128
finish_reason: stop
---

In [170]: arr = rng.standard_normal(5)

In [171]: arr
Out[171]: array([ 0.8981, -1.1704, -0.2686, -0.796 , 1.4522])

In [172]: np.sort(arr)
Out[172]: array([-1.1704, -0.796 , -0.2686, 0.8981, 1.4522])

In [173]: arr
Out[173]: array([ 0.8981, -1.1704, -0.2686, -0.796 , 1.4522])

Все методы сортировки принимают аргумент axis, что позволяет независимо сортировать участки массива вдоль указанной оси:

In [174]: arr = rng.standard_normal((3, 5))

In [175]: arr
Out[175]:
array([[[-0.2535,  2.1183,  0.3634, -0.6245,  1.1279],
        [ 1.6164, -0.2287, -0.6201, -0.1143, -1.2067],
        [-1.0872, -2.1518, -0.6287, -1.3199,   0.083 ]]])

In [176]: arr.sort(axis=1)

In [177]: arr
Out[177]:
array([[[-0.6245, -0.2535,  0.3634,  1.1279,  2.1183],
        [-1.2067, -0.6201, -0.2287, -0.1143,  1.6164],
        [-2.1518, -1.3199, -1.0872, -0.6287,   0.083 ]]])

Вероятно, вы обратили внимание, что ни у одного метода нет параметра, который задавал бы сортировку в порядке убывания. Это реальная проблема, потому что вырезание массива порождает представления, т. е. копия не создается, что позволяет избежать большого объема вычислений. Но многие пользователи Python знают, что если values — список, то values[::-1] возвращает его в обратном порядке. То же справедливо и для объектов ndarray:

In [178]: arr[:, ::-1]
Out[178]:
array([[ 2.1183,  1.1279,  0.3634, -0.2535, -0.6245],
       [ 1.6164, -0.1143, -0.2287, -0.6201, -1.2067],
       [ 0.083 , -0.6287, -1.0872, -1.3199, -2.1518]])

Косвенная сортировка: методы argsort и lexsort

В ходе анализа данных очень часто возникает необходимость переупорядочить набор данных по одному или нескольким ключам. Например, отсортировать таблицу, содержащую данные о студентах, сначала по фамилии, а потом по имени. Это пример косвенной сортировки, и если вы читали главы, относящиеся к библиотеке pandas, то видели много других примеров более высокого уровня. Имея один или несколько ключей (массив или несколько массивов значений), мы хотим получить массив целочисленных индексов (буду называть их просто индексаторами), который говорит, как переупорядочить данные в нужном порядке сортировки. Для этого существуют два основных метода: argsort и numpy.lexsort. Вот пример: