---
source_image: page_344.png
page_number: 344
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 30.64
tokens: 7713
characters: 1607
timestamp: 2025-12-24T02:49:33.588917
finish_reason: stop
---

2006    0.161735
2007    0.417738
2008    0.611901
2009    0.432738
2010    0.571946
2011    0.581987
dtype: float64

Пример: групповая линейная регрессия
Следуя той же методике, что в предыдущем примере, мы можем применить groupby для выполнения более сложного статистического анализа на группах; главное, чтобы функция возвращала объект pandas или скалярное значение. Например, я могу определить функцию regress (воспользовавшись эконометрической библиотекой statsmodels), которая вычисляет регрессию методом обыкновенных наименьших квадратов для каждого блока данных:

import statsmodels.api as sm
def regress(data, yvar=None, xvars=None):
    Y = data[yvar]
    X = data[xvars]
    X["intercept"] = 1.
    result = sm.OLS(Y, X).fit()
    return result.params

Пакет statsmodels можно установить с помощью conda, если он еще не установлен:

conda install statsmodels

Теперь для вычисления линейной регрессии AAPL от суточного оборота SPX по годам нужно написать:

In [143]: by_year.apply(regress, yvar="AAPL", xvars=["SPX"])
Out[143]:
      SPX  intercept
2003  1.195406   0.000710
2004  1.363463   0.004201
2005  1.766415   0.003246
2006  1.645496   0.000080
2007  1.198761   0.003438
2008  0.968016  -0.001110
2009  0.879103   0.002954
2010  1.052608   0.001261
2011  0.806605   0.001514

10.4. ГРУППОВЫЕ ПРЕОБРАЗОВАНИЯ И «РАЗВЕРНУТАЯ» ГРУППИРОВКА
В разделе 10.3 мы рассмотрели, как метод apply применяется в групповых операциях для выполнения преобразований. Имеется еще один встроенный метод, transform, который похож на apply, но налагает больше ограничений на то, какие функции можно использовать: