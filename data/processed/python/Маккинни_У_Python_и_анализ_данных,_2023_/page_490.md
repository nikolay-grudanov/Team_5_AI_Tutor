---
source_image: page_490.png
page_number: 490
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 23.86
tokens: 7580
characters: 1788
timestamp: 2025-12-24T02:53:45.603463
finish_reason: stop
---

from numba import float64, njit

@njit(float64(float64[:], float64[:]))
def mean_distance(x, y):
    return (x - y).mean()

Призываю вас ознакомиться с онлайновой документацией по Numba на сайте http://numba.pydata.org/. В следующем разделе приведен пример создания пользовательской u-функции для NumPy.

Создание пользовательских объектов numpy.ufunc с помощью Numba
Функция numba.vectorize создает откомпилированные u-функции NumPy, которые ведут себя так же, как встроенные. Рассмотрим реализацию numpy.add на Python:

from numba import vectorize

@vectorize
def nb_add(x, y):
    return x + y
Имеем:
In [13]: x = np.arange(10)

In [14]: nb_add(x, x)
Out[14]: array([ 0., 2., 4., 6., 8., 10., 12., 14., 16., 18.])

In [15]: nb_add.accumulate(x, 0)
Out[15]: array([ 0., 1., 3., 6., 10., 15., 21., 28., 36., 45.])

A.8. Дополнительные сведения о вводе-выводе массивов
В главе 4 мы познакомились с методами np.save и np.load для хранения массивов в двоичном формате на диске. Но есть и целый ряд дополнительных возможностей на случай, когда нужно что-то более сложное. В частности, файлы, отображенные на память, позволяют работать с наборами данных, не умещающимися в оперативной памяти.

Файлы, отображенные на память
Отображение файла на память — метод, позволяющий рассматривать потенциально очень большой набор данных на диске как массив в памяти. В NumPy объект memmap реализован по аналогии с ndarray, он позволяет читать и записывать небольшие сегменты большого файла, не загружая в память весь массив. Кроме того, у объекта memmap точно такие же методы, как у массива в памяти, поэтому его можно подставить во многие алгоритмы, ожидающие получить ndarray.
Для создания объекта memmap служит функция np.memmap, которой передается путь к файлу, dtype, форма и режим открытия файла: