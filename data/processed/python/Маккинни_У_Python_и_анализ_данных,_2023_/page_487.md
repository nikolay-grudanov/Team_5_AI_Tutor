---
source_image: page_487.png
page_number: 487
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 37.90
tokens: 7926
characters: 1943
timestamp: 2025-12-24T02:53:56.982746
finish_reason: stop
---

array([-1.9529, -1.4238, -1.3678, -1.2567, -0.8707, -0.7594, -0.7409,
       -0.0607,  0.3611, -0.0753, -0.2592, -0.467 ,  0.5759,  0.9022,
        0.9685,  0.6489,  0.7888,  1.2637,  1.399 ,  2.3474])

После вызова partition(агг, 3) первые три элемента результата — это три наименьших значения в произвольном порядке. Метод numpy.argpartition, похожий на numpy.argsort, возвращает индексы элементов, определяющие эквивалентный порядок:

In [201]: indices = np.argpartition(агг, 3)

In [202]: indices
Out[202]:
array([ 9,  0,  6, 17,  2, 12,  5, 15,  8,  4,  3, 14, 18, 13, 11,  7, 16,
        1, 19, 10])

In [203]: агг.take(indices)
Out[203]:
array([-1.9529, -1.4238, -1.3678, -1.2567, -0.8707, -0.7594, -0.7409,
       -0.0607,  0.3611, -0.0753, -0.2592, -0.467 ,  0.5759,  0.9022,
        0.9685,  0.6489,  0.7888,  1.2637,  1.399 ,  2.3474])

Метод numpy.searchsorted: поиск элементов в отсортированном массиве

Метод массива searchsorted производит двоичный поиск в отсортированном массиве и возвращает место, в которое нужно было бы вставить значение, чтобы массив оставался отсортированным:

In [204]: агг = np.array([0, 1, 7, 12, 15])

In [205]: агг.searchsorted(9)
Out[205]: 3

Можно передать также массив значений и получить в ответ массив индексов:

In [206]: агг.searchsorted([0, 8, 11, 16])
Out[206]: array([0, 3, 3, 5])

Вы, наверное, заметили, что searchsorted вернул индекс 0 для элемента 0. Это объясняется тем, что по умолчанию возвращается индекс самого левого из группы элементов с одинаковыми значениями:

In [207]: агг = np.array([0, 0, 0, 1, 1, 1, 1])

In [208]: агг.searchsorted([0, 1])
Out[208]: array([0, 3])

In [209]: агг.searchsorted([0, 1], side='right')
Out[209]: array([3, 7])

Чтобы проиллюстрировать еще одно применение метода searchsorted, предположим, что имеется массив значений между 0 и 10 000 и отдельный массив «границ интервалов», который мы хотим использовать для распределения данных по интервалам: