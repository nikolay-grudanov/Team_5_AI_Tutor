---
source_image: page_058.png
page_number: 58
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 32.83
tokens: 7622
characters: 1977
timestamp: 2025-12-24T02:41:27.856398
finish_reason: stop
---

Для подстановки значений вместо спецификаторов формата мы передаем методу format последовательность аргументов:

In [80]: template.format(88.46, "Argentine Pesos", 1)
Out[80]: '88.46 Argentine Pesos are worth US$1'

В Python 3.6 были добавлены f-строки (сокращение от «форматированные строковые литералы»), благодаря которым создание форматированных строк стало еще удобнее. Чтобы создать строку, поместите букву f непосредственно перед строковым литералом. А внутри строки заключайте выражения Python в фигурные скобки, тогда вместо них в строку будет подставлено значение выражения:

In [81]: amount = 10

In [82]: rate = 88.46

In [83]: currency = "Pesos"

In [84]: result = f"{amount} {currency} is worth US${amount / rate}"

После каждого выражения можно поставить спецификатор формата — в таком же синтаксисе, как в шаблонах строк выше:

In [85]: f"{amount} {currency} is worth US${amount / rate:.2f}"
Out[85]: '10 Pesos is worth US$0.11'

Форматирование строк — обширная тема; существует несколько методов и многочисленные параметры и ухищрения, призванные контролировать, как именно должны форматироваться значения, подставляемые в результирующую строку. Подробные сведения можно найти в официальной документации по Python (https://docs.python.org/3/library/string.html).

Байты и Unicode
В современном Python (т. е. Python 3.0 и выше) Unicode стал полноправным типом строки, обеспечивающим единообразную обработку любых текстов, а не только в кодировке ASCII. В прежних версиях строка рассматривалась как совокупность байтов без явного предположения о кодировке Unicode. Строку можно было преобразовать в Unicode, если была известна кодировка символов. Рассмотрим пример:

In [86]: val = "español"

In [87]: val
Out[87]: 'español'

Мы можем преобразовать эту Unicode-строку в последовательность байтов в кодировке UTF-8, вызвав метод encode:

In [88]: val_utf8 = val.encode("utf-8")

In [89]: val_utf8
Out[89]: b'espa\xc3\xb1ol'

In [90]: type(val_utf8)
Out[90]: bytes