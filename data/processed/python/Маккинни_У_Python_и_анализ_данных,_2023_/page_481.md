---
source_image: page_481.png
page_number: 481
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 32.88
tokens: 7798
characters: 2267
timestamp: 2025-12-24T02:53:39.839514
finish_reason: stop
---

Функции, созданные методом frompyfunc, всегда возвращают массивы объектов Python, что не очень удобно. По счастью, есть альтернативный, хотя и не столь функционально богатый метод numpy.vectorize, который позволяет задать выходной тип:

In [142]: add_them = np.vectorize(add_elements, otypes=[np.float64])

In [143]: add_them(np.arange(8), np.arange(8))
Out[143]: array([ 0.,  2.,  4.,  6.,  8., 10., 12., 14.])

Оба метода позволяют создавать аналоги u-функций, которые, правда, работают очень медленно, потому что должны вызывать функцию Python для вычисления каждого элемента, а это далеко не так эффективно, как циклы в написанных на С универсальных функциях NumPy:

In [144]: arr = rng.standard_normal(10000)

In [145]: %timeit add_them(arr, arr)
2.43 ms +- 30.5 us per loop (mean +- std. dev. of 7 runs, 100 loops each)

In [146]: %timeit np.add(arr, arr)
2.88 us +- 47.9 ns per loop (mean +- std. dev. of 7 runs, 100000 loops each)

Ниже в этом приложении мы покажем, как создавать быстрые u-функции на Python с помощью библиотеки Numba (http://numba.pydata.org/).

A.5. СТРУКТУРНЫЕ МАССИВЫ И МАССИВЫ ЗАПИСЕЙ

Вы, наверное, обратили внимание, что все рассмотренные до сих пор примеры ndarray были контейнерами однородных данных, т. е. блоками памяти, в которых каждый элемент занимает одно и то же количество байтов, определяемое типом данных dtype. Создается впечатление, что представить в виде массива неоднородные данные, как в таблице, невозможно. Структурный массив — это объект ndarray, в котором каждый элемент можно рассматривать как аналог структуры (struct) в языке C (отсюда и название «структурный») или строки в таблице SQL, содержащие несколько именованных полей:

In [147]: dtype = [('x', np.float64), ('y', np.int32)]

In [148]: sarr = np.array([(1.5, 6), (np.pi, -2)], dtype=dtype)

In [149]: sarr
Out[149]: array([(1.5, 6), (3.1416, -2)], dtype=[('x', '<f8'), ('y', '<i4')])

Существует несколько способов задать структурный dtype (см. документацию по NumPy в сети). Наиболее распространенный — с помощью списка кортежей вида (field_name, field_data_type). Теперь элементами массива являются кортежеподобные объекты, к элементам которых можно обращаться как к словарю:

In [150]: sarr[0]
Out[150]: (1.5, 6)

In [151]: sarr[0]['y']
Out[151]: 6