---
source_image: page_129.png
page_number: 129
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 21.96
tokens: 7679
characters: 1746
timestamp: 2025-12-24T02:43:15.651025
finish_reason: stop
---

<table>
  <tr>
    <th>Метод</th>
    <th>Описание</th>
  </tr>
  <tr>
    <td>min, max</td>
    <td>Минимум и максимум</td>
  </tr>
  <tr>
    <td>argmin, argmax</td>
    <td>Индексы минимального и максимального элементов</td>
  </tr>
  <tr>
    <td>cumsum</td>
    <td>Сумма с нарастающим итогом с начальным значением 0</td>
  </tr>
  <tr>
    <td>cumprod</td>
    <td>Произведение с нарастающим итогом с начальным значением 1</td>
  </tr>
</table>

Методы булевых массивов
В вышеупомянутых методах булевы значения приводятся к 1 (True) и 0 (False). Поэтому функция sum часто используется для подсчета значений True в булевом массиве:

In [205]: arr = rng.standard_normal(100)

In [206]: (arr > 0).sum() # количество положительных значений
Out[206]: 48

In [207]: (arr <= 0).sum() # количество неположительных значений
Out[207]: 52

Здесь скобки в выражении (arr > 0).sum() необходимы, чтобы функция sum() применялась к временному результату вычисления arr > 0.

Существует еще два метода, any и all, особенно полезных в случае булевых массивов. Метод any проверяет, есть ли в массиве хотя бы одно значение, равное True, а all — что все значения в массиве равны True:

In [208]: bools = np.array([False, False, True, False])

In [209]: bools.any()
Out[209]: True

In [210]: bools.all()
Out[210]: False

Эти методы работают и для небулевых массивов, и тогда все отличные от нуля элементы считаются равными True.

Сортировка
Как и встроенные в Python списки, массивы NumPy можно сортировать на месте методом sort:

In [211]: arr = rng.standard_normal(6)

In [212]: arr
Out[212]: array([ 0.0773, -0.6839, -0.7208, 1.1206, -0.0548, -0.0824])

In [213]: arr.sort()

In [214]: arr
Out[214]: array([-0.7208, -0.6839, -0.0824, -0.0548, 0.0773, 1.1206])