---
source_image: page_516.png
page_number: 516
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 29.88
tokens: 7686
characters: 2301
timestamp: 2025-12-24T02:54:40.275417
finish_reason: stop
---

В.6. Советы по продуктивной разработке кода с использованием IPython

При этом производится попытка предоставить новую копию some_lib.py при каждом запуске test_script.py (но не всегда такая попытка оказывается успешной). Очевидно, что если глубина вложенности зависимостей больше единицы, то вставлять reload повсюду становится утомительно. Поэтому в IPython имеется специальная функция dreload (не магическая), выполняющая «глубокую» (рекурсивную) перезагрузку модулей. Если в файле some_lib.py имеется предложение dreload(some_lib), то интерпретатор постарается перезагрузить как модуль some_lib, так и все его зависимости. К сожалению, это работает не во всех случаях, но если работает, то оказывается куда лучше перезапуска всего IPython.

Советы по проектированию программ
Простых рецептов здесь нет, но некоторыми общими соображениями, которые лично мне кажутся эффективными, я все же поделюсь.

Сохраняйте ссылки на нужные объекты и данные
Программы, рассчитанные на запуск из командной строки, нередко структурируются, как показано в следующем тривиальном примере:

from my_functions import g

def f(x, y):
    return g(x + y)

def main():
    x = 6
    y = 7.5
    result = x + y

if __name__ == '__main__':
    main()

Вы уже видите, что случится, если эту программу запустить в IPython? После ее завершения все результаты или объекты, определенные в функции main, будут недоступны в оболочке IPython. Лучше, если любой код, находящийся в main, будет исполняться прямо в глобальном пространстве имен модуля (или в блоке if __name__ == '__main__':, если вы хотите, чтобы и сам модуль был импортируемым). Тогда после выполнения кода командой %run вы сможете просмотреть все переменные, определенные в main. Это эквивалентно определению переменных верхнего уровня в ячейках Jupyter-блокнота.

Плоское лучше вложенного
Глубоко вложенный код напоминает мне чешуи луковицы. Сколько чешуй придется снять при тестировании или отладке функции, чтобы добраться до интересующего кода? Идея «плоское лучше вложенного» — часть «Дзен Python», применимая и к разработке кода, предназначенного для интерактивного использования. Чем более модульными являются классы и функции и чем меньше связей между ними, тем проще их тестировать (если вы пишете автономные тесты), отлаживать и использовать интерактивно.