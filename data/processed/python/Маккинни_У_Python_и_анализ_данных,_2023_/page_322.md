---
source_image: page_322.png
page_number: 322
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 27.58
tokens: 7591
characters: 1558
timestamp: 2025-12-24T02:48:47.980748
finish_reason: stop
---

10.1. Как представлять себе групповые операции

Out[27]:
        data1   data2
key1 key2
a    1   -0.204708   0.281746
     2    0.478943   0.769023
b    1    1.965781  -1.296221
     2   -0.555730   1.007189

Вероятно, вы обратили внимание, что во втором случае — df.groupby("key1").mean() — результат не содержал столбца key1. Поскольку df["key1"] содержит нечисловые данные, говорят, что это посторонний столбец, и в результат не включают. По умолчанию агрегируются все числовые столбцы, хотя можно выбрать и некоторое их подмножество, как мы вскоре увидим.

Вне зависимости от цели использования groupby у объекта GroupBy есть полезный метод size, который возвращает объект Series, содержащий размеры групп:

In [28]: df.groupby(["key1", "key2"]).size()
Out[28]:
key1  key2
a    1      1
     2      1
b    1      1
     2      1
dtype: int64

Обратите внимание, что данные, соответствующие отсутствующим в групповом ключе значениям, по умолчанию исключаются из результата. Это поведение можно подавить, передав groupby параметр dropna=False:

In [29]: df.groupby("key1", dropna=False).size()
Out[29]:
key1
a    3
b    2
NaN  2
dtype: int64

In [30]: df.groupby(["key1", "key2"], dropna=False).size()
Out[30]:
key1  key2
a    1      1
     2      1
     <NA>   1
b    1      1
     2      1
NaN  1      2
dtype: int64

Еще одна групповая функция в духе size — это count; она вычисляет количество отличных от null значений в каждой группе:

In [31]: df.groupby("key1").count()
Out[31]:
    key2  data1  data2
key1
a    2      3      3
b    2      2      2