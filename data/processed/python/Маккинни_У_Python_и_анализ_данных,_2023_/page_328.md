---
source_image: page_328.png
page_number: 328
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 32.56
tokens: 7860
characters: 2127
timestamp: 2025-12-24T02:49:02.894450
finish_reason: stop
---

<table>
  <tr>
    <th>Имя функции</th>
    <th>Описание</th>
  </tr>
  <tr>
    <td>min, max</td>
    <td>Минимальное и максимальное отличные от NA значения</td>
  </tr>
  <tr>
    <td>nth</td>
    <td>Значение, которое занимало бы позицию n, если бы данные были отсортированы</td>
  </tr>
  <tr>
    <td>ohlc</td>
    <td>Статистика типа «начальное–наибольшее–наименьшее–конечное» для данных типа временных рядов</td>
  </tr>
  <tr>
    <td>prod</td>
    <td>Произведение отличных от NA значений</td>
  </tr>
  <tr>
    <td>quantile</td>
    <td>Выборочный квантиль</td>
  </tr>
  <tr>
    <td>rank</td>
    <td>Порядковые ранги отличных от NA значений, как, например, при вызове Series.rank</td>
  </tr>
  <tr>
    <td>size</td>
    <td>Вычисляет размеры группы и возвращает результат в виде объекта Series</td>
  </tr>
  <tr>
    <td>sum</td>
    <td>Сумма отличных от NA значений</td>
  </tr>
  <tr>
    <td>std, var</td>
    <td>Выборочное стандартное отклонение и выборочная дисперсия</td>
  </tr>
</table>

Вы можете придумать собственные способы агрегирования и, кроме того, вызвать любой метод, определенный для группируемого объекта. Например, метод nsmallest выбирает из данных запрошенное количество наименьших значений. Хотя в классе GroupBy метод nsmallest явно не реализован, мы все-таки можем использовать его неоптимизированную реализацию. На самом деле объект GroupBy разбивает Series на части, вызывает piece.nsmallest(n) для каждой части, а затем собирает результаты в итоговый объект.

In [58]: df
Out[58]:
   key1  key2   data1   data2
0     0     a -0.204708  0.281746
1     1     a  0.478943  0.769023
2   None   None -0.519439  1.246435
3     3     b -0.555730  1.007189
4     4     b  1.965781 -1.296221
5     5     a  1.393406  0.274992
6   None   None  0.092908  0.228913

In [59]: grouped = df.groupby("key1")

In [60]: grouped["data1"].nsmallest(2)
Out[60]:
key1
a    0  -0.204708
     1   0.478943
b    3  -0.555730
     4   1.965781
Name: data1, dtype: float64

Для использования собственных функций агрегирования передайте функцию, агрегирующую массив, методу aggregate или его псевдониму agg: