---
source_image: page_137.png
page_number: 137
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 24.46
tokens: 7503
characters: 1470
timestamp: 2025-12-24T02:43:36.174043
finish_reason: stop
---

Out[273]: array([False, True, True, ..., True, False, True])

In [274]: hits30.sum() # сколько раз достигалось 30 или -30
Out[274]: 3395

Имея этот булев массив, мы можем выбрать те строки walks, в которых достигается уровень 30 (по абсолютной величине), и вызвать argmax вдоль оси 1 для получения моментов пересечения:

In [275]: crossing_times = (np.abs(walks[hits30]) >= 30).argmax(axis=1)

In [276]: crossing_times
Out[276]: array([201, 491, 283, ..., 219, 259, 541])

И наконец, вычислим среднее минимальное время пересечения:

In [277]: crossing_times.mean()
Out[277]: 500.5699558173785

Поэкспериментируйте с другими распределениями шагов, не ограничиваясь подбрасыванием симметричной монеты. Всего-то и нужно, что взять другой генератор случайных чисел, например normal для генерации шагов с нормальным распределением с заданными средним и стандартным отклонением:

In [278]: draws = 0.25 * rng.standard_normal((nwalks, nsteps))

Помните, что при таком векторизованном подходе необходимо создать массив, содержащий nwalks * nsteps элементов; для продолжительного моделирования он может занимать много памяти. Если память ограничена, то придется применить какой-то другой подход.

4.8. ЗАКЛЮЧЕНИЕ

Хотя большая часть книги посвящена выработке навыков манипулирования данными в pandas, мы и дальше будем работать с массивами в таком же стиле. В приложении А мы более глубоко рассмотрим возможности NumPy и расскажем о дополнительных приемах вычислений с массивами.