---
source_image: page_097.png
page_number: 97
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 35.56
tokens: 7773
characters: 2185
timestamp: 2025-12-24T02:42:38.317528
finish_reason: stop
---

<table>
  <tr>
    <th>Метод</th>
    <th>Описание</th>
  </tr>
  <tr>
    <td>write(string)</td>
    <td>Записывает переданную строку в файл</td>
  </tr>
  <tr>
    <td>writable()</td>
    <td>Возвращает True, если файл поддерживает операции write</td>
  </tr>
  <tr>
    <td>writelines(strings)</td>
    <td>Записывает переданную последовательность строк в файл</td>
  </tr>
  <tr>
    <td>close()</td>
    <td>Закрывает описатель файла</td>
  </tr>
  <tr>
    <td>flush()</td>
    <td>Сбрасывает внутренний буфер ввода-вывода на диск</td>
  </tr>
  <tr>
    <td>seek(pos)</td>
    <td>Перемещает указатель чтения-записи на байт файла с указанным номером</td>
  </tr>
  <tr>
    <td>seekable()</td>
    <td>Возвращает True, если файл поддерживает поиск, а следовательно, произвольный доступ (некоторые файлоподобные объекты этого не делают)</td>
  </tr>
  <tr>
    <td>tell()</td>
    <td>Возвращает текущую позицию в файле в виде целого числа</td>
  </tr>
  <tr>
    <td>closed</td>
    <td>True, если файл закрыт</td>
  </tr>
  <tr>
    <td>encoding</td>
    <td>Кодировка, используемая при интерпретации байтов файла как Unicode (обычно UTF-8)</td>
  </tr>
</table>

Байты и Unicode в применении к файлам

По умолчанию Python открывает файлы (как для чтения, так и для записи) в текстовом режиме, предполагая, что вы намереваетесь работать со строками (которые хранятся в Unicode). Чтобы открыть файл в двоичном режиме, следует добавить к основному режиму букву b. Рассмотрим файл из предыдущего раздела (содержащий не-ASCII символы в кодировке UTF-8):

In [258]: with open(path) as f:
.....:     chars = f.read(10)
In [259]: chars
Out[259]: 'Sueña el r'

In [260]: len(chars)
Out[260]: 10

UTF-8 — это кодировка Unicode переменной длины, поэтому когда я запрашиваю чтение нескольких символов из файла, Python читает столько байтов, чтобы после декодирования получилось указанное количество символов (это может быть всего 10, а может быть и целых 40 байт). Если вместо этого открыть файл в режиме 'rb', то read прочитает ровно столько байтов, сколько запрошено:

In [261]: with open(path, mode="rb") as f:
.....:     data = f.read(10)

In [262]: data
Out[262]: b'Sue\xc3\xb1a el '