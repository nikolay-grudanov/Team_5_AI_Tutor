---
source_image: page_148.png
page_number: 148
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 30.65
tokens: 7672
characters: 1786
timestamp: 2025-12-24T02:43:58.916491
finish_reason: stop
---

Столбец, возвращенный в ответ на запрос к DataFrame по индексу, является представлением, а не копией данных. Следовательно, любые модификации этого объекта Series найдут отражение в DataFrame. Чтобы скопировать столбец, нужно явно вызвать метод copy объекта Series.

Еще одна распространенная форма данных — словарь словарей:

In [72]: populations = {"Ohio": {2000: 1.5, 2001: 1.7, 2002: 3.6},
    ....:     "Nevada": {2001: 2.4, 2002: 2.9}}

Если передать вложенный словарь объекту DataFrame, то pandas интерпретирует ключи внешнего словаря как столбцы, а ключи внутреннего словаря — как индексы строк:

In [73]: frame3 = pd.DataFrame(populations)

In [74]: frame3
Out[74]:
      Ohio  Nevada
2000   1.5    NaN
2001   1.7    2.4
2002   3.6    2.9

Объект DataFrame можно транспонировать (переставить местами строки и столбцы), воспользовавшись таким же синтаксисом, как для словарей NumPy:

In [75]: frame3.T
Out[75]:
      2000  2001  2002
Ohio   1.5   1.7   3.6
Nevada NaN   2.4   2.9

Отметим, что операция транспонирования стирает типы данных в столбцах, если не все столбцы имеют один и тот же тип данных. Поэтому при двукратном транспонировании прежняя информация о типах может быть потеряна. В этом случае столбцы становятся массивами стандартных объектов Python.

Ключи внутренних словарей объединяются для образования индекса результата. Однако этого не происходит, если индекс задан явно:

In [76]: pd.DataFrame(populations, index=[2001, 2002, 2003])
Out[76]:
      Ohio  Nevada
2001   1.7    2.4
2002   3.6    2.9
2003   NaN    NaN

Словари объектов Series интерпретируются очень похоже:

In [77]: pdata = {"Ohio": frame3["Ohio"][:-1],
    ....:     "Nevada": frame3["Nevada"][:2]}
In [78]: pd.DataFrame(pdata)
Out[78]:
      Ohio  Nevada
2000   1.5    NaN
2001   1.7    2.4