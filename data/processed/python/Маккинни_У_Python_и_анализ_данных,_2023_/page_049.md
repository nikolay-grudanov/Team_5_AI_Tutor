---
source_image: page_049.png
page_number: 49
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 25.59
tokens: 7511
characters: 1539
timestamp: 2025-12-24T02:41:10.152055
finish_reason: stop
---

In [8]: a = [1, 2, 3]

Предположим, что мы присвоили значение a новой переменной b:

In [9]: b = a

In [10]: b
Out[10]: [1, 2, 3]

В некоторых языках такое присваивание приводит к копированию данных [1, 2, 3]. В Python a и b указывают на один и тот же объект — исходный список [1, 2, 3] (это схематически изображено на рис. 2.5). Чтобы убедиться в этом, добавим в список a еще один элемент и проверим затем список b:

In [11]: a.append(4)

In [12]: b
Out[12]: [1, 2, 3, 4]

![Две ссылки на один объект](https://i.imgur.com/3Q5z5QG.png)

Рис. 2.5. Две ссылки на один объект

Понимать семантику ссылок в Python и знать, когда, как и почему данные копируются, особенно важно при работе с большими наборами данных.

Операцию присваивания называют также связыванием, потому что мы связываем имя с объектом. Имена переменных, которым присвоено значение, иногда называют связанными переменными.

Когда объекты передаются функции в качестве аргументов, создаются новые локальные переменные, ссылающиеся на исходные объекты, — копирование не производится. Если новый объект связывается с переменной внутри функции, то переменная с таким же именем в «области видимости» вне этой функции («родительской области видимости») не перезаписывается. Поэтому функция может модифицировать внутреннее содержимое изменяемого аргумента. Пусть имеется такая функция:

In [13]: def append_element(some_list, element):
    ....:     some_list.append(element)

Тогда:

In [14]: data = [1, 2, 3]

In [15]: append_element(data, 4)

In [16]: data
Out[16]: [1, 2, 3, 4]