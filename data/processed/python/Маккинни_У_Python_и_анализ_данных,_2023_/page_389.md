---
source_image: page_389.png
page_number: 389
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 36.56
tokens: 7822
characters: 1571
timestamp: 2025-12-24T02:51:07.154308
finish_reason: stop
---

Здесь мы можем индексировать по столбцу "time", а затем выполнить передискретизацию:

In [243]: df.set_index("time").resample("5min").count()
Out[243]:
        value
time
2017-05-20 00:00:00    5
2017-05-20 00:05:00    5
2017-05-20 00:10:00    5

Предположим, что объект DataFrame включает несколько временных рядов, которые различаются по дополнительному столбцу, содержащему групповой ключ:

In [244]: df2 = pd.DataFrame({"time": times.repeat(3),
    ....:                 "key": np.tile(["a", "b", "c"], N),
    ....:                 "value": np.arange(N * 3.)})

In [245]: df2.head(7)
Out[245]:
      time key  value
0 2017-05-20 00:00:00   a   0.0
1 2017-05-20 00:00:00   b   1.0
2 2017-05-20 00:00:00   c   2.0
3 2017-05-20 00:01:00   a   3.0
4 2017-05-20 00:01:00   b   4.0
5 2017-05-20 00:01:00   c   5.0
6 2017-05-20 00:02:00   a   6.0

Чтобы выполнить одну и ту же передискретизацию для каждого значения "key", введем объект pandas.Grouper:

In [246]: time_key = pd.Grouper(freq="5min")

Затем можно задать индекс по времени, сгруппировать по "key" и time_key и агрегировать:

In [247]: resampled = (df2.set_index("time")
    ....:         .groupby(["key", time_key])
    ....:         .sum())

In [248]: resampled
Out[248]:
        value
key   time
a     2017-05-20 00:00:00    30.0
      2017-05-20 00:05:00    105.0
      2017-05-20 00:10:00    180.0
b     2017-05-20 00:00:00    35.0
      2017-05-20 00:05:00    110.0
      2017-05-20 00:10:00    185.0
c     2017-05-20 00:00:00    40.0
      2017-05-20 00:05:00    115.0
      2017-05-20 00:10:00    190.0