---
source_image: page_486.png
page_number: 486
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 37.57
tokens: 7887
characters: 2097
timestamp: 2025-12-24T02:53:52.650525
finish_reason: stop
---

Альтернативные алгоритмы сортировки

Устойчивый алгоритм сортировки сохраняет относительные позиции равных элементов. Это особенно важно при косвенной сортировке, когда относительный порядок имеет значение:

In [192]: values = np.array(['2:first', '2:second', '1:first', '1:second', '1:third'])
.....:
In [193]: key = np.array([2, 2, 1, 1, 1])
In [194]: indexer = key.argsort(kind='mergesort')
In [195]: indexer
Out[195]: array([2, 3, 4, 0, 1])
In [196]: values.take(indexer)
Out[196]:
array(['1:first', '1:second', '1:third', '2:first', '2:second'], dtype='<U8')

Единственный имеющийся устойчивый алгоритм сортировки с гарантированным временем работы O(n log n) — mergesort, но его производительность в среднем хуже, чем у алгоритма quicksort. В табл. А.3 перечислены имеющиеся алгоритмы, их сравнительное быстродействие и гарантированная производительность. Большинству пользователей эта информация не особенно интересна, но знать о ее существовании стоит.

Таблица А.3. Алгоритмы сортировки массива

<table>
  <tr>
    <th>Алгоритм</th>
    <th>Быстродействие</th>
    <th>Устойчивый</th>
    <th>Рабочая память</th>
    <th>В худшем случае</th>
  </tr>
  <tr>
    <td>'quicksort'</td>
    <td>1</td>
    <td>Нет</td>
    <td>0</td>
    <td>O(n<sup>2</sup>)</td>
  </tr>
  <tr>
    <td>'mergesort'</td>
    <td>2</td>
    <td>Да</td>
    <td>n / 2</td>
    <td>O(n log n)</td>
  </tr>
  <tr>
    <td>'heapsort'</td>
    <td>3</td>
    <td>Нет</td>
    <td>0</td>
    <td>O(n log n)</td>
  </tr>
</table>

Частичная сортировка массивов

Одна из целей сортировки — найти наибольший или наименьший элемент массива. В NumPy имеются оптимизированные методы, numpy.partition и np.argpartition, для разделения массива по k-му наименьшему элементу:

In [197]: rng = np.random.default_rng(12345)
In [198]: arr = rng.standard_normal(20)
In [199]: arr
Out[199]:
array([-1.4238,  1.2637, -0.8707, -0.2592, -0.0753, -0.7409, -1.3678,
        0.6489,  0.3611, -1.9529,  2.3474,  0.9685, -0.7594,  0.9022,
       -0.467 , -0.0607,  0.7888, -1.2567,  0.5759,  1.399 ])
In [200]: np.partition(arr, 3)
Out[200]: