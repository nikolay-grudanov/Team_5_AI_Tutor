---
source_image: page_483.png
page_number: 483
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 36.71
tokens: 7869
characters: 2268
timestamp: 2025-12-24T02:53:49.501512
finish_reason: stop
---

Зачем нужны структурные массивы?
По сравнению с объектом DataFrame из pandas, структурные массивы NumPy — средство более низкого уровня. Они позволяют интерпретировать блок памяти как табличную структуру с вложенными столбцами. Поскольку каждый элемент представлен в памяти фиксированным количеством байтов, структурный массив дает очень эффективный способ записи данных на диск и чтения с диска (в том числе в файлы, отображенные на память, о чем речь пойдет ниже), передачи по сети и прочих операций такого рода. Расположение значений в памяти структурированного массива определяется двоичным представлением структурных типов данных в языке программирования C.

Еще одно распространенное применение структурных массивов связано со стандартным способом сериализации данных в C и C++, часто встречающимся в унаследованных системах; данные выводятся в файл в виде потока байтов с фиксированной длиной записи. Коль скоро известен формат файла (размер каждой записи, порядок байтов и тип данных каждого элемента), данные можно прочитать в память методом np.fromfile. Подобные специализированные применения выходят за рамки этой книги, но знать об их существовании полезно.

A.6. ЕЩЕ О СОРТИРОВКЕ

Как и у встроенных списков Python, метод sort объекта производит сортировку на месте, т. е. массив переупорядочивается без порождения нового массива:

In [163]: arr = rng.standard_normal(6)

In [164]: arr.sort()

In [165]: arr
Out[165]: array([-1.1553, -0.9319, -0.5218, -0.4745, -0.1649, 0.03 ])

Сортируя на месте, не забывайте, что если сортируемый массив — представление другого массива ndarray, то модифицируется исходный массив:

In [166]: arr = rng.standard_normal((3, 5))

In [167]: arr
Out[167]:
array([[-1.1956,  0.4691, -0.3598,  1.0359,  0.2267],
       [-0.7448, -0.5931, -1.055 , -0.0683,  0.458 ],
       [-0.07  ,  0.1462, -0.9944,  1.1436,  0.5026]])

In [168]: arr[:, 0].sort() # Sort first column values in place

In [169]: arr
Out[169]:
array([[-1.1956,  0.4691, -0.3598,  1.0359,  0.2267],
       [-0.7448, -0.5931, -1.055 , -0.0683,  0.458 ],
       [-0.07  ,  0.1462, -0.9944,  1.1436,  0.5026]])

С другой стороны, функция numpy.sort создает отсортированную копию массива, принимая те же самые аргументы (в частности, kind), что и метод ndarray.sort: