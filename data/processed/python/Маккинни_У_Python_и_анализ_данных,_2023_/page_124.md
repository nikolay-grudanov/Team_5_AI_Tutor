---
source_image: page_124.png
page_number: 124
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 46.00
tokens: 8094
characters: 2798
timestamp: 2025-12-24T02:43:32.324893
finish_reason: stop
---

<table>
  <tr>
    <th>Функция</th>
    <th>Описание</th>
  </tr>
  <tr>
    <td><a href="divide, floor_divide">divide, floor_divide</a></td>
    <td>Деление и деление с отбрасыванием остатка</td>
  </tr>
  <tr>
    <td><a href="power">power</a></td>
    <td>Возвести элементы первого массива в степени, указанные во втором массиве</td>
  </tr>
  <tr>
    <td><a href="maximum, fmax">maximum, fmax</a></td>
    <td>Поэлементный максимум. Функция <code>fmax</code> игнорирует значения NaN</td>
  </tr>
  <tr>
    <td><a href="minimum, fmin">minimum, fmin</a></td>
    <td>Поэлементный минимум. Функция <code>fmin</code> игнорирует значения NaN</td>
  </tr>
  <tr>
    <td><a href="mod">mod</a></td>
    <td>Поэлементный модуль (остаток от деления)</td>
  </tr>
  <tr>
    <td><a href="copysign">copysign</a></td>
    <td>Копировать знаки значений второго массива в соответственные элементы первого массива</td>
  </tr>
  <tr>
    <td><a href="greater, greater_equal, less, less_equal, equal, not_equal">greater, greater_equal, less, less_equal, equal, not_equal</a></td>
    <td>Поэлементное сравнение, возвращается булев массив. Эквивалентны инфиксным операторам &gt;, &gt;=, &lt;, &lt;=, ==, !=</td>
  </tr>
  <tr>
    <td><a href="logical_and, logical_or, logical_xor">logical_and, logical_or, logical_xor</a></td>
    <td>Вычислить логическое значение истинности логических операций. Эквивалентны инфиксным операторам &amp;, |, ^</td>
  </tr>
</table>

4.4. Программирование на основе массивов

С помощью массивов NumPy многие виды обработки данных можно записать очень кратко, не прибегая к циклам. Такой способ замены явных циклов выражениями-массивами обычно называется векторизацией. Вообще говоря, векторные операции с массивами выполняются на один-два (а то и больше) порядка быстрее, чем эквивалентные операции на чистом Python. Позже, в приложении А, я расскажу об укладывании, действенном методе векторизации вычислений.

В качестве простого примера предположим, что нужно вычислить функцию \( \sqrt{x^2 + y^2} \) на регулярной сетке. Функция <code>np.meshgrid</code> принимает два одномерных массива и порождает две двумерные матрицы, соответствующие всем парам \((x, y)\) элементов, взятых из обоих массивов:

In [169]: points = np.arange(-5, 5, 0.01) # 100 равноотстоящих точек

In [170]: xs, ys = np.meshgrid(points, points)

In [171]: ys
Out[171]:
array([[-5. , -5. , -5. , ..., -5. , -5. , -5. ],
       [-4.99, -4.99, -4.99, ..., -4.99, -4.99, -4.99],
       [-4.98, -4.98, -4.98, ..., -4.98, -4.98, -4.98],
       ...,
       [ 4.97,  4.97,  4.97, ...,  4.97,  4.97,  4.97],
       [ 4.98,  4.98,  4.98, ...,  4.98,  4.98,  4.98],
       [ 4.99,  4.99,  4.99, ...,  4.99,  4.99,  4.99]])

Теперь для вычисления функции достаточно написать такое же выражение, как для двух точек: