---
source_image: page_324.png
page_number: 324
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 26.11
tokens: 7592
characters: 1461
timestamp: 2025-12-24T02:48:49.729204
finish_reason: stop
---

Группы можно распечатать следующим образом:

In [37]: for group_key, group_values in grouped:
    ....:     print(group_key)
    ....:     print(group_values)
    ....:
data
    data1    data2
0 -0.204708   0.281746
1  0.478943   0.769023
2 -0.519439   1.246435
3 -0.555730   1.007189
4  1.965781  -1.296221
5  1.393406   0.274992
6  0.092908   0.228913
key
    key1   key2
0   a      1
1   a      2
2   None   1
3   b      2
4   b      1
5   a      <NA>
6   None   1

Выборка столбца или подмножества столбцов

Доступ по индексу к объекту GroupBy, полученному группировкой объекта DataFrame путем задания имени столбца или массива имен столбцов, имеет тот же эффект, что выборка этих столбцов для агрегирования. Это означает, что

df.groupby("key1")["data1"]
df.groupby("key1")[["data2"]]

– просто удобный способ записи вместо:

df["data1"].groupby(df["key1"])
df[["data2"]].groupby(df["key1"])

Большие наборы данных обычно желательно агрегировать лишь по немногим столбцам. Так, чтобы в приведенном выше примере вычислить среднее только по столбцу data2 и получить результат в виде DataFrame, можно было бы написать:

In [38]: df.groupby(["key1", "key2"])[["data2"]].mean()
Out[38]:
data2
key1 key2
a    1   0.281746
     2   0.769023
b    1  -1.296221
     2   1.007189

В результате этой операции доступа по индексу возвращается сгруппированный DataFrame, если передан список, или массив, или сгруппированный Series, если передано только одно имя столбца: