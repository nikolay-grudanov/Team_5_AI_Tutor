---
source_image: page_108.png
page_number: 108
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 26.15
tokens: 7567
characters: 1403
timestamp: 2025-12-24T02:42:46.070377
finish_reason: stop
---

Можно также использовать атрибут dtype другого массива:

In [47]: int_array = np.arange(10)

In [48]: calibers = np.array([.22, .270, .357, .380, .44, .50], dtype=np.float64)

In [49]: int_array.astype(calibers.dtype)
Out[49]: array([0., 1., 2., 3., 4., 5., 6., 7., 8., 9.])

На dtype можно сослаться также с помощью коротких кодов типа:

In [50]: zeros_uint32 = np.zeros(8, dtype="u4")

In [51]: zeros_uint32
Out[51]: array([0, 0, 0, 0, 0, 0, 0, 0], dtype=uint32)

При вызове astype всегда создается новый массив (данные копируются), даже если новый dtype не отличается от старого.

Арифметические операции с массивами NumPy

Массивы важны, потому что позволяют выразить операции над совокупностями данных без выписывания циклов for. Обычно это называется векторизацией. Любая арифметическая операция над массивами одинакового размера применяется к соответственным элементам:

In [52]: arr = np.array([[1., 2., 3.], [4., 5., 6.]])
In [53]: arr
Out[53]:
array([[1., 2., 3.],
       [4., 5., 6.]])

In [54]: arr * arr
Out[54]:
array([[ 1.,  4.,  9.],
       [16., 25., 36.]])

In [55]: arr - arr
Out[55]:
array([[0., 0., 0.],
       [0., 0., 0.]])

Арифметические операции, в которых участвует скаляр, применяются к каждому элементу массива:

In [56]: 1 / arr
Out[56]:
array([[1. , 0.5 , 0.3333],
       [0.25 , 0.2 , 0.1667]])

In [57]: arr ** 2
Out[57]:
array([[ 1.,  4.,  9.],
       [16., 25., 36.]])