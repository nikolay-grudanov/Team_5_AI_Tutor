---
source_image: page_480.png
page_number: 480
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 33.18
tokens: 7813
characters: 2102
timestamp: 2025-12-24T02:53:40.006443
finish_reason: stop
---

На выходе получаются результаты редукции (в данном случае суммирования) по срезам arr[0:5], arr[5:8] и arr[8:]. Как и другие методы, reduceat принимает необязательный аргумент axis:

In [136]: arr = np.multiply.outer(np.arange(4), np.arange(5))

In [137]: arr
Out[137]:
array([[ 0,  0,  0,  0],
       [ 0,  1,  2,  3,  4],
       [ 0,  2,  4,  6,  8],
       [ 0,  3,  6,  9, 12]])

In [138]: np.add.reduceat(arr, [0, 2, 4], axis=1)
Out[138]:
array([[ 0,  0,  0],
       [ 1,  5,  4],
       [ 2, 10,  8],
       [ 3, 15, 12]])

Неполный перечень u-функций приведен в табл. А.2.

Таблица А.2. Методы u-функций

<table>
  <tr>
    <th>Метод</th>
    <th>Описание</th>
  </tr>
  <tr>
    <td>accumulate(x)</td>
    <td>Агрегирует значения, сохраняя все промежуточные агрегаты</td>
  </tr>
  <tr>
    <td>at(x, indices, b=None)</td>
    <td>Выполняет операцию над x на месте в точках, определяемых заданными индексами. Аргумент b передается вторым аргументом u-функциям, принимающим два массива</td>
  </tr>
  <tr>
    <td>reduce(x)</td>
    <td>Агрегирует значения путем последовательного применения операции</td>
  </tr>
  <tr>
    <td>reduceat(x, bins)</td>
    <td>«Локальная» редукция, или «group by». Редуцирует соседние срезы данных и порождает массив агрегатов</td>
  </tr>
  <tr>
    <td>outer(x, y)</td>
    <td>Применяет операцию ко всем парам элементов x и y. Результирующий массив имеет форму x.shape + y.shape</td>
  </tr>
</table>

Написание новых u-функций на Python
Для создания собственных u-функций для NumPy существует несколько механизмов. Самый общий — использовать C API NumPy, но он выходит за рамки этой книги. В этом разделе мы будем рассматривать u-функции на чистом Python.

Метод numpy.frompyfunc принимает функцию Python и спецификацию количества входов и выходов. Например, простую функцию, выполняющую поэлементное сложение, можно было бы задать так:

In [139]: def add_elements(x, y):
.....:     return x + y

In [140]: add_them = np.frompyfunc(add_elements, 2, 1)

In [141]: add_them(np.arange(8), np.arange(8))
Out[141]: array([0, 2, 4, 6, 8, 10, 12, 14], dtype=object)