---
source_image: page_471.png
page_number: 471
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 38.20
tokens: 7839
characters: 1542
timestamp: 2025-12-24T02:53:30.084828
finish_reason: stop
---

Out[65]:
array([[ 0.7888, -1.2567,  0.7888, -1.2567],
       [ 0.5759,  1.399 ,  0.5759,  1.399 ]])

Второй аргумент — количество плиток; если это скаляр, то мощение производится по строкам, а не по столбцам. Но второй аргумент tile может быть кортежем, описывающим порядок мощения:

In [66]: arr
Out[66]:
array([[ 0.7888, -1.2567],
       [ 0.5759,  1.399 ]])

In [67]: np.tile(arr, (2, 1))
Out[67]:
array([[ 0.7888, -1.2567],
       [ 0.5759,  1.399 ],
       [ 0.7888, -1.2567],
       [ 0.5759,  1.399 ]])

In [68]: np.tile(arr, (3, 2))
Out[68]:
array([[ 0.7888, -1.2567,  0.7888, -1.2567,
         [ 0.5759,  1.399 ,  0.5759,  1.399 ],
         [ 0.7888, -1.2567,  0.7888, -1.2567],
         [ 0.5759,  1.399 ,  0.5759,  1.399 ],
         [ 0.7888, -1.2567,  0.7888, -1.2567],
         [ 0.5759,  1.399 ,  0.5759,  1.399 ]]])

Эквиваленты прихотливого индексирования:
функции take и put
В главе 4 описывался способ получить и установить подмножество массива с помощью прихотливого индексирования массивами целых чисел:

In [69]: arr = np.arange(10) * 100

In [70]: inds = [7, 1, 2, 6]

In [71]: arr[inds]
Out[71]: array([700, 100, 200, 600])

Существуют и другие методы ndarray, полезные в частном случае, когда выборка производится только по одной оси:

In [72]: arr.take(inds)
Out[72]: array([700, 100, 200, 600])

In [73]: arr.put(inds, 42)

In [74]: arr
Out[74]: array([ 0, 42, 42, 300, 400, 500, 42, 42, 800, 900])

In [75]: arr.put(inds, [40, 41, 42, 43])

In [76]: arr
Out[76]: array([ 0, 41, 42, 300, 400, 500, 43, 40, 800, 900])