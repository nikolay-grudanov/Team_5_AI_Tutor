---
source_image: page_469.png
page_number: 469
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 37.83
tokens: 7810
characters: 1829
timestamp: 2025-12-24T02:53:26.249228
finish_reason: stop
---

Таблица А.1. Функции конкатенации массива

<table>
  <tr>
    <th>Функция</th>
    <th>Описание</th>
  </tr>
  <tr>
    <td>concatenate</td>
    <td>Самая общая функция – конкатенирует коллекцию массивов вдоль указанной оси</td>
  </tr>
  <tr>
    <td>vstack, row_stack</td>
    <td>Составляет массивы по строкам (вдоль оси 0)</td>
  </tr>
  <tr>
    <td>hstack</td>
    <td>Составляет массивы по столбцам (вдоль оси 1)</td>
  </tr>
  <tr>
    <td>column_stack</td>
    <td>Аналогична hstack, но сначала преобразует одномерные массивы в двумерные векторы по столбцам</td>
  </tr>
  <tr>
    <td>dstack</td>
    <td>Составляет массивы в глубину (вдоль оси 2)</td>
  </tr>
  <tr>
    <td>split</td>
    <td>Разбивает массив в указанных позициях вдоль указанной оси</td>
  </tr>
  <tr>
    <td>hsplit / vsplit</td>
    <td>Вспомогательные функции для разбиения по оси 0 и 1 соответственно</td>
  </tr>
</table>

Вспомогательные объекты: r_ и c_
В пространстве имен NumPy есть два специальных объекта: r_ и c_, благодаря которым составление массивов можно записать более кратко:

In [49]: arr = np.arange(6)

In [50]: arr1 = arr.reshape((3, 2))

In [51]: arr2 = rng.standard_normal((3, 2))

In [52]: np.r_[arr1, arr2]
Out[52]:
array([[ 0.   ,  1.   ],
       [ 2.   ,  3.   ],
       [ 4.   ,  5.   ],
       [ 2.3474,  0.9685],
       [-0.7594,  0.9022],
       [-0.467 , -0.0607]])

In [53]: np.c_[np.r_[arr1, arr2], arr]
Out[53]:
array([[ 0.   ,  1.   ,  0.   ],
       [ 2.   ,  3.   ,  1.   ],
       [ 4.   ,  5.   ,  2.   ],
       [ 2.3474,  0.9685,  3.   ],
       [-0.7594,  0.9022,  4.   ],
       [-0.467 , -0.0607,  5.   ]])

С их помощью можно также преобразовывать срезы в массивы:

In [55]: arr = np.arange(3)

In [56]: arr
Out[56]: array([0, 1, 2])

In [57]: arr.repeat(3)
Out[57]: array([0, 0, 0, 1, 1, 1, 2, 2, 2])