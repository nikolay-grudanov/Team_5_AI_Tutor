---
source_image: page_164.png
page_number: 164
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 25.12
tokens: 7598
characters: 1544
timestamp: 2025-12-24T02:44:21.066779
finish_reason: stop
---

In [167]: ser
Out[167]:
    0   0.0
    1   1.0
    2   2.0
dtype: float64

С другой стороны, если индекс не целочисленный, то никакой неоднозначности не возникает:

In [168]: ser2 = pd.Series(np.arange(3.), index=["a", "b", "c"])

In [169]: ser2[-1]
Out[169]: 2.0

Если индекс по какой-то оси содержит целые числа, то выборка данных всегда производится по метке. Как было сказано выше, использование loc (для меток) или iloc (для целых) всегда приводит к желаемому результату:

In [170]: ser.iloc[-1]
Out[170]: 2.0

С другой стороны, срез с применением целых чисел всегда ориентирован на целые:

In [171]: ser[:2]
Out[171]:
    0   0.0
    1   1.0
dtype: float64

Из-за всех этих тонкостей рекомендуется всегда использовать индексирование с помощью loc и iloc, избежав тем самым двусмысленности.

Подвохи цепного индексирования
В предыдущем разделе мы видели, как можно гибко выбирать данные из объекта DataFrame с помощью атрибутов loc и iloc. Их можно использовать также для изменения DataFrame на месте, но делать это следует осторожно.
Например, в предыдущем примере DataFrame мы можем присвоить значение строке или столбцу по метке или по целому числу:

In [172]: data.loc[:, "one"] = 1

In [173]: data
Out[173]:
      one  two  three  four
Ohio   1    0     0     0
Colorado  1   5     6     7
Utah    1   9    10    11
New York  1  13    14    15

In [174]: data.iloc[2] = 5

In [175]: data
Out[175]:
      one  two  three  four
Ohio   1    0     0     0
Colorado  1   5     6     7
Utah    1   9    10    15
New York  1  13    14    15