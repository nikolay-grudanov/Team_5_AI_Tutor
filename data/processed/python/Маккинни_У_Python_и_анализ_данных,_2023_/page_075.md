---
source_image: page_075.png
page_number: 75
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 30.75
tokens: 7608
characters: 1711
timestamp: 2025-12-24T02:41:55.254223
finish_reason: stop
---

Методы keys и values возвращают соответственно список ключей и список значений. Хотя точный порядок пар ключ-значение не определен, эти методы возвращают ключи и значения в одном и том же порядке:

In [99]: list(d1.keys())
Out[99]: ['a', 'b', 7]

In [100]: list(d1.values())
Out[100]: ['some value', [1, 2, 3, 4], 'an integer']

Чтобы обойти одновременно ключи и значения, воспользуйтесь методом items, который отдает 2-кортежи, состоящие из ключа и значения:

In [101]: list(d1.items())
Out[101]: [('a', 'some value'), ('b', [1, 2, 3, 4]), (7, 'an integer')]

Два словаря можно объединить в один методом update:

In [102]: d1.update({"b": "foo", "c": 12})

In [103]: d1
Out[103]: {'a': 'some value', 'b': 'foo', 7: 'an integer', 'c': 12}

Метод update модифицирует словарь на месте, т. е. старые значения существующих ключей, переданных update, стираются.

Создание словаря из последовательностей
Нередко бывает, что имеются две последовательности, которые естественно рассматривать как ключи и соответствующие им значения, а значит, требуется построить из них словарь. Первая попытка могла бы выглядеть так:

mapping = {}
for key, value in zip(key_list, value_list):
    mapping[key] = value

Поскольку словарь — это, по существу, коллекция 2-кортежей, функция dict принимает список 2-кортежей:

In [104]: tuples = zip(range(5), reversed(range(5)))

In [105]: tuples
Out[105]: <zip at 0x7fefe4553a00>

In [106]: mapping = dict(tuples)

In [107]: mapping
Out[107]: {0: 4, 1: 3, 2: 2, 3: 1, 4: 0}

Ниже мы рассмотрим словарное включение — еще один элегантный способ построения словарей.

Значения по умолчанию
Часто можно встретить код, реализующий такую логику:

if key in some_dict:
    value = some_dict[key]