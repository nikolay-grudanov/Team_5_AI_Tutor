---
source_image: page_126.png
page_number: 126
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 30.81
tokens: 7778
characters: 2093
timestamp: 2025-12-24T02:43:17.608607
finish_reason: stop
---

Если вы работаете в IPython, то для закрытия всех открытых окон с графиками можете выполнить метод plt.close("all"):

In [179]: plt.close("all")

Термин vectorization употребляется в информатике и для описания некоторых других понятий, но в этой книге я пользуюсь им для обозначения операций над целыми массивами данных вместо поэлементного применения в цикле for.

Запись логических условий в виде операций с массивами

Функция numpy.where — векторный вариант тернарного выражения x if condition else y. Пусть имеется булев массив и два массива значений:

In [180]: xarr = np.array([1.1, 1.2, 1.3, 1.4, 1.5])
In [181]: yarr = np.array([2.1, 2.2, 2.3, 2.4, 2.5])
In [182]: cond = np.array([True, False, True, True, False])

Допустим, что мы хотим брать значение из массива xarr, если соответственное значение в массиве cond равно True, а в противном случае — значение из yarr. Эту задачу решает такая операция спискового включения:

In [183]: result = [(x if c else y)
.....:     for x, y, c in zip(xarr, yarr, cond)]
In [184]: result
Out[184]: [1.1, 2.2, 1.3, 1.4, 2.5]

Здесь есть сразу несколько проблем. Во-первых, для больших массивов это будет не быстро (потому что весь код написан на чистом Python). Во-вторых, к многомерным массивам такое решение вообще неприменимо. С помощью функции numpy.where можно написать очень лаконичный код:

In [185]: result = np.where(cond, xarr, yarr)
In [186]: result
Out[186]: array([1.1, 2.2, 1.3, 1.4, 2.5])

Второй и третий аргументы numpy.where не обязаны быть массивами — один или оба могут быть скалярами. При анализе данные where обычно применяются, чтобы создать новый массив на основе существующего. Предположим, имеется матрица со случайными данными, и мы хотим заменить все положительные значения на 2, а все отрицательные — на −2. С помощью numpy.where сделать это очень просто:

In [187]: arr = rng.standard_normal((4, 4))
In [188]: arr
Out[188]:
array([[ 2.6182,   0.7774,   0.8286,  -0.959 ],
       [-1.2094,  -1.4123,   0.5415,   0.7519],
       [-0.6588,  -1.2287,   0.2576,   0.3129],
       [-0.1308,   1.27   ,  -0.093 ,  -0.0662]])