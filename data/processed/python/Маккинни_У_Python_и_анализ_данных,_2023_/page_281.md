---
source_image: page_281.png
page_number: 281
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 46.64
tokens: 7929
characters: 1821
timestamp: 2025-12-24T02:48:00.809022
finish_reason: stop
---

Out[150]:
    realgdp   infl   unemp
date
1959-01-01  2710.349  0.00  5.8
1959-04-01  2778.801  2.34  5.1
1959-07-01  2775.488  2.74  5.3
1959-10-01  2785.204  0.27  5.6
1960-01-01  2847.699  2.31  5.2

Здесь я воспользовался методом pop, который удаляет столбец из объекта DataFrame и возвращает его.
Затем выбрал подмножество столбцов и присвоил индексу columns имя "item":

In [151]: data = data.reindex(columns=["realgdp", "infl", "unemp"])

In [152]: data.columns.name = "item"

In [153]: data.head()
Out[153]:
    item   realgdp   infl   unemp
date
1959-01-01  2710.349  0.00  5.8
1959-04-01  2778.801  2.34  5.1
1959-07-01  2775.488  2.74  5.3
1959-10-01  2785.204  0.27  5.6
1960-01-01  2847.699  2.31  5.2

И напоследок я изменил форму методом stack, преобразовал новые уровни индекса в столбцы методом reset_index и присвоил столбцу, содержащему значения данных, имя "value":

In [154]: long_data = (data.stack()
.....:         .reset_index()
.....:         .rename(columns={0: "value"}))

Теперь ldata выглядит следующим образом:

In [155]: long_data[:10]
Out[155]:
      date   item   value
0  1959-01-01  realgdp  2710.349
1  1959-01-01     infl   0.000
2  1959-01-01   unemp   5.800
3  1959-04-01  realgdp  2778.801
4  1959-04-01     infl   2.340
5  1959-04-01   unemp   5.100
6  1959-07-01  realgdp  2775.488
7  1959-07-01     infl   2.740
8  1959-07-01   unemp   5.300
9  1959-10-01  realgdp  2785.204

В этом, так называемом длинном, формате для нескольких временных рядов каждая строка таблицы соответствует одному наблюдению.
Так данные часто хранятся в реляционных базах данных, поскольку при наличии фиксированной схемы (совокупность имен и типов данных столбцов) количество различных значений в столбце item может увеличиваться или уменьшаться при добавлении или удалении данных. В примере выше пара