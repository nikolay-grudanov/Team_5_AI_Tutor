---
source_image: page_464.png
page_number: 464
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 13.70
tokens: 7326
characters: 1057
timestamp: 2025-12-24T02:52:52.241980
finish_reason: stop
---

In [18]: np.float64.mro()
Out[18]:
[numpy.float64,
 numpy.floating,
 numpy.inexact,
 numpy.number,
 numpy.generic,
 float,
 object]

Поэтому мы также имеем:

In [19]: np.issubdtype(ints.dtype, np.number)
Out[19]: True

Большинству пользователей NumPy об этом знать необязательно, но иногда оказывается удобно. На рис. А.2 показан граф наследования dtype12.

![Иерархия классов типов данных в NumPy](https://i.imgur.com/3Q5z5QG.png)

Рис. А.2. Иерархия классов типов данных в NumPy

**А.2. Дополнительные манипуляции с массивами**

Помимо прихотливого индексирования, вырезания и формирования булевых подмножеств, существует много других способов работы с массивами. И хотя большую часть сложных задач, решаемых в ходе анализа данных, берут на себя высокоуровневые функции из библиотеки pandas, иногда возникает необходимость написать алгоритм обработки данных, которого нет в имеющихся библиотеках.

12 В именах некоторых типов dtype присутствуют знаки подчеркивания. Они нужны, чтобы избежать конфликтов между именами типов NumPy и встроенных типов Python.