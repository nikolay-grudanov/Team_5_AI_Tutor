---
source_image: page_390.png
page_number: 390
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 32.25
tokens: 7688
characters: 1606
timestamp: 2025-12-24T02:51:04.885417
finish_reason: stop
---

In [249]: resampled.reset_index()
Out[249]:
    key        time   value
0   a 2017-05-20 00:00:00   30.0
1   a 2017-05-20 00:05:00  105.0
2   a 2017-05-20 00:10:00  180.0
3   b 2017-05-20 00:00:00   35.0
4   b 2017-05-20 00:05:00  110.0
5   b 2017-05-20 00:10:00  185.0
6   c 2017-05-20 00:00:00   40.0
7   c 2017-05-20 00:05:00  115.0
8   c 2017-05-20 00:10:00  190.0

У pandas.Grouper есть ограничение — индекс Series или DataFrame должен быть построен по времени.

11.7. Скользящие оконные функции

Важный класс преобразований массива, применяемый для операций с временными рядами, — статистические и иные функции, вычисляемые в скользящем окне или с экспоненциально убывающими весами. Я называю их скользящими оконными функциями, хотя сюда относятся также функции, не связанные с окном постоянной ширины, например экспоненциально взвешенное скользящее среднее. Как и во всех статистических функциях, отсутствующие значения автоматически отбрасываются.

Для начала загрузим временной ряд и передискретизируем его на частоту «рабочий день»:

In [250]: close_px_all = pd.read_csv("examples/stock_px.csv",
.....: parse_dates=True, index_col=0)
In [251]: close_px = close_px_all[["AAPL", "MSFT", "XOM"]]
In [252]: close_px = close_px.resample("B").ffill()

Теперь я введу в рассмотрение оператор rolling, который ведет себя как resample и groupby. Его можно применить к объекту Series или DataFrame, передав аргумент window (равный количеству периодов; созданный график показан на рис. 11.4):

In [253]: close_px["AAPL"].plot()
Out[253]: <AxesSubplot:>

In [254]: close_px["AAPL"].rolling(250).mean().plot()