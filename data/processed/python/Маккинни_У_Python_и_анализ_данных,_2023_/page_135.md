---
source_image: page_135.png
page_number: 135
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 15.51
tokens: 7387
characters: 1137
timestamp: 2025-12-24T02:43:22.787820
finish_reason: stop
---

Рис. 4.4. Простое случайное блуждание

Наверное, вы обратили внимание, что walk — это просто сумма с нарастающим итогом случайных шагов, которую можно вычислить как выражение-массив. Поэтому я воспользуюсь модулем numpy.random, чтобы за один присест подбросить 1000 монет с исходами 1 и −1 и вычислить нарастающую сумму с нарастающим итогом:

In [256]: nsteps = 1000

In [257]: rng = np.random.default_rng(seed=12345) # Новый генератор случайных чисел

In [258]: draws = rng.integers(0, 2, size=nsteps)

In [259]: steps = np.where(draws == 0, 1, -1)

In [260]: walk = steps.cumsum()

Теперь можно приступить к вычислению статистики, например минимального и максимального значений на траектории блуждания:

In [261]: walk.min()
Out[261]: -8

In [262]: walk.max()
Out[262]: 50

Более сложная статистика — момент первого пересечения — это шаг, на котором траектория случайного блуждания впервые достигает заданного значения. В данном случае мы хотим знать, сколько времени потребуется на то, чтобы удалиться от начала (нуля) на десять единиц в любом направлении. Выражение np.abs(walk) >= 10 дает булев массив, показывающий, в какие моменты