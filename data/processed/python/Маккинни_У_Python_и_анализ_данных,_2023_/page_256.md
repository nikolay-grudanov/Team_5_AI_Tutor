---
source_image: page_256.png
page_number: 256
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 24.14
tokens: 7525
characters: 1250
timestamp: 2025-12-24T02:46:59.579002
finish_reason: stop
---

In [13]: data.index
Out[13]:
MultiIndex([('a', 1),
           ('a', 2),
           ('a', 3),
           ('b', 1),
           ('b', 3),
           ('c', 1),
           ('c', 2),
           ('d', 2),
           ('d', 3)],
          )

К иерархически индексированному объекту возможен доступ по так называемому частичному индексу, что позволяет лаконично записывать выборку подмножества данных:

In [14]: data["b"]
Out[14]:
1    0.204560
3    0.567725
dtype: float64

In [15]: data["b":"c"]
Out[15]:
   b    c
1  0.204560  0.595545
3  0.567725  0.964515
dtype: float64

In [16]: data.loc[["b", "d"]]
Out[16]:
   b    d
1  0.204560  0.653177
3  0.567725  0.748907
dtype: float64

В некоторых случаях возможна даже выборка с «внутреннего» уровня. Ниже я выбрал все элементы со значением 2 на втором уровне индекса:

In [17]: data.loc[:, 2]
Out[17]:
a    0.316376
c    0.964515
d    0.653177
dtype: float64

Иерархическое индексирование играет важнейшую роль в изменении формы данных и групповых операциях, в том числе построении сводных таблиц. Например, эти данные можно было бы преобразовать в DataFrame с помощью метода unstack:

In [18]: data.unstack()
Out[18]:
      1    2    3
a    NaN  0.316376  NaN
c    NaN  0.964515  NaN
d    NaN  0.653177  NaN