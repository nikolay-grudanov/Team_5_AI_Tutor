---
source_image: page_361.png
page_number: 361
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 31.67
tokens: 7841
characters: 1737
timestamp: 2025-12-24T02:50:05.310685
finish_reason: stop
---

Существует эквивалентный метод экземпляра truncate, который возвращает срез Series между двумя датами:

In [58]: ts.truncate(after="2011-01-09")
Out[58]:
2011-01-02   -0.204708
2011-01-05    0.478943
2011-01-07   -0.519439
2011-01-08   -0.555730
dtype: float64

Все вышеперечисленное справедливо и для объекта DataFrame, индексированного своими строками:

In [59]: dates = pd.date_range("2000-01-01", periods=100, freq="W-WED")

In [60]: long_df = pd.DataFrame(np.random.standard_normal((100, 4)),
....:                        index=dates,
....:                        columns=["Colorado", "Texas",
....:                        "New York", "Ohio"])

In [61]: long_df.loc["2001-05"]
Out[61]:
           Colorado   Texas   New York   Ohio
2001-05-02  -0.006045  0.490094 -0.277186 -0.707213
2001-05-09  -0.560107  2.735527  0.927335  1.513906
2001-05-16   0.538600  1.273768  0.667876 -0.969206
2001-05-23   1.676091 -0.817649  0.050188  1.951312
2001-05-30   3.260383  0.963301  1.201206 -1.852001

Временные ряды с неуникальными индексами
В некоторых приложениях бывает, что несколько результатов измерений имеют одну и ту же временную метку, например:

In [62]: dates = pd.DatetimeIndex(["2000-01-01", "2000-01-02", "2000-01-02",
....: "2000-01-02", "2000-01-03"])

In [63]: dup_ts = pd.Series(np.arange(5), index=dates)

In [64]: dup_ts
Out[64]:
2000-01-01    0
2000-01-02    1
2000-01-02    2
2000-01-02    3
2000-01-03    4
dtype: int64

Узнать о том, что индекс не уникален, можно, опросив его свойство is_unique:

In [65]: dup_ts.index.is_unique
Out[65]: False

При доступе к такому временному ряду по индексу будет возвращено либо скалярное значение, либо срез — в зависимости от того, является временная метка уникальной или нет: