---
source_image: page_191.png
page_number: 191
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 33.05
tokens: 7746
characters: 1788
timestamp: 2025-12-24T02:45:11.572717
finish_reason: stop
---

bbb   0.927272   0.302904  -0.032399
ccc  -0.264273  -0.386314  -0.217601
ddd  -0.871858  -0.348382   1.100491

В данном случае поля разделены переменным числом пробелов и, хотя можно было бы переформатировать данные вручную, проще передать функции pandas.read_csv регулярное выражение \s+ в качестве разделителя:

In [22]: result = pd.read_csv("examples/ex3.txt", sep="\s+")

In [23]: result
Out[23]:
      A      B      C
aaa -0.264438 -1.026059 -0.619500
bbb  0.927272  0.302904 -0.032399
ccc -0.264273 -0.386314 -0.217601
ddd -0.871858 -0.348382  1.100491

Поскольку имен столбцов на одно меньше, чем число строк, pandas.read_csv делает вывод, что в данном частном случае первый столбец должен быть индексом DataFrame.

У функций разбора много дополнительных аргументов, которые помогают справиться с широким разнообразием файловых форматов (см. табл. 6.2). Например, параметр skiprows позволяет пропустить первую, третью и четвертую строки файла:

In [24]: !cat examples/ex4.csv
# привет!
a,b,c,d,message
# хотелось немного усложнить тебе жизнь
# да кто вообще читает CSV-файлы на компьютере?
1,2,3,4,hello
5,6,7,8,world
9,10,11,12,foo

In [25]: pd.read_csv("examples/ex4.csv", skiprows=[0, 2, 3])
Out[25]:
    a   b   c   d message
0  1  2  3  4   hello
1  5  6  7  8   world
2  9 10 11 12     foo

Обработка отсутствующих значений — важная и зачастую сопровождаемая тонкими нюансами часть разбора файла. Отсутствующие значения обычно либо вообще опущены (пустые строки), либо представлены специальными маркерами. По умолчанию в pandas используется набор общеупотребительных маркеров: NA, -1.#IND и NULL:

In [26]: !cat examples/ex5.csv
something,a,b,c,d,message
one,1,2,3,4,NA
two,5,6,,8,world
three,9,10,11,12,foo
In [27]: result = pd.read_csv("examples/ex5.csv")

In [28]: result