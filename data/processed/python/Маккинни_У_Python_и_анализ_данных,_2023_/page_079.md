---
source_image: page_079.png
page_number: 79
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 29.84
tokens: 7555
characters: 1546
timestamp: 2025-12-24T02:41:58.148866
finish_reason: stop
---

Если подать на вход методам типа union или intersection значение, не являющееся множеством, то Python преобразует его в множество, прежде чем выполнять операцию. Для бинарных операторов оба аргумента уже должны быть множествами.

У всех логических операций над множествами имеются варианты с обновлением на месте, которые позволяют заменить содержимое множества в левой части результатом операции. Для очень больших множеств это может оказаться эффективнее:

In [132]: c = a.copy()

In [133]: c |= b

In [134]: c
Out[134]: {1, 2, 3, 4, 5, 6, 7, 8}

In [135]: d = a.copy()

In [136]: d &= b

In [137]: d
Out[137]: {3, 4, 5}

Как и в случае словарей, элементы множества, вообще говоря, должны быть неизменяемыми и хешируемыми (т. е. вызов hash для значения не должен возбуждать исключения). Чтобы сохранить в множестве элементы, подобные списку, необходимо сначала преобразовать их в кортеж:

In [138]: my_data = [1, 2, 3, 4]

In [139]: my_set = {tuple(my_data)}

In [140]: my_set
Out[140]: {(1, 2, 3, 4)}

Можно также проверить, является ли множество подмножеством (содержится в) или надмножеством (содержит) другого множества:

In [141]: a_set = {1, 2, 3, 4, 5}

In [142]: {1, 2, 3}.issubset(a_set)
Out[142]: True

In [143]: a_set.issuperset({1, 2, 3})
Out[143]: True

Множества называются равными, если состоят из одинаковых элементов:

In [144]: {1, 2, 3} == {3, 2, 1}
Out[144]: True

Встроенные функции последовательностей
У последовательностей в Python есть несколько полезных функций, которые следует знать и применять при любой возможности.