---
source_image: page_164.png
page_number: 164
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 25.89
tokens: 6689
characters: 1796
timestamp: 2025-12-24T02:13:20.598674
finish_reason: stop
---

self.wih = (numpy.random.rand(self.hnodes, self.inodes) - 0.5)
self.who = (numpy.random.rand(self.onodes, self.hnodes) - 0.5)

Великолепная работа! Мы реализовали то, что составляет саму сердцевину нейронной сети, — матрицы связей между ее узлами!

По желанию: улучшенный вариант инициализации весовых коэффициентов

Описанное в этом разделе обновление кода не является обязательным, поскольку это всего лишь простое, но популярное усовершенствование процесса инициализации весовых коэффициентов.

В конце главы 1 мы обсуждали различные способы подготовки данных и инициализации коэффициентов. Так вот, некоторые предпочитают несколько усовершенствованный подход к созданию случайных начальных значений весов. Для этого весовые коэффициенты выбираются из нормального распределения с центром в нуле и со стандартным отклонением, величина которого обратно пропорциональна корню квадратному из количества входящих связей на узел.

Это легко делается с помощью библиотеки numpy. Опять-таки, в отношении поиска онлайновой документации Google незаменим. Функция numpy.random.normal() описана по такому адресу:

https://docs.scipy.org/doc/numpy-1.10.1/reference/generated/numpy.random.normal.html

Она поможет нам с извлечением выборки из нормального распределения. Ее параметрами являются центр распределения, стандартное отклонение и размер массива numpy, если нам нужна матрица случайных чисел, а не одиночное число.

Обновленный код инициализации весовых коэффициентов будет выглядеть примерно так.

self.wih = numpy.random.normal(0.0, pow(self.hnodes, -0.5), (self.hnodes, self.inodes))
self.who = numpy.random.normal(0.0, pow(self.onodes, -0.5), (self.onodes, self.hnodes))

Как видите, центр нормального распределения установлен здесь в 0,0. Стандартное отклонение вычисляется по количеству узлов