---
source_image: page_156.png
page_number: 156
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 31.79
tokens: 6745
characters: 2242
timestamp: 2025-12-24T02:13:17.675039
finish_reason: stop
---

сталкивались? Определение функции avg() явно указывало на то, что функция ожидает получения двух параметров. Следовательно, функция __init__() нуждается в параметрах petname и temp, а функция setTemperature() — только в параметре temp.

Заглянем внутрь этих функций. Начнем с функции с необычным названием __init__(). Зачем ей присвоено такое замысловатое имя? Это специальное имя, и Python будет вызывать функцию __init__() каждый раз при создании нового объекта данного класса. Это очень удобно для выполнения любой подготовительной работы до фактического использования объекта. Так что же именно происходит в этой магической функции инициализации? Мы создаем две новые переменные: self.name и self.temperature. Вы можете узнать их значения из переменных petname и temp, передаваемых функции. Часть self. в именах означает, что эти переменные являются собственностью объекта, т.е. принадлежат данному конкретному объекту и не зависят от других объектов Dog или общих переменных Python. Мы не хотим смешивать имя данной собаки с именем другой! Если это кажется вам слишком сложным, не беспокойтесь, все значительно упростится, когда мы приступим к рассмотрению конкретного примера.

Следующая на очереди — функция status(), которая действительно проста. Она не принимает никаких параметров и просто выводит значения переменных name и temperature объекта Dog.

Наконец, функция setTemperature() принимает параметр temp, значение которого при ее вызове присваивается внутренней переменной self.temperature. Это означает, что даже после того, как объект создан, вы можете в любой момент изменить его температуру, причем это можно сделать столько раз, сколько потребуется. Мы не будем тратить время на обсуждение того, почему все эти функции, включая bark(), принимают атрибут self в качестве первого параметра. Это особенность Python, которая лично меня немного раздражает, но таков ход эволюции Python. По замыслу разработчиков это должно напоминать Python, что функция, которую вы собираетесь определить, принадлежит объекту, ссылкой на который служит self. Но ведь, по сути, это и так очевидно, ведь код функции находится внутри класса. Таким образом, вас не должно удивлять то, что горячие дискуссии по этому поводу разгорелись даже в среде