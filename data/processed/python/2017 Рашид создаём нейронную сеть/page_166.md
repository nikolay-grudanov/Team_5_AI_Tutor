---
source_image: page_166.png
page_number: 166
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 26.69
tokens: 6667
characters: 1750
timestamp: 2025-12-24T02:13:24.217760
finish_reason: stop
---

расчеты, поскольку им известно об однотипности всех стоящих за этим вычислений.

Вы будете удивлены простотой соответствующего кода на языке Python. Ниже представлена инструкция, которая показывает, как применить функцию скалярного произведения библиотеки numpy к матрицам весов и входных сигналов:

hidden_inputs = numpy.dot(self.wih, inputs)

Вот и все!

Эта короткая строка кода Python выполняет всю работу по объединению всех входных сигналов с соответствующими весами для получения матрицы сглаженных комбинированных сигналов в каждом узле скрытого слоя. Более того, нам не придется ее переписывать, если в следующий раз мы решим использовать входной или скрытый слой с другим количеством узлов. Этот код все равно будет работать!

Именно эта мощь и элегантность матричного подхода являются причиной того, что перед этим мы не пожалели потратить время и усилия на его рассмотрение.

Для получения выходных сигналов скрытого слоя мы просто применяем к каждому из них сигмоиду:

\[
O_{скрытый} = \text{сигмоида}\left(X_{скрытый}\right)
\]

Это не должно вызвать никаких затруднений, особенно если сигмоида уже определена в какой-нибудь библиотеке Python. Оказывается, так оно и есть! Библиотека scipy в Python содержит набор специальных функций, в том числе сигмоиду, которая называется expit(). Не спрашивайте меня, почему ей присвоили такое дурацкое имя. Библиотека scipy импортируется точно так же, как и библиотека numpy.

# библиотека scipy.special содержит сигмоиду expit()
import scipy.special

Поскольку в будущем мы можем захотеть поэкспериментировать с функцией активации, настроив ее параметры или полностью заменив другой функцией, лучше определить ее один раз в объекте нейронной сети во время его инициализации. После этого мы сможем