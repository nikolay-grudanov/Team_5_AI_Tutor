---
source_image: page_190.png
page_number: 190
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 24.01
tokens: 6735
characters: 1921
timestamp: 2025-12-24T02:13:54.999844
finish_reason: stop
---

Первая строка после комментария просто устанавливает количество выходных узлов равным 10, что соответствует нашему примеру с десятью маркерами.

Во второй строке с помощью удобной функции numpy.zeros() создается массив, заполненный нулями. Желаемые размер и конфигурация массива задаются параметром при вызове функции. В данном случае создается одномерный массив, размер onodes которого равен количеству узлов в конечном выходном слое. Проблема нулей, которую мы только что обсуждали, устраняется путем добавления 0,01 к каждому элементу массива.

Следующая строка выбирает первый элемент записи из набора данных MNIST, являющийся целевым маркером тренировочного набора, и преобразует его в целое число. Вспомните о том, что запись читается из исходного файла в виде текстовой строки, а не числа. Как только преобразование выполнено, полученный целевой маркер используется для того, чтобы установить значение соответствующего элемента массива равным 0,99. Здесь все будет нормально работать, поскольку маркер "0" будет преобразован в целое число 0, являющееся корректным индексом данного маркера в массиве targets[]. Точно так же маркер "9" будет преобразован в целое число 9, и элемент targets[9] действительно является последним элементом этого массива.

Вот пример работы этого кода.

In [11]: # количество выходных узлов - 10 (пример)
onodes = 10
targets = numpy.zeros(onodes) + 0.01
targets[int(all_values[0])] = 0.99

In [12]: print(targets)
[ 0.99  0.01  0.01  0.01  0.01  0.01  0.01  0.01  0.01  0.01]

Великолепно! Теперь мы знаем, как подготовить входные значения для тренировки и опроса нейронной сети, а выходные значения — для тренировки.

Обновим наш код с учетом проделанной работы. Ниже представлено состояние кода на данном этапе, включая последнее обновление. Вы также можете в любой момент получить его на сайте GitHub, используя следующую ссылку, в то время как мы продолжим его дальнейшую разработку: