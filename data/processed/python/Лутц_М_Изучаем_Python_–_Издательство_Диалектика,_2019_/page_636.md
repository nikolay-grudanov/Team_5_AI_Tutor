---
source_image: page_636.png
page_number: 636
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 30.77
tokens: 7837
characters: 2688
timestamp: 2025-12-24T01:27:01.269569
finish_reason: stop
---

Тестовый код в конце применяет это к одной и двум последовательностям для производства показанного далее вывода — того же самого, который мы получили бы с помощью встроенной функции map (если хотите самостоятельно запустить код, то он находится в файле mymap.py внутри пакета примеров книги):

[2, 1, 0, 1, 2]
[1, 8, 81]

Правда, в предыдущей версии несложно заметить классическую схему спискового включения, строящую список результатов операции в цикле for. Мы можем записать код функции mymap более компактно как эквивалентное односторочное списковое включение:

# Использование спискового включения
def mymap(func, *seqs):
    return [func(*args) for args in zip(*seqs)]
print(mymap(abs, [-2, -1, 0, 1, 2]))
print(mymap(pow, [1, 2, 3], [2, 3, 4, 5]))

Результаты запуска оказываются такими же, как ранее, но код лаконичнее и может выполняться быстрее (производительность более подробно обсуждается в разделе "Измерение времени выполнения итерационных альтернатив" главы 21). Однако обе написанные выше версии mymap строят результирующие списки целиком, что может привести к излишнему расходу памяти в случае крупных списков. Теперь, когда нам известны генераторные функции и выражения, довольно легко переписать обе альтернативные версии для производства результатов по запросу:

# Использование генераторов: yield и ...
def mymap(func, *seqs):
    for args in zip(*seqs):
        yield func(*args)
def mymap(func, *seqs):
    return (func(*args) for args in zip(*seqs))

Новые версии выпускают такие же результаты, но возвращают генераторы, предназначенные для поддержки протокола итерации — первая версия выдает по одному результату за раз, а вторая возвращает результат генераторного выражения, чтобы делать то же самое. Они дадут такие же результаты, если их поместить внутрь вызовов list для принудительного производства сразу всех значений:

print(list(mymap(abs, [-2, -1, 0, 1, 2])))
print(list(mymap(pow, [1, 2, 3], [2, 3, 4, 5])))

В действительности здесь никакая работа не делается до тех пор, пока вызовы list не заставят генераторы выполняться, активируя протокол итерации. Генераторы, возврашающиеся самими нашими функциями, а также версией zip из Python 3.x, которую они используют, производят результаты только по запросу.

Написание собственных функций zip(...) и map(None, ...)

Разумеется, порядочная часть магии в показанных до сих пор примерах была связана с применением встроенной функции zip для объединения в пары элементов из множества последовательностей или итерируемых объектов, переданных в аргументах. Наши аналоги map также действительно эмулировали поведение версии map из Python 3.x — они выполняли усечение по длине самой короткой последовательности и