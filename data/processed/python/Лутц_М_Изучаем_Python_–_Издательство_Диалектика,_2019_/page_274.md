---
source_image: page_274.png
page_number: 274
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 30.83
tokens: 7889
characters: 2907
timestamp: 2025-12-24T01:15:43.490494
finish_reason: stop
---

В предыдущем взаимодействии обратите внимание на то, что при желании списки могут естественным образом распространяться на несколько строк, т.к. они заключаются между парой квадратных скобок; здесь ... означает приглашение к продолжению ввода в интерактивной подсказке Python.

Дополнительные сведения о матрицах будут приведены позже в главе при обсуждении их представления на основе словарей, которые могут оказаться более эффективными, когда матрицы почти совершенно пусты. Мы также продолжим развивать это направление в главе 20, где запишем добавочный код для работы с матрицами, особенно с помощью списковых включений. Для мощной численной обработки расширение NumPy, упомянутое в главах 4 и 5, предлагает другие способы поддержки матриц.

Изменение списков на месте

Поскольку списки изменяемы, они поддерживают операции, которые изменяют списковый объект на месте. То есть все операции в текущем разделе модифицируют списковый объект напрямую, переписывая его старое значение, и не требуют создания новой копии, как пришлось бы поступать в случае строк. Из-за того, что Python имеет дело только со ссылками на объекты, такое разграничение между изменением объекта на месте и созданием нового объекта является существенным; как обсуждалось в главе 6, изменение объекта на месте может оказать влияние более чем на одну ссылку на него.

Присваивания по индексам и срезам

Содержимое списка можно изменять, присваивая значение либо отдельному элементу (по смещению), либо целому сегменту (по срезу):

```python
>>> L = ['spam', 'Spam', 'SPAM!']
>>> L[1] = 'eggs'      # Присваивание по индексу
>>> L
['spam', 'eggs', 'SPAM!']
>>> L[0:2] = ['eat', 'more']   # Присваивание по срезу: удаление + вставка
>>> L
['eat', 'more', 'SPAM!']
```

Присваивания по индексам и по срезам представляют собой изменения на месте — они модифицируют списковый объект напрямую, а не генерируют для результата новый списковый объект. Присваивание по индексу в Python работает почти как в C и большинстве других языков: Python заменяет одиночную ссылку на объект, находящуюся по заданному смещению, новой ссылкой.

Присваивание по срезу, последняя операция в предыдущем примере, заменяет целый сегмент списка за один шаг. Из-за некоторой сложности для лучшего понимания ее можно воспринимать как комбинацию двух шагов.

1. Удаление. Секция, указанная слева от знака =, удаляется.
2. Вставка. Новые элементы, содержащиеся в итерируемом объекте справа от знака =, вставляются в список слева в месте, где была удалена старая секция².

Это не то, что происходит в действительности, но оно помогает прояснить, почему количество вставляемых элементов не обязано совпадать с количеством удаляемых элементов.

² Описание требует уточнения, когда значение и срез во время присваивания частично перекрываются: скажем, L[2:5]=L[3:6] работает нормально, потому что вставляемое значение извлекается до того, как слева происходит удаление.