---
source_image: page_375.png
page_number: 375
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 28.81
tokens: 7818
characters: 2529
timestamp: 2025-12-24T01:19:00.659958
finish_reason: stop
---

И для добавления набора элементов в конец списка мы можем либо снова выполнить конкатенацию, либо вызвать списковый метод extend²:

```python
>>> L = L + [5, 6]    # Конкатенация: медленнее
>>> L
[1, 2, 3, 4, 5, 6]
>>> L.extend([7, 8])   # Быстрее, но на месте
>>> L
[1, 2, 3, 4, 5, 6, 7, 8]
```

В обоих случаях конкатенация менее подвержена побочным эффектам, связанным с разделяемыми ссылками на объекты, но в целом будет выполнятся медленнее, чем эквивалентное изменение на месте. Операция конкатенации обязана создать новый объект, скопировать список слева и затем скопировать список справа. Напротив, вызов метода изменения на месте просто добавляет элементы в конец блока памяти (внутренне он может быть устроен сложнее, но такого описания вполне достаточно).

Когда для расширения списка используется дополненное присваивание, мы почти полностью можем забыть об этих деталях — Python автоматически вызывает более быстрый метод extend вместо применения медленной операции конкатенации, подразумеваемой +:

```python
>>> L += [9, 10]    # Отображается на L.extend([9, 10])
>>> L
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
```

Тем не менее, следует отметить, что из-за такой эквивалентности присваивание += для списка не точно соответствует операциям + и = во всех случаях — для списков присваивание += допускает произвольные последовательности (как и метод extend), но конкатенация обычно нет:

```python
>>> L = []
>>> L += 'spam'    # += и extend допускают любую последовательность, но + нет!
>>> L
['s', 'p', 'a', 'm']
>>> L = L + 'spam'
TypeError: can only concatenate list (not "str") to list
Ошибка типа: выполнять конкатенацию можно только списка (не строки) со списком
```

Дополненное присваивание и разделяемые ссылки

Как правило, описанное поведение является желательным, но обратите внимание: отсюда вытекает, что присваивание += представляет собой изменение на месте для списков; таким образом, оно не в точности похоже на конкатенацию +, которая всегда создает новый объект. Как и для всех случаев с разделяемыми ссылками, это отличие может иметь значение, когда на изменяемый объект ссылаются другие имена:

```python
>>> L = [1, 2]
>>> M = L    # L и M ссылаются на тот же самый объект
>>> L = L + [3, 4]    # Конкатенация создает новый объект
>>> L, M    # Изменяет L, но не M
([1, 2, 3, 4], [1, 2])
```

² Как предполагалось в главе 6, мы также можем использовать присваивание по срезу (например, L[len(L):] = [11,12,13]), но оно работает практически аналогично более простому и понятному списковому методу extend.