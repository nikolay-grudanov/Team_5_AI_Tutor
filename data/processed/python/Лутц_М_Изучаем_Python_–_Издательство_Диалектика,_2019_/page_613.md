---
source_image: page_613.png
page_number: 613
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 40.03
tokens: 7944
characters: 3129
timestamp: 2025-12-24T01:26:29.941845
finish_reason: stop
---

>>> for x in map((lambda n: n ** 2), range(5)):
    print(x, end=' : ')
0 : 1 : 4 : 9 : 16 :

Тем не менее, в крупных программах генераторы могут быть лучше в плане памяти и производительности. Они позволяют функциям избежать выполнения всей работы заранее, что особенно полезно, когда результирующие списки большие или получение каждого значения требует длительных вычислений. Генераторы распределяют время, необходимое для производства серии значений, по всем итерациям цикла.

Кроме того, для усложненных сценариев применения генераторы способны предложить более простую альтернативу ручному сохранению состояния между итерациями в объектах классов — генераторы обеспечивают автоматическое сохранение и восстановление переменных, доступных в области видимости функций². Мы более подробно обсудим итерируемые объекты на основе классов в части VI.

Генераторные функции гораздо более универсальны, чем могли показаться. Они способны действовать и возвращать объекты любых типов, а также как итерируемые объекты могут появляться во всех итерационных контекстах из главы 14, в том числе в вызовах tuple, перечислениях и включениях словарей:

>>> def ups(line):
    for sub in line.split(','):
        yield sub.upper()
>>> tuple(ups('aaa,bbb,ccc'))      # Все итерационные контексты
('AAA', 'BBB', 'CCC')
>>> {i: s for (i, s) in enumerate(ups('aaa,bbb,ccc'))}
{0: 'AAA', 1: 'BBB', 2: 'CCC'}

Вскоре мы увидим те же самые ресурсы для генераторных выражений — инструмента, который обменивает гибкость функций на лаконичность включений. Позже в главе мы также выясним, что временами генераторы делают невозможное возможным, производя компоненты результирующих наборов, которые оказались бы слишком крупными, чтобы быть созданными полностью за раз. Но сначала давайте исследуем ряд более развитых возможностей генераторных функций.

Расширенный протокол генераторных функций: send или next

В версии Python 2.5 к протоколу генераторных функций был добавлен метод send. Он осуществляет переход на следующий элемент в серии результатов, в точности как __next__, но также снабжает вызывающий код возможностью взаимодействия с генератором для влияния на его работу.

² Интересно отметить, что генераторные функции также являются чем-то вроде механизма многопоточной обработки "для бедняков" — они чередуют работу функции с работой вызывающего кода за счет разделения действия функции на шаги, выполняемые между вызовами yield. Однако генераторы — не потоки: программа явно направляется на функцию и из нее внутри единственного потока управления. Многопоточная обработка в каком-то смысле более универсальна (производители результатов способны выполнять по-настоящему независимо и отправлять результаты в очередь), но генераторы могут быть проще в написании. Краткое введение в инструменты многопоточной обработки Python ищите в сноске, посвященной многопоточности, в главе 17. Обратите внимание, что поскольку управление явно направляется на вызовы yield и next, генераторы также не возвращаются к предыдущему состоянию и имеют более тесное отношение к сопрограммам — формальные понятия, которые выходят за рамки тематики настоящей главы.