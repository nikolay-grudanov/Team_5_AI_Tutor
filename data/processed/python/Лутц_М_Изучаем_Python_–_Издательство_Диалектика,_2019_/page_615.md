---
source_image: page_615.png
page_number: 615
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 31.03
tokens: 7805
characters: 2544
timestamp: 2025-12-24T01:26:24.898578
finish_reason: stop
---

Генераторные выражения:
итерируемые объекты встречаются с включениями

Из-за того, что отложенная оценка генераторных функций оказалась настолько удобной, со временем она распространилась на другие инструменты. В Python 2.x и 3.x понятия итерируемых объектов и списковых включений были объединены в новый инструмент — генераторные выражения. Синтаксически генераторные выражения похожи на нормальные списковые включения и поддерживают весь их синтаксис, в том числе фильтры if и вложение циклов, но они помещаются в круглые скобки, а не в квадратные (подобно кортежам объемлющие круглые скобки часто необязательны):

>>> [x ** 2 for x in range(4)]    # Списковое включение: строит список
[0, 1, 4, 9]
>>> (x ** 2 for x in range(4))    # Генераторное выражение:
# создает итерируемый объект
<generator object <genexpr> at 0x00000000029A8288>

На самом деле, во всяком случае, с точки зрения функциональности, написание кода спискового включения по существу будет тем же, что и помещение генераторного выражения в вызов встроенной функции list для принудительного вырабатывания всех результатов сразу:

>>> list(x ** 2 for x in range(4))    # Эквивалентность списковому включению
[0, 1, 4, 9]

Тем не менее, генераторные выражения совершенно другие: вместо построения результирующего списка в памяти они возвращают объект генератора — автоматически созданный итерируемый объект. В свою очередь этот итерируемый объект поддерживает протокол итерации, чтобы выдавать по одной порции результирующего списка за раз в любом итерационном контексте. Итерируемый объект также сохраняет состояние генератора, пока он действует — переменную x в предшествующих выражениях наряду с местоположением в коде генератора.

Совокупный эффект во многом подобен генераторным функциям, но в контексте выражения включения: мы получаем обратно объект, который запоминает оставленное им место после возврата каждой части результата. Как и в случае генераторных функций, исследование внутренностей протокола, который такие объекты автоматически поддерживают, может помочь прояснить их; здесь снова нет необходимости в вызове iter по причинам, объясняемым далее:

>>> G = (x ** 2 for x in range(4))
>>> iter(G) is G    # Вызов iter(G) необязателен: __iter__ возвращает сам объект
True
>>> next(G)        # Объекты генераторов: автоматические методы
0
>>> next(G)
1
>>> next(G)
4
>>> next(G)
9
>>> next(G)
Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
Трассировка (самый последний вызов указан последним):
    Файл <stdin>, строка 1, в <модуль>