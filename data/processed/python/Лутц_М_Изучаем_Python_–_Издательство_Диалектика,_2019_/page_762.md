---
source_image: page_762.png
page_number: 762
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 13.66
tokens: 7781
characters: 2432
timestamp: 2025-12-24T01:30:41.900455
finish_reason: stop
---

На самом деле это противоположность соглашению _X: __all__ идентифицирует имена, подлежащие копированию, в то время как _X обозначает имена, которые не должны копироваться. Python сначала ищет список __all__ в модуле и копирует его имена вне зависимости от наличия в них подчеркиваний; если переменная __all__ не определена, тогда from * копирует все имена, не содержащие одиночный ведущий символ подчеркивания:

# alls.py
__all__ = ['a', '_c']
a, b, _c, _d = 1, 2, 3, 4

>>> from alls import *
# __all__ имеет приоритет над _X
>>> a, _c
(1, 3)
>>> b
NameError: name 'b' is not defined
Ошибка в имени: имя b не определено

>>> from alls import a, b, _c, _d   # Но другие импортеры получают все имена
>>> a, b, _c, _d
(1, 2, 3, 4)

>>> import alls
>>> alls.a, alls.b, alls._c, alls._d
(1, 2, 3, 4)

Подобно соглашению _X список __all__ имеет смысл только для формы оператора from * и не эквивалентен объявлению закрытости: другие операторы импортирования по-прежнему могут получать доступ ко всем именам, как продемонстрировали последние две проверки. Однако разработчики модулей могут использовать любую из двух методик для реализации модулей, которые должным образом себя ведут, когда применяются вместе с from *. Вспомните также обсуждение списков __all__ внутри файлов __init__.py пакетов в главе 24; там эти списки объявляют подмодули, которые подлежат автоматической загрузке для оператора from * с их контейнером.

Включение будущих языковых средств: __future__

Изменения языка, потенциально способные нарушить работу существующего кода, обычно в Python вводятся постепенно. Они часто появляются как необязательные расширения, которые по умолчанию отключены. Для включения таких расширений используется специальный оператор import следующего вида:

from __future__ import название_средства

В файле сценария этот оператор должен быть первым исполняемым оператором (возможно, находясь после строки документации или комментария), потому что он включает специальную компиляцию кода для каждого модуля по отдельности. Такой оператор можно вводить и в интерактивной подсказке, чтобы поэкспериментировать с предстоящими изменениями языка; средство будет доступным до конца интерактивного сеанса.

Скажем, ранее в книге было показано, как применять данный оператор в Python 2.x для активизации настоящего деления из Python 3.x в главе 5, вызовов print из Python 3.x в главе 11 и операций абсолютного импортирования пакетов из Python