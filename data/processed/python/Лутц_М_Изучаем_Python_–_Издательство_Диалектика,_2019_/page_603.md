---
source_image: page_603.png
page_number: 603
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 36.20
tokens: 7903
characters: 2379
timestamp: 2025-12-24T01:26:06.736895
finish_reason: stop
---

>>> res = []
>>> for x in [0, 1, 2]:
    for y in [100, 200, 300]:
        res.append(x + y)
>>> res
[100, 200, 300, 101, 201, 301, 102, 202, 302]

Хотя списковые включения создают результирующие списки, не забывайте, что они способны проходить по любой последовательности или другому итерируемому объекту. Далее приведен похожий фрагмент кода, который вместо списков чисел обходит строки, накапливая результаты конкатенации:

>>> [x + y for x in 'spam' for y in 'SPAM']
['sS', 'sP', 'sA', 'sM', 'pS', 'pP', 'pA', 'pM',
'aS', 'aP', 'aA', 'aM', 'mS', 'mP', 'mA', 'mM']

Каждая конструкция for может иметь ассоциированный фильтр if независимо от того, насколько глубоко вложены циклы — хотя сценарии использования для кода следующего вида, не считая многоуровневых массивов, придумывать все труднее и труднее:

>>> [x + y for x in 'spam' if x in 'sm' for y in 'SPAM' if y in ('P', 'A')]
['sP', 'sA', 'mP', 'mA']
>>> [x + y + z for x in 'spam' if x in 'sm'
    for y in 'SPAM' if y in ('P', 'A')
    for z in '123' if z > '1']
['sP2', 'sP3', 'sA2', 'sA3', 'mP2', 'mP3', 'mA2', 'mA3']

Наконец, ниже представлено аналогичное списковое включение, которое иллюстрирует эффект от присоединения конструкций выбора if к вложенным конструкциям for, применяемым к числовым объектам вместо строк:

>>> [(x, y) for x in range(5) if x % 2 == 0 for y in range(5) if y % 2 == 1]
[(0, 1), (0, 3), (2, 1), (2, 3), (4, 1), (4, 3)]

Выражение комбинирует четные числа от 0 до 4 с нечетными числами от 0 до 4. Конструкции if отфильтровывают элементы на каждой итерации. Вот эквивалентный код на основе операторов:

>>> res = []
>>> for x in range(5):
    if x % 2 == 0:
        for y in range(5):
            if y % 2 == 1:
                res.append((x, y))
>>> res
[(0, 1), (0, 3), (2, 1), (2, 3), (4, 1), (4, 3)]

Вспомните, что если вам не вполне ясна работа сложного спискового включения, то вы всегда можете подобным образом вложить конструкции for и if спискового включения внутрь друг друга (последовательно смешая вправо каждую конструкцию) и получить эквивалентные операторы. Результат окажется длиннее, но возможно на первый взгляд будет яснее в плане намерений для некоторых читателей, особенно когда они лучше знакомы с базовыми операторами.

Эквивалентные версии со встроенными функциями map и filter последнего примера были бы непомерно сложными и глубоко вложенными, поэтому я даже не