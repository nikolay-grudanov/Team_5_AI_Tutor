---
source_image: page_443.png
page_number: 443
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 40.74
tokens: 7951
characters: 2986
timestamp: 2025-12-24T01:21:24.287162
finish_reason: stop
---

в Python 3.x; позже в главе 21 мы увидим методики измерения времени для определения относительной скорости альтернативных версий вроде показанных выше¹.

Примечание, касающееся нестыковки версий. В Python 2.x метод итерации называется X.next(), а не X.__next__() . Для совместимости встроенная функция next(X) также доступна в Python 3.x и 2.x (в Python 2.6 и последующих версиях); она вызывает X.__next__() в Python 3.x и X.next() в Python 2.x. Помимо имен методов во всех других отношения итерация в Python 2.x и 3.x работает одинаково. В версиях Python 2.6 и 2.7 для ручных итераций просто применяйте X.next() или next(X) вместо X.__next__() из Python 3.x; в версиях, предшествующих Python 2.6, используйте вызовы X.next() вместо next(X).

Ручная итерация: iter и next

Чтобы упростить написание кода ручной итерации, Python 3.x также предлагает встроенную функцию next, которая автоматически вызывает метод __next__ объекта. Согласно предыдущей врезке "На заметку!" ради совместимости этот вызов также поддерживается в Python 2.x. Для заданного объекта итератора X вызов next(X) является тем же самым, что и X.__next__() в Python 3.x (и X.next() в Python 2.x), но он значительно проще и более нейтрален к версиям. Например, с файлами можно применять любую из двух форм:

```python
>>> f = open('script2.py')
>>> f.__next__()    # Вызов итерационного метода напрямую
'import sys\n'
>>> f.__next__()
'print(sys.path)\n'

>>> f = open('script2.py')
>>> next(f)   # В Python 3.x встроенная функция next(f) вызывает f.__next__()
'import sys\n'
>>> next(f)   # next(f) => [Python 3.x: f.__next__()], [Python 2.x: f.next()]
'print(sys.path)\n'
```

Формально есть еще один аспект протокола итерации, который упоминался ранее. Когда цикл for начинается, он сначала получает итератор от итерируемого объекта, передавая его встроенной функции iter; возвращаемый функцией iter объект в свою очередь имеет обязательный метод next. Функция iter внутренне вызывает метод __iter__ во многом подобно next и __next__.

Полный протокол итерации

В качестве более формального определения на рис. 14.1 приведена упрощенная структура полного протокола итерации, который используется каждым итерационным инструментом в Python и поддерживается широким разнообразием типов объектов.

¹ Интрига отменяется: итератор файлового объекта по-прежнему кажется чуть быстрее, чем метод readlines, и минимум на 30% быстрее цикла while в Python 2.7 и 3.3, как показывают тесты, которые я прогонал для кода данной главы на файле с 1000 строк (в Python 2.7 while в два раза медленнее). Применимы обычные оговорки при оценочных испытаниях — это верно только для моих версий Python, моего компьютера и моего тестового файла, а Python 3.x усложняет такой анализ за счет переписывания библиотек ввода-вывода с целью поддержки текста Unicode и уменьшения зависимости от системы. В главе 21 раскрываются инструменты и методики, которые вы можете использовать для самостоятельного измерения времени указанных операторов цикла.