---
source_image: page_787.png
page_number: 787
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 30.77
tokens: 7732
characters: 2509
timestamp: 2025-12-24T01:31:44.620124
finish_reason: stop
---

Когда данный файл импортируется (или запускается как автономная программа), Python выполняет его операторы с начала до конца. Первый вызов func1 терпит неудачу, т.к. оператор func1 def пока еще не выполнялся. Вызов func2 внутри func1 работает при условии, что оператор def для func2 был достигнут ко времени вызова func1 — и это не происходит к моменту выполнения второго вызова func1. Последний вызов func1 в конце файла работает, потому что имена func1 и func2 оба присвоены.

Смешивание операторов def с кодом верхнего уровня не только затрудняет его чтение, но также делает его зависимым от порядка следования операторов. В качестве эмпирического правила запомните: если вам необходимо смешивать немедленно выполняющийся код с операторами def, тогда размещайте операторы def в начале файла, а следом за ними код верхнего уровня. В таком случае ваши функции гарантированно будут определены и присвоены ко времени, когда Python начнет выполнять код, где они применяются.

Оператор from копирует имена, но не ссылки на них

Несмотря на широкое применение, оператор from является источником разнообразных потенциальных затруднений в Python. Как вы уже знаете, оператор from в действительноности представляет собой присваивание именам в области видимости импортера — операцию копирования имени, а не создание псевдонима имени. Последствия такие же, как для всех присваиваний в Python, но они едва различимы, особенно учитывая, что код, который совместно использует объекты, находится в разных файлах. Например, пусть мы определили приведенный ниже модуль nested1.py:

# nested1.py
X = 99
def printer(): print(X)

Если мы импортируем два его имени с применением оператора from в другом модуле, nested2.py, то получим копии этих имен, а не ссылки на них. Изменение имени в импортере переустанавливает только привязку локальной версии данного имени, но не имя в nested1.py:

# nested2.py
from nested1 import X, printer    # Копировать имена
X = 88                            # Изменяет только X в этом модуле!
printer()                          # X в nested1 по-прежнему 99
% python nested2.py
99

Однако если мы используем оператор import для получения модуля целиком и затем присваиваем уточненному имени, тогда изменяется имя в nested1.py. Уточнение посредством атрибутов направляет Python на имя в объекте модуля, а не на имя в импортере nested3.py:

# nested3.py
import nested1    # Получить модуль как единое целое
nested1.X = 88    # Нормально: изменяет X в nested1
nested1.printer()
% python nested3.py
88