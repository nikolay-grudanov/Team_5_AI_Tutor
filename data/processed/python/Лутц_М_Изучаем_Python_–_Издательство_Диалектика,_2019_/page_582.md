---
source_image: page_582.png
page_number: 582
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 27.84
tokens: 7682
characters: 2329
timestamp: 2025-12-24T01:25:22.556190
finish_reason: stop
---

>>> x = echo        # Теперь x тоже ссылается на объект функции
>>> x('Indirect call!')    # Вызов объекта через имя x путем добавления ()
Indirect call!

Поскольку аргументы передаются по присваиванию объектов, функции легко передавать другим функциям в качестве аргументов. Вызываемая функция затем может вызвать переданную функцию, просто добавив аргументы в круглых скобках:

>>> def indirect(func, arg):
    func(arg)                # Вызов переданного объекта путем добавления ()
>>> indirect(echo, 'Argument call!')    # Передача функции другой функции
Argument call!

Объекты функций можно даже помещать внутрь структур данных, как если бы они были целыми числами или строками. Например, в следующем коде функция дважды встраивается в список кортежей, который исполняет роль таблицы действий. Из-за того, что составные типы Python подобного рода способны содержать объекты любых видов, здесь также нет какого-то особого случая:

>>> schedule = [ (echo, 'Spam!'), (echo, 'Ham!') ]
>>> for (func, arg) in schedule:
    func(arg)    # Вызов функций, встроенных в контейнер
Spam!
Ham!

В коде просто производится проход по списку schedule и вызов функции echo с одним аргументом на каждой итерации (обратите внимание в заголовке цикла for на распаковывающее присваивание кортежа, представленное в главе 13). Как демонстрировали примеры в главе 17, функции также можно создавать и возвращать для применения где-то в другом месте — замыкания, созданные в таком режиме, еще и предохраняют состояние из объемлющей области видимости:

>>> def make(label):    # Создание функции без ее вызова
    def echo(message):
        print(label + ':' + message)
    return echo
>>> F = make('Spam')    # label в объемлющей области видимости предохраняется
>>> F('Ham!')    # Вызов функции, возвращенной make
Spam:Ham!
>>> F('Eggs!')
Spam:Eggs!

Универсальная первоклассная объектная модель и отсутствие объявлений типов делают Python невероятно гибким языком программирования.

Интроспекция функций

Поскольку функции являются объектами, мы можем их обрабатывать посредством нормальных инструментов для объектов. На самом деле функции оказываются более гибкими, чем можно было ожидать. Скажем, после создания функцию можно вызывать как обычно:

>>> def func(a):
    b = 'spam'
    return b * a
>>> func(8)
'spamspamspamspamspamspamspamspam'