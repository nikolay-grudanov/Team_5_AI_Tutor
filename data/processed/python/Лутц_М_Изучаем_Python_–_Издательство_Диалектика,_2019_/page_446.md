---
source_image: page_446.png
page_number: 446
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 30.74
tokens: 7641
characters: 2043
timestamp: 2025-12-24T01:21:19.511478
finish_reason: stop
---

В следующем взаимодействии демонстрируется эквивалентность автоматической и ручной итераций²:

```python
>>> L = [1, 2, 3]
>>>
>>> for X in L:
...     print(X ** 2, end=' ')
# Автоматическая итерация
# Получает iter, вызывает __next__,
# перехватывает исключения

...
1 4 9

>>> I = iter(L)    # Ручная итерация: то, что обычно делают циклы for
>>> while True:
...     try:        # Оператор try перехватывает исключения
...         X = next(I)   # Или вызов I.__next__ в Python 3.x
...     except StopIteration:
...         break
...     print(X ** 2, end=' ')
...
1 4 9
```

Чтобы понять приведенный код, необходимо знать, что операторы try запускают действие и перехватывают исключения, которые возникают во время выполнения действия (мы кратко упоминали об исключениях в главе 11, но детально исследуем их в части VII). Я должен также отметить, что циклы for и другие контексты итерации иногда могут работать по-разному для классов, определяемых пользователем, многократно индексируя объект вместо следования протоколу итерации, но отдают предпочтение протоколу итерации, если он используется. Более подробные сведения будут даны в главе 30 после ознакомления с перегрузкой операций в классах.

Итерируемые объекты других встроенных типов

Вдобавок к файлам и физическим последовательностям наподобие списков другие типы также располагают полезными итераторами. Скажем, классический способ прохода по ключам в словаре предусматривает явное запрашивание его ключей:

```python
>>> D = {'a':1, 'b':2, 'c':3}
>>> for key in D.keys():
...     print(key, D[key])
...
a 1
b 2
c 3
```

Однако в последних версиях Python словари являются итерируемыми объектами с итератором, который автоматически возвращает по одному ключу за раз в контексте итерации:

```python
>>> I = iter(D)
>>> next(I)
'a'
>>> next(I)
'b'
```

² Говоря формально, цикл for вызывает внутренний эквивалент I.__next__, а не используемый здесь метод next(I), но между ними редко есть какие-то отличия. При ручной итерации, как правило, можно применять любую из двух схем вызова.