---
source_image: page_797.png
page_number: 797
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 30.38
tokens: 7816
characters: 2626
timestamp: 2025-12-24T01:32:08.217124
finish_reason: stop
---

Трассировка (самый последний вызов указан последним):
    Файл <stdin>, строка 1, в <модуль>
Ошибка деления на ноль: деление на ноль
>>>
>>> spam
Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
NameError: name 'spam' is not defined
Трассировка (самый последний вызов указан последним):
    Файл <stdin>, строка 1, в <модуль>
Ошибка в имени: имя spam не определено

6. Прерывание работы и циклы. Когда вы набираете следующий код:
L = [1, 2]
L.append(L)

то создаете циклическую структуру данных в Python. В выпусках Python, предшествующих 1.5.1, механизм вывода Python не был настолько интеллектуальным, чтобы обнаруживать циклы в объектах. В итоге выводился бы бесконечный поток [1, 2, [1, 2, [1, 2, [1, 2 и т.д. до тех пор, пока вы не нажмете клавиатурную комбинацию прекращения (которая формально инициирует исключение, выводящее стандартное сообщение). Начиная с версии Python 1.5.1, механизм вывода достаточно искусен, чтобы обнаруживать циклы и выводить [[...]], тем самым уведомляя вас о том, что в структуре объекта выявлен цикл, и избегая бесконечного вывода.

Причина возникновения цикла довольно тонкая и требует знания информации, которую вы начнете получать в части II, так что здесь дается что-то вроде предварительного обзора. Но формулируя кратко, присваивания в Python всегда генерируют ссылки на объекты, а не их копии. Вы можете думать об объектах как об участках памяти и о ссылках как об указателях, неявно отслеживающих эти участки. Когда вы запускаете первое из представленных выше присваиваний, имя L становится именованной ссылкой на двухэлементный списковый объект — указатель на участок памяти. Списки Python на самом деле являются массивами ссылок на объекты с методом append, который изменяет массив на месте, присоединяя в конце ссылку на еще другой объект. Здесь вызов append добавляет ссылку на начало L в конец L, что приводит к циклу, проиллюстрированному на рис. Г.1: указатель в конце списка, который указывает обратно на начало списка.

Как вы узнаете в главе 6, помимо вывода особым образом циклические объекты должны также специальным способом обрабатываться сборщиком мусора Python или же занимаемое ими пространство останется невозвратенным обратно, даже когда они больше не используются. Хоть это и редко встречается на практике, в некоторых программах, которые обходят произвольные объекты или структуры, возможно, вам придется обнаруживать такие циклы самостоятельно, отслеживая места, где вы были, чтобы избежать зациклования. Верите или нет, но циклические данные временами могут оказываться полезными, не взирая на связанный с ними особый случай вывода.