---
source_image: page_398.png
page_number: 398
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 27.42
tokens: 7562
characters: 2033
timestamp: 2025-12-24T01:19:48.194230
finish_reason: stop
---

>>> print(branch.get('spam', 'Bad choice'))
1.25
>>> print(branch.get('bacon', 'Bad choice'))
Bad choice

Того же результата можно добиться с применением проверки членства in в операторе if:

>>> choice = 'bacon'
>>> if choice in branch:
...     print(branch[choice])
... else:
...     print('Bad choice')
...
Bad choice

Наконец, оператор try предлагает обобщенный способ поддержки стандартных значений путем перехвата и обработки исключений, которые возникли бы в противном случае (дополнительные сведения об исключениях можно почерпнуть из обзора в главе 11 и полного описания в части VII):

>>> try:
...     print(branch[choice])
... except KeyError:
...     print('Bad choice')
...
Bad choice

Поддержка более сложных действий

Словари хороши для связывания значений с ключами, но как насчет более замысловатых действий, которые можно записывать в блоках операторов, ассоциированных с операторами if? В части IV вы узнаете, что словари могут также содержать функции для представления более сложных действий ветвлений и реализации обобщенных таблиц переходов. Такие функции выглядят как значения словаря, они могут быть записаны как имена функций или внутристрочные выражения lambda и могут вызываться добавлением круглых скобок для инициализации их действий. Ниже приводится абстрактный шаблон, но дождитесь возвращения к данной теме в главе 19 после ознакомления с определением функций:

def function(): ...
def default(): ...

branch = {'spam': lambda: ...,    # Таблица объектов вызываемых функций
          'ham': function,
          'eggs': lambda: ...}

branch.get(choice, default)()

Хотя множественное ветвление на основе словаря удобно в программах, которые имеют дело с динамическими данными, вероятно большинство программистов обнаружат, что написание оператора if является самым прямолинейным способом выполнения множественного ветвления. В качестве эмпирического правила запомните, что в случае сомнений оставайтесь на стороне простоты и читабельности; такой путь соответствует стилю программирования в духе Python.