---
source_image: page_283.png
page_number: 283
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 32.09
tokens: 7940
characters: 3143
timestamp: 2025-12-24T01:16:01.166063
finish_reason: stop
---

быстрый поиск ключей (т.е. хеширование), ключи должны быть переупорядочены в памяти. Именно потому операции, предполагающие фиксированный порядок слева направо (например, нарезание, конкатенация), к словарям не применяются; значения можно извлекать только по ключу, но не по позиции. Формально упорядочение является псевдослучайным — оно не по-настоящему случайное (вы в состоянии расшифровать его, взяв исходный код Python и потратив массу времени), но оно выбрано произвольно и может варьироваться в зависимости от выпуска и платформы и даже от интерактивного сеанса в версии Python 3.3.

Встроенная функция len работает также и со словарями; она возвращает количество элементов, хранящихся в словаре, или, что эквивалентно, длину его списка ключей. Операция членства в словаре in позволяет проверять существование ключей, а метод keys возвращает все ключи в словаре и может быть удобен при последовательной обработке словарей, но вы не должны полагаться на порядок следования ключей в списке. Тем не менее, поскольку результат keys может использоваться как нормальный список, его всегда можно отсортировать, если порядок важен (мы рассмотрим сортировку и словари позже):

    >>> len(D)                # Количество элементов в словаре
    3
    >>> 'ham' in D            # Проверка членства
    True
    >>> list(D.keys())        # Создание нового списка ключей в D
    ['eggs', 'spam', 'ham']

Обратите внимание на второе выражение в листинге. Как упоминалось ранее, проверка членства in, применяемая для строк и списков, также работает со словарями — она выясняет, хранится ли ключ в словаре. Формально она работает из-за того, что словари определяют итераторы ключей и когда только возможно используют быстрый прямой поиск. Другие типы предлагают итераторы, которые отражают их обычное применение; скажем, файлы имеют итераторы, выполняющие чтение строки за строкой. Мы обсудим итераторы в главах 14 и 20.

Также взгляните на синтаксис последнего выражения в листинге. В Python 3.X нам пришлось поместить keys внутрь вызова list по сходным причинам — keys в Python 3.X возвращает итерируемый объект вместо физического списка. Вызов list заставляет его выпустить все значения за раз, так что мы можем вывести их интерактивно, хотя в ряде других контекстов этот вызов не требуется. В Python 2.X метод keys создает и возвращает действительный список, поэтому для отображения результата вызов list не нужен; позже в главе мы еще вернемся к данной теме.

Изменение словарей на месте

Продолжим наш интерактивный сеанс. Словари, как и списки, являются изменяемыми, так что их можно модифицировать, увеличивать и уменьшать на месте, не создавая новые словари: для изменения или создания элемента необходимо просто выполнить присваивание по ключу. Оператор del также работает; он удаляет элемент с ключом, указанным в качестве индекса. Обратите внимание на вложение списка внутрь словаря в следующем примере (значение ключа 'ham'). Все типы данных коллекций в Python допускают произвольное вложение друг в друга:

    >>> D
    {'eggs': 3, 'spam': 2, 'ham': 1}
    >>> D['ham'] = ['grill', 'bake', 'fry'] # Изменение элемента (значение - список)