---
source_image: page_650.png
page_number: 650
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 43.69
tokens: 8088
characters: 2870
timestamp: 2025-12-24T01:27:45.014209
finish_reason: stop
---

В более широком плане, поскольку описанные функции реализованы в файле модуля, они становятся универсально полезными инструментами везде, где возникнет желание их импортировать. Модули и импортирование были представлены в главе 3 и более подробно рассматриваются в следующей части книги, а пока просто импортируйте модуль и вызывайте необходимые функции измерения времени. В несложных ситуациях модуль дает схожий с предшественником результат, но будет гораздо надежнее в более крупных контекстах. Вот пример вызовов функций модуля timer в Python 3.7:

```python
>>> import timer
>>> timer.total(1000, pow, 2, 1000)[0]    # Сравнимо с показанными ранее результатами timer0
0.0029486640000015996
>>> timer.total(1000, str.upper, 'spam')  # Возвращает (время, результат последнего вызова)
(0.0001786260000002926, 'SPAM')
>>> timer.bestof(1000, str.upper, 'spam')  # Почти 1/1555 часть суммарного времени
(1.8960000005563415e-06, 'SPAM')
>>> timer.bestof(1000, pow, 2, 1000000)[0]
0.017638512999994305
>>> timer.bestof(50, timer.total, 1000, str.upper, 'spam')
(0.00020517400000130692, (0.00017483400000628535, 'SPAM'))
>>> timer.bestoftotal(50, 1000, str.upper, 'spam')
(0.0002047939999982873, (0.000174453999998905486, 'SPAM'))
```

Последние два вызова измеряют лучшее суммарное время — наименьшее время из 50 прогонов, каждый из которых измеряет суммарное время выполнения 1000 вызовов str.upper (приблизительно соответствующее показаниям времени в начале листинга). Функция, используемая в последнем вызове, на самом деле является всего лишь удобством, которое отображается на предшествующую ей форму вызова; обе они возвращают кортеж с лучшим временем, умещающий в себе кортеж с суммарным временем и результатом последнего вызова.

Сравните последние два результата со следующей альтернативой, основанной на генераторе:

```python
>>> min(timer.total(1000, str.upper, 'spam') for i in range(50))
(0.000174453999998905486, 'SPAM')
```

Применение min к итерации по результатам total таким способом обеспечивает похожий эффект, потому что сравнениями, выполняемыми min, управляют показания времени в результирующих кортежах (они крайние слева в кортежах). Мы могли бы использовать этот прием в своем модуле (и поступим так в более поздних вариациях); он слегка варьируется, пренебрегая очень малыми издержками в коде функции bestof и не вкладывая результирующие кортежи, но для относительных сравнений вполне достаточно любого из двух результатов. В том виде, как есть, функция bestof должна выбрать высокое начальное значение наименьшего показания времени — хотя 136 лет представляется гораздо более длительным промежутком, чем будет выполняться большинство тестов!

```python
>>> (((2 ** 32) / 60) / 60) / 24) / 365   # Плюс еще несколько добавочных дней
136.19251953323186
>>> (((2 ** 32) // 60) // 60) // 24) // 365   # Округление в меньшую сторону: см. главу 5
```