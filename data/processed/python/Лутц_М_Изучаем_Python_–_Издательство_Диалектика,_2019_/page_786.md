---
source_image: page_786.png
page_number: 786
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 34.53
tokens: 7826
characters: 2781
timestamp: 2025-12-24T01:31:48.333637
finish_reason: stop
---

линейная природа пути поиска модулей означает, что файлы с одинаковыми именами могут конфликтовать.

Для исправления либо избегайте одинаково именованных файлов, либо используйте средство импортирования пакетов из главы 24. Если вам нужно получить доступ к обоим файлам с одинаковыми именами, тогда поместите свои файлы исходного кода в подкаталоги, так чтобы имена каталогов при импортировании пакетов делали ссылки на модули уникальными. До тех пор, пока имена каталогов включающих пакетов уникальны, вы будете иметь возможность доступа к любому или обоим одинаково именованным модулям.

Обратите внимание, что такая проблема может также возникать, если вы случайно выбираете для своего модуля имя, совпадающее с именем стандартного библиотечного модуля, который вам необходим. Дело в том, что ваш локальный модуль в домашнем каталоге программы (или в другом каталоге, находящемся раньше в пути поиска модулей) может скрыть и заменить библиотечный модуль.

Для исправления либо избегайте применять для модуля такое же имя, как у другого необходимого вам модуля, либо храните свои модули в каталоге пакета и используйте модель импортирования относительно пакетов Python 3.x, доступную как вариант в Python 2.x. В рамках такой модели нормальные операции импортирования пропускают поиск в каталоге пакета (так что вы получите версию из библиотеки), но специальные операторы импортирования с точками по-прежнему способны выбирать локальную версию модуля, если она нужна.

Порядок следования операторов в коде верхнего уровня имеет значение

Как вам уже известно, когда модуль импортируется в первый раз (или перезагружается), Python выполняет его операторы друг за другом от начала файла до его конца. В результате возникает несколько тонких последствий в отношении ссылок вперед, которые полезно подчеркнуть здесь.

• Код на верхнем уровне файла модуля (не вложенный в какую-нибудь функцию) выполняется, как только Python его достигает во время выполнения операции импортирования; по этой причине в нем нельзя ссылаться на имена, присваиваемые дальше в файле.
• Код внутри тела какой-то функции не запускается до тех пор, пока функция не будет вызвана; поскольку имена в функции не распознаются вплоть до ее действительного выполнения, внутри функции обычно можно ссылаться на имена, находящиеся где угодно в файле.

Как правило, ссылки вперед становятся проблемой только в коде модуля верхнего уровня, который выполняется немедленно; функции могут ссылаться на имена произвольным образом. В следующем файле иллюстрируются правила ссылок вперед:

func1()        # Ошибка: имя func1 пока еще не присвоено
def func1():
    print(func2())
func1()        # Ошибка: имя func2 пока еще не присвоено
def func2():
    return "Hello"
func1()        # Нормально: имена func1 и func2 присвоены