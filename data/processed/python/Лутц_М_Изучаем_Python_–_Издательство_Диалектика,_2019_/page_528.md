---
source_image: page_528.png
page_number: 528
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 29.71
tokens: 7747
characters: 2713
timestamp: 2025-12-24T01:23:47.029208
finish_reason: stop
---

def f2():
    def f3():
        print(x)      # Находится в локальной области видимости f1!
    f3()
f2()

>>> f1()
99

Python будет искать в локальных областях видимости всех объемлющих def, изнутри наружу, выше локальной области видимости ссылающейся функции и ниже глобальной области видимости модуля или встроенных областей видимости. Однако на практике код такого рода встречается еще реже. И мы снова говорим, что в Python плоский код лучше вложенного, и это остается в целом верным даже с добавлением замыканий вложенных областей видимости. За исключением ограниченных контекстов ваша жизнь (и жизнь коллег) обычно становится проще, если вы будете сводить к минимуму вложенные определения функций.

Оператор nonlocal в Python 3.x

В предыдущем разделе мы исследовали способ, которым вложенные функции могут ссылаться на переменные в области видимости объемлющей функции, даже если объемлющая функция уже произвела возврат. Оказывается, что в Python 3.x (хотя не в Python 2.x) мы также можем изменять такие переменные из объемлющей области видимости при условии их объявления в операторах nonlocal. Благодаря оператору nonlocal вложенные определения def могут иметь доступ по чтению и записи к именам в объемлющих функциях, что делает замыкания вложенных областей видимости более полезными, предоставляя изменяемую информацию о состоянии.

Оператор nonlocal по своей форме и роли похож на рассмотренный ранее оператор global. Подобно global оператор nonlocal заявляет, что будет изменяться имя из объемлющей области видимости. Тем не менее, в отличие от global оператор nonlocal применяется к имени в области видимости объемлющей функции, а не глобальной области видимости модуля за пределами всех def. Также в отличие от global при объявлении имен в nonlocal они уже должны существовать в области видимости объемлющей функции — имена могут существовать только в объемлющих функциях и не могут создаваться первым присваиванием во вложенном операторе def.

Другими словами оператор nonlocal делает возможным присваивание значений именам из областей видимости объемлющих функций и ограничивает поиск таких имен областями видимости объемлющих def. Совокупным эффектом является более прямая и надежная реализация изменяемой информации о состоянии в контекстах, для которых использовать классы с атрибутами, наследованием и множеством линий поведения нежелательно или нет необходимости.

Основы оператора nonlocal

В Python 3.x появился новый оператор nonlocal, имеющий смысл только внутри функции:

def func():
    nonlocal name1, name2, ...   # Здесь нормально
>>> nonlocal x
SyntaxError: nonlocal declaration not allowed at module level
Синтаксическая ошибка: объявление nonlocal не разрешено на уровне модуля