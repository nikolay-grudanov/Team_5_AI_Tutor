---
source_image: page_812.png
page_number: 812
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 40.24
tokens: 7990
characters: 2354
timestamp: 2025-12-24T01:32:48.083208
finish_reason: stop
---

for i in repslist:
    res = sqrt(i)
return res

def powCall():
    for i in repslist:
        res = pow(i, .5)
    return res

def powExpr():
    for i in repslist:
        res = i ** .5
    return res

print(sys.version)
for test in (mathMod, powCall, powExpr):
    elapsed, result = timer2.bestoftotal(test, _reps1=3, _reps=1000)
    print ('%s: %.5f => %s' % (test.__name__, elapsed, result))

Ниже представлены результаты выполнения в трех версиях Python. Выполнение в Python 3.7 и 2.7 оказывается быстрее, чем в версиях Python 3.0 и 2.6, рассматриваемых в предыдущем издании, из-за более производительного компьютера. Для каждой версии Python, где проводилось тестирование, модуль math работает быстрее выражения **, которое быстрее вызова pow; тем не менее, вы должны испытать свой код на своем компьютере с имеющейся версией Python. Кроме того, обратите внимание, что в этом тесте Python 3.7 медленнее, чем Python 2.7, а PyPy гораздо быстрее обеих версий CPython несмотря на наличие математики с плавающей точкой и итераций. Ситуация в более поздних версиях Python может отличаться, так что проверьте все самостоятельно:

c:\code> py -3 timesqrt.py
3.7.3 (v3.7.3:ef4ec6ed12, Mar 25 2019, 21:26:53) [MSC v.1916 32 bit (Intel)]
mathMod: 2.55214 => 99.99499987499375
powCall: 3.80201 => 99.99499987499375
powExpr: 3.05757 => 99.99499987499375

c:\code> py -2 timesqrt.py
2.7.3 (default, Apr 10 2012, 23:24:47) [MSC v.1500 64 bit (AMD64)]
mathMod: 1.04337 => 99.994999875
powCall: 2.57516 => 99.994999875
powExpr: 1.89560 => 99.994999875

c:\code> c:\pypy\pypy-1.9\pypy timesqrt.py
2.7.2 (341ele3821ff, Jun 07 2012, 15:43:00)
[PyPy 1.9.0 with MSC v.1500 32 bit]
mathMod: 0.07491 => 99.994999875
powCall: 0.85678 => 99.994999875
powExpr: 0.85453 => 99.994999875

Чтобы измерить относительные скорости выполнения включений словарей Python 3.x и 2.7 и эквивалентных циклов for в интерактивном сеансе, вы можете организовать взаимодействие вроде приведенного далее. Похоже, что в Python 3.7 скорости выполнения включений словарей и эквивалентных циклов for примерно одинаковы. Однако в отличие от списковых включений в настоящее время ручные циклы слегка быстрее включений словарей (хотя разница не особо значительная — в итоге при создании 50 словарей, каждый из которых состоит из 1 000 000 элементов, мы экономим около двух секунд). Как всегда, вместо