---
source_image: page_592.png
page_number: 592
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 32.03
tokens: 7757
characters: 2763
timestamp: 2025-12-24T01:25:45.201384
finish_reason: stop
---

Что потребует внимания: обратные вызовы lambda

Еще одно очень распространенное приложение lambda связано с определением внутристрочных функций обратного вызова при работе с модулем tkinter, предназначенным для создания графических пользовательских интерфейсов в Python (в Python 2.x он называется Tkinter). Скажем, в следующем коде создается кнопка, которая по щелчку выводит на консоль сообщение, исходя из предположения, что модуль tkinter доступен на компьютере (по умолчанию это так в средах Windows, Mac, Linux и других операционных систем):

import sys
from tkinter import Button, mainloop  # Tkinter в Python 2.x
x = Button(
    text='Press me',
    command=(lambda:sys.stdout.write('Spam\n'))))  # Python 3.x: print()
x.pack()
mainloop()  # В консольном режиме может быть необязательным

В коде регистрируется обработчик обратного вызова путем передачи функции, сгенерированной с помощью lambda, в ключевом аргументе command. Преимущество lambda перед def в данной ситуации связано с тем, что код, который обрабатывает щелчок на кнопке, находится прямо здесь в вызове, создающем кнопку.

В действительности lambda откладывает выполнение обработчика до момента возникновения события: вызов write происходит при щелчке на кнопке, а не когда кнопка создана, и фактически "знает" строку, которую он должен записать при появлении события.

Поскольку правила поиска в областях видимости вложенных функций применимы также к выражениям lambda, начиная с версии Python 2.2, их легче использовать в качестве обработчиков обратных вызовов — они автоматически видят имена из функций, в которых написаны, и в большинстве случаев уже не требуют передачи стандартных значений. Это особенно удобно для доступа к специальному аргументу экземпляра self, который является локальной переменной в функциях методов объемлющего класса (классы рассматриваются в части VI):

class MyGui:
    def makewidgets(self):
        Button(command=(lambda: self.onPress("spam")))
    def onPress(self, message):
        ...использование message...

В ранних версиях Python даже self приходилось передавать в lambda посредством стандартных значений. Как будет показано позже, объекты классов с методами __call__ и привязки также часто исполняют роли обратных вызовов (см. главы 30 и 31).

Инструменты функционального программирования

Согласно большинству определений современный Python сочетает в себе поддержку множества парадигм программирования: процедурной (посредством своих базовых операторов), объектно-ориентированной (с помощью классов) и функциональной. Для последней парадигмы Python включает набор встроенных функций, используемых при функциональном программировании — инструментов, которые применяют функции к последовательностям и другим итерируемым объектам. В состав набора