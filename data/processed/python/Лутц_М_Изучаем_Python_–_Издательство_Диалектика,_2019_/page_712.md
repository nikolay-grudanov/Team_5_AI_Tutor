---
source_image: page_712.png
page_number: 712
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 32.18
tokens: 7850
characters: 2807
timestamp: 2025-12-24T01:29:28.339995
finish_reason: stop
---

После того, как модуль загружен, его область видимости становится пространством имен атрибутов в объекте модуля, который мы получаем из оператора import. Затем мы можем получать доступ к атрибутам в данном пространстве имен, уточняя их именем включающего модуля:

```python
>>> module2.sys
<module 'sys' (built-in)>
>>> module2.name
42
>>> module2.func
<function func at 0x000000000222E7B8>
>>> module2.klass
<class 'module2.klass'>
```

Здесь sys, name, func и klass были присвоены значения во время выполнения операторов модуля, так что после импортирования все они являются атрибутами. Классы будут обсуждаться в части VI, но обратите внимание на атрибут sys — операторы import в действительно присваивают именам объекты модулей, и любое присваивание имени на верхнем уровне файла генерирует атрибут модуля.

**Словари пространств имен: __dict__**

На самом деле внутренне пространства имен модулей хранятся как словарные объекты. Они представляются собой нормальные словари со всеми обычными методами. Когда необходимо (скажем, при написании инструментов, которые выводят содержимое модулей обобщенным образом, что будет делаться в главе 25), мы можем получать доступ к словарю пространства имен модуля через атрибут __dict__ объекта модуля. Продолжим пример из предыдущего раздела (в Python 3.x не забывайте добавить вызов list — атрибут __dict__ является объектом представления и его содержимое может отличаться за пределами использованной здесь версии Python 3.7):

```python
>>> list(module2.__dict__.keys())
['__name__', '__doc__', '__package__', '__loader__', '__spec__', '__file__', '__cached__', '__builtins__', 'sys', 'name', 'func', 'klass']
```

Имена, присвоенные в файле модуля, внутренне становятся ключами словаря, так что некоторые имена отражают присваивания верхнего уровня в файле. Однако Python также автоматически добавляет в пространство имен модуля несколько дополнительных имен; например, __file__ дает имя файла, из которого загружался модуль, а __name__ — его имя, как оно известно импортерам (без расширения .py и пути к каталогу). Чтобы посмотреть только имена, присвоенные в коде, отфильтруем имена с двумя подчеркиваниями, как поступали ранее при описании функции dir в главе 15 и встроенной области видимости в главе 17:

```python
>>> list(name for name in module2.__dict__.keys() if not name.startswith('__'))
['sys', 'name', 'func', 'klass']
>>> list(name for name in module2.__dict__ if not name.startswith('__'))
['sys', 'name', 'func', 'klass']
```

На этот раз мы фильтруем с помощью генератора, а не спискового включения, и можем опустить .keys(), т.к. словари генерируют свои ключи автоматически, хотя и неявно; эффект будет таким же. Аналогичные словари __dict__ мы еще встретим при рассмотрении в части VI объектов, основанных на классах. В обоих случаях извле-