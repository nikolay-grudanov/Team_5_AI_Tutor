---
source_image: page_406.png
page_number: 406
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 34.29
tokens: 7881
characters: 3039
timestamp: 2025-12-24T01:20:09.794842
finish_reason: stop
---

При проверке or объекты операндов оцениваются слева направо, и возвращается первый истинный объект. Кроме того, Python останавливается на первом найденном истинном объекте. Обычно это называют укороченной оценкой, т.к. определение результата остатка выражения прекращается, как только результат становится известным:

```python
>>> 2 or 3, 3 or 2    # Возвращает левый операнд, если он истинный
(2, 3)                # В противном случае возвращает правый операнд
# (истинный или ложный)
>>> [] or 3            # В противном случае возвращает правый операнд
3
>>> [] or {}           # (истинный или ложный)
{}
```

В первой строке предыдущего примера оба операнда (2 и 3) истинны (т.к. они не-нулевые), поэтому Python останавливается и возвращает левый операнд — он устанавливает результат, потому что истина в операции or с чем угодно всегда дает истину. В остальных двух проверках левый операнд является ложным (пустой объект), так что Python просто продолжает оценку и возвращает правый операнд, который при проверке может дать либо истинное, либо ложное значение.

Оценка операции and в Python также прекращается, как только результат становится известным; однако в данном случае Python оценивает операнды слева направо и останавливается, если левый операнд оказывается ложным объектом, т.к. он определяет результат — ложь в операции and с чем угодно всегда дает ложь:

```python
>>> 2 and 3, 3 and 2    # Возвращает левый операнд, если он ложный
(3, 2)                 # В противном случае возвращает правый операнд
# (истинный или ложный)
>>> [] and {}           # В противном случае возвращает правый операнд
[]
>>> 3 and []
[]
```

Здесь в первой строке оба операнда истинны, поэтому Python оценивает обе части операции и возвращает правый операнд. Во второй проверке левый операнд ложный ([]), так что Python останавливает оценку и возвращает его в качестве результата. В последней проверке левая сторона операции является истинной (3), а потому Python продолжает оценку и возвращает правый операнд, который оказывается ложным ([]).

Конечный результат всех проверок такой же, как в C и большинстве других языков — вы получаете значение, которое является логически истинным или ложным при проверке в if либо while согласно нормальным определениям or и and. Тем не менее, булевские операции в Python возвращают объект левого или правого операнда, а не простой целочисленный признак.

Подобное поведение and и or поначалу может показаться экзотическим, но во врезке "Что потребует внимания: булевские операции" далее в главе приводятся примеры его применения при программировании на Python. В следующем разделе показан распространенный способ использования такого поведения в своих интересах и его более наглядная замена в последних версиях Python.

Тернарное выражение if/else

Булевские операции, описанные в предыдущем разделе, часто применяются для написания выражений, выполняемых точно так же, как операторы if. Взгляните на показанный ниже оператор, который устанавливает A либо в Y, либо в Z на основе значения истинности X: