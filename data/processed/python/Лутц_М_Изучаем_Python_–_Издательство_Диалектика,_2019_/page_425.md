---
source_image: page_425.png
page_number: 425
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 34.43
tokens: 7813
characters: 2877
timestamp: 2025-12-24T01:20:46.070306
finish_reason: stop
---

file = open('test.txt')
while True:
    line = file.readline()        # Чтение строка за строкой
    if not line: break
    print(line.rstrip())           # Строка уже содержит \n

file = open('test.txt', 'rb')
while True:
    chunk = file.read(10)         # Чтение байтовых порций: до 10 байтов
    if not chunk: break
    print(chunk)

Байтовые данные обычно читаются по блокам. Однако чтобы читать текстовые файлы строка за строкой, легче написать цикл for, который еще и будет быстрее выполняться:

for line in open('test.txt').readlines():
    print(line.rstrip())

for line in open('test.txt'):
    print(line.rstrip())           # Использование итераторов:
    # лучше для текстового ввода

Обе версии работают в Python 2.x и 3.x. В первой используется файловый метод readlines для загрузки всего содержимого файла в список строк, а вторая версия полагается на файловые итераторы для автоматического чтения по одной строке на каждой итерации цикла.

Последний пример также в целом будет наилучшим вариантом для текстовых файлов — помимо простоты он способен работать с произвольно крупными файлами, потому что не загружает в память сразу все содержимое файла. Кроме того, версия с итератором может оказаться более быстрой, хотя производительность ввода-вывода варьируется в зависимости от линейки и выпуска Python.

Тем не менее, вызовы файлового метода readlines по-прежнему могут быть полезны, скажем, для изменения на противоположный порядка следования строк из файла при условии, что его содержимое способно уместиться в памяти. Встроенная функция reversed принимает последовательность, но не произвольный итерируемый объект, который генерирует значения; другими словами, список подойдет, но файловый объект — нет:

for line in reversed(open('test.txt').readlines()): ...

В некотором коде Python 2.x вы можете заметить, что имя open заменено именем file и для достижения такого же результата, как с автоматическим итератором строк файла, применяется более старый метод xreadlines файлового объекта (он похож на readlines, но не загружает в память сразу весь файл). В версии Python 3.x как file, так и xreadlines были удалены, поскольку они избыточны. В целом при написании нового кода Python 2.x вы должны избегать их использования (в недавних выпусках Python 2.x применяйте файловые итераторы и вызов open), но они могут встречаться в более старом коде и ресурсах.

Дополнительные сведения о задействованных здесь вызовах ищите в руководство по библиотеке, а о файловых итераторах строк — в главе 14. Кроме того, почитайте врезку "Что потребует внимания: команды оболочки и другое" далее в главе; там те же самые файловые инструменты применяются к запускающему модулю os.popen для чтения вывода программ. Более подробно о чтении файлов также рассказывается в главе 37; вы увидите, что в Python 3.x текстовые и двоичные файлы имеют несколько отличающуюся семантику.