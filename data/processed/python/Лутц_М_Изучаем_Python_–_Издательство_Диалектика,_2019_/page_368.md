---
source_image: page_368.png
page_number: 368
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 34.72
tokens: 7864
characters: 2761
timestamp: 2025-12-24T01:18:58.395903
finish_reason: stop
---

Здесь инициализируются три имени целочисленными кодами 0, 1 и 2 соответственно (эквивалент Python перечислимых типов данных, которые вы могли встречать в других языках). Чтобы понять такое присваивание, вам необходимо знать, что встроенная функция range генерирует список следующих друг за другом целых чисел (для отображения сразу всех их значений в Python 3.x потребуется вызов list):

```python
>>> list(range(3))    # В Python 3.x требуется list()
[0, 1, 2]
```

Вызов list кратко затрагивался в главе 4; из-за частого использования функции range в циклах for мы подробно обсудим ее в главе 13.

Другим местом, где вы можете увидеть присваивание кортежей в работе, будет разбиение последовательности на ее голову и остальное в циклах, как иллюстрируется ниже:

```python
>>> L = [1, 2, 3, 4]
>>> while L:
...     front, L = L[0], L[1:]    # В следующем разделе описана
...                                 # альтернатива * из Python 3.x
...     print(front, L)
...
1 [2, 3, 4]
2 [3, 4]
3 [4]
4 []
```

Присваивание кортежей в цикле взамен можно было бы записать следующим образом, но зачастую удобнее объединить их вместе:

```python
... front = L[0]
... L = L[1:]
```

Обратите внимание, что в этом коде список применяется как своего рода структура данных типа стека, которую нередко можно реализовать с помощью методов append и pop списковых объектов. Оператор front = L.pop(0) имел бы почти тот же эффект, что и оператор присваивания кортежа, но он оказался бы изменением на месте. В главе 13 вы узнаете гораздо больше о циклах while и других (часто лучших) способах прохода по последовательности посредством циклов for.

Расширенная распаковка последовательностей в Python 3.x

В предыдущем разделе демонстрировалось, как использовать ручное нарезание, чтобы сделать присваивания последовательностей более универсальными. С целью облегчения этого в Python 3.x (но не в Python 2.x) присваивание последовательности было обобщено. Если кратко, то в цели присваивания можно применять одиночное помеченное звездочкой имя, *X, для указания более универсального сопоставления с последовательностью — имени со звездочкой присваивается список, в котором собраны все элементы, не присвоенные остальным именам. Прием особенно удобен в распространенных кодовых шаблонах, таких как разбиение последовательности на ее "голову" и "остальное", как в последнем примере предыдущего раздела.

Расширенная распаковка в действии

Давайте рассмотрим пример. Как мы уже видели, присваивания последовательностей по обыкновению требуют точно столько имен в цели слева, сколько есть элементов в объекте справа. Если длины не совпадают, тогда мы получим ошибку и в Python 2.x, и в Python 3.x (при условии, что мы не произведем вручную срез, как было показано в предыдущем разделе):