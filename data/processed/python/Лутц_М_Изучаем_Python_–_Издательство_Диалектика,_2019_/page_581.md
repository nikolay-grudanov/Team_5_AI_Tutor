---
source_image: page_581.png
page_number: 581
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 35.75
tokens: 7842
characters: 2955
timestamp: 2025-12-24T01:25:30.488540
finish_reason: stop
---

Во втором и третьем примере будут также обнаруживаться уже посещенные состояния, чтобы избежать циклов и повторений. Хотя для линейных итераций в целом следует отдавать предпочтение обычным циклам по причине их простоты и эффективности, мы обнаружим, что рекурсия будет неотъемлемой в сценариях, подобных упомянутым выше примерам.

Более того, иногда необходимо знать о возможности непреднамеренной рекурсии в своих программах. Как будет показано позже в книге, некоторые методы перегрузки операций в классах, такие как __setattr__ и __getattribute__ и даже __repr__, обладают потенциалом рекурсивного зациклования при некорректном применении. Рекурсия — мощный инструмент, но она проявляет себя наилучшим образом, когда ее понимают и ожидают!

Объекты функций: атрибуты и аннотации

Функции Python гораздо гибче, чем может казаться. Как выяснилось в этой части книги, функции в Python представляют собой намного больше, чем спецификации по генерации кода для компилятора — функции Python являются полноценными объектами, хранящимися в собственных участках памяти. Будучи таковыми они могут свободно передаваться внутри программы и вызываться косвенно. Они также поддерживают операции, которые вообще не имеют отношения к вызовам, а связаны с хранилищем атрибутов и аннотаций.

Косвенные вызовы функций: "первоклассные" объекты

Из-за того, что функции Python представляют собой объекты, вы можете писать программы, которые обрабатывают их обобщенным образом. Объекты функций можно присваивать другим именам, передавать другим функциям, встраивать в структуры данных, возвращать из одной функции в другой и т.п., как если бы они были простыми числами или строками. Кроме того, объекты функций поддерживают специальную операцию: их можно вызывать, перечисляя аргументы в круглых скобках после выражения функции. И все-таки функции относятся к той же самой общей категории, что и остальные объекты.

Обычно это называют первоклассной объектной моделью, в Python она вездесуща и является необходимой частью функционального программирования. Мы исследуем такой режим программирования более полно в текущей и следующей главах; из-за того, что его основная идея зиждется на понятии применения функций, функции должны трактоваться как данные.

Мы уже видели некоторые из обобщенных сценариев использования для функций в более ранних примерах, но краткий обзор поможет акцентировать внимание на объектной модели. Скажем, с указываемым в операторе def именем не связано ничего необычного: оно представляет собой всего лишь переменную, присваиваемую в текущей области видимости, как если бы она находилась слева от знака =. После выполнения оператора def имя функции становится просто ссылкой на объект — вы можете свободно присваивать данный объект другим именам и вызывать его через любую ссылку:

>>> def echo(message):    # Имени echo присваивается объект функции
    print(message)
>>> echo('Direct call')   # Вызов объекта через первоначальное имя
Direct call