---
source_image: page_313.png
page_number: 313
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 35.52
tokens: 7911
characters: 3150
timestamp: 2025-12-24T01:17:07.923594
finish_reason: stop
---

предоставлять уже сформатированные строки. По этой причине при работе с файлами будут полезными инструменты, предназначенные для преобразования объектов в и из строк (например, int, float, str и выражение и метод форматирования строк).

В состав Python также входят стандартные библиотечные инструменты для поддержки обобщенного хранилища объектов (модуль pickle), для работы с упакованными двоичными данными в файлах (модуль struct) и для обработки специальных типов содержимого, таких как текст JSON, XML и CSV. Они будут демонстрироваться позже в главе и книге, а полное их описание доступно в руководствах по Python.

Файлы буферизируются и поддерживают позиционирование

По умолчанию выходные файлы всегда буферизируются, а это значит, что записываемый текст может не сразу быть передан из памяти на диск — сбрасывание буферизированных данных на диск инициирует закрытие файла или вызов метода flush. Избежать буферизации позволяют дополнительные аргументы функции open, но тогда может пострадать производительность. Файлы Python также поддерживают произвольный доступ на основе байтовых смещений — их метод seek дает возможность переходить в специфические позиции для чтения и записи.

Вызов метода close часто необязателен:
автоматическое закрытие при сборке мусора

Вызов метода close прекращает связь с внешним файлом, освобождает системные ресурсы и сбрасывает буферизированный вывод на диск, если он все еще находится в памяти. Как обсуждалось в главе 6, область памяти объекта в Python автоматически освобождается, как только на объект перестают ссылаться где-нибудь в программе. Когда освобождается память, занимаемая файловыми объектами, Python также автоматически закрывает файлы, если они по-прежнему открыты (это также происходит при завершении работы программы).

Таким образом, в стандартном Python закрывать файлы вручную не всегда обязательно, особенно файлы в простых сценариях с коротким временем выполнения и временные файлы, используемые в одной строке кода или выражении.

С другой стороны, включение вызовов close ничем не вредит и может стать хорошей привычкой, особенно в длительно функционирующих системах. Строго говоря, средство автоматического закрытия при сборке мусора не является частью определения языка. Со временем оно может измениться, происходить не тогда, когда вы ожидаете его в интерактивной подсказке, и не работать одинаково в других реализациях Python, в которых сборщики мусора могут освобождать память и закрывать файлы не в те же самые моменты, что и стандартный CPython. На самом деле, когда множество файлов открывается внутри циклов, реализации Python, отличающиеся от CPython, могут требовать вызова close для немедленного освобождения системных ресурсов, прежде чем сборщик мусора займется освобождением памяти, занимаемой объектами. Кроме того, вызовы close иногда могут требоваться для сбрасывания буферизированного вывода файловых объектов, память которых пока еще не освобождена. Альтернативный способ гарантирования автоматического закрытия файловписан позже в текущем разделе при обсуждении диспетчера контекста файлового объекта, применяемого с оператором with/as в Python 2.6, 2.7 и 3.x.