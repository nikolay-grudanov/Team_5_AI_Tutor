---
source_image: page_153.png
page_number: 153
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 33.20
tokens: 7843
characters: 2800
timestamp: 2025-12-24T01:11:42.302887
finish_reason: stop
---

>>> x = 4
>>> while x > 0:
    print('spam!' * x)
    x -= 1
spam!spam!spam!spam!
spam!spam!spam!
spam!spam!
spam!

Мы подробно обсудим операторы циклов, синтаксис и инструменты позже в книге. Но сначала мне нужно признаться, что в настоящем разделе я не был настолько откровенен, насколько мог бы быть. По правде говоря, цикл for и все его категории, выполняющие проход по объектам слева направо, являются не просто операциями над последовательностями, а операциями над итерируемыми объектами, как объясняется в следующем разделе.

Итерация и оптимизация

Если цикл for в предыдущем разделе выглядит подобно выражению спискового включения, введенному ранее, то так и должно быть: на самом деле они оба представляют собой универсальные инструменты для итерации. Фактически они оба будут работать на любом итерируемом объекте, который следует протоколу итерации — всепроникающей идеи в Python, лежащей в основе всех инструментов для итерации.

Говоря кратко, объект считается итерируемым, если он является либо физически сохраненной последовательностью в памяти, либо объектом, который генерирует под одному элементу за раз в контексте итерационной операции — своего рода "виртуальной" последовательностью. Более формально оба типа объектов считаются итерируемыми, поскольку поддерживают протокол итерации — они отвечают на вызов iter значением, которое продвигается вперед в ответ на вызовы next, и генерируют исключение, когда завершают выпуск значений.

К таким объектам относится выражение спискового включения для генератора, которое обсуждалось ранее: его значения вообще не хранятся в памяти, а предоставляются по запросу, обычно выполняемому инструментами итерации. Объекты файлов Python аналогичным образом производят итерации по строкам, когда используются инструментом итерации: содержимое файла — не список, оно извлекается по требованию. Оба являются итерируемыми объектами в Python, относясь к категории, которая в версии Python 3.x была расширена, чтобы включать основные инструменты вроде range и map. Откладывая получение результатов по мере необходимости, эти инструменты могут экономить память и минимизировать задержки.

Мы рассмотрим протокол итерации более подробно далее в книге. А пока запомните, что любой инструмент Python, который проходит по объекту слева направо, действует согласно протоколу итерации. Именно потому вызов sorted, применяемый в предыдущем разделе, работал напрямую на словаре — мы не обязаны вызывать метод keys для получения последовательности, т.к. словари являются итерируемыми объектами с методом next, который возвращает последовательные ключи.

Помочь пониманию способен тот факт, что любое выражение спискового включения, например вычисляющее квадраты для списка чисел:

>>> squares = [x ** 2 for x in [1, 2, 3, 4, 5]]
>>> squares
[1, 4, 9, 16, 25]