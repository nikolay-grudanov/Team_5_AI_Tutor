---
source_image: page_309.png
page_number: 309
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 32.28
tokens: 7936
characters: 3008
timestamp: 2025-12-24T01:16:56.484495
finish_reason: stop
---

На самом деле при необходимости мы можем преобразовывать части словаря в кортеж:

>>> tuple(bob.values())      # Преобразование значений в кортеж
([['dev', 'mgr']], 'Bob', 40.5)
>>> list(bob.items())         # Преобразование элементов в список кортежей
[('jobs', ['dev', 'mgr']), ('name', 'Bob'), ('age', 40.5)]

Но проделав небольшую дополнительную работу, мы можем реализовать объекты, которые предлагают доступ к полям записи и по позиции, и по имени. Например, в стандартном библиотечном модуле collections, упомянутом в главе 8, имеется класс namedtuple. Он реализует тип расширения, добавляя к кортежам логику, которая делает возможным доступ к компонентам по позиции и по имени атрибута, и при желании может быть преобразован в форму словарного вида для доступа по ключу. Имена атрибутов происходят из классов и не являются в точности словарными ключами, но они в аналогичной степени осмысленны:

>>> from collections import namedtuple    # Импортирование типа расширения
>>> Rec = namedtuple('Rec', ['name', 'age', 'jobs'])   # Создание
# производного класса
>>> bob = Rec('Bob', age=40.5, jobs=['dev', 'mgr'])   # Запись в виде
# именованного кортежа
>>> bob
Rec(name='Bob', age=40.5, jobs=['dev', 'mgr'])
>>> bob[0], bob[2]                        # Доступ по позиции
('Bob', ['dev', 'mgr'])
>>> bob.name, bob.jobs                   # Доступ по атрибуту
('Bob', ['dev', 'mgr'])

В случае необходимости именованный кортеж можно преобразовать в словарь, чтобы обеспечить поведение, основанное на ключах:

>>> o = bob._asdict()                    # Форма, похожая на словарь
>>> o['name'], o['jobs']                 # Доступ также и по ключу
('Bob', ['dev', 'mgr'])
>>> o
OrderedDict([('name', 'Bob'), ('age', 40.5), ('jobs', ['dev', 'mgr'])])

Как видите, именованные кортежи представляют собой гибрид кортежа/класса/словаря. Они также демонстрируют классический компромисс. В обмен на дополнительную практичность они требуют написания добавочного кода (две строки в начале предыдущего примера, которые импортируют тип и создают класс), а также влекут за собой определенные затраты в плане производительности. (Короче говоря, именованные кортежи строят новые классы, расширяющие тип кортежей, за счет вставки для каждого именованного поля метода доступа property, который отображает имя на его позицию. Прием опирается на более сложные темы, исследуемые в части VIII, и использует форматированные строки кода вместо инструментов аннотирования классов, таких как декораторы и метаклассы.) И все же они являются хорошим примером разновидности специальных типов данных, которые мы можем создавать на основе встроенных типов вроде кортежей, когда желательно иметь дополнительную полезность.

Именованные кортежи доступны в Python 3.x, 2.7, 2.6 (где _asdict возвращает подлинный словарь) и возможно более ранних версиях, хотя они полагаются на относительно новые средства в стандартах Python. Они также представляют собой расширения, а не основные типы (находятся в стандартной библиотеке и относятся к той