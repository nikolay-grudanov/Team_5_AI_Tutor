---
source_image: page_360.png
page_number: 360
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 29.07
tokens: 7674
characters: 2345
timestamp: 2025-12-24T01:18:35.515024
finish_reason: stop
---

Здесь на месте float также работал бы вызов функции eval языка Python, который мы применяли в главах 5 и 9 для преобразования данных в строках и файлах. Тогда появилась бы возможность вводить произвольные выражения (2 ** 100 было бы допустимым, хотя и необычным вводом, особенно с учетом того, что программа обрабатывает возраст!). Это мощная концепция, которая подвержена тем же самым проблемам с безопасностью, о которых шла речь в предшествующих главах. Если вы не можете доверять источнику строки с кодом, тогда используйте более ограничивающие инструменты преобразования наподобие int и float.

Функция exec языка Python, применяемая в главе 3 для выполнения кода из файла, похожа на eval (но предполагает, что строка является оператором, а не выражением, и не возвращает результат), а вызов compile предварительно компилирует часто используемые строки кода в объекты байт-кода ради достижения высокой скорости. Дополнительные сведения можно получить, запустив help для любого из указанных средств; как упоминалось ранее, exec представляет собой оператор в Python 2.x, но функцию в Python 3.x, поэтому в Python 2.x ищите ее описание в руководстве. Мы также будем применять exec в главе 25 для импортирования модулей, используя строку с именем (пример более динамических ролей данного инструмента).

Вложение кода на три уровня в глубину

Давайте рассмотрим последнее изменение кода. При необходимости вложение можно продолжить; скажем, мы могли бы расширить приведенный ранее сценарий, обрабатывающий только целые числа, для перехода к одной из набора альтернатив на основе относительной величины допустимого ввода:

while True:
    reply = input('Enter text:')
    if reply == 'stop':
        break
    elif not reply.isdigit():
        print('Bad!' * 8)
    else:
        num = int(reply)
        if num < 20:
            print('low')
        else:
            print(num ** 2)
print('Bye')

В последней версии сценария добавлен оператор if, вложенный в часть else другого оператора if, который в свою очередь вложен в цикл while. Когда код является условным или повторяется как здесь, мы просто смещаем его дальше вправо. Совокупный эффект похож на предшествующие версии, но теперь для чисел, меньших 20, будет выводиться слово low:

Enter text:19
low
Enter text:20
400
Enter text:spam
Bad!Bad!Bad!Bad!Bad!Bad!Bad!Bad!
Enter text:stop
Bye