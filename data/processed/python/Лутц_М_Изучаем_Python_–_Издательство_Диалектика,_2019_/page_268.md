---
source_image: page_268.png
page_number: 268
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 32.77
tokens: 7928
characters: 3112
timestamp: 2025-12-24T01:15:33.499206
finish_reason: stop
---

Проверьте свои знания: ответы

1. Нет, потому что методы всегда специфичны для типа, т.е. работают только с единственным типом данных. Однако выражения вроде X+Y и встроенные функции наподобие len(X) являются универсальными и способны работать на множестве типов. В этом случае выражение членства in дает результат, аналогичный строковому методу find, но может применяться для поиска и в строках, и в списках. В Python 3.x была предпринята попытка сгруппировать методы по категориям (скажем, изменяемые типы последовательностей list и bytearray имеют похожие наборы методов), но методы по-прежнему более специфичны к типам, чем другие наборы операций.

2. Да. В отличие от методов выражения универсальны и применимы ко многим типам. В данном случае выражение среза на самом деле является операцией над последовательностями — оно работает на объектах последовательностей любого типа, включая строки, списки и кортежи. Единственное отличие связано с тем, что при нарезании списка обратно получается новый список.

3. Встроенная функция ord(S) преобразует односимвольную строку в целочисленный код символа; chr(I) преобразует целочисленный код в строку. Тем не менее, имейте в виду, что эти целые числа являются лишь кодами ASCII для текста, чьи символы извлекаются только из таблицы символов ASCII. В модели Unicode строки текста фактически представляют собой последовательности кодовых точек Unicode, идентифицируемые целыми числами, которые могут выходить за пределы 7-битного диапазона чисел, зарезервированного кодировкой ASCII (дополнительные сведения о строках Unicode ищите в главах 4 и 37).

4. Строки не могут быть модифицированы; они неизменяемы. Однако похожего результата можно добиться путем создания новой строки — за счет конкатенации, нарезания, выполнения выражений форматирования либо использования вызова метода, подобного replace, — и затем присваивания результата исходной переменной.

5. Можно получить срез строки с применением S[2:4] или разбить строку по запятой и индексировать результат, используя S.split(',',)[1]. Чтобы удостовериться в этом, опробуйте приемы в интерактивной подсказке.

6. Шесть. Строка "a\nb\x1f\000d" содержит символ a, символ новой строки (\n), литеральное значение 31 (шестнадцатеричная управляющая последовательность \x1f), литеральное значение 0 (восьмеричная управляющая последовательность \000) и символ d. Передайте строку встроенной функции len, чтобы проверить это, и выведите результаты функции ord для каждого ее символа, чтобы увидеть действительные значения кодовых точек (идентифицирующих чисел). Управляющие последовательности были описаны в табл. 7.2.

7. В наши дни вы никогда не должны применять модуль string вместо вызова методов строковых объектов — он объявлен устаревшим и в Python 3.x его вызовы полностью устранены. Единственной веской причиной использования модуля string на сегодняшний день являются остальные его инструменты, такие как заранее определенные константы. Вы также можете заметить, что модуль string встречается в очень старом, покрывшемся толстым слоем пыли коде Python (и в книгах из туманного прошлого вроде 1990-х годов).