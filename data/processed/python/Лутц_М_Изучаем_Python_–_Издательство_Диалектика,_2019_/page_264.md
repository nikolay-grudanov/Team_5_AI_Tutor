---
source_image: page_264.png
page_number: 264
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 37.58
tokens: 7976
characters: 3265
timestamp: 2025-12-24T01:15:29.023780
finish_reason: stop
---

С другой стороны, метод форматирования усиливает это, принимая в обоих случаях только общие аргументы функции вместо требования кортежа для множества значений или одиночного значения, которое представляет собой кортеж:

```python
>>> '{0:.2f}'.format(1.2345)      # Одиночное значение
'1.23'
>>> '{0:.2f} {1}'.format(1.2345, 99)   # Множество значений
'1.23 99'
>>> '{0}'.format(1.23)      # Одиночное значение, само по себе
'1.23'
>>> '{0}'.format((1.23,))    # Одиночное значение, являющееся кортежем
'(1.23,)'
```

Следовательно, метод может быть не таким запутывающим для новичков и вызывать меньше ошибок при программировании. Тем не менее, вопрос кажется довольно незначительным — если вы всегда заключаете значения в кортеж и игнорируете вариант без кортежа, то выражение по существу совпадает с вызовом метода. Кроме того, ценой за метод будет раздувание размера кода с целью достижения его режима ограниченного использования. Учитывая широкое применение выражений за всю историю Python, вопрос может считаться больше теоретическим, нежели практическим, и не оправдывать перенос существующего кода на новый инструмент, который настолько похож на то, что он пытается поглотить.

Функции или выражения: незначительное удобство

Последнее логическое обоснование добавления метода format — что он является функцией, которая может появляться там, где выражение не допускается, — требует знания большого объема информации о функциях, чем известно к текущему моменту, поэтому здесь мы на нем останавливаться не будем. Достаточно сказать, что метод str.format и встроенная функция могут передаваться другим функциям, сохраняться в других объектах и т.д. Поступать так с выражением вроде % напрямую нельзя, но это ограниченная точка зрения, поскольку любое выражение легко поместить в однострочный оператор def или lambda и превратить его в функцию с теми же свойствами (хотя найти причину подобного решения может оказаться сложнее):

```python
def myformat(fmt, args): return fmt % args  # См. часть IV
myformat('%s %s', (88, 99))                # Вызов вашего объекта функции
str.format('{} {}'.format(88, 99))          # Или вызов встроенной функции
otherfunction(myformat)                     # Ваша функция - тоже объект
```

В конце концов, здесь не может быть выбора либо-либо. Наряду с тем, что выражение форматирования по-прежнему кажется более распространенным в коде Python, на сегодняшний день для использования доступны как выражения, так и методы форматирования, а потому большинство программистов извлечет выгоду на ближайшие годы, освоив обе методики. Объем работы новичков в языке на данном участке может удвоиться, но на этой ярмарке идей, которую мы называем миром программного обеспечения с открытым кодом, всегда найдется место для других².

² См. также врезку "На заметку!" в главе 31 о дефекте метода str.format (или регрессе) в версиях Python 3.2 и 3.3, касающегося обобщенных пустых целей подстановки для атрибутов объектов, которые не определяют обработчик __format__. Это повлияло на рабочий пример из предыдущего издания книги. Хотя регресс имеет временный характер, во всяком случае, он подчеркивает, что метод str.format продолжает развиваться — еще одна причина поставить под сомнение функциональную избыточность, которую он привносит.