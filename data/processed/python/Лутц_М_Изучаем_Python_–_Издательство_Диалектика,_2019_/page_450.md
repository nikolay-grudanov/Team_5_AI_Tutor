---
source_image: page_450.png
page_number: 450
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 33.97
tokens: 7783
characters: 2754
timestamp: 2025-12-24T01:21:30.041718
finish_reason: stop
---

>>> res = []
>>> for x in L:
...     res.append(x + 10)
...
>>> res
[31, 32, 33, 34, 35]

На самом деле это именно то, что внутренне делает списковое включение.

Однако списковые включения лаконичнее в плане записи, а поскольку такой кодовый шаблон построения результирующих списков настолько часто применяются при работе в Python, они оказываются очень удобными во многих контекстах. Кроме того, в зависимости от версии Python и кода списковые включения могут выполняться гораздо быстрее ручных операторов цикла for (часто примерно вдвое быстрее), потому что их итерации функционируют со скоростью кода на языке C внутри интерпретатора, а не вручную написанного кода Python. Использование выражений списковых включений нередко дают значительное преимущество в отношении производительности, особенно для крупных наборов данных.

Использование списковых включений с файлами

Давайте займемся еще одним распространенным приложением списковых включений, чтобы исследовать их более детально. Вспомните, что файловый объект имеет метод readlines, который загружает весь файл целиком в список строк:

>>> f = open('script2.py')
>>> lines = f.readlines()
>>> lines
['import sys\n', 'print(sys.path)\n', 'x = 2\n', 'print(x ** 32)\n']

Код работает, но все строки в результате содержат в конце символ новой строки (\n). Во многих программах символ новой строки становится помехой — нам необходимо позаботиться об отсутствии в выводе перемежающихся пустых строк и т.п. Было бы неплохо иметь возможность избавиться сразу от всех символов новой строки, не так ли?

Всякий раз, когда мы начинаем думать о выполнении какой-то операции над каждым элементом в последовательности, то находимся в сфере влияния списковых включений. Скажем, предполагая сохранение переменной lines в том виде, как она была в предыдущем взаимодействии, следующий код делает свою работу, прогоная каждую строку в списке через строковый метод rstrip для удаления пробельных символов с правой стороны (подошел бы и срез line[:-1], но лишь в ситуации, когда мы можем быть уверены в том, что все строки надлежащим образом заканчиваются символом \n, а в последней строке файла так может быть не всегда):

>>> lines = [line.rstrip() for line in lines]
>>> lines
['import sys', 'print(sys.path)', 'x = 2', 'print(x ** 32)']

Код работает, как было запланировано. Тем не менее, поскольку списковые включения являются итерационным контекстом подобно операторам цикла for, мы даже не обязаны заблаговременно открывать файл. Если мы откроем его внутри выражения, тогда списковое включение автоматически будет применять протокол итерации, описанный ранее в главе. То есть оно будет читать по одной строке из файла за раз, вызывая метод next файлового объекта, прогональ эту строку через выражение rstrip