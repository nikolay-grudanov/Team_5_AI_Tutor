---
source_image: page_557.png
page_number: 557
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 34.67
tokens: 7866
characters: 2438
timestamp: 2025-12-24T01:24:46.101167
finish_reason: stop
---

calling: func
10

Еще один пример использования такой методики предлагался во врезке "Что потребует внимания: настройка open" в конце предыдущей главы, где она применялась для переустановки встроенной функции open. Позже в книге мы еще рассмотрим дополнительные примеры использования данного приема, в частности при измерении времени в главе 21 и при написании разнообразных декораторных утилит в главе 39. Она представляет собой распространенную технику в рамках универсальных инструментов.

Исчезнувшая встроенная функция apply (Python 2.x)

До выхода Python 3.x эффекта синтаксиса вызовов с переменным количеством аргументов *аргументы и **аргументы можно было достичь с помощью встроенной функции по имени apply. Эта первоначальная методика была удалена в Python 3.x ввиду своей избыточности (в Python 3.x избавились от многих покрытых пылью инструментов, по большому счету бесцельно существовавших годами). Тем не менее, она все еще доступна во всех выпусках Python 2.x и ее можно встретить в более старом коде Python 2.x.

Вот эквивалентный код, применяемый до выхода Python 3.x:

func(*pargs, **kargs)        # Более новый синтаксис вызовов:
функция(*последовательность, **словарь)
apply(func, pargs, kargs)     # Исчезнувшая встроенная функция:
apply(функция, последовательность, словарь)

Например, рассмотрим следующую функцию, которая принимает любое количество позиционных или ключевых аргументов:

>>> def echo(*args, **kwargs): print(args, kwargs)
>>> echo(1, 2, a=3, b=4)
(1, 2) {'a': 3, 'b': 4}

В Python 2.x мы можем вызывать ее обобщенным образом, используя apply или синтаксис, который теперь обязателен в Python 3.x:

>>> pargs = (1, 2)
>>> kargs = {'a':3, 'b':4}
>>> apply(echo, pargs, kargs)
(1, 2) {'a': 3, 'b': 4}
>>> echo(*pargs, **kargs)
(1, 2) {'a': 3, 'b': 4}

Обе формы также работают для встроенных функций в Python 2.x (обратите внимание на наличие хвостовой буквы L для длинных целых Python 2.x):

>>> apply(pow, (2, 100))
1267650600228229401496703205376L
>>> pow(*(2, 100))
1267650600228229401496703205376L

Форма синтаксиса распаковывающих вызовов новее функции apply, она в целом предпочтительнее и является обязательной в Python 3.x. (Формально этот синтаксис был добавлен в версии Python 2.0; функция apply объявлена устаревшей в Python 2.3, по-прежнему может применяться без выдачи предупреждений в Python 2.7, но исчезла в версии Python 3.x.) Помимо симметрии с формами сбора аргументов * в заголов-