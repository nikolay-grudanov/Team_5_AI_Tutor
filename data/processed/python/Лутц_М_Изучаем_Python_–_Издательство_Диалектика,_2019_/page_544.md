---
source_image: page_544.png
page_number: 544
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 27.84
tokens: 7647
characters: 2223
timestamp: 2025-12-24T01:24:14.406907
finish_reason: stop
---

Функция changer присваивает значения самому аргументу a и компоненту объекта, на который ссылается аргумент b. Эти два присваивания внутри функции лишь слегка отличаются по синтаксису, но приводят к совершенно разным результатам.

• Поскольку a — имя локальной переменной в области видимости функции, первое присваивание не влияет на вызывающий код; оно просто модифицирует локальную переменную a, чтобы a ссылалась на другой объект, и не изменяет привязку имени X в области видимости вызывающего кода. Ситуация такая же, как в предыдущем примере.

• Аргумент b тоже является именем локальной переменной, но ему передан изменяемый объект (список, на который ссылается L в области видимости вызывающего кода). Так как второе присваивание представляет собой изменение объекта на месте, результат присваивания b[0] в функции оказывает воздействие на значение L после возврата управления из функции.

На самом деле второй оператор присваивания в changer не изменяет b — он модифицирует часть объекта, на который ссылается b в текущий момент. Такое изменение на месте влияет только на вызывающий код, потому что модифицированный объект остается существовать после вызова функции. Имя L тоже не изменяется (оно по-прежнему ссылается на тот же самый модифицированный объект), но выглядит так, будто бы имя L после вызова стало другим, потому что значение, на которое оно ссылается, было изменено внутри функции. Фактически список по имени L служит входными и выходными данными для функции.

На рис. 18.1 иллюстрируются привязки имя/объект, которые существуют непосредственно после того, как функция была вызвана, и перед выполнением ее кода.

![Схема привязок имен и объектов](https://i.imgur.com/3Q5z5QG.png)

Рис. 18.1. Ссылки: аргументы. Поскольку аргументы передаются по присваиванию, имена аргументов в функции могут разделять объекты с переменными в области видимости вызова. Следовательно, изменения на месте аргументов с изменяемыми объектами в функции могут влиять на вызывающий код. Когда функция вызывается, a и b внутри функции первоначально ссылается на объекты, на которые ссылается переменные X и L. Модификация списка через переменную b делает переменную L выглядящей по-другому после возврата управления из вызова