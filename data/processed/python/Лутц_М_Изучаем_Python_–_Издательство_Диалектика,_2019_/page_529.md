---
source_image: page_529.png
page_number: 529
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 42.27
tokens: 7987
characters: 3549
timestamp: 2025-12-24T01:24:01.608764
finish_reason: stop
---

Оператор nonlocal позволяет вложенной функции изменять одно или большее количество имен, определенных в области видимости синтаксически объемлющей функции. В Python 2.x, когда один оператор def функции вложен в другой, то вложенная функция способна ссылаться на любые имена, определенные присваиванием в области видимости объемлющего оператора def, но не может изменять их. В Python 3.x объявление имен из объемлющих областей видимости в операторе nonlocal дает возможность вложенным функциям выполнять присваивание и тем самым изменять такие имена.

В итоге объемлющие функции располагают способом предоставления записываемой информации о состоянии, запоминаемой при вызове вложенной функции в более позднее время. Разрешение состоянию изменяться делает его более полезным для вложенной функции (в качестве примера представьте себе счетчик в объемлющей области видимости). В Python 2.x программисты обычно достигали похожих целей за счет использования классов или других схем. Однако из-за того, что вложенные функции стали более распространенным кодовым шаблоном для реализации хранения состояния, оператор nonlocal делает их универсально применимыми.

Помимо разрешения именам из объемлющих def изменяться оператор nonlocal также навязывает ограничение для ссылок — во многом подобно global оператор nonlocal приводит к тому, что поиск перечисленных в нем имен начинается в областях видимости объемлющих def, а не в локальной области видимости объявляющей функции. То есть nonlocal также означает "полностью пропустить мою локальную область видимости".

В действительности имена, перечисленные в операторе nonlocal, уже должны быть определены в объемлющем операторе def, когда достигается nonlocal, в противном случае возникает ошибка. Конечный эффект очень похож на global: оператор global означает, что имена находятся во включающем модуле, а nonlocal — что они пребывают в объемлющем def. Оператор nonlocal даже более строгий — поиск в областях видимости ограничивается только объемлющими def. Таким образом, нелокальные имена могут появляться только в объемлющих def, но не в глобальной области видимости модуля или встроенной области видимости за пределами операторов def.

Добывление nonlocal в целом не изменяет правила поиска ссылок на имена в областях видимости; они продолжают работать прежним образом согласно описанному ранее правилу LEGB. Оператор nonlocal служит по большей части для того, чтобы позволить именам из объемлющих областей видимости изменяться, а не просто ссылаться на них. Тем не менее, операторы global и nonlocal ужесточают и даже в чем-то ограничивают правила поиска, когда они размещены внутри функции.

• Оператор global заставляет поиск в областях видимости начинаться в области видимости включающего модуля и открывает возможность присваивания находящимся там именам. Если имя не существует в модуле, тогда поиск продолжается во встроенной области видимости, но присваивания глобальным именам всегда создают или изменяют их в области видимости модуля.

• Оператор nonlocal ограничивает поиск в областях видимости только объемлющими def, требует, чтобы имена уже там существовали, и делает возможным присваивание им значений. Поиск не продолжается в глобальной или встроенной областях видимости.

В Python 2.x разрешена ссылка на имена из областей видимости объемлющих def, но не присваивание. Однако для получения того же эффекта изменяемой информации о состоянии, что и оператор nonlocal, вы по-прежнему можете использовать классы с явными атрибутами (а в ряде контекстов поступать так может быть даже лучше);