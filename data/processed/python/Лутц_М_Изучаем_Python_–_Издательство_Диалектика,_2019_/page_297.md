---
source_image: page_297.png
page_number: 297
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 20.57
tokens: 7539
characters: 1628
timestamp: 2025-12-24T01:16:21.523074
finish_reason: stop
---

>>> D.items()
dict_items([('b', 2), ('c', 3), ('a', 1)])
>>> list(D.items())
[('b', 2), ('c', 3), ('a', 1)]
>>> K[0]        # Без преобразования списковые операции терпят неудачу
TypeError: 'dict_keys' object does not support indexing
Ошибка типа: объект dict_keys не поддерживает индексацию
>>> list(K)[0]
'b'

Помимо отображения результатов в интерактивной подсказке вам вряд ли часто придется обращать внимание на такое изменение, потому что циклические конструкции в Python автоматически заставляют итерируемые объекты выдавать по одному результату на каждой итерации:

>>> for k in D.keys(): print(k)    # В циклах итераторы используются автоматически
...
b
c
a

Вдобавок сами словари Python 3.X по-прежнему имеют итераторы, которые возврашают последовательные ключи — как и в Python 2.X, часто нет необходимости в прямом вызове keys:

>>> for key in D: print(key)      # По-прежнему нет нужды вызывать keys
# для выполнения итерации
...
b
c
a

Однако в отличие от списковых результатов Python 2.X словарные представления в Python 3.X не являются застывшими — они динамически отражают будущие изменения, вносимые в словарь после создания объекта представления:

>>> D = {'a': 1, 'b': 2, 'c': 3}
>>> D
{'b': 2, 'c': 3, 'a': 1}
>>> K = D.keys()
>>> V = D.values()
>>> list(K)        # Представление поддерживает тот же порядок, что и словарь
['b', 'c', 'a']
>>> list(V)
[2, 3, 1]
>>> del D['b']     # Изменение словаря на месте
>>> D
{'c': 3, 'a': 1}
>>> list(K)        # Изменение отражается в любых текущих объектах представлений
['c', 'a']
>>> list(V)        # В Python 2.X это не так! Списки отсоединены от словаря
[3, 1]