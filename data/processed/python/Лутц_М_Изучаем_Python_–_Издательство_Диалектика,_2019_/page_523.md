---
source_image: page_523.png
page_number: 523
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 33.59
tokens: 7850
characters: 3012
timestamp: 2025-12-24T01:23:41.902379
finish_reason: stop
---

Это довольно сложный прием, который не особенно часто встречается в большей части кода, и он может быть популярен среди программистов с опытом использования языков функционального программирования. С другой стороны, объемлющие области видимости нередко употребляются выражениями создания функций lambda, которые объясняются далее в главе — являясь выражениями, они почти всегда вкладываются внутрь def. Скажем, в нашем примере выражение lambda могло бы заменить оператор def:

```python
>>> def maker(N):
    return lambda X: X ** N  # Функции lambda тоже сохраняют состояние
>>> h = maker(3)
>>> h(4)  # Снова 4 ** 3
64
```

За более реалистичным примером замыканий в работе обращайтесь к врезке "Что потребует внимания: настройка open" в конце главы. Там применяются похожие методики для сохранения информации с целью дальнейшего использования в объемлющей области видимости.

Замечания по представлению. В этой главе я начал приводить примеры интерактивного взаимодействия без приглашений к продолжению..., которые в вашем интерфейсе могут отображаться или не отображаться (они отображаются в интерактивной подсказке, но не в IDLE). Такое соглашение будет соблюдаться и далее для крупных примеров кода. Я полагаю, что к настоящему времени вы уже хорошо понимаете правила применения отступов и обрели достаточный опыт в наборе кода Python. Кроме того, я буду представлять все больше и больше кода отдельно или в файлах, произвольно переключаясь между ними и интерактивным вводом.

Замыкания или классы, раунд 1

Классы, подробно описываемые в части VI книги, некоторым могут показаться лучшим вариантом для такого хранения информации о состоянии, поскольку они обеспечивают более явное запоминание посредством присваивания атрибутов. Классы также напрямую поддерживают дополнительные инструменты, которые отсутствуют в функциях замыканий, вроде настройки путем наследования и перегрузки операций, и более естественно реализуют множество линий поведения в форме методов. По причине таких отличий классы могут быть эффективнее при реализации усовершенствованных объектов.

Однако если сохранение состояния является единственной целью, тогда функции замыканий часто оказываются более легковесной и жизнеспособной альтернативой. Они предоставляют каждому вызову локализованное хранилище для данных, требующихся одиночной вложенной функции. Это особенно верно, когда мы добавляем рассматриваемый позже оператор nonlocal из Python 3.x, чтобы разрешить изменять состояние в объемлющей области видимости (в Python 2.x объемлющие области видимости допускают только чтение, а потому с ними связаны ограниченные сценарии использования).

В более широком смысле функциям Python доступны многие способы сохранения состояния между вызовами. Несмотря на то что значения нормальных локальных переменных исчезают, когда управление возвращается из функции, значения могут сохраняться между вызовами в глобальных переменных, в атрибутах экземпляров классов, в обсуждаемых здесь ссылках из объемлющих областей видимости, а также в