---
source_image: page_388.png
page_number: 388
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 30.15
tokens: 7840
characters: 2988
timestamp: 2025-12-24T01:19:30.379830
finish_reason: stop
---

вместо исходного потока вывода. Операции print продолжают вызывать метод write объекта sys.stdout независимо от того, на что ссылается sys.stdout. Поскольку в процессе имеется лишь один модуль sys, подобное переназначение sys.stdout будет перенаправлять каждую операцию print повсюду в программе.

На самом деле, как объясняется во врезке "Что потребует внимания: print и stdout" в конце главы, вы можете переустанавливать sys.stdout даже в объект, вообще не имеющий отношения к файлам, при условии наличия в нем ожидаемого интерфейса — метода по имени write для получения аргумента со строкой выводимого текста. Когда такой объект является классом, выводимый текст можно произвольно направлять и обрабатывать согласно методу write, который вы написали самостоятельно.

Такой прием с переустановкой потока вывода может быть более полезен в программах, первоначально написанных с операторами print. Если вам заранее известно, что вывод должен попадать в файл, то вы можете взамен вызывать файловые методы записи. Однако при перенаправлении вывода программы, основанной на print, переустановка sys.stdout предоставляет удобную альтернативу изменению каждого оператора print или применению синтаксиса перенаправления, который базируется на командной оболочке системы.

В других ролях потоки могут быть переустановлены в объекты, которые отображают текст внутри всплывающих окон в графических пользовательских интерфейсах, раскрашивают его цветом в IDE-средах вроде IDLE и т.д. Это универсальная методика.

Автоматическое перенаправление потока

Хотя перенаправление выводимого текста путем переназначения sys.stdout является удобным инструментом, потенциальная проблема с кодом из предыдущего раздела связана с отсутствием прямой возможности восстановить исходный поток вывода, когда возникнет необходимость переключиться обратно после вывода в файл. Тем не менее, из-за того, что sys.stdout — всего лишь обычный файловый объект, вы всегда можете сохранить его и впоследствии восстановить6:

C:\code> c:\python33\python
>>> import sys
>>> temp = sys.stdout   # Сохранение с целью восстановления в будущем
>>> sys.stdout = open('log.txt', 'a')   # Перенаправление вывода в файл
>>> print('spam')      # Вывод направляется в файл, не сюда
>>> print(1, 2, 3)
>>> sys.stdout.close() # Сброс вывода на диск
>>> sys.stdout = temp  # Восстановление исходного потока
>>> print('back here')
back here
>>> print(open('log.txt').read())   # Результат предшествующих выводов
spam
1 2 3

Но, как вы могли заметить, подобного рода ручное сохранение и восстановление исходного потока вывода влечет за собой дополнительную работу.

6 В Python 2.x и 3.x вы также в состоянии использовать атрибут __stdout__ из модуля sys, который ссылается на исходное значение sys.stdout, установленное во время начального запуска программы. Однако вам все равно придется восстанавливать sys.stdout в sys.__stdout__, чтобы возвратиться к исходному значению потока. Дополнительные сведения ищите в документации по модулю sys.