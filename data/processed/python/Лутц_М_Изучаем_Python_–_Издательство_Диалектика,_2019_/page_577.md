---
source_image: page_577.png
page_number: 577
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 31.55
tokens: 7726
characters: 2300
timestamp: 2025-12-24T01:25:17.800372
finish_reason: stop
---

Операторы цикла или рекурсия

Несмотря на то что рекурсия работает для суммирования в примерах из предшествующих разделов, в таком контексте она видимо будет излишеством. На самом деле рекурсия в Python не применяется настолько же часто, как в экзотических языках вроде Prolog или Lisp, потому что в Python придается особое значение более простым процедурным операторам наподобие циклов, которые обычно намного естественнее. Скажем, while часто привносит чуть большую конкретику и не требует, чтобы функция определялась как допускающая рекурсивные вызовы:

```python
>>> L = [1, 2, 3, 4, 5]
>>> sum = 0
>>> while L:
    sum += L[0]
    L = L[1:]
>>> sum
15
```

Еще лучше то, что циклы for обеспечивают автоматическую итерацию, делая рекурсию во многих случаях излишней (и по всей вероятности менее эффективной в плане расхода памяти и времени выполнения):

```python
>>> L = [1, 2, 3, 4, 5]
>>> sum = 0
>>> for x in L: sum += x
>>> sum
15
```

В случае использования операторов цикла нам не требуется новая копия локальной области видимости в стеке вызовов для каждой итерации, и мы избежаем затрат времени, связанных с вызовами функций в целом. (В главе 21 будет приведен учебный пример, иллюстрирующий способы измерения времени выполнения для альтернативных реализаций подобного рода.)

Обработка произвольных структур

С другой стороны, рекурсия (или эквивалентные явные алгоритмы, основанные на стеке, которые мы вскоре рассмотрим) может требоваться для обхода структур произвольной формы. В качестве простого примера рекурсии в таком контексте возьмем задачу вычисления суммы всех чисел в структуре с вложенными подсписками следующего вида:

```python
[1, [2, [3, 4], 5], 6, [7, 8]]  # Произвольно вложенные под списки
```

Простые операторы циклов здесь не подходят, поскольку это не линейная итерация. Вложенных операторов цикла тоже не будет достаточно, потому что под списки могут быть вложенными на произвольную глубину и в произвольной форме — нет никакого способа узнать, сколько вложенных циклов необходимо написать для обработки всех случаев. Взамен следующий код приспосабливается к такому универсальному вложению за счет применения рекурсии для посещения под списков:

```python
# Файл sumtree.py
def sumtree(L):
    tot = 0
    for x in L:  # Для каждого элемента на этом уровне
```