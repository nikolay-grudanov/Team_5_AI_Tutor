---
source_image: page_468.png
page_number: 468
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 46.20
tokens: 7991
characters: 3078
timestamp: 2025-12-24T01:22:16.301671
finish_reason: stop
---

Таблица 15.1. Источники документации Python

<table>
  <tr>
    <th>Форма</th>
    <th>Роль</th>
  </tr>
  <tr>
    <td>Комментарии #</td>
    <td>Внутрифайловая документация</td>
  </tr>
  <tr>
    <td>Функция dir</td>
    <td>Списки атрибутов, доступных в объектах</td>
  </tr>
  <tr>
    <td>Строки документации: __doc__</td>
    <td>Внутрифайловая документация, присоединенная к объектам</td>
  </tr>
  <tr>
    <td>RyDoc: функция help</td>
    <td>Интерактивная справка для объектов</td>
  </tr>
  <tr>
    <td>RyDoc: отчеты HTML</td>
    <td>Документация по модулям, отображающаяся в браузере</td>
  </tr>
  <tr>
    <td>Сторонний инструмент Sphinx</td>
    <td>Обогащенная документация для более крупных проектов</td>
  </tr>
  <tr>
    <td>Стандартный набор руководств</td>
    <td>Официальные описания языка и библиотек</td>
  </tr>
  <tr>
    <td>Веб-ресурсы</td>
    <td>Онлайновые руководства, примеры и т.д.</td>
  </tr>
  <tr>
    <td>Печатные издания</td>
    <td>Коммерчески совершенные справочники</td>
  </tr>
</table>

Комментарии #

Как уже известно, комментарии # являются наиболее базовым способом документирования кода. Python просто игнорирует весь текст, следующий за символом # (до тех пор, пока он не находится внутри строкового литерала), поэтому вы можете помещать после # любые слова и описания, имеющие смысл для программистов. Однако такие комментарии доступны только в файлах исходного кода; для написания более широко доступных комментариев понадобится применять строки документации.

На самом деле установившаяся в текущее время практика в целом предполагает, что строки документации лучше подходят для более широкого документирования функциональности (скажем, "файл делает то-то и то-то"), а использование комментариев # лучше ограничивать документированием кода (например, "это странное выражение делает вот что") и областью действия оператора или небольшой группы операторов внутри сценария либо функции. Вскоре мы вернемся к строкам документации, но сначала давайте посмотрим, каким образом исследовать объекты.

Функция dir

Как было показано ранее, встроенная функция dir предоставляет легкий способ получения перечня всех атрибутов, доступных внутри объекта (т.е. его методов и более простых элементов данных). Ее можно вызывать без аргументов, чтобы получить список переменных в области видимости вызывающего кода. Но более удобно то, что dir можно вызывать на любом объекте, имеющем атрибуты, в числе которых импортированные модули и встроенные типы, а также имена типов данных. Скажем, для выяснения, что доступно в модуле, подобном sys из стандартной библиотеки, его следует импортировать и передать dir:

```python
>>> import sys
>>> dir(sys)
['__displayhook__', ...остальные имена не показаны..., 'winver']
```

Результаты получены в версии Python 3.7, и большинство имен здесь не показано, т.к. в разных местах они слегка варьируются; чтобы получить полный перечень, выполните приведенные операторы самостоятельно. Фактически в sys имеется 88 атрибутов, хотя в большинстве случаев нас будут интересовать только 77 из них, которые