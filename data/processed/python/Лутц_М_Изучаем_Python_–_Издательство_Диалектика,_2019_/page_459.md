---
source_image: page_459.png
page_number: 459
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 34.92
tokens: 7791
characters: 2558
timestamp: 2025-12-24T01:21:48.540691
finish_reason: stop
---

>>> list(zip('abc', 'xyz'))    # Принудительная выдача списка результатов
#     для отображения в Python 3.x
[('a', 'x'), ('b', 'y'), ('c', 'z')]

Похожее преобразование требуется, когда мы хотим применять списковые операции или операции над последовательностями к большинству итерируемых объектов, которые генерируют элементы по запросу — для индексации, нарезания или конкатенации самого итерируемого объекта, например. Списковые результаты для таких инструментов в Python 2.x поддерживают операции подобного рода напрямую:

>>> z = zip((1, 2), (3, 4))    # В отличие от списков Python 2.x нельзя
#     индексировать и т.д.
>>> z[0]
TypeError: 'zip' object is not subscriptable
Ошибка типа: объект zip не допускает индексацию

Как будет более подробно обсуждаться в главе 20, преобразование в списки может также не настолько очевидно требоваться в целях поддержки множественных итераций для по-новому работающих итерационных инструментов, которые предусматривают только один просмотр, скажем, map и zip. В отличие от списковых форм Python 2.x их значения в Python 3.x израсходуются после одиночного прохода:

>>> M = map(lambda x: 2 ** x, range(3))
>>> for i in M: print(i)
...
1
2
4
>>> for i in M: print(i)    # В отличие от списков Python 2.x только
#     один проход (zip тоже)
...

Такое преобразование в Python 2.x не требуется, потому что функции вроде zip возвращают списки результатов. Тем не менее, в Python 3.x они возвращают итерируемые объекты, производя результат по запросу. В итоге работа кода Python 2.x может быть нарушена, а для отображения в интерактивной подсказке (и возможно в ряде других контекстов) потребуется дополнительный набор, но в более крупных программах это полезное качество — отложенная оценка подобного рода сберегает память и позволяет избежать пауз, связанных с вычислением больших результирующих списков. Давайте посмотрим на некоторые новые итерируемые объекты Python 3.x в действии.

Итерируемый объект range

Мы исследовали базовое поведение встроенной функции range в предыдущей главе. В Python 3.x она возвращает итерируемый объект, который генерирует числа в диапазоне по запросу вместо построения результирующего списка в памяти. Это напоминает старую функцию xrange из Python 2.x (см. врезку "Примечание, касающееся нестыковки версий" далее в главе), и вы должны использовать list(range(...)), чтобы получить фактический список, когда он необходим (например, для отображения результатов):

C:\code> c:\python33\python
>>> R = range(10)    # range возвращает итерируемый объект, а не список
>>> R
range(0, 10)