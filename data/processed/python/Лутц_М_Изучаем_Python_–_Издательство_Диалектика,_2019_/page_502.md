---
source_image: page_502.png
page_number: 502
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 35.45
tokens: 7936
characters: 3199
timestamp: 2025-12-24T01:23:04.151503
finish_reason: stop
---

аргументе выполнить проверку, содержится ли он также во втором аргументе, и если да, то добавить его в результат". На языке Python алгоритм выглядит короче, чем на естественном языке, но смысл остается тем же.

Ради справедливости следует отметить, что наша функция пересечения работает довольно медленно (она выполняет вложенные циклы), не является настоящим математическим пересечением (в результате могут присутствовать дубликаты) и не требуется вообще (тип множества Python предоставляет встроенную операцию пересечения). На самом деле функцию intersect можно было бы заменить выражением спискового включения, т.к. она демонстрирует классический кодовый шаблон цикла с накоплением данных:

```python
>>> [x for x in s1 if x in s2]
['S', 'A', 'M']
```

Однако в качестве примера, иллюстрирующего основы функций, он вполне подходит — как будет объясняться в следующем разделе, этот одиночный фрагмент можно применять к целому диапазону типов объектов. После дополнительного исследования режимов передачи аргументов в главе 18 мы улучшим и расширим его для поддержки произвольно большого количества операндов.

Еще раз о полиморфизме

Как и все добропорядочные функции в Python, функция intersect полиморфна, т.е. работает на произвольных типах при условии, что они поддерживают ожидаемый интерфейс объекта:

```python
>>> x = intersect([1, 2, 3], (1, 4))    # Разнородные типы
>>> x                                  # Сохраненный результирующий объект
[1]
```

В данном примере мы передали нашей функции объекты разных типов — список и кортеж (разнородные типы) — и она по-прежнему выбрала общие элементы. Поскольку нет необходимости указывать типы аргументов заранее, функция intersect благополучно проходит по передаваемым объектам последовательностей любого вида, пока они поддерживают ожидаемые интерфейсы.

Для функции intersect это означает, что первый аргумент должен поддерживать цикл for, а второй — проверку членства in. Любые два таких объекта будут работать независимо от их специфических типов: физически хранимые последовательности наподобие строк и списков; все итерируемые объекты из главы 14, включая файлы и словари; и даже любые объекты, основанные на написанных нами классах, которые применяют методики перегрузки операций, обсуждаемые позже в книге².

² Этот код всегда будет работать, если мы выполняем пересечение содержимого файлов, которое получается посредством file.readlines(). Тем не менее, в зависимости от реализации операции in или универсальной итерации файловым объектом код может не работать для пересечения строк в открытых входных файлах напрямую. В общем случае после того, как однажды был достигнут конец файла, файлы должны быть позиционированы в начало (например, с помощью вызова file.seek(0) или еще одного open), и потому они являются однопроходными итераторами. Как будет показано в главе 30, где исследуется перегрузка операций, объекты реализуют операцию in либо путем предоставления специфического метода __contains__, либо за счет поддержки универсального протокола итерации посредством метода __iter__ или более старого __getitem__; классы могут кодировать упомянутые методы произвольным образом, определяя в итоге смысл итерации для своих данных.