---
source_image: page_578.png
page_number: 578
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 32.84
tokens: 7808
characters: 2572
timestamp: 2025-12-24T01:25:22.541619
finish_reason: stop
---

```python
if not isinstance(x, list):
    tot += x                # Сложение чисел напрямую
else:
    tot += sumtree(x)       # Рекурсия для подсписков
return tot
L = [1, [2, [3, 4], 5], 6, [7, 8]]   # Произвольное вложение
print(sumtree(L)) # Prints 36

# Патологические случаи
print(sumtree([1, [2, [3, [4, [5]]]]]))  # Выводит 15 (перегруженное справа)
print(sumtree([[[[[1], 2], 3], 4], 5]])  # Выводит 15 (перегруженное слева)

Отследите тестовые сценарии в конце кода, чтобы посмотреть, как рекурсия обходит вложенные списки.

Рекурсия или очереди и стеки

Иногда может помочь знание того факта, что внутренне Python реализует рекурсию, заталкивая информацию в стек вызовов при каждом рекурсивном вызове, чтобы запомнить, куда он должен позже возвратиться и продолжить. На самом деле обычно есть возможность реализовать процедуры в рекурсивном стиле без рекурсивных вызовов за счет использования собственного явного стека или очереди для отслеживания оставшихся шагов.

Скажем, приведенный ниже код вычисляет ту же сумму, что и предыдущий пример, но применяет явный список для планирования, когда он посетит элементы в указанном списке, вместо выдачи рекурсивных вызовов; следующим обрабатываемым и суммируемым элементом всегда будет элемент в начале списка:

def sumtree(L):                # Явная очередь с обходом в ширину
    tot = 0
    items = list(L)            # Начать с копии верхнего уровня
    while items:
        front = items.pop(0)   # Извлечь/удалить элемент в начале
        if not isinstance(front, list):
            tot += front        # Напрямую суммировать числа
        else:
            items.extend(front)  # <== Добавить все из вложенного подсписка
    return tot

Формально код обходит список в ширину по уровням, потому что он добавляет содержимое вложенных подсписков в конец списка, формируя очередь типа "первым пришел — первым обслужен". Для более точной эмуляции обхода в версии с рекурсивными вызовами мы можем изменить код так, чтобы он выполнял обход в глубину, просто добавляя содержимое вложенных подсписков в начало списка и формируя стек типа "последним пришел — первым обслужен":

def sumtree(L):                # Явный стек с обходом в глубину
    tot = 0
    items = list(L)            # Начать с копии верхнего уровня
    while items:
        front = items.pop(0)   # Извлечь/удалить элемент в начале
        if not isinstance(front, list):
            tot += front        # Напрямую суммировать числа
        else:
            items[:0] = front   # <== Присоединить спереди все из вложенного подсписка
    return tot
```