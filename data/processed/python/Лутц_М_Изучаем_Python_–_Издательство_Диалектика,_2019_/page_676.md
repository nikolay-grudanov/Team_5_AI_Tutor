---
source_image: page_676.png
page_number: 676
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 32.35
tokens: 7822
characters: 2910
timestamp: 2025-12-24T01:28:20.722678
finish_reason: stop
---

Уточнение (часть .X) извлекает значение из объекта в пространстве имен. Пространством имен интерактивной подсказки является модуль под названием __main__, так что __main__.X обеспечивает доступ к глобальной версии X. Если суть сказанного не вполне ясна, тогда перечитайте главу 17.

В последних версиях Python положение дел несколько улучшилось за счет выдачи более специфичного сообщения об ошибке типа "несвязанная локальная переменная", которая была показана ранее (ранее просто выдавалось универсальное сообщение об ошибке, касающейся имени); однако в целом это затруднение все еще встречается.

Стандартные значения и изменяемые объекты

Как кратко отмечалось в главах 17 и 18, изменяемые объекты для аргументов со стандартными значениями способны предохранять состояние между вызовами, хотя это часто не ожидается. В общем случае стандартные значения аргументов оцениваются и сохраняются однократно при выполнении оператора def, а не каждый раз, когда результирующая функция вызывается в более позднее время. Внутренне Python хранит по одному объекту для аргумента со стандартным значением, присоединяя его к самой функции.

Обычно именно такое поведение и требуется — поскольку стандартные значения оцениваются во время выполнения def, они позволяют при необходимости сохранять значения из объемлющей области видимости (как объясняется далее, функции, определяемые внутри циклов посредством фабрик, могут даже полагаться на такое поведение). Но из-за того, что стандартное значение сохраняется между вызовами, вы должны проявлять осмотрительность при модификации изменяемых объектов, выбранных для стандартных значений. Скажем, в следующей функции в качестве стандартного значения применяется пустой список, который модифицируется на месте каждый раз, когда функция вызывается:

```python
>>> def saver(x=[]):
...     x.append(1)
...     print(x)
...
>>> saver([2])
[2, 1]
>>> saver()
[1]
>>> saver()
[1, 1]
>>> saver()
[1, 1, 1]
```

# Немедленно сохраняет объект списка
# Каждый раз изменяет тот же самый объект!
# Стандартное значение не используется
# Стандартное значение используется
# Растет с каждым вызовом!

Одни рассматривают такое поведение как особенность — так как аргументы с изменяемыми стандартными значениями предохраняют свое состояние между вызовами функции, они могут исполнять часть тех же ролей, что и статические локальные переменные функций в языке C. В известной мере они работают во многом подобно глобальным переменным, но их имена локальны по отношению к функциям и потому не конфликтуют с именами в других местах программы.

Тем не менее, для других это выглядит как затруднение, особенно когда они впервые с ним сталкиваются. В Python существуют более эффективные способы предохранения состояния между вызовами (например, применение замыканий вложенных областей видимости, с которыми мы встречались ранее в данной части, и классов, которые будут исследоваться в части VI).