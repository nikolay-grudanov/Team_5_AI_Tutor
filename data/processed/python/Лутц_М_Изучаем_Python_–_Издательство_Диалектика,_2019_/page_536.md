---
source_image: page_536.png
page_number: 536
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 32.32
tokens: 7777
characters: 2607
timestamp: 2025-12-24T01:24:05.838877
finish_reason: stop
---

для переменных состояния, которые должны изменяться; ссылки на остальные переменные сохраняются и работают нормально.

Важно отметить, что такая схема переносима — подобно классам, но в отличие от nonlocal, атрибуты функций работают в Python 3.x и в Python 2.x. Фактически они доступны, начиная с версии Python 2.1, т.е. гораздо дольше, чем оператор nonlocal из Python 3.x. Поскольку фабричные функции в любом случае создают новую функцию при каждом вызове, дополнительные объекты не требуются — атрибуты новой функции становятся состоянием для вызова во многом таким же образом, как нелокальные переменные, и аналогично ассоциируются со сгенерированной функцией в памяти.

Более того, как и атрибуты классов, атрибуты функций делают возможным доступ к переменным состояния извне вложенной функции; посредством nonlocal переменные состояния можно сделать видимыми только внутри вложенного def. Если необходим внешний доступ к счетчику вызовов, то в данной модели это будет простое извлечение атрибута функции.

Ниже показана финальная версия, основанная на методике с атрибутами функций — в ней nonlocal заменяется атрибутом, присоединенным к вложенной функции. На первый взгляд схема может показаться не особенно понятной; доступ к состоянию осуществляется через имя функции, а не простые переменные, и оно должно быть инициализировано после вложенного оператора def. Но результирующий код намного более переносим, разрешает внешний доступ к состоянию и экономит строку кода, т.к. не требует объявления nonlocal:

```python
>>> def tester(start):
    def nested(label):
        print(label, nested.state)  # Функция nested находится
        # в объемлющей области видимости
        nested.state += 1  # Изменяет атрибут, а не саму функцию nested
        nested.state = start  # Инициализация состояния после определения функции
        return nested
    return nested

>>> F = tester(0)
>>> F('spam')  # F - это nested с присоединенным состоянием
spam 0
>>> F('ham')
ham 1
>>> F.state  # Возможен также доступ к состоянию извне функции
2
```

Из-за того, что каждое обращение к внешней функции производит новый объект вложенной функции, эта схема поддерживает изменяемые данные с множеством копий для каждого вызова в точности как нелокальные замыкания и классы — режим использования, который глобальные переменные обеспечить не могут:

```python
>>> G = tester(42)  # G имеет собственное состояние, состояние F не перезаписывается
>>> G('eggs')
eggs 42
>>> F('ham')
ham 2
>>> F.state  # Состояние доступно и поддерживается для каждого вызова
3
>>> G.state
43
>>> F is G  # Разные объекты функций
False
```