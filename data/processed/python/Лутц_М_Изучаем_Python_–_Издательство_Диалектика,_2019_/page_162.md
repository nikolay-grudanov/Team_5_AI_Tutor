---
source_image: page_162.png
page_number: 162
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 34.10
tokens: 7851
characters: 2894
timestamp: 2025-12-24T01:12:02.380917
finish_reason: stop
---

yes
    >>> if isinstance(L, list):    # Объектно-ориентированная проверка
        print('yes')
yes

Теперь, когда вы увидели все способы выполнения проверки типов, я обязан сообщить вам, что поступать так в программе Python почти всегда неправильно (и это часто служит признаком того, что бывший программист на С впервые начал использовать Python). Причина станет полностью ясной лишь позже в книге, когда мы приступим к написанию более крупных единиц кода, таких как функции, но это является (наверное) основной концепцией Python. Выполняя проверку на предмет специфического типа в своем коде, вы фактически нарушаете гибкость кода — ограничиваете его работой только с одним типом. Без такой проверки код может быть способен работать с целым диапазоном типов.

Все связано с упоминаемой ранее идеей полиморфизма и уходит своими корнями в отсутствие в Python объявлений типов. Как вы узнаете, в Python мы имеем дело с интерфейсами объектов (поддерживаемыми операциями), а не с типами. Другими словами нас заботит, что объект делает, а не чем он является. Отсутствие заботы о специфических типах означает, что код автоматически применим ко многим из них — будет работать любой объект с совместимым интерфейсом независимо от его конкретного типа. Хотя проверка типов поддерживается (и в редких случаях даже требуется), вы увидите, что она обычно отличается от обычного образа мышления Python. На самом деле вы обнаружите, что полиморфизм — вероятно, ключевая идея правильного использования Python.

Классы, определяемые пользователем

Объектно-ориентированное программирование на Python — необязательное, но мощное средство языка, которое сокращает время разработки за счет поддержки программирования через настройку, — подробно рассматривается позже в книге. В общих понятиях классы определяют новые типы объектов, которые расширяют основной набор, поэтому пока они заслуживают лишь мимолетного взгляда. Пусть, например, вы хотите иметь тип объекта, моделирующий сотрудника. Несмотря на отсутствие такого типа в наборе основных типов Python, следующий класс, определяемый пользователем, способен удовлетворить всем требованиям:

>>> class Worker:
    def __init__(self, name, pay):
        self.name = name
        self.pay = pay
    def lastName(self):
        return self.name.split()[-1]
    def giveRaise(self, percent):
        self.pay *= (1.0 + percent)

Класс Worker определяет новый вид объекта, который будет иметь атрибуты name и pay (иногда называемые информацией о состоянии), а также две линии поведения, реализованные как функции (обычно называемые методами). Обращение к классу аналогично функции создает экземпляры нового типа, и методы класса автоматически получают экземпляр, обрабатываемый заданным вызовом метода (в аргументе self):

>>> bob = Worker('Bob Smith', 50000)    # Создать два экземпляра
>>> sue = Worker('Sue Jones', 60000)    # Каждый имеет атрибуты name и pay