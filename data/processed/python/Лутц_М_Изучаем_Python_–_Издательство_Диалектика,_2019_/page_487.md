---
source_image: page_487.png
page_number: 487
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 44.02
tokens: 8042
characters: 3481
timestamp: 2025-12-24T01:22:44.979257
finish_reason: stop
---

Сказанное справедливо не только для Python, но для любого блочно-структурированного языка — если у следующего программиста табуляции настроены по-другому, то ему будет сложно или невозможно понять структуру вашего кода. Надежнее использовать для каждого блока все табуляции или все пробелы.

• Не пишите код Python в стиле C. Напоминание программистам на C/C++: нет необходимости помещать в круглые скобки выражения проверок в заголовках if и while (например, if (X==1) : ). При желании поступать так можно (заключать в круглые скобки разрешено любое выражение), но в данном контексте они совершенно излишни. Кроме того, не заканчивайте все свои операторы точками с запятой; формально делать это в Python законно, но абсолютно бесполезно, если только вы не размещаете в одиночной строке более одного оператора (обычно оператор завершается по достижении конца строки). Также запомните: не встраивайте операторы присваивания в проверки циклов while и не применяйте {} вокруг блоков (взамен согласованно смешайте вложенные блоки кода).

• Используйте простые циклы for вместо while или range. Еще одно напоминание: простой цикл for (скажем, for x in seq:) почти всегда проще в написании и часто быстрее в выполнении, чем цикл с подсчетом на основе while или range. Поскольку Python внутренне поддерживает индексацию для простого цикла for, иногда он может быть быстрее эквивалентного while, хотя ситуация зависит от кода и версии Python. Однако исключительно ради простоты кода не поддавайтесь искушению подсчитывать что-либо в Python!

• Будьте осторожны с изменяемыми объектами в присваиваниях. Об этом упоминалось в главе 11: нужно проявлять осмотрительность при использовании изменяемых объектов в групповом присваивании (a = b = []), а также в дополненном присваивании (a += [1, 2]). В обоих случаях изменения на месте могут повлиять на другие переменные. Если вдруг вы подзабыли, почему сказанное справедливо, тогда снова почитайте главу 11.

• Не ожидайте получить результаты от функций, которые изменяют объекты на месте. Мы уже сталкивались с этим ранее: операции изменения на месте вроде представленных в главе 8 методов list.append и list.sort не возвращают значения (за исключением None), так что они должны вызываться без присваивания результата. Начинающие нередко применяют оператор наподобие mylist = mylist.append(X) в попытке получить результат метода append, но на самом деле он присваивает переменной mylist объект None, а не модифицированный список (фактически будет утрачена ссылка на целый список).
Более коварный пример такого рода относится к коду Python 2.x, в котором предпринимается попытка прохода по элементам словаря в сортированной манере. Довольно часто можно встретить код вида for k in D.keys().sort() : . Код почти работает — метод keys строит список ключей, а метод sort упорядочивает его, — но из-за того, что метод sort возвращает None, цикл терпит неудачу, поскольку в итоге пытается пройти по None (не последовательность). В Python 3.x отказ произойдет даже раньше, т.к. ключи словаря являются представлениями, а не списками! Чтобы написать корректный код, необходимо либо использовать более новую встроенную функцию sorted, которая возвращает отсортированный список, либо разнести вызовы методов по разным операторам: Ks = list(D.keys()), затем Ks.sort() и наконец for k in Ks:. Кстати, это один из случаев, когда может понадобиться вызывать метод keys явно для организации цикла, не полагаясь на словарные итераторы — итераторы не сортируют.