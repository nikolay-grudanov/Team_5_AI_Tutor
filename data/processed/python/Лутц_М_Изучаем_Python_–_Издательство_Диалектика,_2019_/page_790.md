---
source_image: page_790.png
page_number: 790
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 32.81
tokens: 7839
characters: 2923
timestamp: 2025-12-24T01:31:54.381506
finish_reason: stop
---

Как видите, применению reload вместе с from присущи проблемы: вы обязаны не только помнить о необходимости перезагрузки после операций импортирования, но также не забывать о повторном выполнении операторов from после перезагрузки. Это достаточно сложно, чтобы порой сбивать с толку даже эксперта. На самом деле ситуация в Python 3.x стала даже хуже из-за того, что вы должны также не забывать об импортировании самой функции reload!

Короче говоря, не стоит ожидать эффективной совместной работы reload и from. Наилучшей политикой будет отказ от их сочетания — используйте reload с оператором import или запускайте свои программы другими способами, как предлагалось в главе 3: с применением пункта меню Run⇒Run Module (Выполнить⇒Выполнить модуль) в IDLE, щелчков на значках файлов, командных строк системы или встроенной функции exec.

Рекурсивные операции импортирования from могут не работать

Я сохранил самое странное (и к счастью малоизвестное) затруднение на закуску. Поскольку операции импортирования выполняют операторы из файла от начала до конца, вы должны проявлять осмотрительность при использовании модулей, которые импортируют друг друга. Такие операции импортирования часто называют рекурсивными, но рекурсия в действительности не происходит (фактически здесь лучше бы подошел термин циклические) — операции импортирования подобного рода не увязают в бесконечных циклах импортирования. Однако из-за того, что не все операторы в модуле оказываются выполненными, когда он импортирует другой модуль, некоторые имена могут пока не существовать.

Если вы применяете import для получения модуля как единого целого, тогда вероятно проблема не возникнет; имена модуля не будут доступны до тех пор, пока вы не уточните их для извлечения их значений, а к этому моменту модуль, скорее всего, уже завершен. Но если вы используете from, чтобы извлечь специфические имена, то вы должны помнить о том, что будете иметь доступ только к тем именам из данного модуля, которые уже были присвоены, когда запустилась рекурсивная операция импортирования.

Например, рассмотрим показанные далее модули recur1 и recur2. В модуле recur1 присваивается имя X и затем перед присваиванием имени Y импортируется модуль recur2. В этой точке recur2 может извлечь recur1 как единое целое с помощью оператора import — он уже существует во внутренней таблице модулей Python, которая делает его импортируемым и также препятствует зациклыванию операций импортирования. Но если в модуле recur2 применяется from, то он будет в состоянии видеть только имя X; имя Y, которое присваивается позже оператора import в recur1, еще не существует, а потому вы получите ошибку:

# recur1.py
X = 1
import recur2 # Запустить модуль recur2 прямо сейчас, когда он не существует
Y = 2

# recur2.py
from recur1 import X   # Нормально: имя X уже присвоено
from recur1 import Y   # Ошибка: имя Y пока не существует

C:\code> py -3
Traceback (most recent call last):