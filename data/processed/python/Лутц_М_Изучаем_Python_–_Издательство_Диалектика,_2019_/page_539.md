---
source_image: page_539.png
page_number: 539
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 35.34
tokens: 7834
characters: 2978
timestamp: 2025-12-24T01:24:13.281447
finish_reason: stop
---

Поскольку каждая настроенная версия запоминает первую встроенную версию в собственной объемлющей области видимости, по своей природе они могут даже вкладываться способами, которые глобальные переменные не способны поддерживать — каждый вызов функции замыкания makeopen запоминает собственные версии id и original, так что допускается запускать множество настроенных версий:

```python
>>> makeopen('eggs')      # Вложенные настроенные версии тоже работают!
>>> F = open('script2.py') # Из-за того, что каждая сохраняет
                           # собственное состояние
Custom open call 'eggs': ('script2.py',) {}
Custom open call 'spam': ('script2.py',) {}
>>> F.read()
'import sys\nprint(sys.path)\nx = 2\nprint(x ** 32)\n'
```

В том виде, как есть, наша функция просто добавляет к встроенной функции вывод трассировки возможно вложенного вызова, но общая методика способна иметь и другие применения. Эквивалент на основе классов может требовать большего объема кода, потому что ему необходимо сохранять значения id и original явно в атрибутах объекта — но для его реализации нужны знания, которые пока отсутствуют, а потому отложим данную тему до части VI и приведем лишь обзор:

```python
import builtins

class makeopen:    # См. часть VI: вызов захватывает self()
    def __init__(self, id):
        self.id = id
        self.original = builtins.open
        builtins.open = self
    def __call__(self, *pargs, **kargs):
        print('Custom open call %r:' % self.id, pargs, kargs)
        return self.original(*pargs, **kargs)
```

Здесь следует отметить, что классы могут быть более явными, но также требовать написания большего объема кода, когда единственной целью является сохранение состояния. Мы увидим дополнительные сценарии использования позже, особенно когда займемся исследованием декораторов в главе 39, где обнаружится, что замыкания в определенных ролях предпочтительнее классов.

Резюме

В главе вы изучили одну из двух ключевых концепций, связанных с функциями: области видимости, которые определяют, каким образом ищутся переменные, когда на них производится ссылка. Вы узнали, что переменные считаются локальными в определениях функций, в которых им выполняется присваивание, если только они специально не объявлены как глобальные или нелокальные. Мы также исследовали ряд более сложных концепций, касающихся областей видимости, включая области видимости вложенных функций и атрибуты функций. Наконец, мы взглянули на несколько универсальных идей проектирования, в том числе избегание применения глобальных имен и межфайловых изменений.

В следующей главе мы продолжим наш тур по функциям рассмотрением второй ключевой концепции, связанной с функциями: передачи аргументов. Как вы увидите, аргументы передаются в функцию по присваиванию, но Python также предлагает инструменты, которые позволяют функциям быть гибкими в плане передачи элементов. Но прежде чем двигаться дальше, закрепите пройденный материал этой главы, ответив на контрольные вопросы.