---
source_image: page_140.png
page_number: 140
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 35.46
tokens: 7936
characters: 2836
timestamp: 2025-12-24T01:11:20.842692
finish_reason: stop
---

представляет неформатированные байтовые значения (включая закодированный текст); и в целях совместимости литералы Unicode из Python 2.X поддерживаются в Python 3.3 и последующих версиях (они трактуются так же, как обычные строки str из Python 3.X):

    >>> 'sp\xc4m'        # Python 3.X: обычные строки str являются текстом Unicode
    'spAm'
    >>> b'a\x01c'        # Строки bytes - это данные, основанные на байтах
    b'a\x01c'
    >>> u'sp\u00c4m'    # Литералы Unicode из Python 2.X работают в Python 3.3+:
    # просто строка str
    'spAm'

В Python 2.X обычная строка str поддерживает строки 8-битных символов (в том числе текст ASCII) и неформатированные байтовые значения; отдельный строковый тип unicode представляет текст; в целях совместимости байтовые литералы Python 3.X поддерживаются в Python 2.6 и последующих версиях (они трактуются так же, как обычные строки str из Python 2.X):

    >>> print u'sp\xc4m' # Python 2.X: строки Unicode являются отдельным типом
    spAm
    >>> 'a\x01c'          # Обычные строки str содержат текст/данные,
    # основанные на байтах
    'a\x01c'
    >>> b'a\x01c'        # Байтовые литералы из Python 3.X работают в Python 2.6+:
    # просто строка str
    'a\x01c'

Формально в Python 2.X и 3.X строки, отличающиеся от Unicode, представляют собой последовательности 8-битных байтов, которые выводятся в виде символов ASCII, когда это возможно, а строки Unicode — последовательности кодовых точек Unicode (идентифицирующих чисел для символов, которые вовсе не обязательно отображаются на одиночные байты при кодировании в файлах или хранении в памяти). На самом деле понятие байтов неприменимо к Unicode: определенные кодировки содержат кодовые точки, слишком большие, чтобы уместиться в байт, и даже простой текст в 7-битном ASCII не выделяет один байт на символ для ряда кодировок и схем хранения в памяти:

    >>> 'spam'           # Символы могут занимать 1, 2 или 4 байта в памяти
    'spam'
    >>> 'spam'.encode('utf8')   # В UTF-8 кодируется как 4 байта в файлах
    b'spam'
    >>> 'spam'.encode('utf16')  # Но в UTF-16 кодируется как 10 байтов
    b'\xff\xfe\x00p\x00a\x00m\x00'

Версии Python 3.X и 2.X поддерживают и встречавшийся ранее строковый тип bytearray, который по существу является строкой bytes (строкой str в Python 2.X), поддерживающей большинство операций изменения на месте объекта списка.

В версиях Python 3.X и 2.X поддерживается кодирование символов, отличающихся от ASCII, с помощью шестнадцатеричной \x, короткой \u и длинной \U управляющих последовательностей Unicode, а также файловых кодировок, которые объявлены в файлах исходного кода программы. Вот три способа кодирования символа, отличающегося от ASCII, в Python 3.X (чтобы увидеть то же самое в Python 2.X, добавьте ведущий символ u и print):

    >>> 'sp\xc4\u00c4\u0000000c4m'
    'spAAAm'