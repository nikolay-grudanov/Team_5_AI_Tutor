---
source_image: page_511.png
page_number: 511
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 27.43
tokens: 7774
characters: 2541
timestamp: 2025-12-24T01:23:12.465956
finish_reason: stop
---

извлекаться как атрибуты объектов. Поскольку Python ищет указанные имена в объединяющих функциях, но не в объединяющих классах, правило LEGB по-прежнему применимо к объектно-ориентированному коду.

Пример области видимости

Давайте разберем более крупный пример, который демонстрирует идеи, лежащие в основе областей видимости. Предположим, что в файле модуля находится следующий код:

# Глобальная область видимости
X = 99                # Имена X и func присваиваются в модуле: глобальные
def func(Y):
    # Локальная область видимости
    Z = X + Y           # Имя X является глобальным
    return Z
func(1)                # Имя func в модуле: result=100

Для выполнения своей работы модуль и содержащаяся в нем функция задействуют несколько имен. Используя правила областей видимости Python, мы можем классифицировать имена, как описано далее.

Глобальные имена: X, func

Имя X является глобальным, потому что оно присваивается на верхнем уровне файла модуля; на него можно ссылаться внутри функции как на простую неуточненную переменную, не объявляя глобальным. Имя func глобально по той же причине; оператор def присваивает объект функции имени func на верхнем уровне модуля.

Локальные имена: Y, Z

Имена Y и Z являются локальными в функции (и существуют только в период ее выполнения), т.к. им обоим присваиваются значения в определении функции: Z посредством оператора =, а Y из-за того, что аргументы всегда передаются по присваиванию.

Логическое обоснование такой схемы отделения имен состоит в том, что локальные переменные служат временными именами, которые необходимы лишь в течение выполнения функции. Скажем, в предыдущем примере аргумент Y и результат сложения Z существуют только внутри функции; упомянутые имена не пересекаются с пространством имен вмещающего модуля (или любой другой функции, если уж на то пошло). В действительности по завершении вызова функции локальные переменные удаляются из памяти, а объекты, на которые они ссылаются, могут быть подвергнуты сборке мусора, если на них нет ссылок где-то в другом месте. Это автоматический внутренний шаг, но он помогает минимизировать расход памяти.

Разграничение локальные/глобальные также облегчает понимание функций, т.к. большинство имен, используемых функцией, возникает в самой функции, а не каком-то произвольном месте модуля. Кроме того, поскольку вы можете быть уверены в том, что локальные имена не будут изменяться другой функцией в программе, они упрощают отладку и модификацию программ. Функции представляют собой самодостаточные программные единицы.