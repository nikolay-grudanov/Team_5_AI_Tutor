---
source_image: page_202.png
page_number: 202
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 35.89
tokens: 7850
characters: 2498
timestamp: 2025-12-24T01:13:25.263633
finish_reason: stop
---

>>> {c * 4 for c in 'spam'}    # Множество накопленных результатов выражения
{'pppp', 'aaaa', 'ssss', 'mmmm'}
>>> {c * 4 for c in 'spamham'}
{'pppp', 'aaaa', 'hhhh', 'ssss', 'mmmm'}
>>> S = {c * 4 for c in 'spam'}
>>> S | {'mmmm', 'xxxx'}
{'pppp', 'xxxx', 'mmmm', 'aaaa', 'ssss'}
>>> S & {'mmmm', 'xxxx'}
{'mmmm'}

Поскольку остаток включений опирается на концепции, рассматривать которые мы пока еще не готовы, отложим исследование дальнейших деталей до будущих глав книги. В главе 8 мы встретим первого собрата включения множества в Python 3.x и 2.7, включение словаря, а позже обсудим все включения (списков, множеств и словарей), в частности в главах 14 и 20. Вы узнаете, что все включения поддерживают дополнительный синтаксис, не показанный здесь, в том числе вложенные циклы и проверки if, которые могут оказаться сложными для понимания до тех пор, пока вы не изучите более крупные операторы.

Для чего используются множества?

С операциями над множествами связан ряд распространенных применений, часть которых имеет больше практический, нежели математический характер. Скажем, из-за того, что элементы сохраняются во множестве только однократно, множества допускается использовать для фильтрации дубликатов из коллекций, хотя элементы в ходе процесса могут оказаться переупорядоченными, т.к. в общем случае множества являются неупорядоченными. Коллекцию нужно лишь преобразовать во множество и затем выполнить обратное преобразование (множества разрешено указывать в вызове list, потому что они итерируемы — еще один технический артефакт, который мы разберем позже):

>>> L = [1, 2, 1, 3, 2, 4, 5]
>>> set(L)
{1, 2, 3, 4, 5}
>>> L = list(set(L))    # Удаление дубликатов
[1, 2, 3, 4, 5]
>>> list(set(['yy', 'cc', 'aa', 'xx', 'dd', 'aa']))
['cc', 'xx', 'yy', 'dd', 'aa']

Множества можно также применять для выделения различий в списках, строках и других итерируемых объектах (их необходимо просто преобразовать во множества и получить разность), хотя неупорядоченная природа множеств снова означает, что порядок следования результатов может не совпадать с первоначальным порядком. В последних двух примерах ниже сравниваются списки атрибутов в типах строковых объектов для Python 3.x (в случае Python 2.7 результаты будут другими):

>>> set([1, 3, 5, 7]) - set([1, 2, 4, 5, 6])    # Найти различия в списках
{3, 7}
>>> set('abcdefg') - set('abdghij')    # Найти различия в строках
{'c', 'e', 'f'}
>>> set('spam') - set(['h', 'a', 'm'])    # Найти различия,
    # разнородные типы
{'p', 's'}