---
source_image: page_275.png
page_number: 275
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 32.51
tokens: 7904
characters: 2513
timestamp: 2025-12-24T01:15:45.228437
finish_reason: stop
---

Например, для заданного списка L из двух и более элементов присваивание L[1:2]=[4,5] заменяет один элемент двумя — Python сначала удаляет одноэлементную секцию в [1:2] (начинающуюся со смещения 1 и заканчивающуюся смещением 2, но включающую его), а затем вставляет значения 4 и 5 там, где раньше был удаленный срез.

Такой прием также объясняет, почему второе присваивание по срезу из числа показанных ниже на самом деле является вставкой — Python заменяет пустой срез в [1:1] двумя элементами, и почему третье присваивание по срезу фактически представляет собой удаление — Python удаляет срез (элемент по смещению 1) и затем ничего не вставляет:

```python
>>> L = [1, 2, 3]
>>> L[1:2] = [4, 5]    # Замена/вставка
>>> L
[1, 4, 5, 3]
>>> L[1:1] = [6, 7]    # Вставка (ничего не заменяет)
>>> L
[1, 6, 7, 4, 5, 3]
>>> L[1:2] = []        # Удаление (ничего не вставляет)
>>> L
[1, 7, 4, 5, 3]
```

В действительности присваивание по срезу заменяет целую секцию, или "столбец", одновременно — даже если столбец или его замена является пустой. Поскольку длина последовательности, которая присваивается, не обязана совпадать с длиной присваиваемого среза, присваивание по срезу может использоваться для замены (путем перезаписывания), увеличения (путем вставки) или уменьшения (путем удаления) обрабатываемого списка. Это мощная операция, но откровенно говоря, на практике вы будете встречать ее относительно редко. Часто существуют более прямолинейные и понятные способы для замены, вставки и удаления (скажем, конкатенация и списковые методы insert, pop и remove), которым программисты на Python обычно отдают предпочтение.

С другой стороны, операцию присваивания по срезу можно применять как разновидность конкатенации в начале списка — согласно описанию методов в следующем разделе расширение списка более уместно в его конце:

```python
>>> L = [1]
>>> L[:0] = [2, 3, 4]    # Вставить все на место :0, пустой срез в начале
>>> L
[2, 3, 4, 1]
>>> L[len(L):] = [5, 6, 7] # Вставить все на место len(L):, пустой срез в конце
>>> L
[2, 3, 4, 1, 5, 6, 7]
>>> L.extend([8, 9, 10]) # Вставить все в конце, именованный метод
>>> L
[2, 3, 4, 1, 5, 6, 7, 8, 9, 10]
```

Вызовы списковых методов

Подобно строкам списковые объекты Python также поддерживают вызовы методов, специфичных для типов, многие из которых изменяют обрабатываемый список на месте:

```python
>>> L = ['eat', 'more', 'SPAM!']
>>> L.append('please')    # Вызов метода дополнения: добавляет элемент в конец
>>> L
['eat', 'more', 'SPAM!', 'please']
```