---
source_image: page_219.png
page_number: 219
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 31.66
tokens: 7846
characters: 2827
timestamp: 2025-12-24T01:13:48.931954
finish_reason: stop
---

Резюме

В главе мы более подробно рассмотрели модель динамической типизации Python — т.е. способ, которым Python автоматически отслеживает типы объектов, не требуя от нас написания операторов объявлений в сценариях. Попутно вы узнали, каким образом переменные и объекты связываются ссылками в Python; также обсуждалась идея сборки мусора, было показано, как разделяемые ссылки могут влиять на множество переменных, и приведены объяснения воздействия ссылок на понятие равенства в Python.

Поскольку в Python имеется лишь одна модель присваивания и оттого, что присваивание вездесуще в языке, важно понять данную модель, прежде чем двигаться дальше. Следующие контрольные вопросы должны помочь вам закрепить некоторые идеи, изложенные в главе. Затем мы возобновим наш тур по основным объектам, перейдя к рассмотрению строк.

Проверьте свои знания: контрольные вопросы

1. Взгляните на следующие три оператора. Изменяют ли они значение, выводимое для A?
   A = "spam"
   B = A
   B = "shrubbery"

2. Взгляните на приведенные ниже три оператора. Изменяют ли они значение, выводимое для A?
   A = ["spam"]
   B = A
   B[0] = "shrubbery"

3. Как насчет показанных далее трех операторов — изменяется ли A теперь?
   A = ["spam"]
   B = A[:]
   B[0] = "shrubbery"

Проверьте свои знания: ответы

1. Нет: для A по-прежнему выводится "spam". Когда B присваивается строка "shrubbery", все что происходит — переменная B переустанавливается для указания на новый строковый объект. А и В изначально разделяются, т.е. указывают на тот же самый одиночный строковый объект "spam", но в Python два имени никогда не связываются вместе. Таким образом, установка B в другой объект не оказывает влияния на A. Кстати, то же самое справедливо, если бы последним оператором здесь был B = B + 'shrubbery' — конкатенация привела бы к созданию в качестве своего результата нового объекта, который затем был бы присвоен только B. Мы не можем перезаписывать строку (либо число или кортеж) на месте, потому что строки неизменяемы.

2. Да: теперь для A выводится ["shrubbery"]. Формально мы на самом деле не изменяем ни A, ни B; взамен мы модифицируем часть объекта, на который ссылаются обе переменные (указывают на него), перезаписывая этот объект на месте через переменную B. Поскольку A ссылается на тот же самый объект, что и B, обновление отражается также в A.

3. Нет: для A по-прежнему выводится ["spam"]. Присваивание на месте через B на этот раз не оказывает воздействия, т.к. выражение среза создает копию спискового объекта до его присваивания переменной B. После второго оператора присваивания существуют два разных списковых объекта, которые имеют одинаковые значения (в Python они дают True при выполнении операции ==, но не is). Третий оператор изменяет значение спискового объекта, на который указывает B, но не того, на который указывает A.