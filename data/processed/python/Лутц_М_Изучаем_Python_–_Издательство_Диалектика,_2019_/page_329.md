---
source_image: page_329.png
page_number: 329
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 35.79
tokens: 7871
characters: 2930
timestamp: 2025-12-24T01:17:39.318874
finish_reason: stop
---

Сравнения, равенство и истинность

Все объекты Python также реагируют на сравнения: проверки на предмет равенства, проверки относительных величин и т.п. Сравнения Python всегда инспектируют все части составных объектов, прежде чем может быть определен результат. На самом деле, когда присутствуют вложенные объекты, Python автоматически обходит структуры данных для применения сравнений слева направо и настолько глубоко, насколько нужно. Первое отличие, обнаруженное по пути, и определит результат сравнения.

Такое действие иногда называют рекурсивным сравнением — одно и то же сравнение, запрошенное на объектах верхнего уровня, применяется ко всем вложенным объектам, ко всем их вложенным объектам и т.д., пока не будет найден результат. Позже в книге (в главе 19) вы увидите, как писать собственные рекурсивные функции, которые работают похожим образом на вложенных структурах. А пока подумайте о сравнении всех связанных страниц на двух веб-сайтах, если вас интересует модель таких структур и причина написания рекурсивных функций для их обработки.

В отношении основных типов рекурсия происходит автоматически. Например, сравнение списковых объектов автоматически сравнивает все их компоненты до тех пор, пока не будет найдено отличие или не будет достигнут конец:

```python
>>> L1 = [1, ('a', 3)]    # Одинаковые значения, уникальные объекты
>>> L2 = [1, ('a', 3)]
>>> L1 == L2, L1 is L2    # Эквивалентны? Тот же самый объект?
(True, False)
```

Здесь L1 и L2 присвоены списки, которые являются эквивалентными, но отдельными объектами. Как кратко объяснялось в главе 6, из-за природы ссылок Python существуют два способа проверки на равенство.

• Операция == проверяет эквивалентность значений. Python выполняет проверку эквивалентности, рекурсивно сравнивая все вложенные объекты.
• Операция is проверяет идентичность объектов. Python проверяет, являются ли два объекта на самом деле одним и тем же объектом (т.е. располагаются по тому же самому адресу в памяти).

В предыдущем примере L1 и L2 проходят проверку == (они имеют эквивалентные значения, потому что все их компоненты эквивалентны), но не проходят проверку is (они ссылаются на два разных объекта и, следовательно, на два разных участка памяти). Однако взгляните, что происходит для коротких строк:

```python
>>> S1 = 'spam'
>>> S2 = 'spam'
>>> S1 == S2, S1 is S2
(True, True)
```

У нас снова должны быть два отдельных объекта, которые имеют одно и то же значение: проверка == должна дать True, а проверка is — False. Но поскольку Python внутреннее кеширует и повторно использует некоторые строки с целью оптимизации, в действительности в памяти присутствует только одна строка 'spam', разделяемая переменными S1 и S2, поэтому проверка идентичности is сообщит результат True. Чтобы получить нормальное поведение, нам понадобятся более длинные строки:

```python
>>> S1 = 'a longer string'
>>> S2 = 'a longer string'
>>> S1 == S2, S1 is S2
(True, False)
```