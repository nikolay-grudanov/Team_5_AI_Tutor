---
source_image: page_235.png
page_number: 235
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 27.47
tokens: 7787
characters: 2515
timestamp: 2025-12-24T01:14:21.226913
finish_reason: stop
---

Можно также использовать отрицательный страйд для накапливания элементов в противоположном порядке. Скажем, выражение среза "hello"[::−1] возвращает новую строку "olleh" — первые две границы, как и ранее, по умолчанию устанавливаются в 0 и длину последовательности, а страйд −1 указывает, что срез должен идти справа налево, а не слева направо, что обычно принято. По этой причине результатом оказывается обращение последовательности:

```python
>>> s = 'hello'
>>> s[::−1]    # Смена порядка следования элементов на противоположный
'olleh'
```

При отрицательном страйде смысл первых двух границ по существу изменяется на противоположный. Таким образом, срез S[5:1:−1] извлекает элементы со второго по пятый в обратном порядке (результат содержит элементы по смещениям 5, 4, 3 и 2):

```python
>>> s = 'abcdefg'
>>> s[5:1:−1]    # Смысл границ изменяется
'fdec'
```

Пропуск и обращение порядка вроде показанного являются распространенными сценариями применения срезов с тремя пределами, но за дополнительными деталями обращайтесь к руководству по стандартной библиотеке Python (или проведите несколько экспериментов в интерактивной подсказке). Мы еще вернемся к срезам с тремя пределами, когда будем рассматривать оператор цикла for.

Позже в книге вы также узнаете, что нарезание эквивалентно индексации с помощью объекта среза, что важно для разработчиков классов, стремящихся поддерживать обе операции:

```python
>>> 'spam'[1:3]    # Синтаксис нарезания
'pa'
>>> 'spam'[slice(1, 3)]    # Индексация посредством объектов срезов
'pa'
>>> 'spam'[::−1]
'maps'
>>> 'spam'[slice(None, None, −1)]
'maps'
```

Что потребует внимания: срезы

Повсюду в книге я буду включать врезки с общепринятыми сценариями применения (вроде этой), чтобы дать вам представление о том, как некоторые из описываемых языковых средств обычно используются в реальных программах. Поскольку вы не в состоянии оценить смысл реалистичных сценариев применения до тех пор, пока не увидите большую часть картины Python, такие врезки неизбежно будут содержать много ссылок на пока еще не рассмотренные темы. По большому счету вы должны воспринимать их как предварительное ознакомление с тем, как абстрактные языковые концепции могут оказаться полезными при решении распространенных задач программирования.

Например, позже будет показано, что аргументы командной строки при запуске программы Python доступны в атрибуте argv встроенного модуля sys:

# Файл echo.py
import sys
print(sys.argv)

% python echo.py -a -b -c
['echo.py', '-a', '-b', '-c']