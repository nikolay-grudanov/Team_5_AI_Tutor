---
source_image: page_441.png
page_number: 441
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 32.82
tokens: 7769
characters: 2786
timestamp: 2025-12-24T01:21:13.844693
finish_reason: stop
---

Вспомните из главы 9, что открытые файловые объекты имеют метод по имени readline, который читает из файла одну строку текста за раз — при каждом вызове метода readline мы переходим на следующую строку. При достижении конца файла возвращается пустая строка, которую можно выявлять для выхода из цикла:

```python
>>> f = open('script2.py')    # Чтение четырехстрочного файла сценария
                              #   в текущем каталоге
>>> f.readline()              # При каждом вызове метод readline загружает одну строку
'import sys\n'
>>> f.readline()
'print(sys.path)\n'
>>> f.readline()
'x = 2\n'
>>> f.readline()              # Последние строки могут иметь или не иметь \n
'print(x ** 32)\n'
>>> f.readline()              # При достижении конца файла возвращается пустая строка
```

Однако файлы также располагают методом по имени __next__ в Python 3.x (и next в Python 2.x), который имеет почти идентичный эффект — каждый раз, когда __next__ вызывается, он возвращает следующую строку из файла. Единственное заметное отличие в том, что при достижении конца файла метод __next__ генерирует встроенное исключение StopIteration, а не возвращает пустую строку:

```python
>>> f = open('script2.py')    # При каждом вызове метод __next__
                              #   также загружает одну строку
>>> f.__next__()              # Но при достижении конца файла генерирует исключение
'import sys\n'
>>> f.__next__()              # Используйте f.next() в Python 2.x
'print(sys.path)\n'
>>> f.__next__()
'x = 2\n'
>>> f.__next__()
'print(x ** 32)\n'
>>> f.__next__()
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
StopIteration
```

Данный интерфейс является большей частью того, что мы называем протоколом итерации в Python. Любой объект с методом __next__ для перехода на следующий результат, который генерирует исключение StopIteration при достижении конца серии результатов, в Python считается итератором. По любому такому объекту можно также выполнять проход с помощью цикла for или другого итерационного инструмента, потому что все внутренне итерационные инструменты обычно работают, вызывая __next__ на каждой итерации и перехватывая исключение StopIteration для выяснения, когда выходить. Как вскоре будет показано, для некоторых объектов полный протокол включает дополнительный первый шаг, связанный с вызовом iter, но для файлов он не требуется.

Совокупный эффект описанной магии состоит в том, что согласно утверждению, сделанному в главах 9 и 13, наилучший на сегодняшний день способ чтения текстового файла строка за строкой — не читать его вообще, а взамен позволить циклу for автоматически вызывать метод __next__ для перехода к следующей строке на каждой итерации. В ходе дела итератор файлового объекта будет выполнять работу по автоматической