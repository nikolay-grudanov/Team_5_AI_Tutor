---
source_image: page_622.png
page_number: 622
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 23.63
tokens: 7547
characters: 1734
timestamp: 2025-12-24T01:26:30.430617
finish_reason: stop
---

'SSSS'
    >>> next(I1)
    'PPPP'
    >>> I2 = iter(G)      # Второй итератор находится в той же самой позиции!
    >>> next(I2)
    'AAAA'

Более того, как только любая итерация доходит до завершения, все результаты оказываются израсходованными — чтобы начать сначала, нам придется создать новый генератор:

    >>> list(I1)                # Собирает оставшиеся элементы I1
    ['MMMM']
    >>> next(I2)                # Другие итераторы тоже израсходуются
    StopIteration
    >>> I3 = iter(G)            # То же самое касается новых итераторов
    >>> next(I3)
    StopIteration
    >>> I3 = iter(c * 4 for c in 'SPAM')   # Новый генератор, чтобы начать заново
    >>> next(I3)
    'SSSS'

То же самое остается справедливым для генераторных функций — приведенный ниже эквивалент на основе оператора def поддерживает только один активный итератор и израсходуется после одного прохода:

    >>> def timesfour(S):
    ...     for c in S:
    ...         yield c * 4
    ...
    >>> G = timesfour('spam')      # Генераторные функции работают таким же образом
    >>> iter(G) is G
    True
    >>> I1, I2 = iter(G), iter(G)
    >>> next(I1)
    'ssss'
    >>> next(I1)
    'pppp'
    >>> next(I2)                  # I2 находится в той же позиции, что и I1
    'aaaa'

Такое поведение отличается от поведения ряда встроенных типов, которые поддерживают множество итераторов и проходов, а также отражают изменения на месте в активных итераторах:

    >>> L = [1, 2, 3, 4]
    >>> I1, I2 = iter(L), iter(L)
    >>> next(I1)
    1
    >>> next(I1)
    2
    >>> next(I2)                 # Списки поддерживают множество итераторов
    1
    >>> del L[2:]               # Изменения отражаются в итераторах
    >>> next(I1)
    StopIteration