---
source_image: page_141.png
page_number: 141
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 34.54
tokens: 7915
characters: 3007
timestamp: 2025-12-24T01:11:23.073272
finish_reason: stop
---

Смысл этих значений и способы их использования отличаются между текстовыми строками, которые являются обычными строками в Python 3.X и Unicode в Python 2.X, и байтовыми строками, которые представляют собой байты в Python 3.X и обычные строки в Python 2.X. Для внедрения действительно порядковых целочисленных значений кодовых точек Unicode в текстовые строки могут применяться все управляющие последовательности. Напротив, для внедрения закодированной формы текста в байтовые строки используются только шестнадцатеричные управляющие последовательности \x, но не декодированные значения кодовых точек — декодированные байты совпадают с кодовыми точками лишь для некоторых кодировок и символов:

```python
>>> '\u00A3', '\u00A3'.encode('latin1'), b'\xA3'.decode('latin1')
('£', b'\xa3', '£')
```

Заметная разница заключается в том, что Python 2.X позволяет смешивать в выражениях обычные строки и строки Unicode при условии, что обычные строки представлены в кодировке ASCII; в противоположность этому Python 3.X имеет более строгую модель, которая никогда не разрешает смешивать обычные и байтовые строки без явного преобразования:

| u'x' + b'y' | # Работает в Python 2.X (где символ b необязателен и игнорируется) |
| u'x' + 'y' | # Работает в Python 2.X: u'xy' |
| u'x' + b'y' | # Не работает в Python 3.3 (где символ и необязателен и игнорируется) |
| u'x' + 'y' | # Работает в Python 3.3: 'xy' |
| 'x' + b'y'.decode() | # Работает в Python 3.X, если декодировать байты в строку: 'xy' |
| 'x'.encode() + b'y' | # Работает в Python 3.X, если закодировать строку в байты: b'xy' |

Помимо рассмотренных строковых типов обработка Unicode сводится главным образом к передаче текстовых данных в и из файлов — текст кодируется в байты, когда сохраняется в файле, и декодируется в символы (кодовые точки), когда читается обратно в память. После загрузки текст обычно обрабатывается как строки только в декодированной форме.

Тем не менее, из-за такой модели в Python 3.X файлы также зависят от содержимого: текстовые файлы реализуют именованные кодировки, принимают и возвращают строки str, но двоичные файлы взамен имеют дело со строками bytes для неформатированных двоичных данных. В Python 2.X обычным содержимым файлов являются байты str, а специальный модуль codecs обрабатывает Unicode и представляет содержимое с помощью типа unicode.

Далее в главе мы еще вернемся к применению кодировки Unicode в файлах и обсудим ее позже в книге. Она будет кратко затрагиваться в примере с символами валют, рассматриваемом в главе 25, но более подробно исследуется в части книги, посвященной более сложным темам. Кодировка Unicode важна в ряде областей, но многим программистам достаточно лишь беглого знакомства с ней. Если вы работаете только с текстом ASCII, тогда положение дел со строками и файлами по большому счету одинаково в Python 2.X и 3.X. Если же вы — новичок в программировании, то можете спокойно отложить изучение большинства деталей Unicode до тех пор, пока не овладеете основами использования строк.