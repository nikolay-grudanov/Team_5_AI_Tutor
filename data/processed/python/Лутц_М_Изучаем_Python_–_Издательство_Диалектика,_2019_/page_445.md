---
source_image: page_445.png
page_number: 445
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 25.35
tokens: 7569
characters: 1957
timestamp: 2025-12-24T01:21:13.902262
finish_reason: stop
---

словарными методами — чтобы избежать создания полных результирующих списков целиком в памяти.

В реальном коде первый шаг протокола становится очевидным, если взглянуть на то, как циклы for внутренне обрабатывают встроенные типы последовательностей, такие как списки:

```python
>>> L = [1, 2, 3]
>>> I = iter(L)      # Получение объекта итератора из итерируемого объекта
>>> I.__next__()     # Вызов метода next итератора для продвижения
# на следующий элемент
1
>>> I.__next__()     # Или применение I.next() в Python 2.x, next(I) в любой линейке
2
>>> I.__next__()
3
>>> I.__next__()
... текст сообщения об ошибке не показан...
StopIteration
```

Для файлов такой начальный шаг не требуется, поскольку файловый объект является итератором сам по себе. Из-за того, что файлы поддерживают только одну итерацию (они не допускают перемещение в обратном направлении, чтобы поддерживать множество активных просмотров), файловый объект имеет собственный метод __next__ и не нуждается в возвращении особого объекта, который предоставлял бы этот метод:

```python
>>> f = open('script2.py')
>>> iter(f) is f
True
>>> iter(f) is f.__iter__()
True
>>> f.__next__()
'import sys\n'
```

Тем не менее, списки и многие другие встроенные объекты не являются итераторами сами по себе, потому что они поддерживают множество открытых итераций — например, они могут участвовать в нескольких итерациях во вложенных циклах, причем находиться в совершенно разных позициях. Для таких объектов мы обязаны вызывать метод iter для запуска итерации:

```python
>>> L = [1, 2, 3]
>>> iter(L) is L
False
>>> L.__next__()
AttributeError: 'list' object has no attribute '__next__'
Ошибка атрибута: объект list не имеет атрибута __next__
>>> I = iter(L)
>>> I.__next__()
1
>>> next(I)    # То же, что и I.__next__()
2
```

Ручная итерация

Хотя итерационные инструменты Python вызывают такие функции автоматически, мы можем также использовать их для применения протокола итерации вручную.