---
source_image: page_464.png
page_number: 464
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 26.78
tokens: 7634
characters: 2086
timestamp: 2025-12-24T01:21:48.866124
finish_reason: stop
---

>>> for k in D.keys(): print(k, end=' ') # Все итерационные контексты
# применяют итераторы автоматически
...
a b c

Как и со всеми итерируемыми объектами, производящими значения по запросу, вы всегда можете заставить словарное представление Python 3.X строить реальный список, передавая его встроенной функции list. Однако поступать так обычно не требуется, кроме как для отображения результатов в интерактивной подсказке или для применения списковых операций вроде индексации:

>>> K = D.keys()
>>> list(K)    # По-прежнему можно при необходимости создать реальный список
['a', 'b', 'c']
>>> V = D.values()    # То же самое касается представлений values() и items()
>>> V
dict_values([1, 2, 3])
>>> list(V) # Для отображения либо индексации как списка необходим вызов list()
[1, 2, 3]
>>> V[0]
TypeError: 'dict_values' object does not support indexing
Ошибка типа: объект dict_values не поддерживает индексацию
>>> list(V)[0]
1
>>> list(D.items())
[('a', 1), ('b', 2), ('c', 3)]
>>> for (k, v) in D.items(): print(k, v, end=' ')
...
a 1 b 2 c 3

Вдобавок словари Python 3.X по-прежнему сами являются итерируемыми, имея итератор, который возвращает следующие один за другим ключи. Таким образом, в этом контексте вызывать keys напрямую требуется нечасто:

>>> D
{'a': 1, 'b': 2, 'c': 3}
# Словари все еще производят итератор
# На каждой итерации возвращает очередной ключ
>>> I = iter(D)
>>> next(I)
'a'
>>> next(I)
'b'
>>> for key in D: print(key, end=' ')    # По-прежнему нет необходимости
# вызывать keys() для итерации
...
# Но keys также является итерируемым объектом в Python 3.X!
a b c

Запомните еще раз, что поскольку keys больше не возвращает список, традиционный кодовый шаблон для просмотра словаря по отсортированным ключам в Python 3.X работать не будет. Взамен сначала понадобится преобразовать представления ключей посредством вызова list или использовать вызов sorted либо на представлении ключей, либо на самом словаре, как показано ниже. Мы видели это в главе 8, но данный аспект достаточно важен для программистов на Python 2.X, чтобы продемонстрировать его снова: