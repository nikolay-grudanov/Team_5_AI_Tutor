---
source_image: page_769.png
page_number: 769
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 53.03
tokens: 7960
characters: 3102
timestamp: 2025-12-24T01:31:29.822728
finish_reason: stop
---

Ниже показано, как выглядит вывод этого тестового файла в IDLE версии Python 3.7 и в других надлежащим образом сконфигурированных контекстах. В Python 2.X тестовый файл работает точно так же, поскольку он выводит и кодирует строки переносимым образом. Как упоминалось в главе 11, импортирование __future__ включает в Python 2.X вызовы print из Python 3.X. Кроме того, в главе 4 объяснялось, что байтовые литералы b'...' из Python 3.X в Python 2.X рассматриваются как простые строки, а Unicode-литералы u'...' из Python 2.X в Python 3.X трактуются как нормальные строки, начиная с версии Python 3.3.

$54,321.99 54,321.99
£54,321.99 £54,321.99
£54,321.99
€54,321.99 €54,321.99
¤54,321.99

Если это работает на вашем компьютере, то вполне вероятно вы можете пропустить следующие несколько абзацев. Однако в зависимости от имеющихся настроек интерфейса и системы приведение кода в работоспособное состояние может требовать добавочных шагов. На моей машине он ведет себя корректно, когда Python и средства отображения синхронизированы, но в обычном окне командной строки Windows знак евро и обобщенный символ валюты в последних двух строках выводятся с ошибками.

В частности, тестовый сценарий всегда выполняется и производит вывод в графическом пользовательском интерфейсе IDLE из обеих линеек Python 3.X и Python 2.X благодаря хорошей поддержке отображения символов Unicode на их визуальные представления. Он также работает, как заявлено, в Python 3.X на компьютере Windows, если перенаправить вывод в файл, который затем открыть в Блокноте, потому что Python 3.X кодирует содержимое в стандартном формате Windows, который воспринимается Блокнотом:

c:\code> formats_currency.py > temp
c:\code> notepad temp

Тем не менее, это не будет работать в Python 2.X, поскольку по умолчанию Python пытается декодировать выведенный текст как ASCII. Чтобы отображать символы, отличающиеся от ASCII, непосредственно в окне командной строки Windows, на некоторых компьютерах может понадобиться изменить кодовую страницу Windows (используемую для визуализации символов), а также установить переменную среды PYTHONIOENCODING, относящуюся к Python (применяемую в качестве кодировки текста в стандартных потоках данных, в том числе при переводе символов в байты при выводе), в распространенный формат Unicode вроде UTF-8:

c:\code> chcp 65001 # Консоль соответствует Python
c:\code> set PYTHONIOENCODING=utf-8 # Python соответствует консоли
c:\code> formats_currency.py > temp # Python 3.X и 2.X записывают текст UTF-8
c:\code> type temp # Консоль отображает его корректно
c:\code> notepad temp # Блокнот тоже распознает UTF-8

На ряде платформ и даже в некоторых дистрибутивах Windows, возможно, вам не придется выполнять описанные выше шаги. Мне пришлось, потому что кодовая страница в моей системе установлена в 437 (символы для США), но ваша кодовая страница может быть другой.

Довольно тонкая причина того, что данный тест вообще работает в Python 2.X, заключается в том, что Python 2.X разрешает смешивать нормальные строки и строки Unicode при условии наличия в нормальных строках только 7-битных символов ASCII.