---
source_image: page_374.png
page_number: 374
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 25.67
tokens: 7717
characters: 2302
timestamp: 2025-12-24T01:18:55.740162
finish_reason: stop
---

>>> x = 1
>>> x = x + 1      # Традиционное присваивание
>>> x
2
>>> x += 1         # Дополненное присваивание
>>> x
3

Когда дополненная форма применяется к последовательности, подобной строке, она взамен выполняет конкатенацию. Таким образом, вторая строка здесь эквивалентна более длинному оператору S = S + "SPAM":

    >>> S = "spam"
    >>> S += "SPAM"      # Подразумевается конкатенация
    >>> S
'spamSPAM'

Как показано в табл. 11.2, существуют аналогичные дополненные формы присваивания для большинства бинарных операций выражений Python (т.е. операций со значениями в левой и правой сторонах). Скажем, X *= Y умножает и присваивает, X >>= Y сдвигает вправо и присваивает и т.д. Деление с округлением в меньшую сторону (X //= Y) было добавлено в версии Python 2.2.

Дополненные присваивания обладают тремя преимуществами¹.

• Уменьшается объем набора на клавиатуре. Нужно ли продолжать?

• Левая сторона должна оцениваться только раз. В X += Y имя X может быть сложным выражением с объектами. В дополненной форме его код потребуется выполнить лишь однократно. Однако в длинной форме, X = X + Y, имя X встречается два раза и должно быть оценено дважды. По этой причине дополненные присваивания обычно выполняются быстрее.

• Оптимальная методика выбирается автоматически. То есть для объектов, которые поддерживают изменения на месте, дополненные формы автоматически выполняют операции изменения на месте взамен более медленного создания их копий.

Последний пункт требует чуть больших пояснений. В случае дополненных присваиваний в качестве оптимизации к изменяемым объектам могут применяться операции изменения на месте. Вспомните, что списки допускают расширение разнообразными путями. Чтобы добавить одиночный элемент в конец списка, мы можем использовать конкатенацию или вызов append:

    >>> L = [1, 2]
    >>> L = L + [3]      # Конкатенация: медленнее
    >>> L
    [1, 2, 3]
    >>> L.append(4)      # Быстрее, но на месте
    >>> L
    [1, 2, 3, 4]

¹ Программисты на C/C++ заметят, что хотя Python теперь поддерживает операторы вроде X += Y, он все еще не располагает операциями инкремента/декремента (например, X++, --X). Они не вполне укладываются в объектную модель Python, потому что в Python отсутствует понятие изменений на месте для неизменяемых объектов, таких как числа.