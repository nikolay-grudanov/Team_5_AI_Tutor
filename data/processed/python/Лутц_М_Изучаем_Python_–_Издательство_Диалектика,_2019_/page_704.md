---
source_image: page_704.png
page_number: 704
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 36.46
tokens: 7939
characters: 3032
timestamp: 2025-12-24T01:29:15.774857
finish_reason: stop
---

Из-за того, что имена модулей становятся именами переменных внутри программы Python (без суффикса .py), они также обязаны следовать обычным правилам именования переменных, обрисованным в главе 11. Скажем, вы можете создать файл модуля по имени if.py, но будете не в состоянии его импортировать, т.к. if является зарезервированным словом — оператор import if приведет к синтаксической ошибке. На самом деле правилам именования переменных, представленным в главе 11, должны подчиняться как имена файлов модулей, так и имена каталогов, используемых в операциях импортирования пакетов (обсуждаются в следующей главе); например, они могут содержать только буквы, цифры и подчеркивания. Кроме того, каталоги пакетов также не могут содержать синтаксис, специфичный для платформы, такой как пробелы в своих именах.

Когда модуль импортируется, Python отображает внутреннее имя модуля на внешнее имя файла, добавляя путь к каталогу из пути поиска модулей в начало и .py или другое расширение в конец. Скажем, модуль по имени M в итоге отображается на внешний файл <каталог>\M.<расширение>, который содержит код модуля.

Другие виды модулей

Как упоминалось в предыдущей главе, модуль Python возможно также создавать за счет написания кода на внешнем языке вроде C, C++ и других (например, на Java в реализации Jython). Такие модули называются модулями расширений и, как правило, применяются для помещения в оболочки внешних библиотек, подлежащих использованию в сценариях Python. Когда модули расширений импортируются в коде Python, они выглядят и ведут себя точно так же, как модули, реализованные в виде файлов исходного кода Python — доступ к ним производится посредством операторов import, а сами они предоставляют функции и объекты в форме атрибутов модулей. Модули расширений в этой книге не рассматриваются, так что дополнительные сведения ищите в стандартных руководствах по Python или в книгах, подобных Programming Python (http://www.oreilly.com/catalog/9780596158101).

Использование модулей

Клиенты могут задействовать только что написанный простой файл модуля за счет выполнения оператора import или from. Оба оператора ищут, компилируют и запускают код файла модуля, если он еще не был загружен. Главное отличие между ними в том, что import извлекает модуль как единое целое, поэтому для извлечения имен модуля они должны уточняться именем самого модуля; в противоположность ему from извлекает (или копирует) специфические имена из модуля.

Давайте посмотрим, как все выглядит в коде. Все последующие примеры приводят к вызову функции printer, определенной в файле модуля module1.py из предыдущего раздела, но различными способами.

Оператор import

В первом примере имя module1 служит двум разным целям — оно идентифицирует внешний файл, подлежащий загрузке, и оно становится переменной в сценарии, которая ссылается на объект модуля после того, как файл загружен:

>>> import module1    # Получить модуль как единое целое (один или больше)
>>> module1.printer('Hello world!')    # Уточнить, чтобы получить имена
Hello world!