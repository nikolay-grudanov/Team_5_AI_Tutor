---
source_image: page_378.png
page_number: 378
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 33.62
tokens: 7994
characters: 3227
timestamp: 2025-12-24T01:19:16.531762
finish_reason: stop
---

Протокол объявления функциональности нежелательной к использованию в Python

Интересно обратить внимание на то, как изменения в зарезервированных словах постепенно и поэтапно вносятся в язык. Когда новая функциональная возможность способна нарушить работу существующего кода, Python обычно делает ее необязательной и начинает выдавать предупреждения о "нежелательной к использованию" функциональности в одном или большем числе выпусков, прежде чем возможность станет официально доступной. Идея заключается в том, что вы должны располагать достаточным временем, чтобы заметить предупреждения и обновить свой код до перехода на новый выпуск. Сказанное не относится к крупным новым выпускам вроде Python 3.0 (который неограниченно нарушил работу существующего кода), но в целом верно в остальных случаях.

Например, yield было необязательным расширением в Python 2.2, но начиная с Python 2.3, является стандартным ключевым словом. Оно применяется в сочетании с генераторными функциями. Это было одним из немногих случаев, когда в Python нарушалась обратная совместимость. Тем не менее, ключевое слово yield вводилось поэтапно на протяжении длительного времени: в версии Python 2.2 начали выдаватьсь предупреждения о функциональности, нежелательной к использованию, и оно не было задействовано вплоть до версии Python 2.3. Подобным же образом в Python 2.6 слова with и as становятся новыми зарезервированными словами для применения в диспетчерах контекста (более новая форма обработки исключений). Указанные два слова не являются зарезервированными в Python 2.5, если только вручную не включить средство диспетчеров контекста с помощью from __future__ import (обсуждается позже в книге). При использовании в Python 2.5 слова with и as вызывают генерацию предупреждений о предстоящем изменении. Исключением будет версия IDLE в Python 2.5, которая делает данное средство доступным (т.е. применение слов with и as для имен переменных приводит к ошибкам в Python 2.5, но только в версии с графическим пользовательским интерфейсом IDLE).

Соглашения по именованию

Кроме описанных выше правил существует также набор соглашений по именованию — правил, которые не считаются обязательными, но соблюдаются в повседневной практике. Скажем, из-за того, что имена с двумя подчеркиваниями в начале и конце (например, __name__) обычно имеют особый смысл для интерпретатора Python, вы должны избегать использования такого шаблона в собственных именах. Ниже приведен перечень соглашений по именованию, принятых в Python.

• Имена, которые начинаются с одиночного подчеркивания (_X), не импортируются оператором from module import * (описанным в главе 23).
• Имена с двумя подчеркиваниями в начале и конце (__X__) являются системными именами, которые имеют особый смысл для интерпретатора.
• Имена, начинающиеся с двух подчеркиваний, но не оканчивающиеся ими (__X__), локализованы ("искажены") для включения в себя классов (см. обсуждение псевдозакрытых атрибутов в главе 31).
• Имя, состоящее из одиночного подчеркивания (_), хранит результат последнего выражения при работе в интерактивном сеансе.

В дополнение к перечисленным соглашениям, связанным с интерпретатором Python, существует ряд других соглашений, которым по обыкновению следуют про-