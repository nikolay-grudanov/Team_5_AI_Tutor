---
source_image: page_541.png
page_number: 541
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 26.62
tokens: 7623
characters: 2221
timestamp: 2025-12-24T01:24:08.575341
finish_reason: stop
---

Проверьте свои знания: ответы

1. Выводится 'Spam', т.к. функция ссылается на глобальную переменную из включающего модуля (поскольку присваивание переменной в функции не производится, переменная считается глобальной).

2. Выводится снова 'Spam', потому что присваивание переменной внутри функции делает ее локальной и фактически скрывает глобальную переменную с таким же именем. Оператор print обнаруживает переменную неизмененной в глобальной области видимости (модуля).

3. Выводится 'NI' в одной строке и 'Spam' в другой, т.к. ссылка на переменную внутри функции находит присвоенную локальную переменную, а ссылка в операторе print — глобальную переменную.

4. На этот раз выводится 'NI', поскольку объявление global заставляет переменную, присваиваемую внутри функции, ссылаться на переменную в объемлющей глобальной области видимости.

5. В данном случае выводится снова 'NI' в одной строке и 'Spam' в другой, потому что оператор print во вложенной функции находит имя в локальной области видимости объемлющей функции, а отображение в конце находит переменную в глобальной области видимости.

6. Выводится 'Spam', поскольку оператор nonlocal (доступный в Python 3.x, но не в Python 2.x) означает, что присваивание X внутри вложенной функции изменяет X в локальной области видимости объемлющей функции. Без этого оператора присваивание классифицировало бы X как локальную переменную во вложенной функции, делая ее другой переменной; тогда код выводил бы 'NI'.

7. Хотя значения локальных переменных исчезают, когда происходит возврат из функции, вы можете заставить функцию Python сохранять информацию о состоянии за счет использования разделяемых глобальных переменных, ссылок внутри вложенных функций на переменные из области видимости объемлющих функций или стандартных значений аргументов. Атрибуты функций могут иногда позволить состоянию присоединяться к самим функциям вместо выполнения поиска в областях видимости. Еще одна альтернатива, применение классов и объектно-ориентированного программирования, временами поддерживает сохранение состояния лучше, чем любые методики, основанные на областях видимости, потому что делает его явным посредством присваивания атрибутов; мы исследуем этот вариант в части VI.