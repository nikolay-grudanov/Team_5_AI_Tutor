---
source_image: page_785.png
page_number: 785
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 34.88
tokens: 7844
characters: 2783
timestamp: 2025-12-24T01:31:48.662049
finish_reason: stop
---

>>> import os
>>> res1 = os.popen('reloadall.py tkinter').readlines()
>>> res2 = os.popen('reloadall2.py tkinter').readlines()
>>> res3 = os.popen('reloadall3.py tkinter').readlines()
>>> res1[:3]
['reloading tkinter\n', 'reloading enum\n', 'reloading sys\n']
>>> res1 == res2, res2 == res3
(True, False)
>>> set(res1) == set(res2), set(res2) == set(res3)
(True, True)

Запустите сценарии, изучите их код и поэкспериментируйте с ними для более глубокого понимания; они представляют собой импортируемые инструменты, который вы, возможно, пожелаете добавить в свою библиотеку исходного кода. Похожая методика тестирования используется при рассмотрении инструментов для построения листингов деревьев классов в главе 31, где мы будем применять ее для передачи объектов классов, расширяя еще больше.

Также имейте в виду, что все три версии перезагружают только модули, которые были загружены с помощью операторов import — поскольку имена, копируемые посредством операторов from, не приводят к вложению модуля и помещению ссылки на него в пространство имен импортера, содержащий имена модуль не перезагружается. По существу инструменты транзитивной перезагрузки опираются на тот факт, что перезагрузки модулей обновляют объекты модулей на месте, поэтому все ссылки на такие модули в любой области видимости автоматически будут видеть обновленную версию. Из-за того, что импортеры from копируют имена, они не обновляются за счет перезагрузки — транзитивной или нет — и поддержка такого обновления может требовать либо анализа исходного кода, либо настройки работы импортирования (указания ищите в главе 22).

Подобного рода воздействия со стороны инструментов, вероятно, являются еще одной причиной отдавать предпочтение оператору import перед from, что подводит нас к концу главы и части, а также к стандартному набору предостережений по теме настоящей части.

Затруднения, связанные с модулями

В этом разделе мы рассмотрим обычный набор граничных сценариев, которые могут сделать жизнь гораздо интереснее для тех, кто начинает программировать на Python. Некоторые из них приводятся здесь, а некоторые настолько неочевидны, что их трудно сопроводить характерными примерами, но большинство сценариев иллюстрируют какой-то важный аспект языка.

Конфликты имен модулей: операции импортирования пакетов и относительно пакетов

При наличии двух модулей с тем же самым именем вы можете импортировать только один из них — по умолчанию всегда будет выбираться модуль, чей каталог оказывается крайним слева в пути поиска модулей sys.path. Это не проблема, если предпочитаемый модуль находится в каталоге вашего сценария верхнего уровня; поскольку он всегда будет первым в пути поиска модулей, поиск производится сначала в его содержимом. Тем не менее, для операций импортирования между каталогами