---
source_image: page_261.png
page_number: 261
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 36.22
tokens: 8009
characters: 2997
timestamp: 2025-12-24T01:15:24.160019
finish_reason: stop
---

Несмотря на то что на сегодняшний день доступны обе методики и выражение форматирования по-прежнему широко используется, популярность метода format со временем может вырасти и в будущем он получит больше внимания со стороны разработчиков на Python. Кроме того, при наличии в языке выражения и метода в коде, с которым вы столкнетесь, может встретиться любой из них, поэтому вам надлежит понимать обе методики. Но поскольку в настоящее время вы все еще можете делать выбор, когда пишете новый код, давайте кратко остановимся на компромиссах, прежде чем закрывать данную тему.

Дополнительные возможности:
"батарейки" для специальных случаев или универсальные методики

Вызов метода поддерживает несколько дополнительных возможностей, которые отсутствуют в выражении, такие как коды двоичных типов и (начиная с Python 2.7/3.1) группирование тысяч. Тем не менее, выражение форматирования обычно позволяет добиться тех же результатов другими способами. Вот сценарий для двоичного форматирования:

```python
>>> '{0:b}'.format((2 ** 16) - 1)    # Код двоичного формата в методе (только)
'1111111111111111'
>>> '%b' % ((2 ** 16) - 1)
ValueError: unsupported format character 'b'...
Ошибка значения: неподдерживаемый символ формата b...
>>> bin((2 ** 16) - 1)                # Но работают другие более универсальные варианты
'0b1111111111111111'
>>> '%s' % bin((2 ** 16) - 1)         # Подходит для метода и выражения
'0b1111111111111111'
>>> '{}'.format(bin((2 ** 16) - 1))   # С относительной нумерацией Python 2.7/3.1+
'0b1111111111111111'
>>> '%s' % bin((2 ** 16) - 1)[2:]     # Вырезание 0b для получения точного эквивалента
'1111111111111111'
```

Выше во врезке "На заметку!" было показано, что универсальные функции способны аналогичным образом замещать возможность группирования тысяч метода format и более полно поддерживают настройку. В данном случае простая восмистрочная многократно используемая функция приносит ту же пользу без синтаксиса для специальных случаев:

```python
# Новая возможность метода str.format в Python 3.1/2.7
>>> '{:,d}'.format(9999999999999)
'999,999,999,999,999'
# Но % позволяет добиться того же с помощью простой функции
>>> '%s' % commas(9999999999999)
'999,999,999,999,999'
```

Дополнительные сведения ищите в упомянутой врезке "На заметку!". По существу речь идет о сценарии, похожем на применение функции bin для двоичного форматирования, но функция commas является определяемой пользователем, а не встроенной. Как таковая, эта методика гораздо более универсальна, чем готовые инструменты или специальный синтаксис, добавляемый для единственной цели.

Возможно, данный случай также свидетельствует о тенденции Python (и языка написания сценариев в целом) к тому, чтобы больше полагаться на "батарейки в комплекте" для специальных случаев, нежели на универсальные методики разработки. Такой образ мыслей делает код зависимым от этих "батареек" и ему трудно найти объяснение, если только не рассматривать разработку программного обеспечения как занятие конечных