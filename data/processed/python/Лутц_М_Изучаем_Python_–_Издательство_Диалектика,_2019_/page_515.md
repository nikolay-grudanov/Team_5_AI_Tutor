---
source_image: page_515.png
page_number: 515
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 28.36
tokens: 7727
characters: 2517
timestamp: 2025-12-24T01:23:21.305844
finish_reason: stop
---

Главы после исследования замыканий вложенных областей видимости и вариантов сохранения состояния.

Кроме того, еще раз обратите внимание, что сторонние инструменты, такие как PyChecker и другие, скажем, PyLint, будут предупреждать о распространенных ошибках при программировании, в том числе о случайном присваивании встроенным именам (в инструментах подобного рода это обычно известно как "экранирование" встроенного имени). Неплохой идеей будет прогнать несколько первых программ Python через указанные инструменты, чтобы посмотреть, что они покажут.

Оператор global

Оператор global и родственный ему nonlocal из Python 3.X — единственные вещи в Python, которые отдаленно напоминают операторы объявления. Тем не менее, они не являются объявлениями типа или размера, а представляют собой объявления пространств имен. Оператор global сообщает Python, что функция планирует изменять одно и более глобальных имен, т.е. имен, которые существуют в области видимости (пространстве имен) включающего модуля.

Мы уже обсуждали global. Вот краткая сводка.

• Глобальные имена — это переменные, присвоенные на верхнем уровне включающего их файла модуля.
• Глобальные имена должны объявляться, только если им выполняются присваивания внутри функции.
• На глобальные имена можно ссылаться внутри функции без их объявления.

Другими словами, global дает возможность изменять имена, которые существуют вне def на верхнем уровне файла модуля. Как будет показано позже, оператор nonlocal почти идентичен, но применяется к именам в локальной области видимости объемлющего оператора def, а не к именам во включающем модуле.

Оператор global состоит из ключевого слова global, за которым следует одно и более имен, разделенных запятыми. Присваивание или ссылка на все перечисленные имена в теле функции будет приводить к их отображению на область видимости включающего модуля, например:

X = 88        # Глобальная переменная X
def func():
    global X
    X = 99        # Глобальная переменная X: снаружи def
func()
print(X)      # Выводит 99

Мы добавили в пример объявление global, так что имя X внутри def теперь ссылается на имя X снаружи def; на этот раз они представляют собой одну и ту же переменную, а потому изменение X внутри функции приводит к изменению X за ее пределами. Ниже показан чуть более сложный пример использования global:

y, z = 1, 2    # Глобальные переменные в модуле
def all_global():
    global x    # Объявление присваиваемой глобальной переменной
    x = y + z   # Объявлять y, z не нужно: правило LEGB