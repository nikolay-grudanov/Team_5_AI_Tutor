---
source_image: page_108.png
page_number: 108
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 34.52
tokens: 7866
characters: 2884
timestamp: 2025-12-24T01:10:21.362333
finish_reason: stop
---

текущую версию кода. Командная строка системы предлагает похожие преимущества. В случае использования любых таких приемов необходимость в применении reload исчезает.

Вдобавок вы можете столкнуться с проблемами, если будете прямо сейчас использовать модули необычными способами. Скажем, если вас интересует импортирование файла модуля, который хранится не в том каталоге, где вы работаете, тогда придется переключиться на главу 22 и почитать о пути поиска модулей. Пока что, когда нужно импортирование, старайтесь хранить все файлы в рабочем каталоге во избежание затруднений3.

Тем не менее, импортирование и перезагрузка оказались популярной методикой тестирования в классах Python, и вы также можете отдать предпочтение такому подходу. Однако, как обычно, если вы обнаруживаете, что уперлись в стену, то не пытайтесь ее пробить!

Использование exec для выполнения файлов модулей

Строго говоря, для выполнения кода, хранящегося в файлах модулей, существует больше способов, чем было представлено до сих пор. Например, вызов встроенной функции exec(open('module.py').read()) является еще одним приемом запуска файлов из интерактивной подсказки без импортирования и последующей перезагрузки. Каждый такой вызов exec выполняет текущую версию кода, прочитанную из файла, не требуя перезагрузки в более позднее время (script1.py находится в том состоянии, в каком мы его оставили после перезагрузки в предыдущем разделе):

% python
>>> exec(open('script1.py').read())
win32
65536
Spam!Spam!Spam!Spam!Spam!Spam!Spam!Spam!
...Изменение script1.py в окне текстового редактора для вывода 2 ** 32...
>>> exec(open('script1.py').read())
win32
4294967296
Spam!Spam!Spam!Spam!Spam!Spam!Spam!

Эффект от вызова exec похож на результат оператора import, но в действительности не приводит к импортированию модуля. По умолчанию каждый раз, когда вы вызываете exec подобным образом, он выполняет код из файла заново, как будто он был вставлен в то место, где находится вызов exec. Из-за этого exec не требует перезагрузки модуля после внесения изменений в файл — он пропускает обычную логику импортирования модуля.

С другой стороны, поскольку вызов exec работает, как если бы вы поместили код на его место, подобно упомянутому ранее оператору from, потенциально он способен молча переписать переменные, которые используются в текущий момент. Скажем,

3 Если вы слишком любознательны, чтобы ждать до главы 22, то вот вам краткий пересказ: Python ищет импортируемые модули в каждом каталоге, перечисленном в sys.path — список Python строк с именами каталогов в модуле sys, который инициализируется содержимым переменной окружения PYTHONPATH плюс набором стандартных каталогов. Когда необходимо импортировать из каталога, отличающегося от того, где вы работаете, то этот каталог обычно должен присутствовать в PYTHONPATH. За дополнительными деталями обращайтесь в главу 22 и приложение А второго тома.