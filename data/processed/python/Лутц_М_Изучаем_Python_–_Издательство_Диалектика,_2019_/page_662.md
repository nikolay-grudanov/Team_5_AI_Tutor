---
source_image: page_662.png
page_number: 662
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 46.49
tokens: 8282
characters: 3312
timestamp: 2025-12-24T01:28:04.449443
finish_reason: stop
---

(см. приложение А второго тома). Все приведенные ниже команды запускают Python (он же CPython) 3.7. В этом режиме timeit сообщает среднее время для одиночного цикла, количество которых задано посредством флага -n, в микросекундах (usec), миллисекундах (msec) или секундах (sec). Чтобы сравнить полученные здесь результаты со значениями суммарного времени, сообщаемыми другими тестами, их понадобится умножить на количество выполненных циклов — около 500 микросекунд * 1000 циклов дает 500 миллисекунд, или суммарное время полсекунды:

c:\code> c:\python37\Lib\timeit.py -n 1000 "[x ** 2 for x in range(1000)]"
1000 loops, best of 3: 506 usec per loop
1000 циклов, лучшее время из 3: 506 микросекунд на цикл

c:\code> python -m timeit -n 1000 "[x ** 2 for x in range(1000)]"
1000 loops, best of 3: 504 usec per loop
1000 циклов, лучшее время из 3: 504 микросекунд на цикл

c:\code> py -3 -m timeit -n 1000 -r 5 "[x ** 2 for x in range(1000)]"
1000 loops, best of 5: 505 usec per loop
1000 циклов, лучшее время из 5: 505 микросекунд на цикл

В качестве примера мы можем применить командные строки, удостоверившись в том, что выбор вызова таймера не влияет на сравнения скорости между версиями, которые выполнялись в главе до сих пор. Начиная с Python 3.3, по умолчанию используются новые вызовы, что может иметь значение, если точность таймера отличается в широких пределах. Чтобы доказать, что это несущественно, в следующих командах применяется флаг -c, который заставляет timeit использовать time.clock во всех версиях — вариант, помеченный в руководствах по Python 3.3 как устаревший, но он требуется для уравновешивания с предшествующими версиями (ради краткости команд в переменную среды PATH включен путь к PyPy):

c:\code> set PATH=%PATH%;C:\pypy\pypy-1.9

c:\code> py -3 -m timeit -n 1000 -r 5 -c "[x ** 2 for x in range(1000)]"
1000 loops, best of 5: 502 usec per loop
c:\code> py -2 -m timeit -n 1000 -r 5 -c "[x ** 2 for x in range(1000)]"
1000 loops, best of 5: 70.6 usec per loop
c:\code> pyppy -m timeit -n 1000 -r 5 -c "[x ** 2 for x in range(1000)]"
1000 loops, best of 5: 5.44 usec per loop

C:\code> py -3 -m timeit -n 1000 -r 5 -c "[abs(x) for x in range(10000)]"
1000 loops, best of 5: 815 usec per loop
C:\code> py -2 -m timeit -n 1000 -r 5 -c "[abs(x) for x in range(10000)]"
1000 loops, best of 5: 700 usec per loop
C:\code> pyppy -m timeit -n 1000 -r 5 -c "[abs(x) for x in range(10000)]"
1000 loops, best of 5: 61.7 usec per loop

По сути, результаты соответствуют проведенным ранее тестам для кода такого типа. В случае применения x ** 2 версии CPython 2.7 и PyPy оказываются в 10 и 100 раз быстрее CPython 3.7, что говорит о неважности выбора таймера. Для функции abs(x), время выполнения которой ранее измерялось с помощью любительского таймера (timeeqs.py), версии CPython 2.7 и PyPy работают быстрее Python 3.7 соответственно на небольшое константное значение и в 10 раз. Отсюда вытекает, что отличающаяся кодовая структура timeit не влияет на относительные сравнения — величина разницы в скоростях целиком определяется типом тестируемого кода.

Есть один тонкий момент: обратите внимание, что результаты последних трех тестов, имитирующие тесты, которые ранее запускались для любительского таймера, по существу такие же, но несут в себе небольшие совокупные издержки. Такие издержки