---
source_image: page_212.png
page_number: 212
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 35.17
tokens: 8007
characters: 3275
timestamp: 2025-12-24T01:13:37.888834
finish_reason: stop
---

В целях иллюстрации рассмотрим пример, где в каждом присваивании имя x устанавливается в отличающийся объект:

```python
>>> x = 42
>>> x = 'shrubbery'    # Освободить память, занимаемую 42
                        # (если нет ссылок где-то еще)
>>> x = 3.1415          # Освободить память, занимаемую 'shrubbery'
>>> x = [1, 2, 3]       # Освободить память, занимаемую 3.1415
```

Во-первых, обратите внимание, что x каждый раз устанавливается в объект отличающегося типа. И снова, хотя все в действительно не так, эффект выглядит, как если бы тип x менялся с течением времени. Не забывайте, что в Python типы обитают в объектах, а не в именах. Поскольку имена — это лишь обобщенные ссылки на объекты, код подобного рода работает вполне естественным образом.

Во-вторых, обратите внимание, что ссылки на объекты по пути отбрасываются. Каждый раз, когда x присваивается новый объект, Python освобождает память, занятую предыдущим объектом. Например, после присваивания строки 'shrubbery' память, которую занимает объект 42, немедленно освобождается (при условии, что на него больше нет ссылок) — т.е. область памяти объекта автоматически попадает в пул свободного пространства, чтобы быть задействованной каким-то будущим объектом.

Внутренне Python совершает такой ловкий трюк за счет ведения в каждом объекте счетчика, который отслеживает количество ссылок, в текущий момент указывающих на объект. Как только и точно когда этот счетчик уменьшается до нуля, область памяти объекта автоматически освобождается. В листинге выше мы предполагаем, что каждый раз, когда x присваивается новый объект, счетчик ссылок предыдущего объекта уменьшается до нуля, вызывая освобождение занимаемой им памяти.

Самое непосредственно ощутимое преимущество сборки мусора заключается в том, что она означает возможность свободного применения объектов безо всякой необходимости в выделении или освобождении памяти в сценарии. Python будет очищать неиспользуемое пространство в ходе выполнения программы. На практике в результате устраняется значительный объем кода, связанного с управлением памятью, который требуется в языках более низкого уровня, таких как C и C++.

Подробнее о сборке мусора в Python

Говоря формально, сборка мусора в Python основана главным образом на счетчиках ссылок, как здесь описано; однако она также имеет компонент, который обнаруживает и своевременно освобождает пространство памяти, занимаемое объектами с циклическими ссылками. Если вы уверены, что ваш код не создает циклов, тогда можете отключить этот компонент, но по умолчанию он включен.

Циклические ссылки являются классической проблемой в сборщиках мусора, основанных на счетчиках ссылок. Поскольку ссылки реализованы как указатели, вполне возможно, что объект ссылается на самого себя или на другой объект, который ссылается на самого себя. Скажем, в упражнении 6 в конце части I и его решении в приложении показано, насколько легко создать цикл, внедряя в список ссылку на самого себя (например, L.append(L)). Такое же явление может произойти в присваиваниях атрибутов объектов, которые созданы из классов, определяемых пользователем. Несмотря на относительную редкость подобных случаев, с ними нужно обходиться особым образом, потому что счетчики ссылок в таких объектах никогда не уменьшаются до нуля.