---
source_image: page_680.png
page_number: 680
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 37.67
tokens: 7910
characters: 3079
timestamp: 2025-12-24T01:28:34.698843
finish_reason: stop
---

Проверьте свои знания: ответы

1. В общем случае списковые включения быстрее всех; map побеждает списковые включения в Python, только когда все инструменты обязаны вызывать функции, циклы for имеют тенденцию быть медленнее включений, а генераторные функции и выражения медленнее включений на постоянную величину. В реализации PyPy некоторые сведения отличаются; например, map часто показывает разную относительную производительность, а списковые включения кажутся всегда самыми быстрыми, возможно из-за оптимизаций на уровне функций.

По крайней мере, так обстоят дела на сегодняшний день для протестированных версий Python, на заданном компьютере и с имеющейся разновидностью хронометрируемого кода — результаты могут варьироваться, если какой-то из трех аспектов окажется другим. Для тестирования своих сценариев использования с целью получения более подходящих результатов применяйте любительский модуль timer или стандартный библиотечный модуль timeit. Также имейте в виду, что итерация — это всего лишь одна составляющая времени программы: чем больше кода, тем более полной будет картина.

2. В общем PyPy 1.9 (реализация Python 2.7) обычно быстрее CPython 2.7, а CPython 2.7 часто быстрее CPython 3.7. В большинстве случаев измерения времени PyPy примерно в 10 раз быстрее CPython, а CPython 2.7 часто быстрее CPython 3.7 на небольшую постоянную величину. В случаях использования целочисленной математики CPython 2.7 может быть в 10 раз быстрее CPython 3.7, а PyPy — в 100 раз быстрее CPython 3.7. В остальных случаях (например, строковые операции и файловые итераторы) реализация PyPy может оказаться в 10 раз медленнее CPython, хотя на некоторые результаты могут повлиять отличия в timeit и управлении памятью. Эталонный тест pystone подтверждает такое относительное ранжирование по скорости, хотя сообщаемый им размер отличий будет другим из-за хронометрируемого кода.

По крайней мере, так обстоят дела на сегодняшний день для протестированных версий Python, на заданном компьютере и с имеющейся разновидностью хронометрируемого кода — результаты могут варьироваться, если какой-то из трех аспектов окажется другим. Для тестирования своих сценариев использования с целью получения более подходящих результатов применяйте любительский модуль timer или стандартный библиотечный модуль timeit. Это особенно справедливо, когда измеряется время реализаций Python, которые могут оптимизироваться в каждом новом выпуске.

Проверьте свои знания: упражнения для части IV

В предложенных далее упражнениях вам предстоит приступить к написанию более сложно устроенных программ. Обязательно ознакомьтесь с решениями в приложении и начинайте писать код в файлах модулей. Вряд ли вы захотите набирать код решения упражнений заново в случае допущения ошибки.

1. Основы. В интерактивной подсказке Python напишите функцию, которая выводит свой единственный аргумент, и вызовите ее, передавая объекты разнообразных типов: строку, целое число, список, словарь. Затем попробуйте вызвать ее без передачи какого-либо аргумента. Что произошло? Что происходит, когда передаются два аргумента?