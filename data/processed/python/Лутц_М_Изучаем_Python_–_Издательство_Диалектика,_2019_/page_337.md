---
source_image: page_337.png
page_number: 337
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 31.47
tokens: 7807
characters: 2309
timestamp: 2025-12-24T01:17:52.700903
finish_reason: stop
---

Присваивание создает ссылки, а не копии

По причине крайней важности концепции я упомяну о ней снова: разделяемые ссылки на изменяемые объекты в программе могут иметь значение. Например, в следующем взаимодействии на списоковый объект, присвоенный имени L, производится ссылка из L и изнутри списка, присвоенного имени M. Изменение L на месте также изменяет то, на что ссылается M:

```python
>>> L = [1, 2, 3]
>>> M = ['X', L, 'Y']    # Встраивание ссылки на L
>>> M
['X', [1, 2, 3], 'Y']
>>> L[1] = 0             # Изменяет также и M
>>> M
['X', [1, 0, 3], 'Y']
```

Это следствие становится важным только в более крупных программах, к тому же разделяемые ссылки часто представляют собой именно то, что нужно. Если объекты изменяются нежелательным образом, тогда вы можете избежать применения разделяемых ссылок, явно копируя объекты. В случае списка всегда можно создать его копию верхнего уровня с использованием среза с пустыми границами, а также других методик, описанных ранее:

```python
>>> L = [1, 2, 3]
>>> M = ['X', L[:], 'Y']    # Встраивание копии L (или list(L), или L.copy())
>>> L[1] = 0                # Изменяет только L, но не M
>>> L
[1, 0, 3]
>>> M
['X', [1, 2, 3], 'Y']
```

Вспомните, что границы среза по умолчанию принимаются равными 0 и длине нарезаемой последовательности; если обе границы не указаны, то срез извлекает все элементы из последовательности, тем самым создавая копию верхнего уровня (новый, неразделяемый объект).

Повторение добавляет один уровень глубины

Повторение последовательности похоже на добавление ее к самой себе несколько раз. Тем не менее, в случае вложения изменяемых последовательностей результат может не всегда быть тем, который ожидался. Скажем, в следующем примере X присваивается список L, повторенный четыре раза, тогда как Y присваивается список, который содержит список L, повторенный четыре раза:

```python
>>> L = [4, 5, 6]
>>> X = L * 4           # Подобно [4, 5, 6] + [4, 5, 6] + ...
>>> Y = [L] * 4         # [L] + [L] + ... = [L, L,...]
>>> X
[4, 5, 6, 4, 5, 6, 4, 5, 6, 4, 5, 6]
>>> Y
[[4, 5, 6], [4, 5, 6], [4, 5, 6], [4, 5, 6]]
```

Поскольку во втором повторении L вкладывается, в Y попадают встроенные ссылки на исходный список, присвоенный L, и потому возникают побочные эффекты того же рода, что и описанные в предыдущем разделе: