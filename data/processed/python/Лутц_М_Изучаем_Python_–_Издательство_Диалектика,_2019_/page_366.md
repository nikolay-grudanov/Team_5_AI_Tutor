---
source_image: page_366.png
page_number: 366
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 30.99
tokens: 7900
characters: 2935
timestamp: 2025-12-24T01:18:49.013481
finish_reason: stop
---

Обратите внимание, что в третьей строке взаимодействия мы на самом деле записали два кортежа, просто опустив заключающие круглые скобки. Python попарно соединяет значения в кортеже, указанном справа от операции присваивания, с переменными в кортеже слева и присваивает значения по одному за раз.

Присваивание кортежа приводит к распространенному кодовому трюку в Python, который был введен при решении упражнений в конце части II. Поскольку Python создает временный кортеж, который хранит исходные значения переменных справа, пока оператор выполняется, распаковывающие присваивания также представляют собой способ обмена значениями двух переменных без создания временной переменной — кортеж справа запоминает предыдущие значения переменных автоматически:

```python
>>> nudge = 1
>>> wink = 2
>>> nudge, wink = wink, nudge  # Кортежи: обмен значениями
>>> nudge, wink                 # Подобно T = nudge; nudge = wink; wink = T
(2, 1)
```

Фактически первоначальные формы присваивания кортежей и списков в Python были обобщены для приема любого вида последовательности (в действительности итерируемого объекта) справа до тех пор, пока она имеет такую же длину, как последовательность слева. Можно присваивать кортеж значений списку переменных, строку символов кортежу переменных и т.д. Во всех случаях Python присваивает элементы в последовательности справа переменным в последовательности слева позиционно слева направо:

```python
>>> [a, b, c] = (1, 2, 3)      # Присваивание кортежа значений списку имен
>>> a, c
(1, 3)
>>> (a, b, c) = "ABC"         # Присваивание строки символов кортежу
>>> a, c
('A', 'C')
```

Говоря формально, присваивание последовательности на самом деле поддерживает справа не только любую последовательность, но любой итерируемый объект. Он представляет собой более универсальную категорию, включающую коллекции как физические (скажем, списки), так и виртуальные (например, строки файла), которые были кратко определены в главе 4 и время от времени появлялись позже. Мы закрепим данный термин в главах 14 и 20, когда будем исследовать итерируемые объекты.

Расширенные шаблоны присваивания последовательностей

Хотя допускается смешивать типы последовательностей с обеих сторон символа =, мы обычно должны иметь столько же элементов справа, сколько имеем переменных слева, иначе возникнет ошибка. Python 3.x делает возможной более общую форму с расширенным синтаксисом распаковки *, который описан в следующем разделе. Но при нормальных обстоятельствах в Python 3.x — и всегда в Python 2.x — количества элементов в цели и в объекте присваивания обязаны совпадать:

```python
>>> string = 'SPAM'
>>> a, b, c, d = string      # Одинаковые количества с обеих сторон
>>> a, d
('S', 'M')
>>> a, b, c = string        # В противном случае ошибка
...текст сообщения об ошибке не показан...
ValueError: too many values to unpack (expected 3)
Ошибка значения: слишком много значений для распаковки (ожидалось 3)
```