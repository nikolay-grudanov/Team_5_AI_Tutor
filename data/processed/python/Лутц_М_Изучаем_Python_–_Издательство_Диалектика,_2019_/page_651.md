---
source_image: page_651.png
page_number: 651
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 35.24
tokens: 7886
characters: 2993
timestamp: 2025-12-24T01:27:36.626674
finish_reason: stop
---

Новые вызовы таймеров, появившиеся в версии Python 3.3

В этом разделе задействованы вызовы clock и time из модуля time, т.к. они подходят всем читателям книги. В Python 3.3 в модуле time появились новые интерфейсы, которые спроектированы как более переносимые. В частности, поведение вызовов clock и time данного модуля меняется в зависимости от платформы, но его новые функции perf_counter и process_time имеют четко определенную и нейтральную к платформе семантику.

• Функция time.perf_counter() возвращает значение в дробных секундах счетчика производительности, определенного как часы с наивысшим доступным разрешением для измерения коротких промежутков времени. Она включает время, истекшее в состояниях сна, и действует в масштабе всей системы.

• Функция time.process_time() возвращает значение в дробных секундах суммы системного и пользовательского процессорного времени текущего процесса. Она не включает время, истекшее в состояниях сна, и по определению действует в масштабе процесса.

Для обоих вызовов начало отсчета возвращаемого значения не определено, так что имеет силу только разница между результатами последовательных вызовов. Вызов perf_counter можно воспринимать как фактическое время, а начиная с версии Python 3.3, он по умолчанию применяется для оценочных испытаний в обсуждаемом далее модуле timeit; вызов process_time дает процессорное время переносимым образом.

Как показано в книге, в наши дни вызов time.clock все еще годен к употреблению в среде Windows. В руководствах по Python 3.3 он документирован как устаревший, но никаких предупреждений в случае его использования не выдается — теперь его планируют удалить в версии Python 3.8. При необходимости вы можете опознавать Python 3.3 или последующую версию с помощью приведенного ниже кода, который я решил не применять ради краткости и сопоставимости таймеров:

if sys.version_info[0] >= 3 and sys.version_info[1] >= 3:
    timer = time.perf_counter   # или process_time
else:
    timer = time.clock if sys.platform[:3] == 'win' else time.time

В качестве альтернативы следующий код также добавит переносимость и защитит от будущего устаревания, хотя он затрагивает тему исключений, которая пока еще не раскрывалась в полной мере, и его выборы способны сделать недействительными сравнения скоростей выполнения между версиями — таймеры могут отличаться по своему разрешению!

try:
    timer = time.perf_counter   # или process_time
except AttributeError:
    timer = time.clock if sys.platform[:3] == 'win' else time.time

Если бы я писал книгу в расчете на читателей, работающих лишь с Python 3.3+, то использовал бы новые и очевидно улучшенные вызовы, и вы сами должны поступать так, когда находитесь в подобном положении. Однако более новые вызовы не будут работать у пользователей любых других выпусков Python, которых по-прежнему большинство в современном мире Python. Да, легче сделать вид, что прошлое не имеет значения, но это было бы не только бегством от реальности, но и просто явным неуважением.