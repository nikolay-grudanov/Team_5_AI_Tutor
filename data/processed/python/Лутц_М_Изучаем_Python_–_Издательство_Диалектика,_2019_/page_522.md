---
source_image: page_522.png
page_number: 522
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 32.29
tokens: 7840
characters: 2699
timestamp: 2025-12-24T01:23:38.253953
finish_reason: stop
---

вательский интерфейс, где нужно определять действия согласно данным, введенным пользователем, которые невозможно предугадать на этапе построения интерфейса. В таких ситуациях нам требуется функция, создающая и возвращающая другую функцию с информацией, которая может варьироваться в зависимости от создаваемой функции.

Чтобы продемонстрировать прием на простом примере, рассмотрим следующую функцию, набранную в интерактивной подсказке (и приведенную здесь без приглашений к продолжению ..., как описано далее в замечаниях по представлению):

```python
>>> def maker(N):
    def action(X):      # Создание и возвращение функции action
        return X ** N   # action сохраняет N из объемлющей области видимости
    return action
```

В коде определяется внешняя функция, которая просто генерирует и возвращает вложенную функцию, не вызывая ее — maker создает action, но лишь возвращает action без выполнения. Если мы вызовем внешнюю функцию:

```python
>>> f = maker(2)     # Передача 2 аргументу N
>>> f
<function maker.<locals>.action at 0x0000000002A4A158>
```

то получим обратно ссылку на сгенерированную вложенную функцию — ту, что была создана при выполнении вложенного оператора def. Вызов результата, возвращенного внешней функцией:

```python
>>> f(3)    # Передача 3 аргументу X, в N запоминается 2: 3 ** 2
9
>>> f(4)    # 4 ** 2
16
```

приводит к запуску вложенной функции, названной action внутри maker. Другими словами, мы вызываем вложенную функцию, которую создала и возвратила функция maker.

Пожалуй, самой необычной частью следует считать запоминание вложенной функцией целого числа 2, т.е. значения переменной N в maker, хотя к моменту вызова action уже произошел возврат из функции maker, и она закончила работу. По существу N из локальной области видимости объемлющей функции сохраняется как информация о состоянии, присоединенная к сгенерированной функции action — вот почему в результате ее вызова мы получили значение аргумента, возведенное в квадрат.

Не менее важен и тот факт, что если мы снова вызовем внешнюю функцию, то получим обратно новую вложенную функцию с другой присоединенной информацией о состоянии. Так, при вызове новой функции значение аргумента возводится в куб, а не в квадрат, но предыдущая функция по-прежнему возводит в квадрат, как и ранее:

```python
>>> g = maker(3)    # g запоминает 3, f запоминает 2
>>> g(4)            # 4 ** 3
64
>>> f(4)            # 4 ** 2
16
```

Подобное возможно из-за того, что каждый вызов фабричной функции получает собственный набор информации о состоянии. В нашем случае функция, присвоенная имени g, запоминает 3, а f запоминает 2, т.к. каждая имеет свою информацию о состоянии, хранимую в переменной N из maker.