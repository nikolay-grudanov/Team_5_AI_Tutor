---
source_image: page_339.png
page_number: 339
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 37.42
tokens: 7893
characters: 2958
timestamp: 2025-12-24T01:18:03.133690
finish_reason: stop
---

**Непрерывная петля. Дополнительную информацию о проблеме можно почерпнуть из решения упражнений части I в приложении. Также дождитесь общего обсуждения рекурсии в главе 19, программы reloadall.py в главе 25 и класса ListTree в главе 31 второго тома, где будут приведены конкретные примеры программ, в которых обнаружение циклов имеет значение.

Решение в знании: не используйте циклические ссылки, если только действительно не нуждаетесь в них, и удостоверьтесь в том, что предупреждаете их в программах, где они могут возникать. Существуют веские причины создавать циклы, но в отсутствие кода, которому известно, как их обрабатывать, ссылающиеся сами на себя объекты могут стать больше неожиданностью, нежели чем-то полезным.

Неизменяемые типы нельзя модифицировать на месте

И еще раз ради завершенности: нельзя модифицировать на месте неизменяемый объект. Взамен понадобится создать новый объект с помощью нарезания, конкатенации и т.п. и при необходимости присваивать его исходной ссылке:

T = (1, 2, 3)
T[2] = 4      # Ошибка!
T = T[:2] + (4,)    # Нормально: (1, 2, 4)

Это выглядит как дополнительная работа по написанию кода, но положительный момент в том, что описанные выше затруднения не могут возникнуть, когда применяются неизменяемые объекты, подобные кортежам и строкам. Поскольку неизменяемые объекты нельзя модифицировать на месте, с ними не связаны побочные эффекты, которым подвержены списки.

Резюме

В главе рассматривались последние два крупных типа основных объектов — кортежи и файлы. Вы узнали, что кортежи поддерживают все обычные операции над последовательностями, имеют несколько методов, не разрешают модификацию на месте по причине неизменяемости и расширяются типом именованных кортежей. Также вы узнали о том, что файловые объекты возвращаются встроенной функцией open и предлагают методы для чтения и записи данных.

Попутно мы выяснили, как транслировать объекты Python в и из строк для сохранения в файлах, и взглянули на модули pickle, json и struct, предназначенные для решения более сложных задач (сериализация объектов и двоичные данные). В заключение был приведен обзор ряда характеристик, общих для объектов всех типов (например, разделяемые ссылки), и перечень распространенных затруднений в области, связанной с типами объектов.

В следующей части книги мы перейдем к теме синтаксиса операторов — способа кодирования логики обработки в сценариях. Кроме того, будут исследованы все базовые процедурные операторы. В следующей главе эта тема открывается введением в общую модель синтаксиса Python, которая применима ко всем видам операторов. Однако прежде чем двигаться дальше, необходимо ответить на контрольные вопросы главы и затем проработать упражнения, предлагаемые в конце части, для закрепления концепций типов данных. Операторы по большому счету всего лишь создают и обрабатывают объекты, так что перед тем, как переходить к следующей части, проверьте, хорошо ли вы усвоили типы данных, выполнив упражнения.