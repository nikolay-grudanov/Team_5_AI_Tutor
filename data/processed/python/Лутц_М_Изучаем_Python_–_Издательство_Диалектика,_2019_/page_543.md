---
source_image: page_543.png
page_number: 543
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 37.60
tokens: 7891
characters: 2873
timestamp: 2025-12-24T01:24:24.068199
finish_reason: stop
---

Схема передачи по присваиванию Python — не совсем то же самое, что и ссылочные параметры C++, но на практике она очень похожа на модель передачи аргументов в C (и других языках).

• Неизменяемые аргументы фактически передаются "по значению". Объекты, подобные целым числам и строкам, передаются по ссылке на объекты, а не путем копирования, но из-за того, что модифицировать на месте неизменяемые объекты невозможно, эффект во многом похож на создание копий.

• Изменяемые аргументы фактически передаются "по указателю". Объекты вроде списков и словарей также передаются по ссылке на объекты, что аналогично способу передачи массивов как указателей в языке C — изменяемые объекты можно модифицировать на месте в функции почти как массивы в C.

Разумеется, если вы никогда не использовали язык C, то режим передачи аргументов в Python вам покажется еще более простым — он влечет за собой только присваивание объектов именам и работает одинаково для изменяемых и неизменяемых объектов.

Аргументы и разделяемые ссылки

Чтобы оценить характеристики передачи аргументов в работе, рассмотрим следующий код:

```python
>>> def f(a):
    a = 99
>>> b = 88
>>> f(b)
>>> print(b)
88
```

# a присваивается (устанавливается в ссылку на) переданный объект
# Изменяет только локальную переменную a
# a и b первоначально ссылаются на 88
# Значение b не изменилось

В приведенном примере переменной a присваивается объект 88 в момент, когда функция вызывается посредством f(b), но a существует только внутри вызванной функции. Изменение a внутри функции никак не воздействует на место, где функция вызывалась; оно просто переустанавливает локальную перемененную a в совершенно другой объект.

Вот что означает отсутствие совмещения имен — присваивание имени аргумента внутри функции (например, a=99) не изменяет волшебным образом переменную вроде b в области видимости, где вызывалась функция. Имена аргументов могут изначально разделять передаваемые объекты (по существу они являются указателями на эти объекты), но только временно, когда функция вызывается впервые. После повторного присваивания имени аргумента связь разрывается.

По крайней мере, так происходит в случае присваивания самим именам аргументов. Когда аргументам передаются изменяемые объекты, подобные спискам и словарям, мы должны осознавать, что изменения на месте таких объектов могут продолжить свое существование после завершения функции, а потому оказывать воздействие на вызывающий код. Ниже представлен пример, демонстрирующийписанное поведение:

```python
>>> def changer(a, b):
    a = 2
    b[0] = 'spam'
>>> x = 1
>>> L = [1, 2]
>>> changer(x, L)
>>> x, L
(1, ['spam', 2])
```

# Аргументам присваиваются ссылки на объекты
# Изменяет только значение локального имени
# Изменяет разделяемый объект на месте
# Вызывающий код:
# Передача неизменяемого и изменяемого объектов
# X остается прежним, L отличается!