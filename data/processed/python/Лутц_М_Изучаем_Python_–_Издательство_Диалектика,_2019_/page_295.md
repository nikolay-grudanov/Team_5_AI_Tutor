---
source_image: page_295.png
page_number: 295
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 35.61
tokens: 7934
characters: 2584
timestamp: 2025-12-24T01:16:32.348047
finish_reason: stop
---

В качестве иллюстрации стандартный способ динамической инициализации словаря в Python 2.x и 3.x предусматривает объединение его ключей и значений посредством zip с передачей результата вызову dict. Встроенная функция zip — это прием, который позволяет создавать словарь из списков ключей и значений подобным образом; если вы не в состоянии спрогнозировать набор ключей и значений в своем коде, тогда всегда можете построить их как списки и упаковать вместе. Функция zip будет подробно рассматриваться в главах 13 и 14 после исследования операторов; в Python 3.x она возвращает итерируемый объект, поэтому здесь для отображения результатов мы обязаны поместить ее внутрь вызова list, но ее базовое применение в других обстоятельствах прямолинейно:

```python
>>> list(zip(['a', 'b', 'c'], [1, 2, 3])) # Упаковка вместе ключей и значений
[('a', 1), ('b', 2), ('c', 3)]
>>> D = dict(zip(['a', 'b', 'c'], [1, 2, 3])) # Создание словаря
# из результата zip
>>> D
{'b': 2, 'c': 3, 'a': 1}
```

Тем не менее, в Python 3.x и 2.7 того же эффекта можно достичь посредством выражения включения словаря. Ниже строится новый словарь с парами "ключ/значение" для каждой такой пары в результате zip (код Python читается почти так же, как описание на естественном языке, но чуть более формально):

```python
>>> D = {k: v for (k, v) in zip(['a', 'b', 'c'], [1, 2, 3])}
>>> D
{'b': 2, 'c': 3, 'a': 1}
```

Фактически в этом случае включения требуют большего объема кода, но они более универсальны, чем вытекает из приведенного примера — их допускается использовать также для отображения одиночного потока значений на словари, а ключи могут вычисляться с помощью выражений, как и значения:

```python
>>> D = {x: x ** 2 for x in [1, 2, 3, 4]} # Или range(1, 5)
>>> D
{1: 1, 2: 4, 3: 9, 4: 16}
>>> D = {c: c * 4 for c in 'SPAM'} # Проход в цикле по любому
# итерируемому объекту
>>> D
{'S': 'SSSS', 'P': 'PPPP', 'A': 'AAAA', 'M': 'MMMM'}
>>> D = {c.lower(): c + '!' for c in ['SPAM', 'EGGS', 'HAM']}
>>> D
{'eggs': 'EGGS!', 'spam': 'SPAM!', 'ham': 'HAM!'}
```

Включения словарей также удобны для инициализации словарей из списков ключей во многом таким же способом, как метод fromkeys, который был представлен в конце предыдущего раздела:

```python
>>> D = dict.fromkeys(['a', 'b', 'c'], 0) # Инициализация словаря из ключей
>>> D
{'b': 0, 'c': 0, 'a': 0}
>>> D = {k:0 for k in ['a', 'b', 'c']} # То же самое, но посредством включения
>>> D
{'b': 0, 'c': 0, 'a': 0}
>>> D = dict.fromkeys('spam') # Другие итерируемые объекты, стандартное значение
>>> D
{'s': None, 'p': None, 'a': None, 'm': None}
```