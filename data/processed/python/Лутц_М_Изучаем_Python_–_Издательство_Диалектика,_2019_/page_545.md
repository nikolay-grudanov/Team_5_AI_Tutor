---
source_image: page_545.png
page_number: 545
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 34.34
tokens: 7825
characters: 2718
timestamp: 2025-12-24T01:24:20.967280
finish_reason: stop
---

Если рассмотренный пример все еще сбивает с толку, тогда может помочь тот факт, что результат автоматических присваиваний передаваемых аргументов будет таким же, как и выполнение серии простых операторов присваивания. Что касается первого аргумента, то присваивание никак не воздействует на вызываемый код:

```python
>>> X = 1
>>> a = X    # Разделяют тот же самый объект
>>> a = 2    # Переустанавливает только a, значением X по-прежнему будет 1
>>> print(X)
1
```

Однако присваивание через второй аргумент оказывает влияние на переменную в вызывающем коде, т.к. оно является изменением объекта на месте:

```python
>>> L = [1, 2]
>>> b = L    # Разделяют тот же самый объект
>>> b[0] = 'spam'    # Изменение на месте: L тоже увидит изменение
>>> print(L)
['spam', 2]
```

Вспомнив обсуждение разделяемых изменяемых объектов из глав 6 и 9, вы опознаете данное явление в действии: модификация изменяемого объекта на месте может оказать влияние на другие ссылки на этот объект. Здесь эффект заключается в том, что аргументы работают подобно входным и выходным данным функции.

Избегайте модификации изменяемых аргументов

Подобное поведение модификации на месте изменяемых аргументов ошибкой не является — просто именно так работает передача аргументов в Python, которая еще и оказывается очень удобной на практике. Аргументы обычно передаются функциям по ссылке, что как раз желательно. Это означает, что мы можем передавать крупные объекты внутри программы, не создавая попутно многочисленные копии, и в ходе дела легко обновлять такие объекты. Фактически, как будет показано в части VI, при обновлении состояния объекта модель классов Python основывается на изменении переданного аргумента self на месте.

Тем не менее, если вносить изменения на месте внутри функций, воздействуя на передаваемые объекты, нежелательно, тогда можно просто создавать явные копии изменяемых объектов, как объяснялось в главе 6. В случае аргументов функций мы всегда можем создать копию списка в точке вызова с помощью инструмента вроде list.copy (начиная с Python 3.3) или пустого среза:

```python
L = [1, 2]
changer(X, L[:])    # Передача копии, так что L не изменяется
```

Мы можем также создавать копию внутри самой функции, если не хотим изменять передаваемые объекты независимо от того, как вызывается функция:

```python
def changer(a, b):
    b = b[:]    # Создание копии входного списка,
    # чтобы не влиять на вызывающий код
    a = 2
    b[0] = 'spam'    # Изменяет только копию списка
```

Обе схемы копирования не мешают функции изменять объект — они всего лишь не допускают влияния изменений на вызывающий код. Чтобы действительно предотвратить изменения, мы всегда можем преобразовать в неизменяемые объекты, модифи-