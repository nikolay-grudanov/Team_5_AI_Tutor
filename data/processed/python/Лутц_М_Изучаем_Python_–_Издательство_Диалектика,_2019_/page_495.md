---
source_image: page_495.png
page_number: 495
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 36.75
tokens: 7912
characters: 3319
timestamp: 2025-12-24T01:22:53.109106
finish_reason: stop
---

В этой части книги мы исследуем инструменты, используемые для написания кода функций в Python: основы функций, правила областей видимости и передачу аргументов вместе с несколькими связанными концепциями, такими как генераторы и инструменты функционального программирования. Мы также возвратимся к введенному ранее в книге понятию полиморфизма, поскольку на данном уровне кодирования его важность становится более очевидной. Вы заметите, что функции не несут в себе особо много нового синтаксиса, но они подводят нас к ряду более развитых идей программирования.

Написание кода функций

Хотя и не очень формально, но в предшествующих главах мы уже применяли несколько функций. Скажем, для создания файлового объекта мы вызывали встроенную функцию open; аналогично мы использовали встроенную функцию len, чтобы запросить количество элементов в объекте коллекции.

В этой главе мы выясним, как писать новые функции в Python. Написанные нами функции ведут себя подобно встроенным функциям, которые мы уже видели: они вызываются в выражениях, принимают значения и возвращают результаты. Но написание новых функций требует приложения ряда дополнительных идей, которые пока еще не были представлены. Кроме того, функции в Python ведут себя совершенно не так, как в компилируемых языках вроде C. Ниже предлагается краткое введение в главные концепции, лежащие в основе функций Python, которые будут исследованы в текущей части книги.

• def является исполняемым кодом. Функции Python пишутся с помощью нового оператора def. В отличие от функций в компилируемых языках, таких как C, def представляет собой исполняемый оператор — ваша функция не существует до тех пор, пока Python не встретит и не выполнит def. В действительности законно (и подчас удобно) вкладывать операторы def внутрь операторов if, циклов while и даже других def. При типовом применении операторы def помещаются в файлы модулей и естественным образом выполняются для генерации функций, когда файл модуля, где они находятся, импортируется в первый раз.

• def создает объект и присваивает его имени. Когда Python достигает и выполняет оператор def, генерируется новый объект функции, который присваивается имени функции. Как и со всеми присваиваниями, имя функции становится ссылкой на объект функции. С именем функции не связано ничего магического — вы увидите, что объект функции можно присваивать другим именам, сохранять в списке и т.п. Объекты функций также могут иметь произвольные определяемые пользователем атрибуты, присоединяемые к ним для регистрации данных.

• lambda создает объект, но возвращает его в качестве результата. Функции можно также создавать с помощью выражения lambda — средства, которое позволяет встраивать определения функций в места, где оператор def синтаксически не допускается. Мы отложим рассмотрение этой более сложной концепции до главы 19.

• return отправляет результирующий объект вызывающему коду. Когда функция вызывается, вызывающий код приостанавливается до тех пор, пока функция не завершит свою работу и не возвратит управление обратно. Функции, которые вычисляют значение, посылают его вызывающему коду посредством оператора return; возвращенное значение становится результатом вызова функции. Оператор return без значения просто возвращает управление в вызывающий код (и отправляет стандартный результат None).