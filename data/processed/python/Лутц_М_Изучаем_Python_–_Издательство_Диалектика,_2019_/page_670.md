---
source_image: page_670.png
page_number: 670
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 44.28
tokens: 8099
characters: 2997
timestamp: 2025-12-24T01:28:20.988021
finish_reason: stop
---

(0, 0, "{x: x ** 2 for x in range(1000)}"),
(0, 0, "d={}\nfor x in range(1000): d[x] = x ** 2"),
# Патологический случай: 301030 цифр
(1, 1, "len(str(2**1000000))")]    # На этот раз PyPy проигрывает

По результатам выполнения сценария в CPython 3.X видно, что тар оказывается быстрее, когда вызовы функций уравнивают шансы (ранее функция тар проигрывала в других тестах, выполнявших операцию x ** 2):

c:\code> py -3 pybench_cases2.py
3.7.3 (v3.7.3:ef4ec6ed12, Mar 25 2019, 21:26:53) [MSC v.1916 32 bit (Intel)]
0.7237 ["[ord(x) for x in 'spam' * 2500]"]
1.3471 ["res=[]\nfor x in 'spam' * 2500: res.append(ord(x))"]
0.6160 ["list(map(ord, 'spam' * 2500))"]
1.1244 ["list(ord(x) for x in 'spam' * 2500)"]
0.5446 ['{x ** 2 for x in range(1000)}']
0.6053 ['s=set()\nfor x in range(1000): s.add(x ** 2)']
0.5278 ['{x: x ** 2 for x in range(1000)}']
0.5414 ['d={}\nfor x in range(1000): d[x] = x ** 2']
1.8933 ['len(str(2**1000000))']

Как и прежде, в текущее время Python 2.X работает быстрее Python 3.X, а PyPy быстрее на всех тестах кроме последнего, по скорости выполнения которого он проигрывает на порядок (в 10 раз), хотя при выполнении всех остальных тестов в такой же степени выигрывает. Тем не менее, если вы запустите файловые тесты, написанные в pybench_cases2.py, то заметите, что PyPy также проигрывает CPython, когда читает файлы строка за строкой, как в случае следующего тестового кортежа в списке stmts:

(0, 0, "f=open('C:/Python37/Lib/pdb.py')\nfor line in f: x=line\nf.close()"),

Тест открывает и читает 1 728-строчный текстовый файл размером около 62 Кбайт строка за строкой с применением файловых итераторов. В этом тесте CPython 2.7 в два раза быстрее CPython 3.7, но PyPy снова на порядок медленнее, чем CPython в целом. Данный случай можно найти в файлах результатов pybench_cases2 или проверить интерактивно либо в командной строке (что внутренне делает pybench):

c:\code> py -3 -m timeit -n 1000 -r 5 "f=open('C:/Python37/Lib/pdb.py')"
"for line in f: x=line" "f.close()"

>>> import timeit
>>> min(timeit.repeat(number=1000, repeat=5,
stmt="f=open('C:/Python37/Lib/pdb.py')\nfor line in f: x=line\nf.close()"))

Еще один пример измерения скорости выполнения списковых включений и чтения файлов PyPy приведен в файле listcomp-speed.txt из пакета примеров; в нем используются прямые командные строки PyPy для запуска кода из главы 14 с похожими результатами: построчный ввод PyPy медленнее приблизительно на порядок.

Вывод из других версий Python здесь не показан ради экономии места, а также потому, что на момент чтения вами книги ситуация наверняка изменится. Как обычно, разные типы кода могут демонстрировать разные типы производительности. Наряду с тем, что реализация PyPy способна оптимизировать большинство алгоритмического кода, вас самих она может как оптимизировать, так и нет. Вы найдете дополнительные результаты в пакете примеров книги, но может быть лучше самостоятельно проверить эти сведения сейчас, чем получить, возможно, другие результаты в будущем.