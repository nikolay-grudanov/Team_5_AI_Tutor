---
source_image: page_626.png
page_number: 626
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 33.87
tokens: 7827
characters: 2883
timestamp: 2025-12-24T01:26:48.390041
finish_reason: stop
---

Поскольку встроенная функция print в Python 3.x выводит все переменное количество своих аргументов, следующие далее формы будут эквивалентными — в последней используется * для распаковки результатов, поступивших из генераторного выражения (во второй форме также создается список возвращаемых значений, а первая может оставить курсор в конце строки вывода в некоторых оболочках, но не в графическом пользовательском интерфейсе IDLE):

```python
>>> for x in 'spam': print(x.upper(), end=' ')
SPAM

>>> list(print(x.upper(), end=' ') for x in 'spam')
SPAM [None, None, None, None]

>>> print(*(x.upper() for x in 'spam'))
SPAM
```

Дополнительный пример распаковки строк, переданных файловым итератором, в аргументы приводился в главе 14.

Предварительный обзор:
итерируемые объекты, определяемые пользователем в классах

Несмотря на что данная тема выходит за рамки настоящей главы, следует упомянуть о возможности реализации произвольных определяемых пользователем объектов генераторов с помощью классов, которые адаптированы к протоколу итерации. В таких классах определен специальный метод __iter__, запускаемый встроенной функцией iter. Функция iter в свою очередь возвращает объект, который имеет метод __next__ (next в Python 2.x), запускаемый встроенной функцией next:

```python
class SomeIterable:
    def __iter__(...): ...
        # Запускается iter(): возвращает текущий или
        # дополнительный объект
    def __next__(...): ...
        # Запускается next(): реализуется здесь или
        # в другом классе
```

Как упоминалось в предыдущем разделе, эти классы обычно возвращают свои объекты напрямую для поведения с единственной итерацией или дополнительный объект для поддержки множества проходов.

В качестве альтернативы функции методов в определяемом пользователем классе итерируемых объектов временами может использоваться yield для превращения их самих в генераторы с автоматически создаваемым методом __next__ — распространенное применение yield, демонстрируемое в главе 30, которое совершенно нев явное и потенциально полезное! Метод индексации __getitem__ также доступен в виде запасного варианта для итерации, хотя он часто не настолько гибкий, как схема с __iter__ и __next__ (но обладает преимуществами при работе с последовательностями).

Объекты экземпляров, созданные из такого класса, считаются итерируемыми и могут использоваться в циклах for и всех остальных итерационных контекстах. Тем не менее, посредством классов мы имеем доступ к развитым возможностям логики и структурирования данных, таким как наследование, которое другие генераторные конструкции сами по себе предложить не в состоянии. За счет написания кода методов классы также могут делать поведение итерации более явным, нежели "магические" объекты итераторов, ассоциированные со встроенными типами и генераторными функциями и выражениями (правда, классы обладают собственной магией).