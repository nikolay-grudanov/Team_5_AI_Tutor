---
source_image: page_620.png
page_number: 620
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 32.14
tokens: 7765
characters: 2661
timestamp: 2025-12-24T01:26:36.752607
finish_reason: stop
---

**Генераторные функции**

Определение def, содержащее оператор yield, превращается в генераторную функцию. При вызове она возвращает новый объект генератора с автоматическим сохранением локальной области видимости и местоположения в коде, автоматически созданным методом __iter__, который просто возвращает сам объект, и автоматически созданным методом __next__ (next в Python 2.x), который запускает функцию или возобновляет ее выполнение с места, где она находилась в последний раз, и инициирует исключение StopIteration, когда выпуск результатов завершен.

**Генераторные выражения**

Выражение включения, помещенное в круглые скобки, известно как генераторное выражение. Оно возвращает новый объект генератора с таким же автоматически созданным интерфейсом в виде методов и сохранением состояния, как у генераторной функции, т.е. с методом __iter__, просто возвращающим сам объект, и методом next (next в Python 2.x), который запускает неявный цикл или возобновляет его выполнение с места, где он находился в последний раз, и инициирует исключение StopIteration, когда выпуск результатов завершен.

Совокупным эффектом является выпуск результатов по запросу в итерационных контекстах, которые задействуют такие интерфейсы автоматически.

Как вытекает из ряда предшествующих разделов, одну и ту же итерацию часто можно записать с помощью либо генераторной функции, либо генераторного выражения. Скажем, следующее генераторное выражение повторяет каждый символ в строке четыре раза:

```python
>>> G = (c * 4 for c in 'SPAM')    # Генераторное выражение
>>> list(G)                        # Заставляет генератор выпустить все результаты
['SSSS', 'PPPP', 'AAAA', 'MMMM']
```

Эквивалентная генераторная функция требует чуть больше кода, но как функция с множеством операторов при необходимости она будет способна содержать больше логики и использовать больший объем информации о состоянии. По существу речь идет о таком же компромиссе, как между lambda и def в предыдущей главе — лаконичность выражения против мощи оператора:

```python
>>> def timesfour(S):                # Генераторная функция
...     for c in S:
...         yield c * 4
...
>>> G = timesfour('spam')
>>> list(G)                          # Автоматическая итерация
['ssss', 'pppp', 'aaaa', 'mmmm']
```

Для клиентов две версии больше похожи, нежели разнятся. Как выражения, так и функции поддерживают автоматическую и ручную итерацию — вызов list выше выполняет автоматическую итерацию, а в следующем коде итерация осуществляется вручную:

```python
>>> G = (c * 4 for c in 'SPAM')
>>> I = iter(G)                      # Итерация вручную (выражение)
>>> next(I)
'SSSS'
>>> next(I)
'PPPP'
```