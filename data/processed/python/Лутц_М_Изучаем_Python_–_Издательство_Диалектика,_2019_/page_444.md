---
source_image: page_444.png
page_number: 444
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 23.75
tokens: 7537
characters: 1789
timestamp: 2025-12-24T01:21:09.890202
finish_reason: stop
---

В действительности он основан на двух объектах, применяемых итерационными инструментами на двух отдельных шагах:

• итерируемый объект, для которого запрашивается итерация, чей метод __iter__ запускается методом iter;
• объект итератора, возвращенный итерируемым объектом, который фактически производит значения во время итерации, чей метод __next__ запускается методом next, и генерирует исключение StopIteration, когда завершает выдачу результатов.

![Протокол итерации Python](https://i.imgur.com/3Q5z5QG.png)

Рис. 14.1. Протокол итерации Python, используемый циклами for, включениями, картами и т.д., который поддерживается файлами, списками, словарями, генераторами из главы 20 и другими объектами. Некоторые объекты представляют собой одновременно итерационный контекст и итерируемый объект, такие как генераторные выражения и варианты ряда инструментов в Python 3.x (вроде map и zip). Определенные объекты являются и итерируемыми, и итераторами, возвращая самих себя для вызова iter(), который затем будет пустой операцией

В большинстве случаев такие шаги организуются итерационными инструментами автоматически, но полезно понимать роли упомянутых двух объектов. Скажем, в ряде ситуаций эти два объекта представляют собой одно и то же, когда поддерживается только одиночный просмотр (например, файлы), а объект итератора часто является временным, используемым внутренне итерационным инструментом.

Более того, определенные объекты оказываются как инструментом контекста итерации (они выполняют итерацию), так и итерируемым объектом (их результаты итерируемы), включая генераторные выражения из главы 20, а также map и zip в Python 3.x. Как мы увидим позже, в Python 3.x состав итерируемых объектов пополнился дополнительными инструментами, в том числе map, zip, range и некоторыми