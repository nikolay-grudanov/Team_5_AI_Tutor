---
source_image: page_633.png
page_number: 633
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 47.91
tokens: 8207
characters: 3068
timestamp: 2025-12-24T01:27:16.290274
finish_reason: stop
---

ением списка либо введет заметную и возможно бесконечную паузу, либо потерпит неудачу из-за высоких требований к памяти. С другой стороны, рекурсивный генератор permute2 справляется с задачей, т.к. быстро возвращает индивидуальные результаты и может обрабатывать очень крупные наборы значений:

```python
>>> import math
>>> math.factorial(10)    # 10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1
3628800
>>> from permute import permute1, permute2
>>> seq = list(range(10))
>>> p1 = permute1(seq)     # 37 секунд на компьютере с четырехядерным
# процессором 2 ГГц
# Создает список из более 3,6 миллиона чисел
>>> len(p1), p1[0], p1[1]
(3628800, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [0, 1, 2, 3, 4, 5, 6, 7, 9, 8])
```

В данном случае функция permute1 сделала на моем компьютере паузу длительностью 37 секунд, пока строила список из более 3,6 миллиона элементов, но функция permute2 может начать возвращение результатов незамедлительно:

```python
>>> p2 = permute2(seq)     # Генератор немедленно возвращает управление
>>> next(p2)               # И быстро производит каждый результат по запросу
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
>>> next(p2)
[0, 1, 2, 3, 4, 5, 6, 7, 9, 8]
>>> p2 = list(permute2(seq))   # Около 28 секунд, хотя в этом нет смысла
>>> p1 == p2                 # Генерируется точно такой же набор результатов
True
```

Естественно, мы могли бы оптимизировать код функции построения списка, чтобы он выполнялся быстрее (скажем, применение явного стека вместо рекурсии изменило бы ее производительность), но для более крупных последовательностей эта функция вообще неприемлема — для всего лишь 50 элементов количество перестановок не позволяет построить список результатов, требуя ожидания слишком долгого времени для простых смертных вроде нас (и более высокие значения превышат заранее установленный предел глубины стека рекурсии: см. предыдущую главу). Тем не менее, генератор вполне жизнеспособен — он в состоянии производить индивидуальные результаты незамедлительно:

```python
>>> math.factorial(50)
30414093201713378043612608166064768844377641568960512000000000000
>>> p3 = permute2(list(range(50)))
>>> next(p3)                # permute1 здесь не подходит!
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,
23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43,
44, 45, 46, 47, 48, 49]
```

Ради еще большей забавы, а также для выдачи более изменчивых и менее детерминированных результатов, мы могли бы также использовать модуль Python по имени random из главы 5, чтобы случайным образом тасовать последовательность до того, как функция перестановок начнет свою работу. (Фактически в общем случае допускается применять функцию случайного тасования в качестве генератора перестановок, когда мы либо можем предположить, что она не будет повторять тасования, пока мы их потребляем, либо проверять ее результаты перед тасованием во избежание повторений — и уповать на то, что мы не живем в странной вселенной, где случайная последовательность повторяет тот же самый результат бесконечное количество раз!)