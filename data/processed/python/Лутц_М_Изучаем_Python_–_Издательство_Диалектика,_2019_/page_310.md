---
source_image: page_310.png
page_number: 310
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 34.36
tokens: 7928
characters: 3033
timestamp: 2025-12-24T01:17:00.685974
finish_reason: stop
---

же категории, что и типы Fraction и Decimal из главы 5), поэтому ищите сведения о них в руководстве по библиотеке Python.

Однако кратко отметим, что кортежи и именованные кортежи поддерживают распаковывающее присваивание кортежей, которое мы формально обсудим в главе 13, а также итерационные контексты, исследуемые в главах 14 и 20 (обратите внимание на позиционные начальные значения: именованные кортежи принимают их по имени, по позиции или по тому и другому):

```python
>>> bob = Rec('Bob', 40.5, ['dev', 'mgr']) # Для кортежей и именованных кортежей
>>> name, age, jobs = bob                  # Присваивание кортежей (глава 11)
>>> name, jobs
('Bob', ['dev', 'mgr'])
>>> for x in bob: print(x)                 # Итерационный контекст (главы 14, 20)
... выводит Bob, 40.5, ['dev', 'mgr']...
```

Распаковывающее присваивание кортежей не вполне применимо к словарям, если не считать извлечения и преобразования ключей и значений, а также допущения или навязывания им позиционного упорядочения (словари не являются последовательностями), и итерация проходит по ключам, а не по значениям (обратите внимание на форму словарного литерала как альтернативу dict):

```python
>>> bob = {'name': 'Bob', 'age': 40.5, 'jobs': ['dev', 'mgr']}
>>> job, name, age = bob.values()
>>> name, job                        # Эквивалент dict (но порядок может варьироваться)
('Bob', ['dev', 'mgr'])
>>> for x in bob: print(bob[x])      # Проход по ключам, индексация значений
... выводит значения...
```

Дождитесь финальной переделки этого представления записи в главе 27, где будет показано, каким образом в общую картину вписываются классы, определяемые пользователем; как выяснится, классы также обозначают поля именами, но могут предоставить еще и программную логику для обработки данных записи в той же самой упаковке.

Файлы

Возможно, вы уже знакомы с понятием файлов, которые представляют собой именованные ячейки хранилища на компьютере, управляемые операционной системой. Последний исследуемый крупный встроенный тип основных объектов обеспечивает способ доступа к таким файлам внутри программ Python.

Вкратце встроенная функция open создает файловый объект Python, который служит ссылкой на файл, находящийся на вашем компьютере. После вызова open вы можете передавать строки данных в и из ассоциированного внешнего файла, вызывая методы возвращенного файлового объекта.

По сравнению с типами, которые вы видели до сих пор, файловые объекты кое в чем необычны. Они считаются основным типом, потому что создаются встроенной функцией, но отличаются от чисел, последовательностей или отображений, а также не реагируют на операции выражений; файловые объекты экспортируют только методы для решения распространенных задач обработки файлов. Большинство файловых методов занимаются выполнением ввода из и вывода во внешний файл, ассоциированный с файловым объектом, но остальные файловые методы позволяют переходить в новую позицию внутри файла, сбрасывать буферы вывода и т.д. В табл. 9.2 приведен обзор часто применяемых файловых операций.