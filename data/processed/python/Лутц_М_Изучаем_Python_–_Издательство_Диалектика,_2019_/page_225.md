---
source_image: page_225.png
page_number: 225
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 30.42
tokens: 7835
characters: 2755
timestamp: 2025-12-24T01:13:58.416629
finish_reason: stop
---

Управляющие последовательности позволяют внедрять в строки символы, которые не могут быть легко набраны на клавиатуре. Символ \ и один или более следующих за ним символов в строковом литерале в результирующем строковом объекте заменяются одиночным символом, который имеет двоичное значение, указанное управляющей последовательностью. Скажем, вот пятисимвольная строка, в которую внедрены символы новой строки и табуляции:

```python
>>> s = 'a\nb\tc'
```

Два символа \n обозначают одиночный символ — двоичное значение символа новой строки в таблице символов (код символа 10 в ASCII). Подобным образом последовательность \t заменяется символом табуляции. То, как строка будет выглядеть при выводе, зависит от способа ее вывода. Интерактивный автоматический вывод показывает специальные символы как управляющие последовательности, но print их интерпретирует:

```python
>>> s
'a\nb\tc'
>>> print(s)
a
b    c
```

Чтобы выяснить, сколько действительных символов содержится в строке, применийте встроенную функцию len, которая возвращает фактическое количество символов в строке независимо от того, каким образом они кодируются или отображаются:

```python
>>> len(s)
5
```

Строка имеет длину пять символов: она содержит ASCII-символ a, символ новой строки, ASCII-символ b и т.д.

Если вы привыкли к тексту, который весь представлен в кодировке ASCII, то заманчиво думать, что этот результат означает также 5 байтов, но поступать так не следует. На самом деле "байты" в мире Unicode ничего не значат. Прежде всего, строковый объект в Python, вероятно, занимает больше памяти.

Что более важно, содержимое и длина строки отражают кодовые точки (идентифицирующие числа) в терминах Unicode, где одиночный символ не обязательно отображается напрямую на один байт, либо когда кодируется в файлах, либо когда хранится в памяти. Такое отображение может оставаться правильным для простого текста в 7-битной кодировке ASCII, но даже это зависит как от типа внешней кодировки, так и от используемой схемы внутреннего хранилища. Например, в UTF-16 символы ASCII занимают несколько байтов в файлах и могут требовать 1, 2 или 4 байта в памяти в зависимости от того, каким образом Python выделяет для них пространство. Для текста, отличающегося от ASCII, чьи значения символов могут быть слишком большими, чтобы уместиться в 8-битный байт, отображение символов на байты вообще неприменимо.

Фактически ради ясности в Python 3.x строки str формально определены как последовательности кодовых точек Unicode, но не байтов. При желании можете почитать главу 37, в которой рассказывается, как строки хранятся внутренне. Пока безопаснее всего думать о символах, а не байтах в строках. Доверьтесь мне; как бывшему программисту на C мне тоже пришлось избавиться от этой привычки!