---
source_image: page_462.png
page_number: 462
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 30.54
tokens: 7728
characters: 2313
timestamp: 2025-12-24T01:21:48.268637
finish_reason: stop
---

Встроенная функция filter, которая кратко упоминалась в главе 12, и будет подробно рассматриваться в следующей части книги, аналогична. Она возвращает элементы в итерируемом объекте, для которых переданная функция дает True (как уже известно, в Python значение True относится к непустым объектам, а bool возвращает значение истинности объекта):

```python
>>> filter(bool, ['spam', '', 'ni'])
<filter object at 0x00000000029B7B70>
>>> list(filter(bool, ['spam', '', 'ni']))
['spam', 'ni']
```

Подобно большинству инструментов, обсуждаемых в этом разделе, встроенная функция filter как принимает итерируемый объект для обработки, так и возвращает итерируемый объект для генерации результатов в Python 3.x. Обычно ее можно эмулировать посредством расширенного синтаксиса списковых включений, который автоматически проверяет значения истинности:

```python
>>> [x for x in ['spam', '', 'ni'] if bool(x)]
['spam', 'ni']
>>> [x for x in ['spam', '', 'ni'] if x]
['spam', 'ni']
```

Итераторы с множеством проходов или с одним проходом

Важно видеть, чем объект, возвращаемый range, отличается от объектов, которые возвращаются встроенными функциями, описанными в настоящем разделе. Он поддерживает функцию len и индексацию, сам не является итератором (итератор создается вручную с помощью iter) и допускает использование в отношении результата множества итераторов с запоминанием их позиций независимым образом:

```python
>>> R = range(3)      # range допускает множество итераторов
>>> next(R)
TypeError: range object is not an iterator
Ошибка типа: объект range не является итератором
>>> I1 = iter(R)
>>> next(I1)
0
>>> next(I1)
1
>>> I2 = iter(R)      # Два итератора на одном диапазоне
>>> next(I2)
0
>>> next(I1)          # I1 находится не в том же месте, что и I2
2
```

Напротив, в Python 3.x встроенные функции zip, map и filter не поддерживают множество активных итераторов на том же самом результате. По указанной причине вызов iter необязателен для прохода по результатам таких объектов — они сами являются iter (в Python 2.x упомянутые встроенные функции возвращают списки с возможностью множества проходов, так что следующий подход к ним неприменим):

```python
>>> Z = zip((1, 2, 3), (10, 11, 12))
>>> I1 = iter(Z)
>>> I2 = iter(Z)      # Два итератора на одном результате zip
>>> next(I1)
(1, 10)
```