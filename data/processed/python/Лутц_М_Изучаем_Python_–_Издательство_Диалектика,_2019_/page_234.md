---
source_image: page_234.png
page_number: 234
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 35.24
tokens: 7893
characters: 2736
timestamp: 2025-12-24T01:14:27.254191
finish_reason: stop
---

Нарезание (S[i:j]) извлекает непрерывные сегменты последовательности:

• верхняя граница является исключающей;
• если границы не указаны, тогда по умолчанию для них принимаются 0 и длина последовательности;
• S[1:3] извлекает элементы, которые начинаются со смещения 1 и заканчиваются по смещению 3, не включая его;
• S[1:] извлекает элементы, начиная со смещения 1 и до конца (длина последовательности);
• S[:3] извлекает элементы, которые начинаются со смещения которые начинаются со смещения 0 и заканчиваются по смещению 3, не включая его;
• S[:−1] извлекает элементы, начиная со смещения 0 и заканчивая последним элементом, но не включая его;
• S[:] извлекает элементы, начиная со смещения 0 и до конца — создает копию верхнего уровня S.

Расширенное нарезание (S[i:j:k]) принимает шаг (или страйд (большой шаг)) k, который по умолчанию равен +1:
• позволяет пропускать элементы и менять порядок на противоположный, как объясняется в следующем разделе.

Во втором с конца пункте списка описан очень распространенный прием: создание полной копии верхнего уровня объекта последовательности — объект с тем же значением, но расположенный в отдельном участке памяти (вы больше узнаете о копиях в главе 9). Прием не особенно полезен для неизменяемых объектов вроде строк, но пригодится для объектов, которые могут изменяться на месте, таких как списки.

В следующей главе вы увидите, что синтаксис, используемый для индексации по смещению (квадратные скобки), применяется также и для индексации словарей по ключу; операции выглядят одинаково, но их интерпретации отличаются.

Расширенное нарезание: третий предел и объекты срезов

В Python 2.3 и последующих версиях для выражений срезов имеется поддержка необязательного третьего индекса, используемого в качестве шага (иногда называемого страйдом (большим шагом)). Шаг добавляется к индексу каждого извлеченного элемента. Теперь развитая форма среза выглядит как X[I:J:K] и означает "извлечь все элементы в X, начиная со смещения I и заканчивая смещением J−1, с шагом K". Третий предел, K, по умолчанию устанавливается в +1 и поэтому все элементы в срезе обычно извлекаются слева направо. Однако если вы укажете явное значение, то сможете применять третий предел для пропуска элементов или смены порядка их следования на противоположный.

Например, срез X[1:10:2] будет извлекать каждый второй элемент из X в рамках смещений 1–9, т.е. он накопит элементы по смещениям 1, 3, 5, 7 и 9. Как обычно, первый и второй пределы по умолчанию принимаются равными 0 и длине последовательности соответственно, так что X[:2] получает каждый второй элемент с начала и до конца последовательности:

>>> S = 'abcdefghijklmnopqrstuvwxyz'
>>> S[1:10:2]   # Пропуск элементов
'bdfhj'
>>> S[::2]
'acegikmo'