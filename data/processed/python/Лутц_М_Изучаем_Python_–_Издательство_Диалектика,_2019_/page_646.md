---
source_image: page_646.png
page_number: 646
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 27.77
tokens: 7672
characters: 2408
timestamp: 2025-12-24T01:27:16.297528
finish_reason: stop
---

ГЛАВА 21

Оценочные испытания

Теперь, когда известно, как писать код функций и пользоваться итерационными инструментами, мы собираемся приложить дополнительные усилия, чтобы заставить их работать вместе. Настоящая глава завершает часть книги, посвященную функциям, довольно крупным учебным примером, в котором измеряется относительная производительность описанных ранее итерационных инструментов.

Попутно в учебном примере исследуются инструменты Python для измерения времени выполнения кода, обсуждаются методики оценочных испытаний в целом и предоставляется возможность изучить код, который чуть более реалистичен и полезен, чем большинство того, что было показано до сих пор. Мы также измерим скорость текущих реализаций Python — величину, которая может быть, а может и не быть важной в зависимости от типа кода, который приходится писать.

Наконец, поскольку это последняя глава в данной части книги, мы представим обычный набор распространенных ловушек и упражнений, которые помогут приступить к реализации изученных идей. Но сначала давайте насладимся реалистичным приложением Python.

Измерение времени выполнения итерационных альтернатив

В книге встречалось несколько итерационных альтернатив. Как и многое другое в программировании, они демонстрируют компромиссы — в свете субъективных факторов вроде выразительности и более объективных критериев, таких как производительность. Часть вашей работы как программиста и инженера связана с выбором инструментов на основе факторов подобного рода.

С точки зрения производительности несколько раз упоминалось о том, что списковые включения иногда обладают преимуществом в скорости по сравнению с операторами цикла for, а вызовы map могут быть быстрее или медленнее в зависимости от схем вызова. Генераторные функции и выражения из предыдущей главы имеют тенденцию быть немного медленнее списковых включений, хотя они минимизируют требования относительно пространства памяти и не заставляют вызывающий код ожидать генерации всех результатов, когда их много.

В целом все это верно, но относительная производительность со временем может варьироваться из-за того, что внутренние механизмы Python постоянно изменяются и оптимизируются, а структура кода может произвольно влиять на скорость. Если вы хотите самостоятельно оценивать их производительность, тогда должны измерять время выполнения альтернативных версий на своем компьютере и своей версии Python.