---
source_image: page_594.png
page_number: 594
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 39.96
tokens: 7915
characters: 2893
timestamp: 2025-12-24T01:25:57.820818
finish_reason: stop
---

Подлежащая применению функция добавляет 3 к каждому элементу в списке counters; так как эта небольшая функция больше нигде не нужна, она была записана как внутристрочная посредством выражения lambda. Из-за того, что такие использования map эквивалентны циклам for, добавив немного кода, вы можете получить универсальную утилиту отображения:

```python
>>> def mymap(func, seq):
    res = []
    for x in seq: res.append(func(x))
    return res
```

Предполагая, что функция inc осталась в прежнем виде, мы можем отобразить ее на последовательность (или другой итерируемый объект) с помощью встроенной функции или нашего эквивалента:

```python
>>> list(map(inc, [1, 2, 3]))  # Встроенная функция является итерируемым объектом
[11, 12, 13]
>>> mymap(inc, [1, 2, 3])      # Наша функция строит список (см. генераторы)
[11, 12, 13]
```

Тем не менее, так как map — встроенная функция, она всегда доступна, всегда работает одинаково и дает преимущества в плане производительности (как будет доказано в главе 21, в некоторых режимах применения она быстрее вручную написанного цикла for). Кроме того, функцию map можно использовать более развитыми способами, чем показано здесь. Скажем, получив в качестве аргументов несколько последовательностей, map передает извлеченные из последовательностей элементы как индивидуальные аргументы функции pow:

```python
>>> pow(3, 4)                   # 3**4
81
>>> list(map(pow, [1, 2, 3], [2, 3, 4]))   # 1**2, 2**3, 3**4
[1, 8, 81]
```

В случае множества последовательностей map ожидает функцию с N аргументами для N последовательностей. Функция pow принимает в каждом вызове два аргумента — по одному из каждой последовательности, переданной map. Эмуляция такого обобщения на множество последовательностей в коде требует не особенно много работы, но мы отложим ее выполнение до следующей главы, где будут представлены дополнительные инструменты итерации.

Вызов map похож на выражения списковых включений, которые мы исследовали в главе 14 и в следующей главе снова к ним обратимся с точки зрения функционального программирования:

```python
>>> list(map(inc, [1, 2, 3, 4]))
[11, 12, 13, 14]
>>> [inc(x) for x in [1, 2, 3, 4]]  # Для генерации элементов взамен используйте ()
[11, 12, 13, 14]
```

В ряде случаев map способна выполнять быстрее, чем списковое включение (например, когда отображается встроенная функция), и может также требовать меньшего объема кода. С другой стороны, поскольку map применяет к каждому элементу вызов функции, а не произвольное выражение, она является менее универсальным инструментом и часто требует добавочных вспомогательных функций или lambda. Вдобавок помещение включения в круглые скобки вместо квадратных приводит к созданию объекта, который генерирует значения по запросу с целью экономии памяти и увеличения скорости реагирования, что во многом похоже на map в Python 3.x — мы займемся этой темой в следующей главе.