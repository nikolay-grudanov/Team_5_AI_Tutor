---
source_image: page_442.png
page_number: 442
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 30.49
tokens: 7686
characters: 2398
timestamp: 2025-12-24T01:21:13.567869
finish_reason: stop
---

загрузке строк. Скажем следующий код читает файл строка за строкой, попутно выводя версию каждой строки в верхнем регистре, причем вообще без явного чтения из файла:

```python
>>> for line in open('script2.py'):
    print(line.upper(), end='')
```

Обратите внимание, что end='' в print здесь используется для того, чтобы подавить добавление символа \n, т.к. строки уже его содержат (без end='' строки вывода будут чередоваться с пустыми строками; хвостовая запятая в Python 2.x делает ту же работу, что и end). В наши дни такой способ считается наилучшим для чтения текстовых файлов строка за строкой по трем причинам: он самый простой в плане написания кода, может оказаться самым быстрым при выполнении и лучший в отношении затрат памяти. Более старый, первоначальный способ достижения того же эффекта посредством цикла for предусматривает вызов файлового метода readlines для загрузки содержимого файла в память в виде списка строк:

```python
>>> for line in open('script2.py').readlines():
    print(line.upper(), end='')
```

Прием с методом readlines по-прежнему работает, но теперь не рассматривается как рекомендуемый подход и хуже в том, что касается расходования памяти. В действительности, поскольку эта версия фактически загружает в память сразу весь файл, он даже не будет работать для файлов, которые слишком велики, чтобы уместиться в пространстве памяти, доступном на компьютере. Напротив, из-за чтения по одной строке за раз версия на основе итератора неуязвима для такого рода проблем бурного роста расходуемой памяти. Кроме того, версия с итератором способна выполняться быстрее, хотя скорость может варьироваться от выпуска к выпуску.

Как упоминалось во врезке "Что потребует внимания: приемы просмотра файлов" в главе 13, читать файл строка за строкой возможно также с помощью цикла while:

```python
>>> f = open('script2.py')
>>> while True:
    ...     line = f.readline()
    ...     if not line: break
    ...     print(line.upper(), end='')
...
... тот же самый вывод...
```

Тем не менее, такой код может выполняться медленнее, чем версия на основе итератора с циклом for, потому что итераторы работают внутри Python со скоростью скомпилированного кода C, а версия с циклом while запускает байт-код Python через виртуальную машину Python. Каждый раз, когда мы меняем код Python на код C, скорость имеет тенденцию возрастать. Однако это не абсолютная истина, особенно