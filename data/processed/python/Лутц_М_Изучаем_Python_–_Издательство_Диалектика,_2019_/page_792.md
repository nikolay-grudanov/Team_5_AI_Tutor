---
source_image: page_792.png
page_number: 792
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 29.85
tokens: 7783
characters: 2787
timestamp: 2025-12-24T01:31:56.135021
finish_reason: stop
---

В следующей главе мы начнем исследование класса Python — инструмента объектно-ориентированного программирования. Там будут применимы многие темы, раскрытые в последних нескольких главах: классы также существуют в модулях и пространствах имен, но они добавляют к процессу нахождения атрибутов дополнительный компонент, который называется поиском в цепочке наследования. Но прежде чем переходить к классам, закрепите пройденный материал, ответив на контрольные вопросы главы, и выполните упражнения для данной части книги.

Проверьте свои знания: контрольные вопросы

1. Что важно знать о переменных на верхнем уровне модуля, чьи имена начинаются с одиночного подчеркивания?
2. Что означает наличие у переменной __name__ модуля строки "__main__"?
3. Если пользователь интерактивно вводит имя модуля для тестирования, то каким образом вы будете импортировать его в коде?
4. Чем изменение sys.path отличается от установки PYTHONPATH для модификации пути поиска модулей?
5. Если модуль __future__ позволяет импортировать из будущего, то можно ли импортировать также из прошлого?

Проверьте свои знания: ответы

1. Переменные на верхнем уровне модуля, чьи имена начинаются с одиночного подчеркивания, не копируются в область видимости импортера, когда используется форма оператора from *. Тем не менее, они по-прежнему доступны посредством оператора import или нормальной формы оператора from. Список __all__ похож, но является логической противоположностью; он содержит только те имена, которые копируются при выполнении from *.
2. Если значением переменной __name__ модуля является строка "__main__", то это означает, что файл выполняется как сценарий верхнего уровня, а не импортируется в другом файле внутри программы. То есть файл эксплуатируется как программа, не как библиотека. Такая переменная режима использования поддерживает код с двойным режимом и код самотестирования.
3. Вводимые пользователем данные обычно поступают внутрь сценария в виде строки; чтобы импортировать модуль, имя которого указано в строке, вы можете сформировать и запустить оператор import с помощью exes или передать строку с именем в вызове __import__ либо importlib.import_module.
4. Изменение sys.path воздействует только на одну выполняющуюся программу (процесс), и оно временно — когда программа заканчивает работу, изменение утрачивается. Настройка PYTHONPATH существует в среде операционной системы — она подхватывается глобально всеми вашими программами на компьютере и потому эта настройка остается после завершения программ.
5. Нет, импортировать из прошлого в Python нельзя. Мы можем установить (или упорно использовать) более старую версию языка, но обычно наилучшим выбором будет самая последняя версия Python (во всяком случае, внутри линеек — посмотрите только на долгожительство Python 2.x!).