---
source_image: page_455.png
page_number: 455
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 36.94
tokens: 7909
characters: 2976
timestamp: 2025-12-24T01:21:40.276134
finish_reason: stop
---

показаны в действии, автоматически запуская итератор файлового объекта, чтобы читать файл строка за строкой:

```python
>>> sorted(open('script2.py'))
['import sys\n', 'print(sys.path)\n', 'print(x ** 32)\n', 'x = 2\n']
>>> list(zip(open('script2.py'), open('script2.py')))
[('import sys\n', 'import sys\n'), ('print(sys.path)\n', 'print(sys.path)\n'), ('x = 2\n', 'x = 2\n'), ('print(x ** 32)\n', 'print(x ** 32)\n')]
>>> list(enumerate(open('script2.py')))
[(0, 'import sys\n'), (1, 'print(sys.path)\n'), (2, 'x = 2\n'), (3, 'print(x ** 32)\n')]
>>> list(filter(bool, open('script2.py')))    # nonempty=True
['import sys\n', 'print(sys.path)\n', 'x = 2\n', 'print(x ** 32)\n']
>>> import functools, operator
>>> functools.reduce(operator.add, open('script2.py'))
'import sys\nprint(sys.path)\nx = 2\nprint(x ** 32)\n'
```

Все они являются итерационными инструментами, но исполняют индивидуальные роли. Мы встречали zip и enumerate в предыдущей главе, а filter и reduce будут обсуждаться в главе 19 при рассмотрении области функционального программирования, поэтому мы отложим выяснение деталей до указанной главы. Здесь важно отметить лишь то, что они используют протокол итерации для файлов и других итерируемых объектов.

Впервые мы видели функцию sorted в работе в главе 4, и она применялась для словарей в главе 8. sorted является встроенной функцией, которая задействует протокол итерации — она похожа на первоначальный списковый метод sort, но возвращает в качестве результата новый отсортированный список и выполняется на любом итерируемом объекте. Обратите внимание, что в отличие от map и остальных функция sorted в Python 3.x возвращает реально существующий список, а не итерируемый объект.

Интересен тот факт, что протокол итерации в современном Python даже еще более вездесущий, чем демонстрировалось на примерах до сих пор — по существу абсолютно все встроенные инструменты в наборе Python, которые просматривают объект слева направо, определены для использования протокола итерации на указанном объекте. Сюда даже входят такие инструменты, как встроенные функции list и tuple (которые строят новые объекты из итерируемых объектов) и строковый метод join (который создает новую строку путем помещения подстроки между строками, содержащимися в итерируемом объекте). Следовательно, они также будут работать на открытом файле и автоматически читать по одной строке за раз:

```python
>>> list(open('script2.py'))
['import sys\n', 'print(sys.path)\n', 'x = 2\n', 'print(x ** 32)\n']
>>> tuple(open('script2.py'))
('import sys\n', 'print(sys.path)\n', 'x = 2\n', 'print(x ** 32)\n')
>>> '&'.join(open('script2.py'))
'import sys\n&print(sys.path)\n&x = 2\n&print(x ** 32)\n'
```

К этой категории относятся даже такие инструменты, которые вы могли не ожидать. Скажем, присваивание последовательностей, проверка членства in, присваивание срезов и списковый метод extend также задействуют протокол итерации для просмотра и потому автоматически читают файл по строкам: