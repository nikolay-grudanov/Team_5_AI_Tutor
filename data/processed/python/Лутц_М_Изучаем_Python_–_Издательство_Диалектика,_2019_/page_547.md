---
source_image: page_547.png
page_number: 547
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 41.14
tokens: 7936
characters: 2895
timestamp: 2025-12-24T01:24:28.230397
finish_reason: stop
---

заключается в том, что он отправляет обратно множественные результаты и эмулирует выходные параметры в других языках посредством явных присваиваний. Здесь X и L изменяются после вызова, но лишь потому, что так реализовано в коде.

Распаковка аргументов в Python 2.X. В предыдущем примере производилась распаковка кортежа, возвращенного функцией, с помощью присваивания кортежей. В Python 2.X можно также автоматически распаковывать кортежи в аргументах, передаваемых в функцию. В Python 2.X (только) функция, определенная со следующим заголовком:

def f((a, (b, c))): может быть вызвана с кортежами, которые имеют ожидаемую структуру: f((1, (2, 3))) присваивает a, b и с значения 1, 2 и 3 соответственно. Естественно, передаваемый кортеж также может быть объектом, созданным перед вызовом (f(T)). Представленный синтаксис def больше не поддерживается в Python 3.X. Взамен функция должна быть написана так:

def f(T): (a, (b, c)) = T

для распаковки в явном операторе присваивания. Такая явная форма работает и в Python 3.X, и в Python 2.X. Как сообщают, распаковка аргументов является малоизвестным и редко используемым средством в Python 2.X (помимо кода, в котором она применяется!). Кроме того, заголовок функции в Python 2.X поддерживает только кортежную форму присваивания последовательности; более универсальные присваивания последовательностей (например, def f((a, [b, c])):) вызывают в Python 2.X синтаксические ошибки, а также требуют явной формы присваивания, обязательной в Python 3.X. И наоборот, произвольные последовательности в вызове успешно сопоставляются с кортежами в заголовке (скажем, f((1, [2, 3])), f((1, "ab"))).

Синтаксис распаковки кортежей в аргументах также запрещен в списках аргументов функции lambda в Python 3.X: за примером распаковки для lambda обращайтесь во врезку "Что потребует внимания: списковые включения и тар" в главе 20. Несколько противоречиво, но распаковывающее присваивание кортежей по-прежнему автоматически выполняется для целей циклов for в Python 3.X; примеры ищите в главе 13.

Специальные режимы сопоставления аргументов

Как было показано, аргументы в Python всегда передаются по присваиванию; имени в заголовке def присваиваются переданные объекты. Тем не менее, помимо этой модели Python предлагает дополнительные инструменты, которые изменяют способ сопоставления объектов-аргументов в вызове с именами аргументов в заголовке до момента присваивания. Все инструменты такого рода необязательны, но они позволяют писать функции, которые поддерживают более гибкие шаблоны вызова, к тому же встречаются библиотеки, которые их требуют.

По умолчанию аргументы сопоставляются по позиции, слева направо, и необходимо передавать ровно столько аргументов, сколько есть имен аргументов в заголовке функции. Однако можно также задавать сопоставление по имени, предоставлять стандартные значения и использовать собиратели для добавочных аргументов.