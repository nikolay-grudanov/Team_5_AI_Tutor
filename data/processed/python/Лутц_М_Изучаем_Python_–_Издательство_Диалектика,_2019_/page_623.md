---
source_image: page_623.png
page_number: 623
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 35.38
tokens: 7820
characters: 2576
timestamp: 2025-12-24T01:26:42.369397
finish_reason: stop
---

Хотя указанная особенность не настолько очевидна в простых примерах, она может иметь значение в вашем коде: если вы хотите просматривать значения генератора много раз, тогда должны либо создавать новый генератор для каждого просмотра, либо построить из его значений список, допускающий многократные просмотры — значения единственного генератора будут потребляться и израсходоваться после одного прохода. Основной пример кода, который должен приспосабливаться к такому свойству генераторов, предложен во врезке "Что потребует внимания: одноразовые итерации" далее в главе.

Начав писать код итерируемых объектов на основе классов в части VI второго тома, мы также увидим, что сами решаем, сколько итераций должны поддерживаться для объектов. В целом объекты, которым необходимо поддерживать множество проходов, будут возвращать вместо самих себя экземпляры добавочного класса. Предварительный обзор такой модели представлен в следующем разделе.

Расширение yield from из Python 3.3

В версии Python 3.3 появился расширенный синтаксис для оператора yield, который делает возможным делегирование работы подгенератору с помощью конструкции from генератор. В простых ситуациях он эквивалентен выдаче в цикле for — в следующем коде вызов list заставляет генератор выпустить все свои значения, а включение в круглых скобках является генераторным выражением, раскрытым в данной главе:

```python
>>> def both(N):
    for i in range(N): yield i
    for i in (x ** 2 for x in range(N)): yield i
>>> list(both(5))
[0, 1, 2, 3, 4, 0, 1, 4, 9, 16]
```

Новый синтаксис Python 3.3 возможно делает это более лаконичным и явным и поддерживает все обычные контексты применения генераторов:

```python
>>> def both(N):
    yield from range(N)
    yield from (x ** 2 for x in range(N))
>>> list(both(5))
[0, 1, 2, 3, 4, 0, 1, 4, 9, 16]
>>> ': '.join(str(i) for i in both(5))
'0 : 1 : 2 : 3 : 4 : 0 : 1 : 4 : 9 : 16'
```

Однако в более развитых ролях такое расширение позволяет подгенераторам получать значения, переданные методами send и throw, напрямую из вызывающей области видимости и возвращать финальное значение внешнему генератору. В итоге появляется возможность разделения таких генераторов на множество подгенераторов, очень похожую на возможность разделения одиночной функции на несколько подфункций.

Поскольку расширение yield from доступно, только начиная с Python 3.3, и выходит за рамки общего описания генераторов, дополнительные сведения ищите в руководствах по языку. Еще один пример использования yield from можно найти в решении упражнения 11, приведенного в конце главы 21.