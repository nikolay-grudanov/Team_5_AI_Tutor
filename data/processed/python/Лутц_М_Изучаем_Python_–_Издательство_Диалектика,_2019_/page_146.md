---
source_image: page_146.png
page_number: 146
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 36.06
tokens: 7949
characters: 2825
timestamp: 2025-12-24T01:11:34.233981
finish_reason: stop
---

>>> [[x ** 2, x ** 3] for x in range(4)]   # Множество значений, фильтры if
[[0, 0], [1, 1], [4, 8], [9, 27]]
>>> [[x, x / 2, x * 2] for x in range(-6, 7, 2) if x > 0]
[[2, 1, 4], [4, 2, 8], [6, 3, 12]]

Как вы, по всей видимости, можете сказать, списковые включения и родственные им встроенные функции вроде map и filter слишком запутаны, чтобы их удалось полностью раскрыть в обзорной главе. Главная цель этого краткого введения — показать, что в арсенале Python имеются и простые, и сложные инструменты. Списковые включения относятся к необязательным средствам, но оказываются очень удобными на практике и часто предлагают преимущество высокой скорости обработки. Они работают с любым типом, являющимся последовательностью в Python, а также с рядом типов, которые последовательностями не являются. В ходе чтения книги вы еще неоднократно столкнетесь с ними.

Однако, забегая несколько вперед, следует отметить, что в последних версиях Python синтаксис списковых включений обобщен для исполнения других ролей: в наши дни они предназначены не только для построения списков. Например, помещая списковое включение в круглые скобки, можно создавать генераторы, которые производят результаты по требованию. В целях иллюстрации встроенная функция sum суммирует элементы в последовательности; вот пример суммирования всех элементов в строках нашей матрицы по требованию:

>>> G = (sum(row) for row in M)   # Создать генератор сумм элементов в строках
>>> next(G)                        # iter(G) здесь не требуется
6
>>> next(G)                        # Запустить протокол итерации next()
15
>>> next(G)
24

Встроенная функция map способна выполнять похожую работу, генерируя результаты прогона элементов через функцию, по одному за раз и по запросу. Подобно range ее помещение внутрь вызова list приводит к возвращению всех значений в Python 3.x. В версии Python 2.x в этом нет необходимости, т.к. там функция map одновременно создает список результатов. Нет нужды вызывать list и в других контекстах, которые выполняют итерацию автоматически, если только не требуется множество проходов или поведение как у списков:

>>> list(map(sum, M))   # Отобразить sum на элементы в M
[6, 15, 24]

В версиях Python 2.7 и 3.x синтаксис списковых включений можно также использовать для создания множеств и словарей:

>>> {sum(row) for row in M}   # Создать множество сумм элементов в строках
{24, 6, 15}
>>> {i : sum(M[i]) for i in range(3)}   # Создать таблицу ключей/
# значений сумм элементов в строках
{0: 6, 1: 15, 2: 24}

На самом деле в Python 3.x и 2.7 списки, множества, словари и генераторы могут быть проростоены с помощью списковых включений:

>>> [ord(x) for x in 'спраам']   # Список порядковых чисел для символов
[115, 112, 97, 97, 109]
>>> {ord(x) for x in 'спраам'}   # Множество с удаленными дубликатами
{112, 97, 115, 109}