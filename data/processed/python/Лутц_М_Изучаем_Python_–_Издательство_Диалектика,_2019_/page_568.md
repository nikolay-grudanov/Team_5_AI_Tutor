---
source_image: page_568.png
page_number: 568
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 26.58
tokens: 7701
characters: 2413
timestamp: 2025-12-24T01:24:54.867391
finish_reason: stop
---

1...2...3
1...[2]...(3,)
4567 8 9
1???2???3.

При выполнении в Python 3.X, хотя это не имеет особого смысла, результаты будут идентичными. Как обычно, универсальность структуры Python позволяет нам создавать прототипы или развивать концепции в самом языке Python. В данном случае инструменты сопоставления аргументов в коде Python оказываются в той же степени гибкими, как и во внутренней реализации Python.

Использование аргументов с передачей только по ключевым словам

Интересно отметить, что рассмотренный выше пример можно было бы реализовать с применением аргументов с передачей только по ключевым словам Python 3.X, описанных ранее в главе, для автоматической проверки конфигурационных аргументов. Вот вариант кода из файла print3_alt1.py:

#!/python3
"Использование аргументов с передачей только по ключевым словам Python 3.X"
import sys

def print3(*args, sep=' ', end='\n', file=sys.stdout):
    output = ''
    first = True
    for arg in args:
        output += ('' if first else sep) + str(arg)
        first = False
    file.write(output + end)

Версия работает точно так же, как оригинал, и является главным примером, насколько полезными могут оказаться аргументы с передачей только по ключевым словам. В первоначальной версии предполагается, что все позиционные аргументы подлежат выводу, а все ключевые аргументы предназначены только для конфигурационных параметров. Этого почти достаточно, но любые добавочные ключевые аргументы молча игнорируются. Вызов вроде следующего, например, корректно сгенерирует исключение, когда функция имеет аргументы с передачей только по ключевым словам:

>>> print3(99, name='bob')
TypeError: print3() got an unexpected keyword argument 'name'
Ошибка типа: print3() получила непредвиденный ключевой аргумент name

но молча проигнорирует аргумент name в первоначальной версии функции. Для обнаружения избыточных ключевых аргументов вручную мы могли бы использовать dict.pop(), чтобы удалять извлеченные элементы и проверять, не пуст ли словарь. Показанная далее версия из файла print3_alt2.py эквивалентна версии, где применяются аргументы с передачей только по ключевым словам — она генерирует встроенное исключение с помощью оператора raise, который работает так, как если бы исключение генерировал Python (мы исследуем его более детально в части VII):

#!/python
"Использование удаления ключевых аргументов Python 2.X/3.X со стандартными значениями"
import sys