---
source_image: page_647.png
page_number: 647
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 29.30
tokens: 7730
characters: 2469
timestamp: 2025-12-24T01:27:17.905069
finish_reason: stop
---

Модуль измерения времени: любительский

К счастью, Python делает измерение времени выполнения кода простым. Например, чтобы получить суммарное время, необходимое для выполнения множества вызовов функции с произвольными позиционными аргументами, может быть достаточно следующей упрощенной функции:

# Файл timer0.py
import time
def timer(func, *args):        # Упрощенная функция измерения времени
    start = time.clock()
    for i in range(1000):
        func(*args)
    return time.clock() - start   # Суммарное истекшее время в секундах

Функция timer работает — она извлекает значения времени из модуля Python по имени time и вычитает системное время начала из времени останова после выполнения 1 000 вызовов переданной функции с переданными инструментами. Вот пример ее запуска на компьютере с версией Python 3.7:

>>> from timer0 import timer
>>> timer(pow, 2, 1000)      # Время, затраченное на вызов pow(2, 1000)
1000 раз
0.0029763490000007664
>>> timer(str.upper, 'spam')  # Время, затраченное на вызов 'spam'.upper()
1000 раз
0.000178626999999682263

Наряду с простотой функция timer также является довольно ограниченной и намеренно демонстрирует несколько классических заблуждений относительно проектирования функций и оценочных испытаний. Помимо прочего она:

• не поддерживает ключевые аргументы в вызове тестируемой функции;
• имеет жестко закодированное количество повторений;
• добавляет затраты на вызов range ко времени тестируемой функции;
• всегда использует метод time.clock, который может оказаться не самым лучшим вариантом за пределами Windows;
• не предоставляет вызывающему коду способа проверки, что тестируемая функция действительно работает;
• дает только суммарное время, которое может меняться на сильно загруженных компьютерах.

Другими словами, код измерения времени сложнее, чем вы могли ожидать! Чтобы обеспечить большую универсальность и точность, давайте расширим его до по-прежнему простых, но более полезных служебных функций хронометража, которые мы сможем задействовать для сравнения итерационных альтернатив и применять для решения других задач измерения времени в будущем. Функции будут помещены в файл модуля, так что их можно будет использовать в разнообразных программах, и иметь строки документации, предоставляющие основные детали, которые инструмент PyDoc способен отображать по запросу — на рис. 15.2 был представлен экранный снимок страниц документации, визуализируемых для создаваемых здесь модулей измерения времени: