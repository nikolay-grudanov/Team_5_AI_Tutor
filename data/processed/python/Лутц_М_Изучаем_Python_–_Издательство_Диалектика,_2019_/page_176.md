---
source_image: page_176.png
page_number: 176
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 36.84
tokens: 7990
characters: 3199
timestamp: 2025-12-24T01:12:30.050228
finish_reason: stop
---

В первом выражении скобки отсутствуют, поэтому Python автоматически группирует компоненты согласно правилу старшинства — из-за того, что операция / находится в табл. 5.2 ниже +, ее приоритет выше, и она вычисляется первой. Результат получается такой, как если бы выражение было организовано с помощью скобок в соответствие с тем, что показано в комментарии справа от кода.

Кроме того, обратите внимание на то, что в первом выражении все числа являются целыми. В итоге операция / из Python 2.X выполняет целочисленное деление и сложение, давая результат 5, тогда как операция / из Python 3.X выполняет настоящее деление, которое всегда предохраняет дробные остатки и дает показанный результат 5.0. Если вам необходимо целочисленное деление Python 2.X в версии Python 3.X, тогда запишите выражение в виде b // 2 + a. Если же нужно настоящее деление Python 3.X в версии Python 2.X, то запишите выражение в форме b / 2.0 + a (мы обсудим деление очень скоро).

Во втором выражении часть + помещена в круглые скобки, чтобы заставить Python вычислить ее первой (т.е. перед операцией /). Мы также сделали один из операндов числом с плавающей точкой, добавив десятичную точку: 2.0. По причине разнородности типов Python преобразует целое значение, на которое ссылается a, в значение с плавающей точкой (3.0) перед выполнением операции +. Если бы все числа в выражении были целыми, то целочисленное деление (4 / 5) выдало бы усеченное целое значение 0 в Python 2.X, но значение с плавающей точкой 0.8 в Python 3.X. Дождитесь формальных деталей, касающихся деления.

Форматы числового отображения

Если вы работаете с Python 2.6, Python 3.0 или более ранней версией, то результат последнего из предшествующих примеров на первый взгляд может показаться несколько странным:

```python
>>> b / (2.0 + a)    # Python <= 2.6: выводит больше (или меньше) цифр
0.80000000000000004
>>> print(b / (2.0 + a))   # Но print выполняет округление
0.8
```

Мы соприкоснулись с таким явлением в предыдущей главе, и в Python 2.7, 3.1 и последующих версиях оно отсутствует. Причина столь странного результата связана с ограничениями оборудования для вычислений с плавающей точкой и его неспособностью к точному представлению некоторых значений в ограниченном количестве битов. Поскольку архитектура компьютера выходит за рамки тематики настоящей книги, мы обойдем это и заявим, что оборудование для вычислений с плавающей точкой делает все возможное, и ни оно, ни Python здесь не ошибается.

В действительности возникает просто проблема отображения — автоматический вывод интерактивной подсказки содержит больше цифр, чем вывод оператора print, только потому, что он использует отличающийся алгоритм. В памяти хранится одно и то же число. Если вы не хотите видеть все цифры, тогда применяйте print; как объясняется во врезке "Форматы отображения str и repr" далее в главе, вы получите отображение, дружественное в отношении пользователя. Начиная с версий Python 2.7 и 3.1, логика отображения чисел с плавающей точкой старается быть более интеллектуальной и обычно показывает меньше цифр, но временами больше.

Тем не менее, обратите внимание, что так много цифр отображается не для всех значений:

```python
>>> 1 / 2.0
0.5
```