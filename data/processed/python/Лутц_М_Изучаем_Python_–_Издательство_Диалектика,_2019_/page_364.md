---
source_image: page_364.png
page_number: 364
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 35.94
tokens: 8033
characters: 3103
timestamp: 2025-12-24T01:18:49.513807
finish_reason: stop
---

• Перед ссылкой именам должно быть выполнено присваивание. Ошибочно применять имя, которому пока еще не присваивалось значение. На попытку поступить так Python отреагирует генерацией исключения, а не возвращением какого-нибудь неясного стандартного значения. Это оказывается критически важным в Python, потому что имена заранее не объявляются — если бы Python предоставлял стандартные значения в случае использования в программе имен, которым не производилось присваивание, вместо того, чтобы трактовать их как ошибки, тогда было бы гораздо сложнее отлавливать опечатки в коде.

• Некоторые операции неявно выполняют присваивания. В текущем разделе мы сосредоточим внимание на операторе =, но в Python присваивания происходят во многих контекстах. Скажем, позже вы увидите, что импортирование модулей, определения функций и классов, переменные циклов for и аргументы функций являются неявными присваиваниями. Поскольку присваивание работает одинаково везде, где встречается, во время выполнения все упомянутые контексты просто связывают (т.е. присваивают) имена со ссылками на объекты.

Формы оператора присваивания

Несмотря на то что присваивание в Python является универсальной и всепроникающей концепцией, в главе нас интересует главным образом операторы присваивания. В табл. 11.1 проиллюстрированы различные формы оператора присваивания в Python вместе с их синтаксическими шаблонами.

Таблица 11.1. Формы оператора присваивания

<table>
  <tr>
    <th>Операция</th>
    <th>Описание</th>
  </tr>
  <tr>
    <td>spam = 'Spam'</td>
    <td>Базовая форма</td>
  </tr>
  <tr>
    <td>spam, ham = 'yum', 'YUM'</td>
    <td>Присваивание кортежа (позиционное)</td>
  </tr>
  <tr>
    <td>[spam, ham] = ['yum', 'YUM']</td>
    <td>Присваивание списка (позиционное)</td>
  </tr>
  <tr>
    <td>a, b, c, d = 'spam'</td>
    <td>Присваивание последовательности, обобщенное</td>
  </tr>
  <tr>
    <td>a, *b = 'spam'</td>
    <td>Расширенная распаковка последовательности (Python 3.x)</td>
  </tr>
  <tr>
    <td>spam = ham = 'lunch'</td>
    <td>Групповое присваивание</td>
  </tr>
  <tr>
    <td>spams += 42</td>
    <td>Дополненное присваивание (эквивалентно spams = spams + 42)</td>
  </tr>
</table>

Наиболее распространенной безоговорочно считается первая форма присваивания в табл. 11.1: связывание имени (или компонента структуры данных) с одиночным объектом. В действительности вы могли бы сделать всю свою работу с помощью только этой базовой формы. В остальных строках табл. 11.1 представлены специальные формы, которые необязательны, но программисты часто находят их удобными на практике.

Распаковывающие присваивания кортежей и списков

Вторая и третья формы в табл. 11.1 являются родственными. Когда вы записываете кортеж или список слева от =, Python попарно соединяет объекты справа с целями слева по позициям, выполняя присваивание слева направо. Например, во второй строке табл. 11.1 имени spam присваивается строка 'yum', а имя ham связывается со строкой 'YUM'. В данном случае Python внутренне может создавать кортеж элементов справа, поэтому такое присваивание называют распаковывающим.