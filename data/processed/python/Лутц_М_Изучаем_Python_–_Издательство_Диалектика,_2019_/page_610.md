---
source_image: page_610.png
page_number: 610
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 36.11
tokens: 7954
characters: 3470
timestamp: 2025-12-24T01:26:21.367985
finish_reason: stop
---

### Приостановка выполнения с сохранением состояния

В отличие от нормальных функций, которые возвращают значение и прекращают работу, генераторные функции автоматически приостанавливают и возобновляют свое выполнение и состояние вокруг точки генерации значений. По этой причине они часто будут служить удобной альтернативой заблаговременному вычислению полной серии значений с последующим сохранением и восстановлением вручную состояния посредством классов. Состояние, которое генераторные функции сохраняют, когда приостанавливаются, содержит местоположение в коде и полную локальную область видимости. Следовательно, их локальные переменные помнят информацию между выпуском результатов и делают ее доступной при возобновлении выполнения функциями.

Основная разница между кодом генераторных и нормальных функций заключается в том, что генератор выдает значение, а не возвращает его — оператор yield приостанавливает функцию и отправляет значение обратно вызывающему коду, но сохраняет достаточный объем состояния, чтобы предоставить функции возможность возобновить работу с места, которое она покинула. При возобновлении функция продолжает выполнение сразу после последнего запуска yield. С точки зрения функции такой прием позволяет ее коду производить серию значений с течением времени вместо вычисления их всех сразу и возвращения в чем-нибудь, подобном списку.

### Объединение с протоколом итерации

Чтобы по-настоящему понять генераторные функции, вы должны знать, что они тесно связаны с понятием протокола итерации в Python. Как вы видели, объекты итераторов определяют метод __next__ (next в Python 2.x), который либо возвращает очередной элемент в итерации, либо инициирует специальное исключение StopIteration для окончания итерации. Итератор итерируемого объекта первоначально извлекается с помощью встроенной функции iter, хотя этот шаг ничего не делает для объектов, которые сами являются итераторами.

Циклы for в Python и все остальные итерационные контексты используют протокол итерации для прохода по генератору последовательностей или значений, если протокол поддерживается (если нет, тогда итерация взамен предпринимает многократную индексацию последовательностей). Любой объект, поддерживающий такой интерфейс, работает со всеми итерационными инструментами.

Для поддержки протокола итерации функции, содержащие оператор yield, компилируются особым образом как генераторы — они не будут нормальными функциями, а строятся с целью возврата объекта с ожидаемыми методами из протокола итерации. При последующем вызове они возвращают объект генератора, который поддерживает интерфейс итерации с автоматически созданным методом по имени __next__, предназначенным для запуска или возобновления выполнения.

Генераторные функции могут также иметь оператор return, который наряду с перемещением за конец блока def просто прекращает генерацию значений — формально за счет инициирования исключения StopIteration после всех обычных действий по выходу из функции. С точки зрения вызывающего кода метод __next__ генератора возобновляет выполнение функции до тех пор, пока либо не возвратится следующий результат yield, либо до возникновения исключения StopIteration.

Совокупный эффект в том, что генераторные функции, которые записаны как операторы def, содержащие операторы yield, автоматически делаются доступными для протокола итерации и потому могут применяться в любом итерационном контексте, чтобы производить результаты с течением времени и по запросу.