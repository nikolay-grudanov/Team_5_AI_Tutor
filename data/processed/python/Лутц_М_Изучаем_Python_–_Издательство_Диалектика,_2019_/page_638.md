---
source_image: page_638.png
page_number: 638
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 30.42
tokens: 7795
characters: 2495
timestamp: 2025-12-24T01:27:07.124658
finish_reason: stop
---

нам понадобится снова использовать вызов list, чтобы заставить генераторы выдать свои значения для отображения:

# Применение генераторов: yield
def myzip(*seqs):
    seqs = [list(S) for S in seqs]
    while all(seqs):
        yield tuple(S.pop(0) for S in seqs)
def mymapPad(*seqs, pad=None):
    seqs = [list(S) for S in seqs]
    while any(seqs):
        yield tuple((S.pop(0) if S else pad) for S in seqs)
S1, S2 = 'abc', 'xyz123'
print(list(myzip(S1, S2)))
print(list(mymapPad(S1, S2)))
print(list(mymapPad(S1, S2, pad=99)))

Наконец, ниже показана альтернативная реализация наших эмуляторов zip и map — вместо удаления аргументов из списков с помощью метода pop следующие версии делают свою работу путем вычисления минимальных и максимальных длин аргументов. Располагая длинами, легко написать вложенные списковые включения для прохода по диапазонам индексов аргументов:

# Альтернативная реализация с использованием длин
def myzip(*seqs):
    minlen = min(len(S) for S in seqs)
    return [tuple(S[i] for S in seqs) for i in range(minlen)]
def mymapPad(*seqs, pad=None):
    maxlen = max(len(S) for S in seqs)
    index = range(maxlen)
    return [tuple((S[i] if len(S) > i else pad) for S in seqs) for i in index]
S1, S2 = 'abc', 'xyz123'
print(myzip(S1, S2))
print(mymapPad(S1, S2))
print(mymapPad(S1, S2, pad=99))

Поскольку в функциях применяется len и индексация, они предполагают, что аргументы являются последовательностями или чем-то подобным, а не произвольными итерируемыми объектами, как было в наших ранних версиях функций перемешивания и перестановки. Внешние включения выполняют проход по диапазонам индексов аргументов, а внутренние включения (передаваемые tuple) проходят по переданным последовательностям для параллельного извлечения аргументов. Результаты запуска будут такими же, как ранее.

Больше всего поражает в данном примере обилие генераторов и итераторов. Передаваемые в min и max аргументы представляют собой генераторные выражения, которые выполняются до конца перед тем, как начнется итерация по вложенным включениям. Более того, вложенные списковые включения задействуют два уровня отложенной оценки — встроенная функция range из Python 3.x выдает итерируемый объект, как и аргумент в виде генераторного выражения для tuple.

На самом деле никакие результаты здесь не выпускаются до тех пор, пока квадратные скобки списковых включений не запросят значения для помещения в результирующий список — они заставляют включения и генераторы выполнятьсь. Чтобы пре-