---
source_image: page_409.png
page_number: 409
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 37.48
tokens: 7941
characters: 3102
timestamp: 2025-12-24T01:20:19.255007
finish_reason: stop
---

Вы уже видели еще одно применение такого поведения ранее в главе: из-за способа работы булевских операций выражение ((A and B) or C) может использоваться для эмуляции оператора if — почти полной.

Дополнительные сценарии применения булевских операций встречались в предшествующих главах. Как было показано в главе 9, поскольку все объекты по своей сути считаются истинными или ложными, в Python принято и более просто проверять объект напрямую (if X:), чем сравнивать его с пустым значением (if X != '':). Для строки обе проверки эквивалентны. В главе 5 объяснялось, что предварительно установленные булевские значения True и False являются тем же, что и целые числа 1 и 0; они пригодны для инициализации переменных (X = False), для проверок в циклах (while True:) и для отображения результатов в интерактивной подсказке.

Также дождитесь связанного обсуждения перегрузки операций в части VI: когда мы определяем новые типы объектов с помощью классов, то можем задавать их булевскую природу посредством методов __bool__ или __len__ (метод __bool__ в Python 2.7 называется __nonzero__). Метод __len__ вызывается при отсутствии метода __bool__ и обозначает ложь, возвращая длину ноль — пустой объект трактуется как ложный.

Наконец, в качестве предварительного представления отметим, что в Python есть другие инструменты с ролями, похожими на цепочки or в начале данной врезки. Вызов filter и списковые включения, которые будут рассматриваться позже, могут использоваться для выбора истинных значений, когда набор кандидатов не известен вплоть до времени выполнения (хотя они оценивают все значения и возвращают все истинные из них). Встроенные функции any и all могут применяться для проверки, является любое или все элементы в коллекции истинными (правда, они не выбирают элемент):

>>> L = [1, 0, 2, 0, 'spam', '', 'ham', []]
>>> list(filter(bool, L))      # Получение истинных значений
[1, 2, 'spam', 'ham']
>>> [x for x in L if x]        # Включения
[1, 2, 'spam', 'ham']
>>> any(L), all(L)             # Накопление значений истинности
(True, False)

Как было показано в главе 9, функция bool просто возвращает истинное или ложное значение своего аргумента, как будто бы оно проверялось в if. Дополнительные сведения о таких связанных инструментах будут приведены в главах 14, 19 и 20.

Резюме

В главе мы исследовали оператор if языка Python. Кроме того, поскольку он был первым составным и логическим оператором, мы пересмотрели общие синтаксические правила Python и более глубоко проанализировали работу значений истинности и проверок, чем были в состоянии делать это до сих пор. Попутно мы также взглянули на способы кодирования множественного ветвления в Python, узнали о выражении if/else, появившемся в Python 2.5, и ознакомились с распространенными случаями появления булевских значений в коде.

В следующей главе мы продолжим рассмотрение процедурных операторов подробным обсуждением циклов while и for. Вы узнаете об альтернативных способах написания циклов в Python, часть которых может быть лучше других. Но прежде чем двигаться дальше, по традиции ответьте на контрольные вопросы главы.