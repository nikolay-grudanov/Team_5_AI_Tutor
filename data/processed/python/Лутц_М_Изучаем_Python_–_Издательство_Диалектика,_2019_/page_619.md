---
source_image: page_619.png
page_number: 619
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 31.25
tokens: 7701
characters: 2391
timestamp: 2025-12-24T01:26:34.504041
finish_reason: stop
---

Генераторные выражения или filter

Генераторные выражения также поддерживают весь обычный синтаксис списковых включений, в том числе конструкции if, которые работают подобно рассмотренному ранее вызову filter. Поскольку filter в Python 3.x является итерируемым объектом, который генерирует свои результаты по запросу, генераторное выражение с конструкцией if функционально эквивалентно (в Python 2.x функция filter производит временный список, чего не делает генератор, но снова сравнение их кода применимо). В следующем коде вызова join достаточно для принудительного выпуска результатов во всех формах:

```python
>>> line = 'aa bbb c'
>>> ''.join(x for x in line.split() if len(x) > 1)    # Генератор с
# конструкцией if
'aabbb'
>>> ''.join(filter(lambda x: len(x) > 1, line.split()))  # Подобный вызов filter
'aabbb'
```

Генератор выглядит минимально проще filter. Тем не менее, что касается списковых включений, то добавление шагов обработки к результатам filter также требует вызова map, который делает filter заметно сложнее генераторного выражения:

```python
>>> ''.join(x.upper() for x in line.split() if len(x) > 1)
'AABBB'
>>> ''.join(map(str.upper, filter(lambda x: len(x) > 1, line.split())))
'AABBB'
```

Фактически генераторные выражения делают для итерируемых объектов Python 3.x вроде создаваемых функциями map и filter то, что списковые включения делают для вариантов этих вызовов с построителями списков Python 2.x — они предоставляют более общие кодовые структуры, которые не опираются на функции, но по-прежнему откладывают выпуск результатов. Также подобно списковым включениям для генераторного выражения всегда имеется эквивалент на основе операторов, хотя временно он требует написания значительно большего объема кода:

```python
>>> ''.join(x.upper() for x in line.split() if len(x) > 1)
'AABBB'
>>> res = ''
>>> for x in line.split():
...     if len(x) > 1:
...         res += x.upper()
...
>>> res
'AABBB'
```

Однако в данном случае операторная форма не совсем такая же — она не может выпускать по одному элементу за раз и также эмулирует эффект метода join, который приводит к производству сразу всех результатов. Подлинным эквивалентом генераторного выражения была бы генераторная функция с оператором yield, как показано в следующем разделе.

Генераторные функции или генераторные выражения

Давайте подытожим то, что было рассмотрено до сих пор в разделе.