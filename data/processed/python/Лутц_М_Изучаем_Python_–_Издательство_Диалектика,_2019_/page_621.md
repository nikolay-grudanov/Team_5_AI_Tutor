---
source_image: page_621.png
page_number: 621
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 30.56
tokens: 7702
characters: 2354
timestamp: 2025-12-24T01:26:37.316280
finish_reason: stop
---

>>> G = timesfour('spam')
>>> I = iter(G)        # Итерация вручную (функция)
>>> next(I)
'ssss'
>>> next(I)
'pppp'

В обоих случаях Python автоматически создает объект генератора, который имеет оба метода, требуемые протоколом итерации, а также обеспечивает сохранение состояния для переменных из кода генератора и текущего местоположения в коде. Обратите внимание на то, что для повторной итерации мы создаем новые генераторы — как объясняется в следующем разделе, генераторы являются одноразовыми итераторами.

Тем не менее, для выражения, приведенного в конце предыдущего раздела, есть подлинный эквивалент на основе операторов: функция, которая выдает значения — хотя разница несущественна, если применяющий его код производит все результаты посредством инструмента, подобного join:

>>> line = 'aa bbb c'
>>> ''.join(x.upper() for x in line.split() if len(x) > 1)    # Выражение
'AABBB'
>>> def gensub(line):
    for x in line.split():
        if len(x) > 1:
            yield x.upper()
>>> ''.join(gensub(line))    # Но зачем генерировать?
'AABBB'

Несмотря на то что генераторы способны исполнять адекватные роли, в случаях вроде представленного использование генераторов вместо показанного ранее простого операторного эквивалента может быть затруднительно оправдать кроме как стилистическими причинами. С другой стороны, обмен четырех строк кода на одну многим может показаться довольно убедительной стилистической причиной!

Генераторы являются объектами с одиночной итерацией

Тонкий, но важный момент: генераторные функции и генераторные выражения сами представляют собой итераторы и потому поддерживают только одну активную итерацию — в отличие от ряда встроенных типов нельзя иметь множество итераторов, каждый из которых находится в отличающейся позиции внутри набора результатов. Из-за этого итератором генератора является сам генератор; фактически, как указывалось ранее, вызов iter на генераторном выражении или функции необязателен и ничего не делает:

>>> G = (c * 4 for c in 'SPAM')
>>> iter(G) is G    # Итератором генератора является сам генератор:
#     G имеет метод __next__
True

В случае выполнения итерации по потоку результатов с помощью множества итераторов все они будут указывать на ту же самую позицию:

>>> G = (c * 4 for c in 'SPAM')    # Создать новый генератор
>>> I1 = iter(G)        # Итерация вручную
>>> next(I1)