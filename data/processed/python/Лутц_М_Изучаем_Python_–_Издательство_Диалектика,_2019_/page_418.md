---
source_image: page_418.png
page_number: 418
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 26.71
tokens: 7624
characters: 2106
timestamp: 2025-12-24T01:20:26.088178
finish_reason: stop
---

Что потребует внимания: эмуляция циклов while языка C

В разделе главы 11, посвященном операторам выражений, было указано, что Python не разрешает операторам вроде присваивания находиться в местах, где ожидается выражение. То есть каждый такой оператор в общем случае должен располагаться в отдельной строке, а не быть вложенным в более крупную конструкцию. Это означает, что распространенный кодовый шаблон языка C в Python работать не будет:

while ((x = next(obj)) != NULL) {...обработка x...}

Присваивания в C возвращают присвоенные значения, но присваивания в Python являются просто операторами, а не выражениями. Тем самым устраняется пользующаяся дурной славой категория ошибок в C: вы не можете в Python случайно набрать =, когда имели в виду ==. Однако если вам необходимо похожее поведение, то есть по меньшей мере три способа достичь того же эффекта в циклах while языка Python, не встраивая присваивания в проверки циклов. Вы можете перенести присваивание в тело цикла и добавить break:

while True:
    x = next(obj)
    if not x: break
    ...обработка x...

или перенести присваивание в цикл с проверками:

x = True
while x:
    x = next(obj)
    if x:
        ...обработка x...

либо вынести первое присваивание за пределы цикла:

x = next(obj)
while x:
    ...обработка x...
    x = next(obj)

Первый кодовый шаблон из показанных трех некоторые могут посчитать наименее структурированным, но он также проще и применяется чаще. Простой цикл for языка Python также может заменить подобные циклы C, но в языке C его прямой аналог отсутствует:

for x in obj: ...обработка x...

Циклы for

Цикл for является универсальным итератором в Python: он может проходить по элементам в любой упорядоченной последовательности или в другом итерируемом объекте. Оператор for работает на строках, списках, кортежах и прочих встроенных итерируемых объектах, а также на новых объектах, определяемых пользователем, которые мы позже научимся создавать с помощью классов. Мы кратко касались for в главе 4 и в сочетании с типами объектов последовательностей; давайте рассмотрим его использование более формально.