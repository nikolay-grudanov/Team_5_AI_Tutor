---
source_image: page_553.png
page_number: 553
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 35.11
tokens: 7959
characters: 2956
timestamp: 2025-12-24T01:24:36.781777
finish_reason: stop
---

>>> f(1, c=6)    # Выбор стандартных значений
1 2 6

Здесь а получает значение 1 по позиции, с получает 6 по ключевому слову, а b — стандартное значение 2.

Будьте внимательны, чтобы не перепутать специальный синтаксис имя=значение в заголовке функции и в вызове функции; в вызове он означает ключевой аргумент, сопоставляемый по имени, тогда как в заголовке задает стандартное значение для необязательного аргумента. В обоих случаях это не оператор присваивания (несмотря на его внешний вид); он представляет собой специальный синтаксис для указанных двух контекстов, который видоизменяет механику сопоставления аргументов.

Комбинирование ключевых слов и стандартных значений

Далее приведен чуть больший пример, демонстрирующий в действии ключевые слова и стандартные значения. Вызывающий код должен всегда передавать, по крайней мере, два аргумента (для соответствия spam и eggs), но другие два аргумента необязательны. Если они опущены, то Python присваивает toast и ham стандартные значения, указанные в заголовке:

def func(spam, eggs, toast=0, ham=0):    # Первые два аргумента обязательны
    print((spam, eggs, toast, ham))
func(1, 2)
func(1, ham=1, eggs=0)
func(spam=1, eggs=0)
func(toast=1, eggs=2, spam=3)
func(1, 2, 3, 4)

# Вывод: (1, 2, 0, 0)
# Вывод: (1, 0, 0, 1)
# Вывод: (1, 0, 0, 0)
# Вывод: (3, 2, 1, 0)
# Вывод: (1, 2, 3, 4)

Снова обратите внимание, что в случае использования в вызове ключевых аргументов порядок, в котором перечисляются аргументы, несущественен; Python сопоставляет по имени, а не по позиции. В вызывающем коде должны быть предоставлены значения для spam и eggs, но они могут сопоставляться по позиции или по имени. Опять-таки имейте в виду, что форма имя=значение в вызове и в def имеет разный смысл — ключевой аргумент в вызове и стандартное значение в заголовке.

Остерегайтесь изменяемых стандартных значений. Как отмечалось в сноске в предыдущей главе, если вы укажете в качестве стандартного значения изменяемый объект (скажем, def f(a=[]) ), тогда тот же самый изменяемый объект будет повторно использоваться каждый раз, когда функция вызывается — даже в случае его модификации на месте внутри функции. В результате стандартное значение аргумента сохраняется из предыдущего вызова и не переустанавливается в первоначальное значение, закодированное в заголовке def. Чтобы переустанавливать его заново в каждом вызове, перенесите присваивание в тело функции. Изменяемые стандартные значения допускают сохранение состояния, но часто приводят к неожиданностям. Так как это настолько распространенная ловушка, мы отложим дальнейшие ее исследования до списка "затруднений" в конце главы 21.

Примеры произвольного количества аргументов

Последние два расширения при сопоставлении, * и **, предназначены для поддержки функций, которые принимают любое количество аргументов. Оба расширения могут встречаться либо в определении функции, либо в вызове функции, и в указанных двух местах они преследуют связанные цели.