---
source_image: page_535.png
page_number: 535
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 34.47
tokens: 7851
characters: 2857
timestamp: 2025-12-24T01:24:05.367207
finish_reason: stop
---

eggs 2
>>> F.state # Доступ к состоянию возможен извне класса
3

Добив лишь чуть больше магии (в которую мы углубимся позже в книге), мы могли бы сделать объекты классов выглядящими как вызываемые функции, используя перегрузку операций. Функция __call__ перехватывает прямые обращения к экземпляру, так что вызывать какой-то именованный метод не требуется:

>>> class tester:
    def __init__(self, start):
        self.state = start
    def __call__(self, label): # Перехватывает прямые обращения к экземпляру
        print(label, self.state) # Таким образом, .nested() не требуется
        self.state += 1
>>> H = tester(99)
>>> H('juice') # Вызывает __call__
juice 99
>>> H('pancakes')
pancakes 100

Пока не стоит беспокоиться по поводу деталей показанного кода; он приведен в основном как предварительный обзор с намерением только сравнить классы с замыканиями. Мы будем исследовать классы в части VI, а специфические инструменты для перегрузки операций наподобие __call__ рассмотрим в главе 30. Здесь важно отметить, что классы способны сделать информацию о состоянии более очевидной за счет того, что они задействуют явное присваивание атрибутов вместо неявного поиска в областях видимости. Вдобавок атрибуты классов всегда допускают изменение и не требуют оператора nonlocal, а классы рассчитаны на реализацию объектов с более широкими возможностями, имеющими многочисленные атрибуты и линии поведения.

Наряду с тем, что применение классов для хранения информации о состоянии в целом является хорошим эмпирическим правилом, которому имеет смысл следовать, они также могут оказываться крайностью в ситуациях вроде этой, где состояние представляет собой одиночный счетчик. Такие тривиальные варианты состояния встречаются чаще, чем вы могли подумать; в подобных случаях вложенные def иногда будут легковеснее классов, особенно когда вы еще не освоили объектно-ориентированное программирование. Более того, существуют сценарии, в которых вложенные def на самом деле могут работать лучше классов — пример, выходящий далеко за рамки настоящей главы, будет приведен в главе 39, гдеписаны декораторы методов.

Состояние с помощью атрибутов функций: Python 3.x и 2.x

В качестве переносимого и часто более простого варианта хранения состояния мы можем временами достичь эффекта нелокальных переменных с помощью атрибутов функций — определяемых пользователем имен, напрямую присоединяемых к функциям. Когда определяемые пользователем атрибуты присоединяются к вложенными функциям, генерируемым объемлющими фабричными функциями, они способны также служить состоянием для каждого вызова с множеством копий и возможностью записи, что очень похоже на нелокальные замыкания и атрибуты классов. Имена определяемых пользователем атрибутов не будут конфликтовать с именами, создаваемыми Python самостоятельно, и как при использовании nonlocal, они применяются только