---
source_image: page_681.png
page_number: 681
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 41.64
tokens: 8030
characters: 3356
timestamp: 2025-12-24T01:28:38.772099
finish_reason: stop
---

2. Аргументы. Напишите функцию по имени adder в файле модуля Python. Функция должна принимать два аргумента и возвращать сумму (или результат конкатенации) их двух. Затем добавьте в конец файла код для вызова функции adder с объектами различных типов (две строки, два списка, два числа с плавающей точкой) и запустите файл как сценарий в окне командной строки системы. Требуется ли явно выводить результаты, чтобы видеть их на экране?

3. Переменное количество аргументов. Обобщите написанную в предыдущем упражнении функцию adder, чтобы она вычисляла сумму произвольного количества аргументов, и измените вызовы для передачи более или менее двух аргументов. Какой тип имеет возвращаемое значение суммы? (Подсказки: срез вроде S[:0] возвращает пустую последовательность того же типа, что и S, а с помощью встроенной функции type можно проверять типы, но более простой подход ищите во вручную написанных примерах функции min в главе 18.) Что происходит при передаче аргументов отличающихся типов? Как насчет передачи словарей?

4. Ключевые аргументы. Измените функцию adder из упражнения 2, чтобы она принимала и выполняла суммирование/конкатенацию трех аргументов: def adder(good, bad, ugly). Снабдите каждый аргумент стандартным значением и поэкспериментируйте с вызовом функции в интерактивной подсказке. Попробуйте передать один, два, три и четыре аргумента. Работает ли вызов adder(ugly=1, good=2)? Почему? Затем обобщите новую функцию adder с целью приема и выполнения суммирования/конкатенации для произвольного количества ключевых аргументов. Похожая работа делалась в упражнении 3, но здесь необходимо проходить по словарю, а не по кортежу. (Подсказка: метод dict.keys возвращает список, по которому можно проходить с помощью цикла for или while, но для индексации в Python 3.x не забудьте поместить его внутрь вызова list; также может помочь метод dict.values.)

5. Слованные инструменты. Напишите функцию по имени copyDict(dict), которая копирует свой аргумент типа словаря. Она должна возвращать новый словарь, содержащий все элементы из своего аргумента. Используйте для итерации словарный метод keys (или в Python 2.2 и последующих версиях проходите по словарю, не вызывая keys). Копировать последовательности легко (X[:] создает копию верхнего уровня); работает ли такой прием также для словарей? Как объясняется в решении этого упражнения, поскольку словари теперь снабжены похожими инструментами, текущее и следующее упражнения являются лишь тренировкой в написании кода, но все-таки служат характерными примерами функций.

6. Слованные инструменты. Напишите функцию по имени addDict(dict1, dict2), которая вычисляет объединение двух словарей. Она должна возвращать новый словарь, содержащий все элементы из своих двух аргументов (по предположению являющиеся словарями). Если в обоих аргументах встречается один и тот же ключ, выбирайте значение из любого по своему усмотрению. Протестируйте написанную функцию, запустив файл как сценарий. Что произойдет, если передать списки вместо словарей? Как можно было бы обобщить функцию для обработки такого случая? (Подсказка: примените упомянутую ранее встроенную функцию type.) Имеет ли значение порядок, в котором передаются аргументы?

7. Дополнительные примеры сопоставления аргументов. Определите следующие шесть функций (в интерактивной подсказке или в модуле, который можно импортировать):