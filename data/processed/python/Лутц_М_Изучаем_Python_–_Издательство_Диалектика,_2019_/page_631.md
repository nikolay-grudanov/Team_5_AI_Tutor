---
source_image: page_631.png
page_number: 631
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 33.80
tokens: 7803
characters: 2518
timestamp: 2025-12-24T01:26:58.088061
finish_reason: stop
---

Обе функции производят одинаковые результаты, хотя вторая откладывает выполнение большей части своей работы до тех пор, пока у нее не будет запрошен результат. Код чуть сложнее, особенно во второй функции (и некоторым новичкам в Python он может даже показаться жестоким и бесчеловечным наказанием!). Однако, как вскоре выяснится, есть сценарии, где подход с генератором может быть крайне удобным.

Изучите и протестируйте приведенный код, чтобы лучше его понять, и добавьте вывод для его трассировки, если это поможет. Если он по-прежнему выглядит загадочным, попробуйте разобраться сначала с первой версией; вспомните, что генераторные функции просто возвращают объекты посредством методов, которые поддерживают операции next, выполняемые циклами for на каждом уровне, и не производят результатов до тех пор, пока не будут подвергнуты итерации. Кроме того, отслеживайте некоторые из представляемых далее примеров, чтобы посмотреть, как с ними справляется данный код.

Перестановки производят больше порядков, чем первоначальная функция тасования — для N элементов мы получаем N! (факториал) результатов, а не просто N (24 результата для 4 элементов: 4 * 3 * 2 * 1). На самом деле именно поэтому здесь необходима рекурсия: количество вложенных циклов произвольно и зависит от длины переставляемой последовательности:

```python
>>> from scramble import scramble
>>> from permute import permute1, permute2

>>> list(scramble('abc'))
['abc', 'bca', 'cab']

>>> permute1('abc')
['abc', 'acb', 'bac', 'bca', 'cab', 'cba']

>>> list(permute2('abc'))
['abc', 'acb', 'bac', 'bca', 'cab', 'cba']

>>> G = permute2('abc')
>>> next(G)
'abc'
>>> next(G)
'acb'
>>> for x in permute2('abc'): print(x)
... выводит шесть строк...
```

# Простое перемешивание: N
# Перестановок больше: N!
# Генерация всех комбинаций
# Итерация (iter() не требуется)
# Автоматическая итерация

Результаты версий со списком и генератором одинаковы, хотя генератор минимизирует потребление памяти и время ожидания результатов. Для большего числа элементов набор всех перестановок будет намного большим, чем дает простое перемешивание:

```python
>>> permute1('spam') == list(permute2('spam'))
True
>>> len(list(permute2('spam'))), len(list(scramble('spam')))
(24, 4)

>>> list(scramble('spam'))
['spam', 'pams', 'amsp', 'mspa']
>>> list(permute2('spam'))
['spam', 'spma', 'sapm', 'samp', 'smpa', 'smap', 'psam', 'psma', 'pasm', 'pams',
 'pmsa', 'pmas', 'aspm', 'asmp', 'apsm', 'apms', 'amsp', 'amps', 'mspa',
 'msap', 'mpsa', 'mpas', 'masp', 'maps']
```