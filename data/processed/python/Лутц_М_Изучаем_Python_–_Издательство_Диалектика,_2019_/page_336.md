---
source_image: page_336.png
page_number: 336
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 33.56
tokens: 7871
characters: 2961
timestamp: 2025-12-24T01:17:50.551945
finish_reason: stop
---

Например, все показанные далее проверки типов дают True:

type([1]) == type([])      # Сравнение с типом другого списка
type([1]) == list           # Сравнение с именем спискового типа
isinstance([1], list)       # Проверка, список ли это или его настройка
import types                # Модуль types содержит имена для других типов
def f(): pass
type(f) == types.FunctionType

Поскольку теперь типы в Python можно создавать как производные классы, рекомендуется использовать методику с функцией isinstance. Создание производных классов для встроенных типов в Python 2.2 и последующих версиях более подробно обсуждается в главе 32 второго тома.

В главе 32 мы также исследуем, как type(X) и проверка типов в целом применяются к экземплярам классов, определяемых пользователем. Выражаясь кратко, в Python 3.x и для классов нового стиля в Python 2.x типом экземпляра класса является класс, из которого был создан экземпляр. В случае традиционных классов Python 2.x экземпляры всех классов взамен относятся к типу "экземпляр" и для содержательного сравнения типов мы должны сравнивать атрибуты __class__ экземпляров. Так как вы пока еще не готовы заняться темой классов, мы отложим ее до главы 32.

Прочие типы в Python

Помимо основных объектов, обсуждаемых в этой части книги, и объектов программных единиц, таких как функции, модули и классы, которые мы встретим позже, обычная установка Python располагает десятками дополнительных типов объектов, доступных в форме связанных расширений C или классов Python — объекты регулярных выражений, файлы DBM, виджеты графических пользовательских интерфейсов, сетевые сокеты и т.д. В зависимости от того, у кого вы спрашиваете, рассмотренный ранее в главе именованный кортеж также может быть отнесен к данной категории (Decimal и Fraction из главы 5, как правило, более неоднозначны).

Главное отличие между такими дополнительными инструментами и встроенными типами, которые мы видели до сих пор, заключается в том, что для встроенных типов в языке предусмотрен специальный синтаксис создания их объектов (например, 4 для целого числа, [1, 2] для списка, функция open для файлов и def и lambda для функций). Прочие инструменты, как правило, доступны в стандартных библиотечных модулях, которые придется сначала импортировать для использования, и обычно не считаются основными типами. Скажем, чтобы создать объект регулярного выражения, понадобится импортировать модуль re и вызвать re.compile(). Исчерпывающее руководство по всем инструментам, доступным для программ Python, ищите в справочнике по библиотеке Python.

Затруднения, связанные со встроенными типами

Мы подошли к концу исследования основных типов данных. В завершение этой части книги мы обсудим распространенные проблемы, с которыми могут столкнуться новички (а временами даже эксперты), и предложим их решения. Кое-что в обсуждении является обзором тех идей, которые уже были раскрыты, но проблемы достаточно важны для того, чтобы напомнить о них еще раз.