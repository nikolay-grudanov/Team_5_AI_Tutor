---
source_image: page_198.png
page_number: 198
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 26.47
tokens: 7738
characters: 2328
timestamp: 2025-12-24T01:13:02.354856
finish_reason: stop
---

Заметным исключением из этого правила является проверка членства во множестве in — такое выражение определено для работы со всеми остальными типами коллекций, где оно также выполняет проверку членства (или поиск, если вы предпочитаете процедурные термины). Следовательно, для выполнения такой проверки преобразовывать строки и списки во множества не придется:

```python
>>> 'e' in x                # Проверка членства (множества)
True
>>> 'e' in 'Camelot', 22 in [11, 22, 33]   # Но работает также и с другими типами
(True, True)
```

В дополнение к выражениям объект множества предоставляет методы, которые соответствуют этим и другим операциям и поддерживают изменения множеств: метод add вставляет один элемент, update представляет собой объединение на месте, а remove удаляет элемент по значению (вызовите dir для любого экземпляра множества либо для имени типа set, чтобы увидеть все доступные методы). Предположим, что x и y остались такими, как они были в последнем взаимодействии:

```python
>>> z = x.intersection(y)      # То же, что и x & y
>>> z
set(['b', 'd'])
>>> z.add('SPAM')              # Вставка одного элемента
>>> z
set(['b', 'd', 'SPAM'])
>>> z.update(set(['X', 'Y']))   # Слияние: объединение на месте
>>> z
set(['Y', 'X', 'b', 'd', 'SPAM'])
>>> z.remove('b')               # Удаление одного элемента
>>> z
set(['Y', 'X', 'd', 'SPAM'])
```

Как итерируемые контейнеры, множества могут также использоваться в операциях вроде len, циклах for и списковых включениях. Тем не менее, из-за того, что множества неупорядочены, они не поддерживают операции над последовательностями, подобные индексации и нарезанию:

```python
>>> for item in set('abc'): print(item * 3)
aaa
ccc
bbb
```

Наконец, хотя показанные ранее выражения с множествами в общем случае требуют двух множеств, их аналоги, основанные на методах, часто способны работать также и с любым итерируемым типом:

```python
>>> S = set([1, 2, 3])
>>> S | set([3, 4])           # Выражения требуют двух множеств
set([1, 2, 3, 4])
>>> S | [3, 4]
TypeError: unsupported operand type(s) for |: 'set' and 'list'
Ошибка типа: неподдерживаемые типы операндов для |: set и list
>>> S.union([3, 4])           # Но методы разрешают указывать любой итерируемый тип
set([1, 2, 3, 4])
>>> S.intersection((1, 3, 5))
set([1, 3])
>>> S.issubset(range(-5, 5))
True
```