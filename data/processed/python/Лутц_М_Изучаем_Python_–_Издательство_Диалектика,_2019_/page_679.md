---
source_image: page_679.png
page_number: 679
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 34.79
tokens: 7865
characters: 2979
timestamp: 2025-12-24T01:28:29.107656
finish_reason: stop
---

областях видимости. Дополнительные сведения по этой теме представлены в разделе "Переменные цикла могут требовать стандартные значения, а не области видимости" главы 17.

Сокрытие встроенных функций за счет присваивания: экранирование

В главе 17 также была описана возможность повторного присваивания встроенных имен в ближайшей локальной или глобальной области видимости; повторное присваивание фактически скрывает и заменяет такое встроенное имя для оставшейся части кода в области видимости, где присваивание произошло. Это означает, что использовать первоначальное значение для имени не удастся. До тех пор, пока встроенное значение для имени не требуется, проблема не возникает — многие имена являются встроенными и могут свободно применяться многократно. Тем не менее, если выполнить повторное присваивание встроенному имени, на которое полагается ваш код, тогда могут появиться проблемы. Таким образом, либо не поступайте так, либо используйте инструмент вроде PyChecker, который способен предупредить о такой ситуации. Хорошая новость в том, что часто применяемые встроенные функции скоро станут второй натурой, а средство улавливания ошибок Python будет предупреждать на ранней стадии тестирования, если ваше встроенное имя оказывается не тем, о чем вы думали.

Резюме

Глава завершила обсуждение функций и встроенных итерационных инструментов проработкой более крупного учебного примера, в котором измерялась производительность альтернативных вариантов итерации и версий Python, а также обзором распространенных заблуждений, связанных с функциями, чтобы помочь избежать ловушек. У истории с итерацией есть последнее продолжение в части VI, при обсуждении перегрузки операций в главе 30 второго тома, где будет показано, как создавать определяемые пользователем итерируемые объекты, которые генерируют значения, с помощью классов и __iter__.

Итак, часть книги, посвященная функциям, завершена. В следующей части мы расширим знания о модулях — файлах инструментов, которые образуют самую верхнюю организационную единицу в Python и структуру, где всегда находятся наши функции. Затем мы исследуем классы — инструменты, которые по большому счету представляют собой пакеты функций с особыми первыми аргументами. Как выяснится, определяемые пользователем классы могут реализовывать объекты, подключаемые к протоколу итерации в точности как встречавшиеся ранее генераторы и итерируемые объекты. На самом деле все, что мы изучили в этой части книги, будет применяться позже, когда функции всплывут в контексте методов классов.

Но прежде чем переходить к модулям, закрепите пройденный материал, ответив на контрольные вопросы главы, и выполните упражнения для данной части книги, чтобы попрактиковаться с функциями.

Проверьте свои знания: контрольные вопросы

1. Какие выводы вы можете сделать из этой главы об относительной скорости итерационных инструментов Python?

2. Какие выводы вы можете сделать из этой главы об относительной скорости хронометрируемых версий Python?