---
source_image: page_263.png
page_number: 263
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 37.98
tokens: 7974
characters: 2651
timestamp: 2025-12-24T01:15:28.934099
finish_reason: stop
---

не сложности форматирования и на практике встречается нечасто; более типичные сценарии использования не выглядят настолько однозначными. Кроме того, с выходом версий Python 3.1 и 2.7 нумерованные цели подстановки стали необязательными, когда применяются относительные позиции, что потенциально вообще отменяет указанное преимущество:

```python
>>> 'The {0} side {1} {2}'.format('bright', 'of', 'life') # Python 3.x, 2.6+
'The bright side of life'
>>> 'The {} side {} {}'.format('bright', 'of', 'life')    # Python 3.1+, 2.7+
'The bright side of life'
>>> 'The %s side %s %s' % ('bright', 'of', 'life')        # Все версии Python
'The bright side of life'
```

Учитывая краткость второго вызова, он вероятно предпочтительнее первого, но, похоже, сводит на нет часть преимущества метода. Сравните, например, эффект форматирования чисел с плавающей точкой — выражение форматирования по-прежнему лаконичнее и выглядит менее запутанным:

```python
>>> '{0:.f}, {1:.2f}, {2:05.2f}'.format(3.14159, 3.14159, 3.14159)
'3.141590, 3.14, 03.14'
>>> '{:.f}, {:.2f}, {:06.2f}'.format(3.14159, 3.14159, 3.14159)
'3.141590, 3.14, 003.14'
>>> '%f, .2f, %06.2f' % (3.14159, 3.14159, 3.14159)
'3.141590, 3.14, 003.14'
```

Именованный метод и контекстно-нейтральные аргументы:
эстетика или практичность

Метод форматирования также заявляет о пользе от замены операции % мнемоническим именем метода format и от того, что он не проводит различие между одиночным значением и множеством значений подстановки. На первый взгляд замена % именем format способно сделать метод более простым для восприятия новичками (format может быть легче распознавать, чем многочисленные символы %), хотя это вероятно зависит от того, кто читает код, и выглядит незначительным.

Некоторые могут счесть вторую характеристику более существенной — в выражении форматирования одиночное значение можно задавать само по себе, но множество значений должно заключаться в кортеж:

```python
>>> '%.2f' % 1.2345           # Одиночное значение
'1.23'
>>> '%.2f %s' % (1.2345, 99)  # Кортеж с множеством значений
'1.23 99'
```

Формально выражение форматирования принимает одиночное значение подстановки или кортеж с одним и более элементов. Как следствие, поскольку одиночный элемент может быть задан либо сам по себе, либо внутри кортежа, подлежащий форматированию кортеж должен предоставляться как вложенный кортеж — возможно редкий, но правдоподобный случай:

```python
>>> '%s' % 1.23                # Одиночное значение, само по себе
'1.23'
>>> '%s' % (1.23,)             # Одиночное значение, в кортеже
'1.23'
>>> '%s' % ((1.23,),)          # Одиночное значение, являющееся кортежем
'(1.23,)'
```