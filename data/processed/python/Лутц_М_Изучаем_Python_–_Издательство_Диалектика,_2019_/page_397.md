---
source_image: page_397.png
page_number: 397
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 32.41
tokens: 7748
characters: 2524
timestamp: 2025-12-24T01:19:53.169409
finish_reason: stop
---

Если вы использовали языки наподобие C или Pascal, тогда вам небезынтересно будет узнать, что в Python отсутствует оператор вроде switch или case, который выбирал бы действие на основе значения переменной. Взамен множественное ветвление обычно записывается в виде серии проверок if/elif, как в предыдущем примере, и иногда реализуется путем индексирования словарей или поиска в списках. Поскольку словари и списки можно динамически создавать на стадии выполнения, временами они оказываются более гибкими, чем логика if, жестко закодированная в сценарии:

```python
>>> choice = 'ham'
>>> print({'spam': 1.25,
...         'ham': 1.99,
...         'eggs': 0.99,
...         'bacon': 1.10}[choice])
1.99
```

# Аналог switch на основе словаря
# Для получения стандартного значения
# используется has_key или get

Хотя осознание этого поначалу может потребовать некоторого времени, показанный словарь реализует множественное ветвление — индексация по ключу choice обеспечивает переход к одному из набора значений во многом подобно оператору switch в C. Почти эквивалентный, но более многословный оператор if языка Python мог бы выглядеть следующим образом:

```python
>>> if choice == 'spam':
...     print(1.25)
... elif choice == 'ham':
...     print(1.99)
... elif choice == 'eggs':
...     print(0.99)
... elif choice == 'bacon':
...     print(1.10)
... else:
...     print('Bad choice')
...
1.99
```

# Эквивалентный оператор if

Несмотря на возможно лучшую читабельность, его потенциальный недостаток в том, что если не считать оформления такого оператора if в виде строки и выполнения с помощью eval или exec, то создать его во время выполнения не настолько легко, как словарь. В более динамических программах структуры данных зачастую добавляют гибкости.

Поддержка стандартных значений

В приведенном выше операторе if обратите внимание на конструкцию else, которая предназначена для обработки стандартного случая, когда совпадения по ключу отсутствуют. Как объяснялось в главе 8, стандартные значения словарей можно запи- сывать с помощью выражений in, вызовов метода get или перехвата исключений посредством оператора try, представленного в предыдущей главе. Те же самые методики можно применять здесь для кодирования стандартного действия при множественном ветвлении, основанном на словаре. В качестве обзора в контексте этого сценария использования далее показано, как схема get работает со стандартными значениями:

```python
>>> branch = {'spam': 1.25,
...            'ham': 1.99,
...            'eggs': 0.99}
```