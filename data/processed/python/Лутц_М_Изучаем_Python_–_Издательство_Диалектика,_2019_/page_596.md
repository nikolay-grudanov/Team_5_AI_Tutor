---
source_image: page_596.png
page_number: 596
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 30.98
tokens: 7677
characters: 2270
timestamp: 2025-12-24T01:25:53.580044
finish_reason: stop
---

На каждом шаге reduce передает текущую сумму или произведение вместе с очередным элементом из списка указанной функции lambda. По умолчанию начальное значение инициализируется первым элементом последовательности. В целях иллюстрации вот эквивалент в виде цикла for первого из двух вызовов с жестко закодированным сложением внутри цикла:

```python
>>> L = [1,2,3,4]
>>> res = L[0]
>>> for x in L[1:]:
    res = res + x
>>> res
10
```

Написание собственной версии reduce на самом деле довольно прямолинейно. Следующая функция эмулирует большую часть поведения встроенной функции и помогает прояснить ее работу в целом:

```python
>>> def myreduce(function, sequence):
    tally = sequence[0]
    for next in sequence[1:]:
        tally = function(tally, next)
    return tally

>>> myreduce((lambda x, y: x + y), [1, 2, 3, 4, 5])
15
>>> myreduce((lambda x, y: x * y), [1, 2, 3, 4, 5])
120
```

Встроенная функция reduce разрешает передавать необязательный третий аргумент, который фактически помещается перед элементами последовательности и служит начальным значением, а также стандартным результатом, когда последовательность пуста, но мы оставим такое расширение для самостоятельного исследования.

Если продемонстрированная методика написания кода пробудила у вас интерес, тогда ваше внимание может привлечь стандартный библиотечный модуль operator, предлагающий функции, которые соответствуют встроенными выражениям и оказываются полезными в ряде сценариев использования инструментов функционального программирования (дополнительные сведения о модуле operator ищите в руководстве по библиотеке Python):

```python
>>> import operator, functools
>>> functools.reduce(operator.add, [2, 4, 6])  # Операция +, основанная на функции
12
>>> functools.reduce((lambda x, y: x + y), [2, 4, 6])
12
```

Все вместе функции map, filter и reduce поддерживают мощные методики функционального программирования. Как уже упоминалось, многие эксперты склонны расширять инструментальный набор для функционального программирования в Python, дополняя его замыканиями вложенных областей видимости (известными еще и как фабричные функции) и анонимными функциями lambda (оба инструмента обсуждались ранее), а также генераторами и включениями, к которым мы снова обратимся в следующей главе.