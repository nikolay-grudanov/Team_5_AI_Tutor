---
source_image: page_416.png
page_number: 416
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 32.85
tokens: 7781
characters: 2684
timestamp: 2025-12-24T01:20:29.433311
finish_reason: stop
---

Enter name: bob
Enter age: 40
Hello bob => 1600
Enter name: sue
Enter age: 30
Hello sue => 900
Enter name: stop

Обратите внимание на преобразование введенного значения age в целое число посредством функции int перед его возведением в квадрат; вспомните, что поступать так необходимо из-за того, что input возвращает введенное пользователем значение в виде строки. В главе 36 вы увидите, что input также генерирует исключение при обнаружении признака конца файла (например, когда пользователь нажимает <Ctrl+Z> в Windows или <Ctrl+D> в Unix); если это важно, тогда поместите input внутрь оператора try.

Конструкция else цикла

В сочетании с конструкцией else цикла оператор break часто позволяет устранить потребность во флагах состояния поиска, используемых в других языках. Скажем, следующий фрагмент кода определяет, является ли положительное целое число y простым, за счет поиска сомножителей больше 1:

x = y // 2                # Для значений y > 1
while x > 1:
    if y % x == 0:
        print(y, 'has factor', x)   # Остаток от деления
        break                        # Имеет сомножитель
        # Пропуск else
    x -= 1
else:
    print(y, 'is prime')            # Нормальный выход
    # Является простым

Вместо установки флага, предназначенного для проверки, нужно ли выходить из цикла, в коде применяется оператор break, когда сомножитель найден. В итоге можно допустить, что конструкция else цикла будет выполняться, только если сомножители не найдены; попадание на break означает, что число простое. Выполните код пошагово, чтобы посмотреть, как он работает.

Конструкция else цикла также выполняется, если тело цикла ни разу не выполнялось, потому что в этом случае не выполняется и оператор break; в цикле while подобное происходит, когда проверка в заголовке с самого начала дает ложное значение. Таким образом, в предыдущем примере все равно будет выводиться сообщение is prime, если x изначально меньше или равно 1 (т.е. когда y равно 2).

В рассмотренном примере выявлялись простые числа, но лишь неформально. Согласно строгому математическому определению числа меньше 2 не считаются простыми. Более того, такой код также терпит неудачу для отрицательных чисел и успешно выполняется для чисел с плавающей точкой без дробной части. Вдобавок следует отметить, что в случае Python 3.x в коде вместо операции / должна использоваться операция // из-за преобразования / в "настоящее деление", как было описано в главе 5 (начальное деление необходимо для усечения остатка, а не для его предохранения!). Если вы хотите поэкспериментировать с данным кодом, тогда обратитесь к упражнению в конце части IV, где он помещается внутрь функции для многократного применения.