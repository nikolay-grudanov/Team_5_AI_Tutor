---
source_image: page_508.png
page_number: 508
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 38.72
tokens: 7955
characters: 3220
timestamp: 2025-12-24T01:23:19.285018
finish_reason: stop
---

менными, которые доступны целому интерактивному сеансу. Модули будут подробно рассматриваться в следующей части книги.

Также обратите внимание, что присваивание любого вида внутри функции классифицирует имя как локальное, включая операторы =, имена модулей в операторе import, имена функций в операторе def, имена аргументов функций и т.д. Присваивание имени любым способом внутри def по умолчанию делает его локальным в данной функции.

Наоборот, изменения на месте объектов не классифицируют имена как локальные; так поступают только присваивания действительнох имен. Скажем, если имени L присваивается список на верхнем уровне модуля, то оператор L = X внутри функции будет классифицировать L как локальное имя, но L.append(X) — нет. В последнем случае мы изменяем списковый объект, на который ссылается L, а не само имя L — переменная L находится в глобальной области видимости, как обычно, и Python успешно модифицирует ее, не требуя объявления global (или nonlocal). Как всегда, это помогает сохранять четкое различие между именами и объектами: изменение объекта не является присваиванием имени.

Распознавание имен: правило LEGB

Несмотря на то, что объяснения в предыдущем разделе могут сбивать с толку, на самом деле все сводится к трем простым правилам. Внутри оператора def:

• присваивания имен по умолчанию создают либо изменяют локальные имена;
• ссылки на имена производят поиск самое большое в четырех областях видимости — в локальной области видимости, затем в областях видимости объемлющих функций (если есть), далее в глобальной области видимости и, наконец, во встроенной области видимости;
• имена, объявленные в операторах global и nonlocal, отображают присвоенные имена на области видимости включающего модуля и функции соответственно.

Другими словами, все имена, присвоенные внутри оператора def функции (или внутри lambda — выражение, которое мы исследуем позже), по умолчанию будут локальными. В функциях можно свободно использовать имена, присвоенные в синтаксически объемлющих функциях и глобальной области видимости, но для изменения таких имен они должны быть объявлены как нелокальные и глобальные.

Ниже описана схема распознавания имен Python, которая иногда называется правилом LEGB согласно названиям областей видимости.

• Когда внутри функции указывается неуточненное имя, Python ищет его максимум в четырех местах — в локальной (L (local)) области видимости, затем в локальных областях видимости любых объемлющих (E (enclosing)) операторов def и lambda, далее в глобальной (G (global)) области видимости и, наконец, во встроенной (B (built-in)) области видимости — и останавливает поиск на первом же месте, где обнаруживается имя. Если в результате такого поиска имя найти не удалось, тогда Python сообщит об ошибке
• Когда внутри функции выполняется присваивание имени (вместо просто ссылки на него в выражении), Python всегда создает либо изменяет имя в локальной области видимости, если только оно не было объявлено в этой функции как глобальное или нелокальное.
• Когда производится присваивание имени за пределами всех функций (т.е. на верхнем уровне файла модуля или в интерактивной подсказке), локальная область видимости совпадает с глобальной — пространством имен модуля.