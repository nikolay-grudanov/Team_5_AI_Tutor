---
source_image: page_671.png
page_number: 671
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 49.55
tokens: 8187
characters: 2853
timestamp: 2025-12-24T01:28:26.816468
finish_reason: stop
---

Снова о влиянии вызовов функций

Как предполагалось ранее, map также выигрывает для добавленных функций, определяемых пользователем; следующие тесты подтверждают сделанное ранее заявление о том, что map выигрывает состязание у CPython, если в альтернативных версиях должна применяться любая функция:

stmts = [
    (0, 0, "def f(x): return x\n[f(x) for x in 'spam' * 2500]"),
    (0, 0, "def f(x): return x\nres=[]\nfor x in 'spam' * 2500: res.append(f(x))"),
    (0, 0, "def f(x): return x\n$listif3(map(f, 'spam' * 2500))"),
    (0, 0, "def f(x): return x\nlist(f(x) for x in 'spam' * 2500)")]
c:\code> py -3 pybench_cases2.py
3.7.3 (v3.7.3:ef4ec6ed12, Mar 25 2019, 21:26:53) [MSC v.1916 32 bit (Intel)]
1.5400 ["def f(x): return x\n[f(x) for x in 'spam' * 2500]"]
2.0506 ["def f(x): return x\nres=[]\nfor x in 'spam' * 2500: res.append(f(x))"]
1.2489 ["def f(x): return x\nlist(map(f, 'spam' * 2500))"]
1.6526 ["def f(x): return x\nlist(f(x) for x in 'spam' * 2500)"]

Сравните это с тестами ord из предыдущего раздела; хотя определяемые пользователем функции могут работать медленнее встроенных, крупный скачок скорости в наши дни, похоже, коснулся функций в целом, будь они встроенными или нет. Обратите внимание, что суммарное время здесь включает затраты на создание вспомогательной функции, правда, только один раз на 10 000 повторений внутреннего цикла — пренебрежимо малый фактор как с точки зрения здравого смысла, так и для запуска дополнительных тестов.

Сравнение методик: любительская или батарейки

На перспективу давайте посмотрим, как полученные в данном разделе результаты, основанные на модуле timeit, соотносятся с результатами, которые получены с помощью любительского таймера в предыдущем разделе, запустив файл timeseqs3.py из пакета примеров — в нем используется любительский таймер, но выполняется та же самая операция x ** 2 с применением таких же счетчиков повторений, как в pybench_cases.py:

c:\code> py -3 timeseqs3.py
3.7.3 (v3.7.3:ef4ec6ed12, Mar 25 2019, 21:26:53) [MSC v.1916 32 bit (Intel)]
forLoop : 0.50858 => [0...998001]
listComp : 0.40494 => [0...998001]
mapCall : 0.49577 => [0...998001]
genExpr : 0.46281 => [0...998001]
genFunc : 0.46362 => [0...998001]

c:\code> py -3 pybench_cases.py
3.7.3 (v3.7.3:ef4ec6ed12, Mar 25 2019, 21:26:53) [MSC v.1916 32 bit (Intel)]
0.4294 ['[x ** 2 for x in range(1000)]']
0.5434 ['res=[]\nfor x in range(1000): res.append(x ** 2)']
0.5096 ['list(map(lambda x: x ** 2, range(1000)))']
0.4820 ['list(x ** 2 for x in range(1000))']
1.3042 ["s = 'spam' * 2500\nx = [s[i] for i in range(10000)]"]
2.4690 ["s = '?'\nfor i in range(10000): s += '?'"]

Результаты, полученные с использованием любительского таймера, очень похожи на результаты, основанные на pybench, которые получались в этом разделе с помощью timeit, хотя и не совсем так, как яблоко на яблоко. В файле timeseqs3.py,