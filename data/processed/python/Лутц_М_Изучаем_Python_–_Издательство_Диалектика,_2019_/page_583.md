---
source_image: page_583.png
page_number: 583
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 28.22
tokens: 7714
characters: 2305
timestamp: 2025-12-24T01:25:23.135476
finish_reason: stop
---

Но выражение вызова — только одна операция, определенная для работы на объектах функций. Мы можем также инспектировать их атрибуты обобщенным образом (следующий код запускался в Python 3.7, но результаты в Python 2.x похожи):

```python
>>> func.__name__
'func'
>>> dir(func)
['__annotations__', '__call__', '__class__', '__closure__', '__code__',
... остальные не показаны: всего их 35...
'__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__']
```

Инструменты для интроспекции позволяют нам исследовать также детали реализации — например, функции имеют присоединенные кодовые объекты, которые предоставляют подробные сведения о таких аспектах, как локальные переменные и аргументы функций:

```python
>>> func.__code__
<code object func at 0x00000000021A6030, file "<stdin>", line 1>
>>> dir(func.__code__)
['__class__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__',
... остальные не показаны: всего их 38...
'co_name', 'co_names', 'co_nlocals', 'co_stacksize', 'co_varnames']
>>> func.__code__.co_varnames
('a', 'b')
>>> func.__code__.co_argcount
1
```

Разработчики инструментов могут задействовать информацию такого рода для управления функциями (фактически мы сделаем это в главе 39, чтобы реализовать проверку достоверности аргументов функций в декораторах).

**Атрибуты функций**

Объекты функций не ограничены системными атрибутами, перечисленными в предыдущем разделе. Как было указано в главе 17, начиная с версии Python 2.1, к ним можно присоединять произвольные атрибуты, определяемые пользователем:

```python
>>> func
<function func at 0x000000000296A1E0>
>>> func.count = 0
>>> func.count += 1
>>> func.count
1
>>> func.handles = 'Button-Press'
>>> func.handles
'Button-Press'
>>> dir(func)
['__annotations__', '__call__', '__class__', '__closure__', '__code__',
... и т.д.: в Python 3.x все остальные имена имеют двойные подчеркивания,
    так что ваши имена с ними не конфликтуют...
'__str__', '__subclasshook__', 'count', 'handles']
```

Собственные связанные с реализацией данные Python, хранящиеся с объектами функций, следуют соглашениям об именовании, которые предотвращают конфликты с более произвольными именами атрибутов, которые вы можете назначать самостоятельно. В Python 3.x все имена внутренностей функций содержат ведущие и хвосто-