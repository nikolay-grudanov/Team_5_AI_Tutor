---
source_image: page_330.png
page_number: 330
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 32.99
tokens: 7848
characters: 2830
timestamp: 2025-12-24T01:17:36.795239
finish_reason: stop
---

Разумеется, по причине неизменяемости строк механизм кеширования никак не связан с вашим кодом — строки нельзя модифицировать на месте вне зависимости от того, сколько переменных на них ссылается. Если проверки идентичности выглядят сбивающими с толку, тогда загляните в главу 6, чтобы освежить в памяти концепции ссылок на объекты.

В качестве эмпирического правила запомните: операция == является тем, что вы будете использовать для почти всех проверок эквивалентности, тогда как операция is зарезервирована для очень специализированных ролей. Позже в книге будут приведены случаи применения обеих операций.

Сравнения относительных величин также работают рекурсивно в отношении вложенных структур данных:

```python
>>> L1 = [1, ('a', 3)]
>>> L2 = [1, ('a', 2)]
>>> L1 < L2, L1 == L2, L1 > L2    # Меньше, равно, больше: кортеж результатов
(False, False, True)
```

Здесь L1 больше L2, потому что вложенное значение 3 больше, чем 2. К этому времени вы должны знать, что результатом последней строки на самом деле будет кортеж из трех объектов — результатов трех введенных выражений (пример кортежа без круглых скобок).

Говоря более конкретно, Python сравнивает типы следующим образом.

• Числа сравниваются по относительным величинам после преобразования в случае необходимости к общему наибольшему типу.
• Строки сравниваются лексикографически (по значениям кодовых точек из таблицы символов, возвращаемым функцией ord) символ за символом до достижения конца или первого несовпадения ("abc" < "ac").
• Списки и кортежи сравниваются путем сравнения каждого компонента слева направо и рекурсивно для вложенных структур до достижения конца или первого несовпадения ([2] > [1, 2]).
• Множества равны, если оба содержат те же самые элементы (формально, если каждое является подмножеством другого), а сравнения множеств по относительным величинам применяют проверки на подмножество и надмножество.
• Словари считаются равными, если равны их отсортированные списки пар (ключ, значение). Сравнения по относительным величинам для словарей не поддерживаются в Python 3.x, но работают в Python 2.x, как если бы сравнивались отсортированные списки пар (ключ, значение).
• Сравнения величин разнородных типов (например, 1 < 'spam') вызывают ошибку в Python 3.x. Они разрешены в Python 2.x, но используют фиксированное и вместе с тем произвольное правило, основанное на строке имени типа. Опосредованно то же самое применимо к сортировке, которая внутренне использует сравнения: коллекции нечисловых разнородных типов не могут быть отсортированы в Python 3.x.

В общем случае сравнения структурированных объектов происходят так, как если бы мы записали объекты в виде литералов и сравнивали все их части по одной за раз слева направо. В последующих главах вы увидите другие типы объектов, которые способны изменять способ своего сравнения.