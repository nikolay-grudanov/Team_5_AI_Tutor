---
source_image: page_675.png
page_number: 675
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 30.14
tokens: 7823
characters: 2749
timestamp: 2025-12-24T01:28:15.213360
finish_reason: stop
---

Здесь имя X в функции распознается как имя X в модуле. Но посмотрим, что произойдет, если добавить присваивание X после ссылки на него:

```python
>>> def selector():
    print(X)      # Пока еще не существует!
    X = 88        # X классифицируется как локальное имя (повсюду)
    # Может также произойти в случае import X, def X и т.д.
>>> selector()
UnboundLocalError: local variable 'X' referenced before assignment
Ошибка несвязанной локальной переменной: ссылка на локальную переменную X перед ее присваиванием
```

Выдается сообщение об ошибочном применении имени, но причина ее довольно тонкая. Python читает и компилирует этот код, когда он набирается в интерактивной подсказке либо импортируется из модуля. На стадии компиляции Python видит присваивание X и решает, что X будет локальным именем повсюду в функции. Но когда функция фактически запущена, из-за того, что к моменту выполнения print присваивание еще не произошло, Python сообщает о попытке использования неопределенного имени. Согласно правилам применения имен он обязан выдать такое сообщение — локальное имя X используется до его присваивания. В действительности любое присваивание в теле функции делает имя локальным. Такое поведение касается импортирования, операций =, вложенных def, вложенных классов и т.д.

Проблема обусловлена тем, что присвоенные имена трактуются как локальные повсюду в функции, а не только после операторов, где они присваивались. На самом деле предыдущий пример неоднозначен: заключалось ли намерение в том, чтобы вывести глобальное имя X и создать локальное имя X, либо просто в коде была допущена ошибка? Поскольку Python рассматривает X как локальное имя везде в функции, ситуация воспринимается как ошибочная; если подразумевается вывод глобального имени X, тогда его необходимо объявить в операторе global:

```python
>>> def selector():
    global X    # Сделать X глобальным именем (повсюду)
    print(X)
    X = 88
>>> selector()
99
```

Тем не менее, помните о том, что тогда присваивание будет изменять глобальное имя X, а не локальное X. Внутри функции невозможно применять локальную и глобальную версии того же самого простого имени. Если действительно намерение состояло в том, чтобы вывести глобальную переменную и затем установить локальную переменную с тем же именем, тогда придется импортировать включающий модуль и использовать для обращения к глобальной переменной форму записи атрибута модуля:

```python
>>> X = 99
>>> def selector():
    import __main__    # Импортирование включающего модуля
    print(__main__.X)   # Уточнение для обращения к глобальной версии имени
    X = 88             # Имя X без уточнения классифицируется как локальное
    print(X)           # Выводит локальную версию имени
>>> selector()
99
88
```