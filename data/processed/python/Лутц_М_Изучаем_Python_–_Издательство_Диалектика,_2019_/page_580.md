---
source_image: page_580.png
page_number: 580
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 34.28
tokens: 7833
characters: 2873
timestamp: 2025-12-24T01:25:27.035104
finish_reason: stop
---

В нерекурсивных альтернативах можно было бы аналогичным образом избегать добавления уже посещенных состояний с помощью показанного далее кода. Обратите внимание, что проверка на предмет дубликатов, уже находящихся в списке элементов, позволит избежать планирования какого-то состояния во второй раз, но не предотвратит повторное посещение состояния, которое обходилось ранее и потому удалено из списка:

visited.add(front)
...обработка...
items.extend([x for x in front if x not in visited])

Представленная модель не совсем применима к сценарию использования в данном разделе, в котором просто суммируются числа в списках, но более крупные приложения будут способны идентифицировать повторяющиеся состояния — например, URL ранее посещенной веб-страницы. Фактически мы будем применять такие методики, чтобы избежать циклов и повторений в примерах, рассматриваемых в следующем разделе.

Некоторые программы могут также нуждаться в записывании полных путей, пройденных к каждому состоянию, чтобы по завершении сообщать решения. В подобных случаях каждый элемент в стеке или очереди из нерекурсивной схемы может быть списком полного пути, который достаточен для записи посещенных состояний и содержит следующий элемент, подлежащий исследованию на любом конце.

Также обратите внимание, что стандартный Python ограничивает глубину своего стека вызовов, критически важную для программ с рекурсивными вызовами, чтобы отлавливать ошибки бесконечной рекурсии. Для расширения стека используйте модуль sys:

>>> sys.getrecursionlimit()   # По умолчанию глубина составляет 1000 вызовов
1000
>>> sys.setrecursionlimit(10000)   # Делает возможным более глубокое вложение
>>> help(sys.setrecursionlimit)   # Дополнительные сведения об этой настройке

Максимально допустимое значение для настройки может варьироваться в зависимости от платформы. Она не требуется для программ, в которых применяются стеки или очереди, чтобы избежать рекурсивных вызовов и получить больший контроль над процессом обхода.

Дополнительные примеры рекурсии

Несмотря на искусственность примера в данном разделе, он является типичным представителем более широкого класса программ; скажем, деревья наследования классов и цепочки импортирования модулей могут показывать похожие общие структуры, а вычислительные структуры вроде перестановок могут требовать произвольно много вложенных циклов. Позже в книге мы снова будем использовать рекурсию в более реалистичных примерах:

• в файле permute.py из главы 20 для тасования произвольных последовательностей;
• в файле reloadall.py из главы 25 для обхода цепочек импортирования модулей;
• в файле classtree.py из главы 29 для обхода деревьев наследования классов;
• в файле lister.py из главы 31 опять для обхода деревьев наследования классов;
• в решениях двух упражнений для этой части книги (обратного отсчета и вычисления факториала), приведенных в приложении.