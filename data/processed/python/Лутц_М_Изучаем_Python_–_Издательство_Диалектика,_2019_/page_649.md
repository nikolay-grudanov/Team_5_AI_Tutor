---
source_image: page_649.png
page_number: 649
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 33.50
tokens: 7866
characters: 2978
timestamp: 2025-12-24T01:27:31.644827
finish_reason: stop
---

Ниже объясняется, каким образом данная реализация устраняет недостатки предшествующей версии.

• Модуль time в Python предоставляет доступ к текущему времени с точностью, которая зависит от платформы. В Windows заявлено, что его функция clock обеспечивает микросекундную степень детализации и потому очень точна. Поскольку функция time в Unix может быть лучше, сценарий автоматически делает выбор между ними на основе строки platform из модуля sys; при выполнении в среде Windows она начинается с 'win'. Другие варианты в Python 3.3 и последующих версиях, которые по причине переносимости здесь не применяются, описаны во врезке "Новые вызовы таймеров, появившиеся в версии Python 3.3" далее в главе. Дело в том, что мы будем также измерять время в Python 2.X, где более новые вызовы не доступны, и их результаты на платформе Windows в любом случае выглядят похожими в Python 3.3 и последующих версиях.

• Вызов range в функции total вынесен за пределы цикла измерения времени, поэтому связанные с ним затраты не учитываются для хронометрируемой функции в Python 2.X. Вызов range в Python 3.X дает итерируемый объект, так что данный шаг необязателен и безвреден, но мы все равно прогонаем результат через list и затраты на обход оказываются одинаковыми в Python 2.X и 3.X. Сказанное неприменимо к функции bestof, т.к. время, связанное с range, не учитывается при измерении времени выполнения тестируемой функции.

• Счетчик reps передается в качестве аргумента перед тестируемой функцией и ее аргументами, чтобы позволить варьировать количество повторений для каждого вызова.

• Любое количество позиционных и ключевых аргументов собирается посредством синтаксиса аргументов со звездочкой, так что они должны отправляться индивидуально, а не внутри последовательности или словаря. При необходимости вызывающий код может распаковывать коллекции аргументов в отдельные аргументы с помощью звездочек в вызове, как делается в конце функции bestoftotal. Такой прием обсуждался в главе 18.

• Первая функция в модуле возвращает суммарное истекшее время для всех вызовов в кортеже вместе с финальным возвращаемым значением измеряемой функции, чтобы в вызывающем коде была возможность проверить правильность ее выполнения.

• Вторая функция делает похожую работу, но вместо суммарного возвращает лучшее (минимальное) время — более полезное, когда желательно отфильтровать влияние другой активности на компьютере, и менее полезное для тестируемых функций, которые выполняются слишком быстро, чтобы давать значимые показатели времени прогона.

• Для решения проблемы, упомянутой в предыдущем пункте, последняя функция модуля запускает вложенные вызовы total внутри bestof, чтобы получить лучшее суммарное время. Вложенная операция total способна сделать показатели времени прогона более полезными, но мы по-прежнему имеем фильтр для лучшего времени. Код функции может быть легче понять, если помнить о том, что каждая функция является передаваемым объектом, даже сами тестирующие функции.