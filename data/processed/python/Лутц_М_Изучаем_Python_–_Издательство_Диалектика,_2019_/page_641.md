---
source_image: page_641.png
page_number: 641
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 24.41
tokens: 7632
characters: 1738
timestamp: 2025-12-24T01:27:06.825702
finish_reason: stop
---

c:\code> py -3
>>> (X for X in range(5))
<generator object <genexpr> at 0x0000000028E4798>
>>> X
NameError: name 'X' is not defined
Ошибка имени: имя X не определено

>>> X = 99
>>> [X for X in range(5)]    # Python 3.x: генераторы и включения множеств,
#    словарей и списков локализуют
[0, 1, 2, 3, 4]
>>> X
99

>>> Y = 99
>>> for Y in range(5): pass   # Но операторы циклов имена не локализуют
>>> Y
4

Как упоминалось в главе 17, переменные Python 3.x, присвоенные во включении, на самом деле имеют особую вложенную область видимости; остальные имена, на которые производится ссылка внутри таких выражений, следуют обычным правилам LEGB. Например, в показанном ниже генераторе Z локализуется во включении, но Y и X находятся в объемлющей локальной и в глобальной областях видимости, как обычно:

>>> X = 'aaa'
>>> def func():
    Y = 'bbb'
    print(''.join(Z for Z in X + Y))    # Z во включении, Y в локальной,
    #    X в глобальной области видимости
>>> func()
aaabbb

В данном отношении ситуация Python 2.x аналогична, не считая того, что переменные списковых включений не локализуются — они работают в точности как в циклах for и сохраняют свои значения из последней итерации, но также подвержены неожиданным конфликтам с внешними именами. Включения множеств, словарей и генераторы локализуют имена как в Python 3.x:

c:\code> py -2
>>> (X for X in range(5))
<generator object <genexpr> at 0x0000000002147EE8>
>>> X
NameError: name 'X' is not defined
Ошибка имени: имя X не определено

>>> X = 99
>>> [X for X in range(5)]    # Python 2.x: подобно for списковое включение
#    не локализует свои имена
[0, 1, 2, 3, 4]
>>> X
4

>>> Y = 99
>>> for Y in range(5): pass   # Циклы for не локализуют имена в Python 2.x и 3.x
>>> Y
4