---
source_image: page_606.png
page_number: 606
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 27.91
tokens: 7727
characters: 2445
timestamp: 2025-12-24T01:26:03.194155
finish_reason: stop
---

res = []
for row in range(3):
    tmp = []
    for col in range(3):
        tmp.append(M[row][col] * N[row][col])
    res.append(tmp)

Ради еще большей забавы мы можем применить zip для образования пар элементов с целью перемножения. Приведенные ниже версии со списковым включением и операторами цикла производят тот же самый список списков с результатами попарного перемножения, что и предшествующий пример (и поскольку zip в Python 3.x представляет собой генератор значений, решение не настолько неэффективно, как может показаться):

[[col1 * col2 for (col1, col2) in zip(row1, row2)] for (row1, row2) in zip(M, N)]
res = []
for (row1, row2) in zip(M, N):
    tmp = []
    for (col1, col2) in zip(row1, row2):
        tmp.append(col1 * col2)
    res.append(tmp)

По сравнению с эквивалентными операторами версия со списковым включением требует только одной строки кода, может выполняться значительно быстрее для крупных матриц и просто способна взорвать ваш мозг! Что и подводит нас к следующему разделу.

Не злоупотребляйте списковыми включениями: KISS

При такой универсальности списковые включения могут быстро стать малопонятными, особенно когда они вложенные. Некоторые задачи программирования сложны по своей природе, и мы не можем приукрашивать их в попытке сделать проще, чем они есть на самом деле (в качестве основного примера дождитесь грядущих перестановок). Инструменты вроде включений являются мощными решениями, когда используются разумно, и по существу нет ничего плохого в том, чтобы применять их в своих сценариях.

Вместе с тем код, подобный представленному в предыдущем разделе, может выйти за границы допустимой сложности — и, откровенно говоря, способен непропорционально возбудить интерес у тех, кто придерживается ошибочного предположения о том, что запутывание кода каким-то образом намекает на наличие таланта. Поскольку такие инструменты имеют тенденцию быть притягательными для определенных людей больше, чем вероятно должны, я вынужден прояснить здесь область их применения.

В книге демонстрируются усложненные включения в учебных целях, но в реальном мире использование неоправданно трудного для понимания и замысловатого кода служит признаком скверного проектирования и плохой заботы о его потребителях. Перефразируя мысль из первой главы: программа не должна быть заумной и непонятной — она должна четко сообщать о своем предназначении.

Или вот один из девизов, выводимых import this:

Простое лучше сложного.