---
source_image: page_518.png
page_number: 518
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 34.25
tokens: 7896
characters: 3139
timestamp: 2025-12-24T01:23:33.463259
finish_reason: stop
---

# second.py
import first
print(first.X)    # Нормально: ссылка на имя из другого файла
first.X = 88      # Но его изменение может быть слишком тонким и неявным

В первом модуле определяется переменная X, которая во втором модуле вводится и затем изменяется путем присваивания. Обратите внимание, что во втором модуле мы должны сначала импортировать первый модуль, чтобы вообще получить доступ к его переменной — как уже известно, каждый модуль является самодостаточным пространством имен (пакетом переменных), и мы обязаны импортировать один модуль, чтобы видеть его содержимое в другом. В том и заключается сущность модулей: за счет разделения переменных на пофайловой основе удается избежать конфликтов имен между файлами во многом подобно тому, как локальные переменные позволяют не допускать конфликтов имен среди функций.

Тем не менее, с точки зрения тематики настоящей главы глобальная область видимости файла модуля на самом деле становится пространством имен атрибутов объекта модуля после его импортирования. Импортирующие модули автоматически получают доступ ко всем глобальным переменным файла, потому что глобальная область видимости модуля превращается в пространство имен атрибутов объекта, когда модуль импортируется.

После импортирования первого модуля второй модуль выполняет вывод его переменной и затем присваивает ей новое значение. Ссылаясь на переменную модуля для ее вывода вполне нормально — именно так модули увязываются вместе в более крупную систему. Однако проблема с присваиванием first.X заключается в том, что оно чрезмерно скрыто: разработчику, отвечающему за сопровождение или многократное применение первого модуля, вряд ли известно о том, что какой-то произвольно далеко стоящий в цепочке наследования модуль может изменять X во время выполнения. В действительности второй модуль может находиться в совершенно другом каталоге, так что его вообще будет сложно заметить.

Хотя межфайловые изменения переменных вполне возможны в Python, они обычно гораздо более неуловимые, нежели бы вам хотелось. Вдобавок такие изменения делают связность двух файлов слишком тесной — поскольку они оба зависят от значения переменной X, понять или повторно использовать один файл без другого затруднительно. Такие неявные межфайловые зависимости могут в лучшем случае привести к негибкому коду, в худшем — к откровенным ошибкам.

И снова рекомендуется в целом не поступать так — наилучший способ взаимодействия между границами файлов предусматривает вызов функций с передачей им аргументов и получением обратно возвращаемых значений. В этом особом случае, возможно, было бы разумно написать функцию доступа для управления изменением:

# first.py
X = 99
def setX(new):    # Функция доступа делает внешние изменения явными
    global X     # И она позволяет управлять доступом в одном месте
    X = new
# second.py
import first
first.setX(88)    # Вызвать функцию вместо изменения напрямую

Такой подход требует большего объема кода и может показаться тривиальным изменением, но он демонстрирует огромное отличие в плане читабельности и удобства сопровождения — когда разработчик, читающий только код первого модуля, увидит