---
source_image: page_204.png
page_number: 204
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 33.36
tokens: 7826
characters: 2820
timestamp: 2025-12-24T01:13:23.295193
finish_reason: stop
---

>>> engineers | managers      # Все сотрудники в обеих категориях
{'bob', 'tom', 'sue', 'vic', 'ann'}
>>> engineers - managers    # Инженеры, не являющиеся менеджерами
{'vic', 'ann', 'bob'}
>>> managers - engineers    # Менеджеры, не являющиеся инженерами
{'tom'}
>>> engineers > managers     # Все ли менеджеры — инженеры? (надмножество)
False
>>> {'bob', 'sue'} < engineers   # Оба ли сотрудника — инженеры? (подмножество)
True
>>> (managers | engineers) > managers # Все сотрудники — надмножество менеджеров?
True
>>> managers ^ engineers      # Кто находится в одной категории, но не в обеих?
{'tom', 'vic', 'ann', 'bob'}
>>> (managers | engineers) - (managers ^ engineers)   # Пересечение!
{'sue'}

Дополнительные детали об операциях над множествами вы можете найти в руководстве по стандартной библиотеке Python и книгах, посвященных математике и базам данных. Кроме того, в главе 8 мы еще вернемся к некоторым рассмотренным здесь операциям над множествами в контексте объектов представлений словарей из Python 3.x.

Булевские значения

Некоторые могут утверждать, что булевский тип в Python, bool, является по своей природе числовым, поскольку два его значения, True и False, являются настроенными версиями целых чисел 1 и 0, которые всего лишь выводят себя по-другому. Хотя это все, что нужно знать большинству программистов, давайте исследуем булевский тип чуть более подробно.

Выражаясь более формально, в наши дни Python имеет явный булевский тип данных по имени bool со значениями True и False, доступными как предварительно определенные имена. Внутренне имена True и False являются экземплярами типа bool, который в свою очередь представляет собой подкласс (в объектно-ориентированном смысле) встроенного целого типа int. Имена True и False ведут себя в точности как целые числа 1 и 0 за исключением того, что они имеют специальную логику вывода — они отображают себя в виде слов True и False, а не цифр 1 и 0. В типе bool это достигается за счет переопределения форматов строк str и repr для двух указанных объектов.

Вследствие такой настройки вывод булевских выражений, набираемых в интерактивной подсказке, выглядит как True и False взамен старых и менее очевидных 1 и 0. Вдобавок булевский тип делает истинные значения более явными в коде. Скажем, бесконечный цикл теперь можно записать как while True: вместо менее понятного варианта while 1:. Аналогично появляется возможность более ясной инициализации флагов наподобие flag = False. В части III мы обсудим эти операторы более подробно.

Однако для большинства практических целей вы можете трактовать True и False так, как если бы они были заранее определенными переменными, установленными в целые значения 1 и 0. Большинство программистов в любом случае предварительно присваивали True и False значения 1 и 0; тип bool просто делает это стандартом.