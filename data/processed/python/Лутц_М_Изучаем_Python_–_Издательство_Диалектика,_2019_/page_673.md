---
source_image: page_673.png
page_number: 673
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 36.31
tokens: 7949
characters: 2904
timestamp: 2025-12-24T01:28:17.903939
finish_reason: stop
---

(0, 0, "def f(x):\n\treturn x",
    "[f(x) for x in 'spam' * 2500]"),
(0, 0, "def f(x):\n\treturn x",
    "res=[]\nfor x in 'spam' * 2500:\n\tres.append(f(x))"),
(0, 0, "L = [1, 2, 3, 4, 5]", "for i in range(len(L)): L[i] += 1"),
(0, 0, "L = [1, 2, 3, 4, 5]", "i=0\nwhile i < len(L):\n\tL[i] += 1\n\ti += 1")
...
pybench2.runner(stmts, pythons, tracecmd)

Запустите этот сценарий с флагами командной строки -a и -t, чтобы посмотреть, каким образом конструируются командные строки для кода настройки. Например, следующий кортеж спецификаций теста генерирует командную строку для Python 3.7 — возможно, не особо приглядную внешне, но достаточную, чтобы передать строки из Windows в timeit, которые объединяются с разрывами строк и вставляются внутрь сгенерированной функции измерения времени с подходящими отступами:

(0, 0, "def f(x):\n\treturn x",
    "res=[]\nfor x in 'spam' * 2500:\n\tres.append(f(x))")
C:\python37\python -m timeit -n 1000 -r 5 -s "def f(x):" -s "    return x" "res=[]"
    "for x in 'spam' * 2500:" "    res.append(f(x))"

В режиме вызовов API-интерфейса строки с кодом передаются в неименном виде, поскольку нет необходимости умиротворять командную оболочку, так что встроенных табуляций и символов конца строки вполне достаточно. Поэкспериментируйте самостоятельно, чтобы раскрыть для себя еще больше аспектов, касающихся скорости выполнения кодовых альтернатив Python. В итоге вы можете столкнуться с ограничениями оболочки для более крупных разделов кода в режиме командной строки, но любительский таймер и основанный на timeit режим вызовов API-интерфейса модуля pybench поддерживают более произвольный код. Оценочные испытания могут оказаться самым приятным времепрепровождением, так что дальнейшие усовершенствования оставляются в качестве упражнений.

Другие темы, связанные с оценочными испытаниями: тест pystone

Главное внимание в главе уделяется основам хронометража, которые вы можете задействовать в своем коде, которые применимы к оценочным испытаниям Python в общем и которые служат распространенными сценариями использования при разработке более крупных примеров в книге. Однако оценочные испытания Python являются более широкой и насыщенной предметной областью, чем предполагалось до сих пор. Если вас интересуют дальнейшие исследования данной темы, тогда поищите ссылки в веб-сети. Помимо прочего вы найдете:

• pystone.py — программа, предназначенная для измерения скорости Python в широком диапазоне кода (https://github.com/blackberry/Python/blob/master/Python-3/Lib/test/pystone.py);
• https://speed.python.org — сайт проекта для координации работы над распространенными эталонными тестами Python;
• https://speed.pyru.org — сайт оценочных испытаний PyPy, который частично эмулирует предыдущий пункт.

Скажем, тест pystone основан на программе оценочных испытаний языка C, которая была переведена на Python первоначальным создателем Python Гвидо ван Россумом.