---
source_image: page_562.png
page_number: 562
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 34.46
tokens: 7859
characters: 3013
timestamp: 2025-12-24T01:24:55.265636
finish_reason: stop
---

следует отметить, что пользователям Python 3.x не нужно поддерживать словари, потому что их словари не поддерживают прямые сравнения; см. главы 8 и 9.)

Первое требование предоставляет собой естественный пример того, как можно эффективно задействовать средство * — мы можем собрать аргументы в кортеж и пройти по ним с помощью простого цикла for. Вторая часть постановки задачи сложностью не отличается: из-за того, что каждый тип объекта поддерживает сравнения, нам не придется специализировать функцию по типам (случай употребления полиморфизма); мы просто вслепую сравниваем объекты и позволяем Python выяснить то, сравнение какого вида выполнять в отношении сравниваемых объектов.

Основная задача

В файле mins.py показаны три способа реализации данной операции, по крайней мере, один из которых был предложен моим студентом (я часто предлагаю группе студентов решить такое упражнение, чтобы вывести их из полусонного состояния после обеда).

• Первая функция извлекает первый аргумент (args является кортежем) и проходит по остальным путем нарезания первого (нет смысла сравнивать объект с самим собой, особенно если он может быть крупной структурой).

• Вторая функция позволяет Python автоматически выбирать первый и остальные аргументы, тем самым избегая индексирования и нарезания.

• Третья функция преобразует кортеж в список посредством встроенного вызова list и задействует списковый метод sort.

Метод sort написан на C, так что временами он может оказываться быстрее других подходов, но линейный просмотр в первых двух версиях способен делать их быстрее в большинстве случаев1. Вот три решения из файла mins.py:

def min1(*args):
    res = args[0]
    for arg in args[1:]:
        if arg < res:
            res = arg
    return res
def min2(first, *rest):
    for arg in rest:
        if arg < first:
            first = arg
    return first

1 На самом деле все довольно сложно. Процедура sort в Python написана на C и использует крайне оптимизированный алгоритм, который старается извлечь преимущество из частичного упорядочения элементов, подлежащих сортировке. Он назван timsort в честь своего создателя Тима Петерса (Tim Peters) и в его документации заявлено, что временами алгоритм обладает "сверхъестественной производительностью" (совсем неплохо как для сортировки!). Тем не менее, сортировка по своей сути является быстрорастущей операцией (она обязана разбивать последовательность и собирать ее снова много раз), а другие версии просто выполняют один линейный просмотр слева направо. Совокупный эффект в том, что сортировка проходит быстрее, если аргументы частично упорядочены, но в противном случае вероятно будет медленнее (что подтверждается тестовыми запусками в Python 3.x). Но даже при этих условиях производительность Python со временем может меняться, и тот факт, что сортировка реализована на языке C, способен значительно помочь; для точного анализа потребуется измерить время выполнения альтернативных версий посредством модуля time или timeit, как будет показано в главе 21.