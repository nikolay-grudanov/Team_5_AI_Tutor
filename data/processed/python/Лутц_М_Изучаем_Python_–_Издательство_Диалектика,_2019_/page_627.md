---
source_image: page_627.png
page_number: 627
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 30.76
tokens: 7747
characters: 2411
timestamp: 2025-12-24T01:26:48.473479
finish_reason: stop
---

Таким образом, история с итераторами и генераторами фактически не может быть завершена до тех пор, пока мы не увидим, как она соотносится с классами. В текущий момент мы должны довольствоваться тем, что отложим ее окончание — и финальный результат — до обсуждения итерируемых объектов, основанных на классах, в главе 30.

Пример: генерация перемешанных последовательностей

Чтобы продемонстрировать мощь итерационных инструментов в действии, давайте обратимся к более полным сценариям применения. В главе 18 была написана тестовая функция, которая перемешивала порядок следования аргументов, используемых для проверки работоспособности обобщенных функций пересечения и объединения. Там отмечалось, что возможно было бы лучше ее реализовать в виде генератора значений. Теперь, когда известно, как писать генераторы, это послужит иллюстрацией практического применения.

Одно заблаговременное замечание: поскольку все примеры в этом разделе (включая перестановки в конце) выполняют срез и конкатенацию объектов, они работают только с последовательностями вроде строк и списков, но не с произвольными итерируемыми объектами наподобие файлов, отображений и других генераторов. То есть некоторые примеры сами по себе будут генераторами, производя значения по запросу, но они не могут обрабатывать генераторы как входные данные. Обобщение для более широких категорий остается открытой задачей, хотя код здесь в основном не придется изменять, если перед передачей генераторов, отличных от последовательностей, помещать их внутрь вызовов list.

Перемешивание последовательностей

Как было показано в главе 18, мы можем переупорядочивать последовательность посредством нарезания и конкатенации, перемещая головной элемент в конец на каждой итерации цикла; использование нарезания вместо индексации элемента позволяет операции + работать для произвольных типов последовательностей:

>>> L, S = [1, 2, 3], 'spam'
>>> for i in range(len(S)):
    S = S[1:] + S[:1]
    print(S, end=' ')
pams amsp mspa spam
>>> for i in range(len(L)):
    L = L[1:] + L[:1]
    print(L, end=' ')
[2, 3, 1] [3, 1, 2] [1, 2, 3]

Как объяснялось в главе 13, добиться тех же результатов по-другому можно путем перемещения целого головного раздела в конец, но порядок результатов слегка варьируется:

>>> for i in range(len(S)):
    X = S[i:] + S[:i]  # Задняя часть + передняя часть (тот же самый эффект)
    print(X, end=' ')
spam pams amsp mspa