---
source_image: page_773.png
page_number: 773
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 42.01
tokens: 7729
characters: 2649
timestamp: 2025-12-24T01:31:19.663402
finish_reason: stop
---

Как обсуждалось в главе 23, это расширение часто применяется с целью предоставления кратких псевдонимов для более длинных имен и устранения конфликтов имен, когда в сценарии уже используется имя, которое иначе было бы перезаписано обычным оператором import:

import reallylongmodulename as name    # Использовать короткий псевдоним
name.func()

from module1 import utility as util1    # Можно иметь только одно имя utility
from module2 import utility as util2
util1(); util2()

Расширение as также оказывается полезным, когда нужно предоставить короткое простое имя для целого пути к каталогу и избежать конфликтов имен в случае применения средства импортирования пакетов, описанного в главе 24:

import dir1.dir2.mod as mod    # Полный путь указывается только один раз
mod.func()

from dir1.dir2.mod import func as modfunc # При необходимости переименовать,
# чтобы сделать уникальным
modfunc()

Прием также является своего рода защитой от изменения имен: если в новом выпуске библиотеки модуль или инструмент, широко используемый в вашем коде, получает новое имя, либо предлагается альтернатива, которую необходимо применять взамен, тогда вы при импортировании всего лишь назначаете ему прежнее имя и предотвращаете нарушение работоспособности имеющегося кода:

import newname as oldname
from library import newname as oldname
...и продолжить использовать oldname до тех пор, пока не появится время обновить весь код...

Скажем, такой подход может справиться с некоторыми изменениями в библиотеке Python 3.X (например, tkinter из Python 3.X против Tkinter из Python 2.X), хотя часто они представляют собой нечто большее, чем просто новые имена!

Пример: модули являются объектами

Поскольку модули делают видимыми большинство своих интересных свойств в форме встроенных атрибутов, легко писать программы, которые управляют другими программами. Такие управляющие программы мы обычно называем метапрограммами, потому что они работают поверх других систем. На это также ссылаются как на самоанализ, т.к. программы способны видеть и обрабатывать внутренности объектов. Самоанализ — довольно сложное средство, но оно может быть полезным для построения программных инструментов.

Например, чтобы получить атрибут по имени name из модуля M, мы можем использовать уточнение с помощью атрибута или индекс в словаре атрибутов модуля, доступном через встроенный атрибут __dict__, который обсуждался в главе 23. Python также экспортирует список всех загруженных модулей в виде словаря sys.modules и предоставляет встроенную функцию getattr, которая позволяет извлекать атрибуты по строкам с их именами, что похоже на object.attr, но только attr является выра-