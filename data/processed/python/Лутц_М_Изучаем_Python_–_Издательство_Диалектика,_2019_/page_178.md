---
source_image: page_178.png
page_number: 178
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 25.13
tokens: 7736
characters: 2201
timestamp: 2025-12-24T01:12:23.040430
finish_reason: stop
---

>>> 1 < 2      # Меньше
True
>>> 2.0 >= 1     # Больше или равно: число разнородного типа 1 преобразуется в 1.0
True
>>> 2.0 == 2.0   # Равенство значений
True
>>> 2.0 != 2.0   # Неравенство значений
False

Снова обратите внимание на то, что в числовых выражениях (и только в них) разрешены разнородные типы; во втором выражении Python сравнивает значения в рамках более сложного типа с плавающей точкой.

Интересно отметить, что Python также позволяет выстраивать в цепочку множество сравнений для выполнения проверок вхождения в диапазон. Сцепленные сравнения являются своего рода краткой записью для более крупных булевских выражений. Словом, Python дает возможность связывать вместе проверки со сравнениями по абсолютной величине, чтобы представлять сцепленные сравнения, такие как проверки вхождения в диапазон. Например, выражение (A < B < C) проверяет, находится ли B между A и C; оно эквивалентно булевской проверке (A < B and B < C), но легче воспринимается на глаз (и проще набирается на клавиатуре). Например, пусть есть следующие присваивания:

>>> x = 2
>>> y = 4
>>> z = 6

Приведенные далее два выражения дают идентичные результаты, но первое короче в наборе и может выполняться чуть быстрее, т.к. Python придется оценивать Y только один раз:

>>> x < y < z    # Сцепленные сравнения: проверки вхождения в диапазон
True
>>> x < y and y < z
True

Такая же эквивалентность сохраняется для ложных результатов, к тому же разрешено выстраивать цепочки произвольной длины:

>>> x < y > z
False
>>> x < y and y > z
False
>>> 1 < 2 < 3.0 < 4
True
>>> 1 > 2 > 3.0 > 4
False

В сцепленных проверках можно использовать другие сравнения, но результирующие выражения могут стать менее понятными, если только вы не будете их оценивать так, как делает Python. Скажем, следующее выражение дает ложный результат, потому что 1 не равно 2:

>>> 1 == 2 < 3    # То же, что и 1 == 2 and 2 < 3
False           # Не то же, что и False < 3 (эквивалентно 0 < 3, которое истинно!)

Python не сравнивает результат False выражения 1 == 2 с числом 3 — формально это означает то же, что и выражение 0 < 3, которое дает True (как мы увидим позже в главе, True и False представляют собой всего лишь настроенные 1 и 0).