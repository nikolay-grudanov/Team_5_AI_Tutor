---
source_image: page_556.png
page_number: 556
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 32.55
tokens: 7868
characters: 2860
timestamp: 2025-12-24T01:24:41.182462
finish_reason: stop
---

Обобщенное применение функций

Примеры в предыдущем разделе могли показаться учебными (если вообще не экзотическими), но они используются чаще, чем возможно ожидалось. Некоторые программы нуждаются в вызове произвольных функций в обобщенной манере, не зная заранее их имена или аргументы. Фактически реальная мощь специального синтаксиса вызовов с переменным количеством аргументов заключается в том, что при написании сценария вы не знаете, сколько аргументов требует вызов функции. Скажем, вы можете применять логику if для выбора из набора функций и списков аргументов и вызывать любую из них обобщенным образом (функции в ряде следующих далее примеров являются гипотетическими):

if sometest:
    action, args = func1, (1,)                # Вызов func1 с одним аргументом
else:
    action, args = func2, (1, 2, 3)           # Вызов func2 с тремя аргументами
...и так далее...
action(*args)                                 # Выполнение обобщенным образом

Здесь задействована форма * и тот факт, что функции представляют собой объекты, на которые можно ссылаться и вызывать через любую переменную. В более общем случае такой синтаксис вызовов с переменным количеством аргументов удобен всякий раз, когда предугадать список аргументов невозможно. Например, если пользователь выбирает произвольную функцию через какой-то пользовательский интерфейс, тогда у вас может отсутствовать возможность жестко закодировать вызов функции при написании сценария. В качестве обходного способа просто постройте список аргументов с помощью операций над последовательностями и вызовите функцию с использованием синтаксиса аргумента со звездочкой, чтобы распаковать аргументы:

>>> ...определить либо импортировать func3...
>>> args = (2, 3)
>>> args += (4,)
>>> args
(2, 3, 4)
>>> func3(*args)

Поскольку список аргументов здесь передается как кортеж, программа может построить его во время выполнения. Эта методика также оказывается полезной для функций, которые тестируют либо измеряют время работы других функций. Скажем, в приведенном далее коде мы поддерживаем любую функцию с любыми аргументами, передавая ей все, что было отправлено (файл tracer0.py в пакете примеров для книги):

def tracer(func, *pargs, **kargs):      # Принимает произвольные аргументы
    print('calling:', func.__name__)
    return func(*pargs, **kargs)         # Передает произвольные аргументы
def func(a, b, c, d):
    return a + b + c + d
print(tracer(func, 1, 2, c=3, d=4))

В коде применяется встроенный атрибут __name__, присоединяемый к каждой функции (он вполне ожидаемо содержит строку с именем функции), и синтаксис со звездочками для сбора и последующей распаковки аргументов, предназначенных транслируемой функции. Другими словами, когда код выполняется, аргументы перехватываются функцией tracer и затем передаются посредством синтаксиса вызовов с переменным количеством аргументов: