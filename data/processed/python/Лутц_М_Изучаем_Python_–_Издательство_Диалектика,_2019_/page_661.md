---
source_image: page_661.png
page_number: 661
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 41.11
tokens: 8112
characters: 3008
timestamp: 2025-12-24T01:27:57.488523
finish_reason: stop
---

реализации PyPy (поддерживает код Python 2.7). Результаты дают лучшее суммарное время в секундах из 5 запусков, каждый из которых выполняет строку кода 1000 раз; сама строка кода всякий раз создает 1000-элементный список целых чисел (применяемый для разнообразия в первых двух командах запускающий модуль Windows описан в приложении Б второго тома):

c:\code> py -3
Python 3.7.3 (v3.7.3:ef4ec6ed12, Mar 25 2019, 21:26:53) [MSC v.1916 32 bit... 
>>> import timeit
>>> min(timeit.repeat(stmt="[x ** 2 for x in range(1000)]", number=1000, repeat=5))
0.62164939799999956

c:\code> py -2
Python 2.7.3 (default, Apr 10 2012, 23:24:47) [MSC v.1500 64 bit (AMD64)] on win32
>>> import timeit
>>> min(timeit.repeat(stmt="[x ** 2 for x in range(1000)]", number=1000, repeat=5))
0.0708020004193198

c:\code> c:\pypy\pypy-1.9\pypy.exe
Python 2.7.2 (341e1e3821ff, Jun 07 2012, 15:43:00)
[PyPy 1.9.0 with MSC v.1500 32 bit] on win32
>>> import timeit
>>> min(timeit.repeat(stmt="[x ** 2 for x in range(1000)]", number=1000, repeat=5))
0.0059330329674303905

Вы заметите, что PyPy выполняется более чем в 10 раз быстрее CPython 2.7 и более чем в 100 раз быстрее CPython 3.7. Разумеется, это небольшое искусственное оценочное испытание, но выглядит оно ошеломляюще и отражает относительное ранжирование по скорости, которое обычно поддерживается другими тестами, приводимыми в данной книге (хотя, как мы увидим, CPython все еще побеждает PyPy в ряде типов кода).

Приведенный тест измеряет скорость спискового включения и целочисленной математики. Последняя варьируется между линейками: CPython 3.X имеет единственный целый тип, а CPython 2.X — короткие и длинные целые, что может объяснить часть величины разницы, но результаты, несомненно, правомерны. Нечелочисленные тесты выдают похожее ранжирование (например, тест с плавающей точкой в решениях упражнений текущей части), и целочисленная математика имеет значение — ускорение на один и два порядка (степень 10) будут претворены в жизнь многими реальными программами, поскольку целые числа и итерации в коде Python вездесущи.

Полученные результаты также отличаются от относительных скоростей разных версий в предыдущем разделе, где CPython 2.7 был немного быстрее CPython 3.7, а PyPy в целом в 10 раз быстрее, что также подтверждается большинством других тестов в книге. Помимо отличающегося типа хронометрируемого здесь кода влияние может оказывать и другая кодовая структура внутри timeit — для тестируемых строк модуль timeit строит, компилирует и выполняет строку с оператором def функции, в который вставлена строка, посредством чего устраняется вызов функции для внутреннего цикла. Однако, как будет показано в следующем разделе, с точки зрения относительной скорости это выглядит несущественным.

Использование в командной строке

В модуле timeit предусмотрены обоснованные стандартные параметры. Его можно запускать как сценарий, либо явно указывая имя файла, либо полагаясь на автоматическое нахождение в пути поиска модулей через флаг -m интерпретатора Python