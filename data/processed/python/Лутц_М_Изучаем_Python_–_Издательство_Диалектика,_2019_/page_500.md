---
source_image: page_500.png
page_number: 500
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 36.45
tokens: 7975
characters: 3390
timestamp: 2025-12-24T01:23:02.416909
finish_reason: stop
---

То есть когда передаваемые в функцию объекты имеют ожидаемые методы и операции выражений, они считаются автоматически совместимыми с логикой функции.

Даже в нашей простой функции times это означает, что любые два объекта, которые поддерживают операцию *, будут работать независимо от того, что они собой представляют и когда закодированы. Функция times будет работать с двумя числами (выполняя умножение), со строкой и числом (выполняя повторение) или с любой другой комбинацией объектов, поддерживающих ожидаемый интерфейс — даже с объектами, основанными на классах, которые мы даже еще не придумали.

Более того, если переданные объекты не поддерживают ожидаемый интерфейс, то Python обнаружит ошибку при попытке выполнить выражение * и автоматически сгенерирует исключение. Следовательно, обычно не имеет смысла писать код проверки на предмет ошибок. На самом деле добавление такого кода проверки ограничило бы полезность нашей функции, поскольку она смогла бы работать только с объектами, чьи типы проверяются.

Описанное поведение оказывается ключевым философским отличием между Python и статически типизированными языками вроде C++ и Java: в Python ваш код не обязан заботиться о специфических типах данных. Если это произойдет, тогда код ограничится работой только с теми типами, которые вы предвидели при его написании, и не будет поддерживать другие совместимые типы объектов, которые возможно появятся в будущем. Хотя можно проверять на предмет принадлежности к типам с помощью инструментов, подобных встроенной функции type, наличие таких проверок сведет на нет гибкость кода. Вообще говоря, в Python мы пишем код для интерфейсов объектов, а не для типов данных¹.

Разумеется, определенные программы имеют уникальные требования, и суть такой полиморфной модели программирования в том, что мы обязаны тестировать свой код с целью выявления ошибок, а не предоставлять компилятору объявления типов, которые он сможет использовать для обнаружения специфических разновидностей ошибок заблаговременно. Тем не менее, в обмен на небольшое первоначальное тестирование мы получаем радикальное сокращение объема кода, который приходится писать, и весомое увеличение гибкости результирующего кода. Как вы увидите, на практике это означает чистый выигрыш.

Второй пример:
пересечение последовательностей

Давайте рассмотрим второй пример функции, которая делает что-то более полезное, чем перемножение аргументов, и дополнительно иллюстрирует основы функций.

В главе 13 мы писали код цикла for, который накапливал элементы, общие для двух строк. Там мы отметили, что код получился не настолько полезным, каким мог бы быть, поскольку он настроен на работу только со специфическими переменными

¹ В последние годы такое полиморфное поведение также стало известным под названием утиная типизация, которая гласит, что ваш код не обязан заботиться о том, является ли объект уткой, а только о том, что он крякает. Подойдет все, что крякает, утка или нет, и реализация кряканья возлагается на объект — принцип станет гораздо более ясным, когда мы приступим к изучению классов в части VI. Конечно, это является лишь наглядной метафорой, хотя на самом деле представляет собой просто новое обозначение старой идеи, и сценарии использования для крякающего программного обеспечения могут показаться ограниченными в материальном мире (говорит он, разгребая почтовые завалы от активистов-орнитологов...).