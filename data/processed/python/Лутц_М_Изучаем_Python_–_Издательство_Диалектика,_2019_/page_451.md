---
source_image: page_451.png
page_number: 451
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 36.18
tokens: 7827
characters: 2801
timestamp: 2025-12-24T01:21:32.953264
finish_reason: stop
---

и добавлять полученный результат в итоговый список. И снова мы получаем то, что запрашивали — результаты выполнения rstrip для всех строк в файле:

```python
>>> lines = [line.rstrip() for line in open('script2.py')]
>>> lines
['import sys', 'print(sys.path)', 'x = 2', 'print(x ** 32)']
```

Это выражение многое делает неявно, но мы получаем большой объем работы "даром" — Python просматривает файл по строкам и автоматически строит список результатов выполнения операции. Оно также представляет собой эффективный способ кодирования такой операции: из-за того, что большинство работ делается внутри интерпретатора Python, списковое включение может быть быстрее эквивалентного оператора for и не загружает все содержимое файла в память подобно ряду других методик. Опять-таки, особенно для крупных файлов, преимущества списковых включений могут оказаться значительными.

Помимо эффективности списковые включения также удивительно выразительные. В рассмотренном примере при проведении итераций мы можем выполнять в отношении строк файла любую строковую операцию. В целях иллюстрации ниже показан эквивалент в виде спискового включения для приведенного ранее примера с итератором файлового объекта, преобразующим строки в верхний регистр, вместе с рядом других типичных операций:

```python
>>> [line.upper() for line in open('script2.py')]
['IMPORT SYS\n', 'PRINT(SYS.PATH)\n', 'X = 2\n', 'PRINT(X ** 32)\n']
>>> [line.rstrip().upper() for line in open('script2.py')]
['IMPORT SYS', 'PRINT(SYS.PATH)', 'X = 2', 'PRINT(X ** 32)']
>>> [line.split() for line in open('script2.py')]
[['import', 'sys'], ['print(sys.path)'], ['x', '=', '2'], ['print(x', '*', '32)']]
>>> [line.replace(' ', '!') for line in open('script2.py')]
['import!sys\n', 'print(sys.path)\n', 'x!=!2\n', 'print(x**!32)\n']
>>> [('sys' in line, line[:5]) for line in open('script2.py')]
[(True, 'impor'), (True, 'print'), (False, 'x = 2'), (False, 'print')]
```

Вспомните, что выстраивание вызовов методов в цепочку во втором примере работает из-за того, что строковые методы возвращают новую строку, к которой можно применять другой строковый метод. В последнем примере показано, что можно также накапливать множество результатов, пока они помещены в коллекцию вроде кортежа или списка.

Один тонкий момент: вспомните из главы 9, что файловые объекты сами автоматически закрывают файлы, если на момент обработки сборщиком мусора они все еще открыты. Следовательно, такие списковые включения также будут автоматически закрывать файлы, когда их временные файловые объекты подвергается сборке мусора после того, как выражение выполнено. Однако за пределами CPython при выполнении списковых включений в цикле может возникнуть желание вручную закрывать файлы, чтобы немедленно освобождать ресурсы. Дополнительные сведения ищите в главе 9.