---
source_image: page_555.png
page_number: 555
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 35.15
tokens: 7919
characters: 2439
timestamp: 2025-12-24T01:24:41.046841
finish_reason: stop
---

>>> def func(a, b, c, d): print(a, b, c, d)
>>> args = (1, 2)
>>> args += (3, 4)
>>> func(*args)      # То же, что и func(1, 2, 3, 4)
1 2 3 4

Подобным же образом синтаксис ** в вызове функции распаковывает словарь пар ключ/значение в отдельные ключевые аргументы:

>>> args = {'a': 1, 'b': 2, 'c': 3}
>>> args['d'] = 4
>>> func(**args)      # То же, что и func(a=1, b=2, c=3, d=4)
1 2 3 4

И снова мы можем комбинировать нормальные, позиционные и ключевые аргументы очень гибкими способами:

>>> func(*(1, 2), **{'d': 4, 'c': 3})    # То же, что и func(1, 2, d=4, c=3)
1 2 3 4
>>> func(1, *(2, 3), **{'d': 4})         # То же, что и func(1, 2, 3, d=4)
1 2 3 4
>>> func(1, c=3, *(2,), **{'d': 4})      # То же, что и func(1, 2, c=3, d=4)
1 2 3 4
>>> func(1, *(2, 3), d=4)                # То же, что и func(1, 2, 3, d=4)
1 2 3 4
>>> func(1, *(2,), c=3, **{'d': 4})       # То же, что и func(1, 2, c=3, d=4)
1 2 3 4

Код такого рода удобен, когда спрогнозировать количество передаваемых функции аргументов на стадии написания сценария невозможно; взамен во время выполнения строится коллекция аргументов и функция вызывается подобным способом. Опять-таки не путайте синтаксис аргументов с */** в заголовке функции и в вызове функции — в заголовке он собирает любое количество аргументов, а в вызове распаковывает любое количество аргументов. В обоих местах одна звездочка означает позиционные аргументы, тогда как две звездочки применяются к ключевым аргументам.

В главе 14 было показано, что форма *pargs в вызове является итерационным контекстом и потому формально она принимает любой итерируемый объект, а не только кортежи или другие последовательности, как демонстрировалось ранее в примерах. Скажем, если указать после * объект файла, то его строки распакуются в индивидуальные аргументы (например, func(*open('fname'))). В главе 20 после исследования генераторов будут приведены дополнительные примеры.

Такая универсальность поддерживается в Python 3.x и 2.x, но только для вызовов — аргумент *pargs в вызове допускает любой итерируемый объект, в то время как та же самая форма в заголовке def всегда объединяет добавочные аргументы в кортеж. Описанное поведение заголовка по духу и синтаксису похоже на поведение * в расширенных формах распаковывающего присваивания последовательностей из Python 3.x, которые встречались в главе 11 (вроде x, *y = z), хотя использование звездочки всегда приводит к созданию списков, а не кортежей.