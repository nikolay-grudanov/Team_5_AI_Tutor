---
source_image: page_660.png
page_number: 660
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 34.47
tokens: 7923
characters: 3116
timestamp: 2025-12-24T01:27:50.819276
finish_reason: stop
---

Вы можете попробовать изменить или эмулировать сценарий хронометража для измерения скорости включений множеств и словарей Python 3.x и 2.7, показанных в предыдущей главе, вместе с их эквивалентами в форме циклов for. В программах на Python они применяются реже, чем построение списков результатов, так что мы оставляем эту задачу в качестве упражнения для самостоятельного выполнения (пожалуйста, не спорьте...); следующий раздел частично испортит сюрприз.

Наконец, сохраните модуль для измерения времени в файле, чтобы обращаться к нему в будущем — мы переделаем его с целью измерения производительности альтернативных числовых операций по вычислению квадратного корня в упражнении, приведенном в конце настоящей главы. Если вы заинтересованы продолжить данную тему, то мы также поэкспериментируем с методиками хронометража для включений словарей и циклов for интерактивно в упражнениях.

Измерение времени выполнения итераций и версий Python с помощью модуля timeit

В предыдущем разделе использовались любительские функции измерения времени для сравнения скорости выполнения кода. Как там упоминалось, в состав стандартной библиотеки входит модуль по имени timeit, который можно применять похожими способами, но он предлагает добавочную гибкость и может лучше защитить клиентов от влияния ряда отличий между платформами.

Как обычно в Python, важно понимать первоосновы, подобные тем, что иллюстрировались в предыдущем разделе. Принятый в Python подход "батарейки в комплекте" означает, что обычно вы также найдете предварительно реализованные варианты, хотя для их надлежащего использования по-прежнему необходимо знать лежащие в основе идеи. В действительно модуль timeit является ярким примером — похоже, с ним связана настоящая история неправильной эксплуатации людьми, которые недостаточно хорошо понимали заключенные в нем принципы. Тем не менее, изучив основы, давайте перейдем к инструменту, который способен автоматизировать большую часть нашей работы.

Базовое использование timeit

Прежде чем задействовать модуль timeit в более крупных сценариях, начнем с его основ. Вместе с timeit тесты указываются посредством либо вызываемых объектов, либо строк операторов; последние могут хранить множество операторов, если в них применяются разделители ; или символы \n для разрывов строк и пробелы или табуляции для отступа операторов во вложенных блоках (например, \n\t). Тесты могут выполнять действия по настройке и запускаться из командной строки и через вызовы API-интерфейса, а также из сценариев и в интерактивной подсказке.

Интерактивное использование и вызовы API-интерфейса

Скажем, вызов repeat модуля timeit возвращает список, дающий суммарное время, которое заняло выполнение теста number раз для каждого из прогонов repeat. Вызов min с таким списком позволяет получить лучшее время среди прогонов и помогает отфильтровать колебания загрузки системы, которые иначе могут искусственно искажать результаты измерения времени в большую сторону.

В следующем коде вызов repeat демонстрируется в действии, хронометрируя списковое включение в двух версиях CPython и описанной в главе 2 оптимизированной