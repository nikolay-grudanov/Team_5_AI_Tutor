---
source_image: page_608.png
page_number: 608
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 33.52
tokens: 7916
characters: 3075
timestamp: 2025-12-24T01:26:14.460789
finish_reason: stop
---

Давайте рассмотрим несколько более реалистичных примеров списковых включений и вызовов map в действии. Первый пример мы решали в главе 14 с использованием списковых включений, но здесь мы исследуем альтернативную версию с применением map. Вспомните, что файловый метод readlines возвращает строки с символами \n в конце (в следующем коде предполагается наличие 3-строчного текстового файла в текущем каталоге):

```python
>>> open('myfile').readlines()
['aaa\n', 'bbb\n', 'ccc\n']
```

Если вам не нужны символы \n, тогда можете отсечь их во всех строках за один шаг с помощью спискового включения или вызова map (результаты map являются итерируемыми объектами в Python 3.x, поэтому их необходимо прогнать через вызов list, чтобы отобразить сразу все результаты):

```python
>>> [line.rstrip() for line in open('myfile').readlines()]
['aaa', 'bbb', 'ccc']
>>> [line.rstrip() for line in open('myfile')]
['aaa', 'bbb', 'ccc']
>>> list(map((lambda line: line.rstrip()), open('myfile')))
['aaa', 'bbb', 'ccc']
```

В последних двух версиях используются файловые итераторы; как было показано в главе 14, это означает, что вам не понадобится вызывать какой-то метод для чтения строк в итерационных контекстах. Вызов map чуть длиннее спискового включения, но в обоих случаях нет необходимости в явном управлении созданием результирующего списка.

Списковое включение может применяться также как разновидность операции проецирования столбцов. Стандартный API-интерфейс для работы с базами данных SQL в Python возвращает результаты запросов в форме последовательности последовательностей вроде следующей ниже; список представляет таблицу, кортежи — строки, а элементы в кортежах — значения столбцов:

```python
>>> listoftuple = [('bob', 35, 'mgr'), ('sue', 40, 'dev')]
```

С использованием цикла for можно было бы извлечь все значения из выбранного столбца вручную, но вызовы map и списковые включения способны выполнить такую работу за один шаг, к тому же быстрее:

```python
>>> [age for (name, age, job) in listoftuple]
[35, 40]
>>> list(map((lambda row: row[1]), listoftuple))
[35, 40]
```

В первом варианте задействовано присваивание кортежа, чтобы распаковать кортежи со строками в списке, а во втором применяется индексация. В Python 2.x (но не в Python 3.x — см. врезку "На заметку!" о распаковке аргументов в Python 2.x, приведенную в главе 18) функция map тоже может использовать распаковку кортежей в своем аргументе:

```python
# Только Python 2.x
>>> list(map((lambda (name, age, job): age), listoftuple))
[35, 40]
```

Дополнительные сведения относительно API-интерфейса для работы с базами данных в Python ищите в других книгах и ресурсах.

Помимо различий в выполнении функций и выражений самое большое несходство между map и списковыми включениями в Python 3.x связано с тем, что map является итерируемым объектом, генерирующим результаты по запросу. Чтобы достичь той же экономии памяти и временного разделения при выполнении, списковые включения должны записываться как генераторные выражения — одна из крупных тем этой главы, которая рассматривается следующей.