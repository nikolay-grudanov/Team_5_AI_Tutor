---
source_image: page_537.png
page_number: 537
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 36.32
tokens: 7898
characters: 3144
timestamp: 2025-12-24T01:24:11.372829
finish_reason: stop
---

Код полагается на тот факт, что имя функции nested представляет собой локальную переменную в области видимости tester, включающей в себя nested; по существу на нее можно свободно ссылаться внутри nested. Код также основывается на том, что изменение объекта на месте не является присваиванием имени; когда инкрементируется nested.state, то изменяется часть объекта, на который ссылается nested, а не само имя nested. Поскольку на самом деле мы не выполняем присваивание имени из объемлющей области видимости, никакие объявления nonlocal не требуются.

Атрибуты функций поддерживаются в Python 3.x и 2.x; мы более подробно рассмотрим их в главе 19. Там мы увидим одну важную деталь: в Python 2.x и 3.x применяются соглашения об именовании, гарантирующие отсутствие конфликтов между произвольными именами, которые вы назначаете атрибутам функций, и именами, которые имеют отношение к внутренней реализации, что делает пространство имен эквивалентным области видимости. Помимо субъективных факторов роль атрибутов частично перекрывается с ролью более нового оператора nonlocal в Python 3.x, приводя к его избыточности и меньшей переносимости.

Состояние с помощью изменяемых объектов:
неотчетливый призрак прошлого Python?

В качестве связанного замечания: в Python 2.x and 3.x возможно также изменять изменяемый объект из объемлющей области видимости, не объявляя его имя в nonlocal. Скажем, следующий код работает точно так же, как предыдущая версия, является в такой же степени переносимым и обеспечивает изменяемое состояние для каждого вызова:

def tester(start):
    def nested(label):
        print(label, state[0])  # Использует в своих интересах изменение
        state[0] += 1           # на месте изменяемого объекта
    state = [start]
    return nested

Код задействует изменяемость списков и подобно атрибутам функций опирается на тот факт, что изменение объекта на месте не классифицирует имя как локальное. Однако такой код вероятно еще менее понятен, чем атрибуты функций или оператор nonlocal из Python 3.x — он демонстрирует методику, которая предшествовала даже атрибутам функций, и в наши дни, похоже, находится где-то между искусственной поделкой и черной магией! Возможно, лучше использовать именованные атрибуты функций, чем списки и числовые смещения подобным образом, хотя такие решения могут встречаться в коде, с которым вам приходится работать.

Подытожим: глобальные переменные, нелокальные переменные, классы и атрибуты функций предлагают варианты сохранения изменяемого состояния. Глобальные переменные поддерживают лишь одиночную копию разделяемых данных; нелокальные переменные могут изменяться только в Python 3.x; классы требуют базовых знаний объектно-ориентированного программирования; а классы и атрибуты функций предоставляют переносимые решения, которые делают возможным доступ к состоянию напрямую извне самого запоминающего состояние вызываемого объекта. Как обычно, наилучший инструмент для программы определяется целями, преследуемыми программой.

В главе 39 мы снова вернемся к представленным здесь вариантам поддержки состояния при исследовании более реалистичного контекста — декораторов, которые яв-