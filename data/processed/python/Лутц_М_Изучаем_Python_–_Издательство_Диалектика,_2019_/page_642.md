---
source_image: page_642.png
page_number: 642
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 38.97
tokens: 7984
characters: 2483
timestamp: 2025-12-24T01:27:22.003729
finish_reason: stop
---

Если вас заботит переносимость версий и гармония с оператором цикла for, тогда в качестве эмпирического правила применяйте уникальные имена для переменных в выражениях включений. Поведение Python 2.x имеет смысл с учетом того, что объект генератора отбрасывается после завершения производства результатов, но списковое включение эквивалентно циклу for — хотя эта аналогия не сохраняется для включений множеств и словарей, которые локализуют свои имена в обеих линейках Python и рассматриваются в следующем разделе.

Осмысление включений множеств и словарей

В известном смысле включения множеств и словарей представляют собой всего лишь синтаксический сахар для передачи генераторных выражений именам типов. Так как оба включения принимают любой итерируемый объект, показанные далее итераторы будут нормально работать:

```python
>>> {x * x for x in range(10)}        # Включение
{0, 1, 4, 81, 64, 9, 16, 49, 25, 36}
>>> set(x * x for x in range(10))     # Генератор и имя типа
{0, 1, 4, 81, 64, 9, 16, 49, 25, 36}
>>> {x: x * x for x in range(10)}
{0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6: 36, 7: 49, 8: 64, 9: 81}
>>> dict((x, x * x) for x in range(10))
{0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6: 36, 7: 49, 8: 64, 9: 81}
>>> x                                 # Переменная цикла локализуется в Python 2.x и 3.x
NameError: name 'x' is not defined
Ошибка имени: имя x не определено
```

Тем не менее, что касается списковых включений, то мы всегда можем построить результирующие объекты также с помощью ручного кода. Вот эквиваленты, основанные на операторах, для последних двух включений (но согласно предыдущему разделу они отличаются локализацией имени):

```python
>>> res = set()
>>> for x in range(10):    # Эквивалентное включение множества
    res.add(x * x)
>>> res
{0, 1, 4, 81, 64, 9, 16, 49, 25, 36}
>>> res = {}
>>> for x in range(10):    # Эквивалентное включение словаря
    res[x] = x * x
>>> res
{0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6: 36, 7: 49, 8: 64, 9: 81}
>>> x                        # Локализуется в выражениях включений, но не в операторах циклов
```

Обратите внимание, что хотя включения множеств и словарей принимают и про-сматривают итерируемые объекты, в них отсутствует понятие генерации результатов по запросу — обе формы строят сразу полные объекты. Если вы намереваетесь выпускать ключи и значения по запросу, тогда больше подойдет генераторное выражение:

```python
>>> G = ((x, x * x) for x in range(10))
>>> next(G)
(0, 0)
>>> next(G)
(1, 1)
```