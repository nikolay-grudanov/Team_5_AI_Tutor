---
source_image: page_591.png
page_number: 591
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 32.36
tokens: 7778
characters: 2595
timestamp: 2025-12-24T01:25:43.131708
finish_reason: stop
---

of
life
>>> showall = lambda x: [print(line, end='') for line in x] # То же самое:
# только Python 3.x
>>> showall = lambda x: print(*x, sep='', end='') # То же самое:
# только Python 3.x

Существует ограничение на эмуляцию операторов с помощью выражений: скажем, вы не можете напрямую достичь эффекта оператора присваивания, хотя иногда подходят инструменты вроде встроенной функции setattr, атрибута __dict__ с привязками пространств имен и методов, которые модифицируют изменяемые объекты на месте, а методики функционального программирования способны увести вас в темное королевство мудреных выражений.

Теперь, продемонстрировав такие трюки, я обязан попросить вас применять их только в крайнем случае. Без должного старания они могут привести к нечитабельному (т.е. запутанному) коду на Python. В общем и целом простое лучше сложного, явное лучше неявного и полные операторы лучше загадочных выражений. Вот почему lambda ограничивается выражениями. При необходимости написания более крупной логики используйте оператор def; выражение lambda предназначено для небольших порций внутристрочного кода. С другой стороны, при умеренном применении вы можете найти эти методики удобными.

Области видимости: выражения lambda также могут быть вложенными

Выражения lambda являются главными выгодоприобретателями поиска в областях видимости вложенных функций (E в правиле LEGB из главы 17). В качестве проверки далее выражение lambda находится внутри def — типичный случай — и потому способно получать доступ к значению, которое имя x имело в области видимости объёмлющей функции на момент, когда эта функция вызывалась:

>>> def action(x):
    return (lambda y: x + y) # Создание и возвращение функции, запоминание x
>>> act = action(99)
>>> act
<function action.<locals>.<lambda> at 0x0000000029CA2F0>
>>> act(2) # Вызов того, что возвратила action
101

В предыдущем обсуждении областей видимости вложенных функций не был проиллюстрирован тот факт, что функция lambda также имеет доступ к именам в любой объёмлющей функции lambda. Данный случай не вполне ясен, но вообразите, что мы перепишем предшествующий оператор def с использованием lambda:

>>> action = (lambda x: (lambda y: x + y))
>>> act = action(99)
>>> act(3)
102
>>> ((lambda x: (lambda y: x + y))(99))(4)
103

Здесь вложенная структура lambda создает функцию, которая при вызове также создает функцию. В обеих ситуациях код вложенной конструкции lambda имеет доступ к переменной x из объёмлющей конструкции lambda. Хотя код работает, он выглядит довольно запутанным; в интересах читабельности вложенных lambda в целом лучше избегать.