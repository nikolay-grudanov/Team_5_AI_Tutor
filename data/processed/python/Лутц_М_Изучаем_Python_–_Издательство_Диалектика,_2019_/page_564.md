---
source_image: page_564.png
page_number: 564
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 28.60
tokens: 7674
characters: 2238
timestamp: 2025-12-24T01:24:52.697606
finish_reason: stop
---

def lessthan(x, y): return x < y
def grtrthan(x, y): return x > y
print(minmax(lessthan, 4, 2, 1, 5, 6, 3))    # Тестовый код
print(minmax(grtrthan, 4, 2, 1, 5, 6, 3))
% python minmax.py
1
6

Функции являются еще одним видом объекта, который можно передавать в функцию, подобную показанной. Скажем, чтобы сделать ее функцией max (или другой), мы просто передаем функцию test надлежащего вида. Может показаться, что мы вынуждены делать дополнительную работу, но основной смысл такого обобщения функций — вместо вырезания и вставки с целью изменения всего лишь одного символа — заключается в том, что у нас остается только одна версия для изменения в будущем, а не две.

Заключение

Разумеется, все это было обычным упражнением по написанию кода. В действительности нет никаких причин писать код для функции min или max, потому что они доступны как встроенные функции в Python! Мы бегло сталкивались с ними в главе 5 при обсуждении инструментов для обработки чисел и еще раз в главе 14, когда исследовали итерационные контексты. Встроенные версии работают в точности как наши, но они реализованы на языке C для обеспечения оптимальной скорости и принимают либо одиночный итерируемый объект, либо множество аргументов. Однако, несмотря на избыточность в данном контексте, применяемый здесь универсальный кодовый шаблон может оказаться удобным в других сценариях.

Обобщенные функции для работы с множествами

Давайте рассмотрим более полезный пример со специальными режимами сопоставления аргументов. В конце главы 16 мы написали функцию, которая возвращала пересечение двух последовательностей (она выбирала элементы, присутствующие в обеих последовательностях). Ниже представлена версия, которая ищет пересечение произвольного числа последовательностей (одной и более), используя форму сопоставления с переменным количеством аргументов *аргументы для сбора всех переданных аргументов. Поскольку аргументы поступают в виде кортежа, мы можем обрабатывать произвольное число аргументов с целью сбора элементов, имеющихся во всех операндах:

def intersect(*args):
    res = []
    for x in args[0]:
        if x in res: continue
        for other in args[1:]:
            if x not in other: break
    else:
        res.append(x)
    return res