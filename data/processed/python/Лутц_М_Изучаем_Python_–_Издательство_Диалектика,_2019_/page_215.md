---
source_image: page_215.png
page_number: 215
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 34.47
tokens: 7932
characters: 3125
timestamp: 2025-12-24T01:13:49.390035
finish_reason: stop
---

Разделяемые ссылки и изменения на месте

Как вы увидите позже в главах текущей части, существуют объекты и операции, которые вносят в объекты изменения на месте — изменяемые типы Python, включающие списки, словари и множества. Скажем, присваивание по смещению в списке фактически изменяет сам списковый объект на месте, а не создает совершенно новый такой объект.

Несмотря на то что пока вы должны принять это на веру, такая отличительная особенность может быть очень важной в ваших программах. В отношении объектов, поддерживающих изменения на месте, вам необходимо больше заботиться о разделяемых ссылках, потому что модификация одного имени может повлиять на другие имена. В противном случае ваши объекты могут изменяться без видимой причины. Учитывая, что все присваивания основаны на ссылках (включая передачу аргументов функциям), подобное вполне возможно.

Для иллюстрации сказанного давайте еще раз обратимся к списковым объектам, введенным в главе 4. Вспомните, что списки, которые поддерживают присваивания по позиции на месте, представляют собой просто коллекции других объектов, записанные в квадратных скобках:

```python
>>> L1 = [2, 3, 4]
>>> L2 = L1
```

Здесь L1 — список, содержащий объекты 2, 3 и 4. Элементы внутри списка доступны по своим позициям, поэтому L1[0] ссылается на объект 2, т.е. первый элемент в списке L1. Разумеется, списки сами по себе являются объектами в точности как целые числа и строки. После выполнения показанных выше двух операторов L1 и L2 ссылаются на тот же самый разделяемый объект подобно a и b в предыдущем примере (см. рис. 6.2). А теперь, как и ранее, расширим взаимодействие следующим оператором:

```python
>>> L1 = 24
```

Такое присваивание просто устанавливает L1 в другой объект; L2 по-прежнему ссылается на первоначальный список. Тем не менее, если мы слегка изменим синтаксис оператора, то получим совершенно другой результат:

```python
>>> L1 = [2, 3, 4]      # Изменяемый объект
>>> L2 = L1             # Создает ссылку на тот же самый объект
>>> L1[0] = 24          # Изменение на месте
>>> L1                  # L1 отличается
[24, 3, 4]
>>> L2                  # Но отличается и L2!
[24, 3, 4]
```

На самом деле мы здесь не модифицировали сам список L1, а изменили компонент объекта, на который L1 ссылается. Изменение такого рода перезаписывает часть значения спискового объекта на месте. Однако поскольку списковый объект совместно используется другой переменной (она ссылается на него), изменение на месте подобного вида оказывает влияние не только на L1. В итоге вы должны осознавать, что такие изменения могут воздействовать на другие части программы. В приведенном примере эффект модификации отражается и в списке L2, т.к. он ссылается на тот же самый объект, что и L1. В действительности мы не изменяли список L2, но его значение стало другим, потому что он ссылается на объект, который был перезаписан на месте.

Такое поведение характерно только для изменяемых объектов, которые поддерживают изменения на месте, и обычно является желательным, но вы обязаны знать, как оно работает, и ожидать его. Кроме того, так происходит по умолчанию: если вас не