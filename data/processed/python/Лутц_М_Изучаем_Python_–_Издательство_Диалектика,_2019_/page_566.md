---
source_image: page_566.png
page_number: 566
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 35.38
tokens: 7800
characters: 2533
timestamp: 2025-12-24T01:25:00.191427
finish_reason: stop
---

>>> tester(intersect, ('ba', 'abcdefg', 'abdst', 'albmcnd'), False)
['a', 'b']
['a', 'b']
['a', 'b']
['a', 'b']

Перестановка аргументов здесь не обеспечивает генерацию всех возможных порядков следования аргументов (для этого потребовалась бы полная перестановка — 24 порядка для 4 аргументов), но их достаточно для выяснения, влияет ли порядок аргументов на результаты. Продолжив тестирование, вы заметите, что дубликаты не появляются ни в результатах пересечения, ни в результатах объединения, что с точки зрения математики квалифицирует их как операции над множествами:

>>> intersect([1, 2, 1, 3], (1, 1, 4))
[1]
>>> union([1, 2, 1, 3], (1, 1, 4))
[1, 2, 3, 4]
>>> tester(intersect, ('ababa', 'abcdefga', 'aaaab'), False)
['a', 'b']
['a', 'b']
['a', 'b']

С алгоритмической точки зрения они все еще далеки от оптимальных, но с учетом замечания в следующей далее врезке "На заметку!" мы оставляем дальнейшее совершенствование кода в качестве упражнения для самостоятельного решения. Также имейте в виду, что перестановка аргументов в функции tester может оказаться полезным инструментом в общем смысле, и функция tester стала бы проще, если делегировать выполнение перестановки другой функции, которая по своему усмотрению могла бы создавать или генерировать комбинации аргументов:

>>> def tester(func, items, trace=True):
    for args in scramble(items):
        ...использовать аргументы...

На самом деле мы займемся этим — пример будет соответствующим образом переработан в главе 20, когда мы выясним, каким образом писать определяемые пользователем генераторы. Кроме того, в главе 32 мы перепишем код операций над множествами еще раз, а решение упражнения для части VI в виде классов расширит объект списка методами.

Поскольку Python теперь располагает типом множества (описанным в главе 5), ни один из примеров обработки множеств в книге больше не требуется; они включены только для демонстрации методик написания кода и в наши дни являются всего лишь учебными. За счет постоянного улучшения и расширения, похоже, Python устраивает коварный заговор против моих примеров в книге, делая их устаревшими!

Эмуляция функции print из Python 3.x

В завершение главы давайте рассмотрим последний пример сопоставления аргументов в работе. Показанный далее код предназначен для использования в Python 2.x и более ранних версиях (он работает также в Python 3.x, но в нем нет никакого смысла). В коде применяются кортеж с произвольным количеством позиционных аргументов *аргументы и словарь с произвольным количеством ключевых аргуме-