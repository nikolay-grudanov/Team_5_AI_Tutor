---
source_image: page_635.png
page_number: 635
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 30.86
tokens: 7858
characters: 2492
timestamp: 2025-12-24T01:27:01.330532
finish_reason: stop
---

>>> S1 = 'abc'
>>> S2 = 'xyz123'
>>> list(zip(S1, S2))
[('a', 'x'), ('b', 'y'), ('c', 'z')]
# zip объединяет в пары элементы из итерируемых объектов

[('a', 'x'), ('b', 'y'), ('c', 'z')]
# zip объединяет элементы в пары, усекает до самого короткого
>>> list(zip([-2, -1, 0, 1, 2]))
[(-2,), (-1,, (0,, (1,, (2,,)]
# Единственная последовательность:
# 1-арные кортежи

[(1, 2), (2, 3), (3, 4)]
# N последовательностей:
# N-арные кортежи

# map передает объединенные в пары элементы функции, усекает
>>> list(map(abs, [-2, -1, 0, 1, 2]))
[2, 1, 0, 1, 2]
# Единственная последовательность:
# 1-арная функция

>>> list(map(pow, [1, 2, 3], [2, 3, 4, 5]))
[1, 8, 81]
# N последовательностей:
# N-арная функция, Python 3.x

# map и zip принимают произвольные итерируемые объекты
>>> list(map(lambda x, y: x + y, open('script2.py'), open('script2.py')))
['import sys\nimport sys\n', 'print(sys.path)\nprint(sys.path)\n', ...и так далее...]
>>> [x + y for (x, y) in zip(open('script2.py'), open('script2.py'))]
['import sys\nimport sys\n', 'print(sys.path)\nprint(sys.path)\n', ...и так далее...]

Несмотря на использование для разных целей, если вы достаточно хорошо изучите приводимые примеры, то сможете заметить отношение между результатами zip и аргументами функции map, которое задействовано в следующем примере.

Написание собственной функции map(func, ...)

Хотя встроенные функции map и zip отличаются высокой скоростью и удобством, их всегда возможно эмулировать в собственном коде. Например, в предыдущей главе мы видели функцию, которая эмулировала встроенную функцию map для единственного аргумента в форме последовательности (или другого итерируемого объекта). Она требовала гораздо большей работы, чтобы разрешить передачу множества последовательностей, как делает встроенная функция:

# Аналог map(func, seqs...) на основе zip
def mymap(func, *seqs):
    res = []
    for args in zip(*seqs):
        res.append(func(*args))
    return res
print(mymap(abs, [-2, -1, 0, 1, 2]))
print(mymap(pow, [1, 2, 3], [2, 3, 4, 5]))

Версия mymap в значительной степени опирается на специальный синтаксис передачи аргументов *аргументы — она накапливает множество аргументов в виде последовательностей (в действительности итерируемых объектов), распаковывает их как аргументы zip для объединения и затем распаковывает результирующие пары zip как аргументы для переданной функции. То есть мы задействуем тот факт, что объединение в пары по существу представляет собой вложенную операцию в отображении.