---
source_image: page_216.png
page_number: 216
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 35.24
tokens: 7906
characters: 2894
timestamp: 2025-12-24T01:13:51.965176
finish_reason: stop
---

устраивает это поведение, тогда можете запросить у Python копирование объектов вместо ссылки на них. Доступны разнообразные способы копирования списка, включая применение встроенной функции list и стандартного библиотечного модуля copy. Пожалуй, наиболее распространенный способ предусматривает нарезание с начала до конца (нарезание подробно обсуждается в главах 4 и 7):

```python
>>> L1 = [2, 3, 4]
>>> L2 = L1[:]      # Создать копию L1 (или list(L1), copy.copy(L1) и т.д.)
>>> L1[0] = 24
>>> L1
[24, 3, 4]
>>> L2      # L2 не изменяется
[2, 3, 4]
```

Здесь изменение, внесенное через L1, не влияет на L2, поскольку L2 ссылается на копию, а не на оригинал объекта, на который ссылается L1; т.е. две переменные указывают на разные участки памяти.

Обратите внимание, что такой подход с нарезанием не будет работать с другими изменяемыми основными типами, словарями и множествами, потому что они не являются последовательностями. Для копирования словарей или множеств взамен нужно использовать вызов их метода X.copy() (начиная с версии Python 3.3, списки тоже его имеют) или передавать исходный объект их именам типов, dict и set. Вдобавок следует отметить, что стандартный библиотечный модуль copy имеет вызов для копирования объекта любого типа обобщенным образом и вызов для копирования структур с вложенными объектами, например, словаря с вложенными списками:

```python
import copy
X = copy.copy(Y)      # Создать "поверхностную" копию верхнего уровня
# любого объекта Y
X = copy.deepcopy(Y)  # Создать глубокую копию любого объекта Y:
# копировать все вложенные части
```

В главах 8 и 9 мы более глубоко исследуем списки и словари, а также возвратимся к концепции разделяемых ссылок и копий. Пока имейте в виду, что объекты, которые могут изменяться на месте (т.е. изменяемые объекты), всегда открыты для эффектов подобного рода в любом коде, через который они проходят. В Python к ним относятся списки, словари, множества и ряд объектов, определенных с помощью операторов class. Если это не является желаемым поведением, тогда можете просто копировать объекты по мере необходимости.

Разделяемые ссылки и равенство

Ради полного раскрытия следует отметить, что описанное ранее в главе поведение сборки мусора для определенных типов может оказаться более сложным. Взгляните на приведенные далее операторы:

```python
>>> x = 42
>>> x = 'shrubbery'   # Память, выделенная под объект 42, теперь освобождена?
```

Поскольку Python кеширует и повторно использует небольшие целые числа и строки, как упоминалось ранее, память для объекта 42 возможно не освобождается здесь буквально; взамен объект вероятно останется в системной таблице для повторного применения в следующий раз, когда в коде появится 42. Тем не менее, память большинства объектов освобождается немедленно, как только на них перестают ссылаться; что касается тех, память которых не освобождается, механизм кеширования от-