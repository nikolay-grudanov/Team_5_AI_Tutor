---
source_image: page_185.png
page_number: 185
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 38.10
tokens: 8152
characters: 2762
timestamp: 2025-12-24T01:12:49.861385
finish_reason: stop
---

ления применялась для указания величины целого числа, в памяти оно будет тем же самым:

    >>> 0o1, 0o20, 0o377   # Восьмеричные литералы: основание 8, цифры 0-7 (3.x, 2.6+)
    (1, 16, 255)
    >>> 0x01, 0x10, 0xFF   # Шестнадцатеричные литералы: основание 16,
    # цифры 0-9/A-F (3.x, 2.x)
    (1, 16, 255)
    >>> 0b1, 0b10000, 0b11111111   # Двоичные литералы: основание 2,
    # цифры 0-1 (3.x, 2.6+)
    (1, 16, 255)

Здесь восьмеричное значение 0o377, шестнадцатеричное значение 0xFF и двоичное значение 0b11111111 представляют собой десятичное число 255. Каждая цифра F в шестнадцатеричном значении, например, означает 15 в десятичной форме и четырехбитное 1111 в двоичной форме и отражает степень 16. Таким образом, шестнадцатеричное значение 0xFF и другие преобразуются в десятичные значения, как показано далее:

    >>> 0xFF, (15 * (16 ** 1)) + (15 * (16 ** 0))   # Как шестнадцатеричное/двоичное
    # число отображается на десятичное
    (255, 255)
    >>> 0x2F, (2 * (16 ** 1)) + (15 * (16 ** 0))
    (47, 47)
    >>> 0xF, 0b1111, (1*(2**3) + 1*(2**2) + 1*(2**1) + 1*(2**0))
    (15, 15, 15)

По умолчанию Python выводит целые значения в десятичной форме (по основанию 10), но предоставляет встроенные функции, которые дают возможность преобразовывать целые числа в строки цифр из других систем счисления, в форме литералов Python; они удобны, когда программы или пользователи ожидают видеть значения в заданной системе счисления:

    >>> oct(64), hex(64), bin(64)   # Числа => строки цифр
    ('0o100', '0x40', '0b1000000')

Функция oct преобразует десятичное число в восьмеричное, hex — в шестнадцатеричное и bin — в двоичное. Еще одна встроенная функция, int, преобразует строку цифр в целое число и принимает необязательный второй аргумент, позволяющий указывать основание системы счисления; она удобна для работы с числами, которые читаются из файлов в виде строк, а не записываются в сценариях:

    >>> 64, 0o100, 0x40, 0b1000000   # Цифры => числа в сценариях и строки
    (64, 64, 64, 64)
    >>> int('64'), int('100', 8), int('40', 16), int('1000000', 2)
    (64, 64, 64, 64)
    >>> int('0x40', 16), int('0b1000000', 2)   # Литеральные формы также поддерживаются
    (64, 64)

Функция eval, с которой вы столкнетесь позже в книге, трактует строки, как если бы они были кодом Python. Следовательно, она обеспечивает похожий результат, но обычно выполняется медленнее. Фактически eval компилирует и запускает строку как порцию программы, при этом предполагая, что выполняемая строка была получена из надежного источника — ловкий пользователь способен отправить строку, которая удалит файлы на компьютере, так что будьте аккуратны с таком вызовом:

    >>> eval('64'), eval('0o100'), eval('0x40'), eval('0b1000000')
    (64, 64, 64, 64)