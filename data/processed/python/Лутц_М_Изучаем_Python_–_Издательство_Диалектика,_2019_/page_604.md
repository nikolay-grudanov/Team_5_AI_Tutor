---
source_image: page_604.png
page_number: 604
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 32.17
tokens: 7832
characters: 2316
timestamp: 2025-12-24T01:26:06.938763
finish_reason: stop
---

пытаюсь воспроизвести их здесь, а оставляю в качестве упражнения мастерам дзен, бывшим программистам на Lisp и попросту безрассудным!

Пример: списковые включения и матрицы

Разумеется, не все списковые включения настолько искусственны. Давайте взглянем на еще одно приложение, чтобы поразмять свои синапсы. Как было показано в главах 4 и 8, один из основных способов записи матриц (многомерных массивов) в Python задействует вложенные списковые структуры. Например, в следующем коде определяются две матрицы \(3 \times 3\) в виде списков вложенных списков:

```python
>>> M = [[1, 2, 3],
        [4, 5, 6],
        [7, 8, 9]]
>>> N = [[2, 2, 2],
        [3, 3, 3],
        [4, 4, 4]]
```

Имея такую структуру, мы всегда можем индексировать по строкам и столбцам внутри строк с использованием нормальных операций индексации:

```python
>>> M[1]      # Строка 2
[4, 5, 6]
>>> M[1][2]   # Строка 2, элемент 3
6
```

Однако списковые включения являются мощным инструментом для обработки таких структур, потому что они автоматически просматривают строки и столбцы. Скажем, хотя такая структура хранит матрицу по строкам, для сбора значений второго столбца мы можем просто проходить по строкам и извлекать желаемый столбец или проходить по позициям в строках с индексацией в ходе дела:

```python
>>> [row[1] for row in M]           # Столбец 2
[2, 5, 8]
>>> [M[row][1] for row in (0, 1, 2)] # Использование смещений
[2, 5, 8]
```

По заданным позициям мы также можем выполнять задачи наподобие извлечения диагонали. В первом из приведенных далее выражений с применением функции range генерируется список смещений и производится индексация с одинаковыми номерами строк и столбцов, выбирающая M[0][0], затем M[1][1] и т.д. Во второй строке индекс столбца уравновешивается для извлечения M[0][2], M[1][1] и т.д. (мы предполагаем, что матрица имеет равное количество строк и столбцов):

```python
>>> [M[i][i] for i in range(len(M))]    # Диагонали
[1, 5, 9]
>>> [M[i][len(M)-1-i] for i in range(len(M))]    # Использование смещений
[3, 5, 7]
```

Изменение такой матрицы на месте требует присваивания по смещениям (если форма отличается, тогда используйте range дважды):

```python
>>> L = [[1, 2, 3], [4, 5, 6]]
>>> for i in range(len(L)):
    for j in range(len(L[i])):    # Обновление на месте
        L[i][j] += 10
```