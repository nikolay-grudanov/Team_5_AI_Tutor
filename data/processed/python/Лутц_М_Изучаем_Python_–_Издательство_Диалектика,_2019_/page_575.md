---
source_image: page_575.png
page_number: 575
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 31.88
tokens: 7687
characters: 2197
timestamp: 2025-12-24T01:25:13.111511
finish_reason: stop
---

Суммирование с помощью рекурсии

Давайте обратимся к примерам. Чтобы получить сумму списка (или другой последовательности) чисел, мы можем либо использовать встроенную функцию sum, либо написать собственную более специализированную версию. Вот как может выглядеть специальная функция суммирования, в которой применяется рекурсия:

```python
>>> def mysum(L):
    if not L:
        return 0
    else:
        return L[0] + mysum(L[1:])  # Рекурсивный вызов самой себя
>>> mysum([1, 2, 3, 4, 5])
15
```

На каждом уровне функция mysum рекурсивно вызывает саму себя, чтобы вычислить сумму остатка списка, которая позже добавляется к элементу в голове списка. Когда список становится пустым, рекурсивный цикл заканчивается и возвращается ноль. В случае использования рекурсии такого рода каждый открытый уровень вызова функции имеет собственную копию локальной области видимости функции в стеке вызовов времени выполнения — здесь это означает, что переменная L на каждом уровне разная.

Если код труден для понимания (что часто бывает у новичков), тогда попробуйте добавить в функцию вывод L и запустите ее снова, чтобы отследить текущий список на каждом уровне вызова:

```python
>>> def mysum(L):
    print(L)  # Трассировка уровней рекурсии
    if not L:  # На каждом уровне L становится короче
        return 0
    else:
        return L[0] + mysum(L[1:])
>>> mysum([1, 2, 3, 4, 5])
[1, 2, 3, 4, 5]
[2, 3, 4, 5]
[3, 4, 5]
[4, 5]
[5]
[]
15
```

Как легко заметить, суммируемый список на каждом уровне рекурсии становится все меньше, пока окончательно не опустеет — конец рекурсивного цикла. Сумма вычисляется при раскручивании рекурсивных вызовов по возврату.

Альтернативные варианты кода

Интересно, что мы можем сделать код более компактным, применив тернарное выражение if/else (описанное в главе 12). Мы также в состоянии обобщить его для любого типа, допускающего суммирование (что легче сделать, если предположить наличие во входных данных, по крайней мере, одного элемента, как делалось в примере с нахождением минимального значения из главы 18), и использовать расширенное присваивание последовательностей Python 3.x, чтобы упростить распаковку первого элемента и остальных (см. главу 11):