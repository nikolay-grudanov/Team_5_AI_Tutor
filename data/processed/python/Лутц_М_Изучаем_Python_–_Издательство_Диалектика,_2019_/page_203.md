---
source_image: page_203.png
page_number: 203
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 38.03
tokens: 7890
characters: 2981
timestamp: 2025-12-24T01:13:27.470788
finish_reason: stop
---

>>> set(dir(bytes)) - set(dir(bytearray))    # В bytes, но не в bytearray
{'__getnewargs__'}
>>> set(dir(bytearray)) - set(dir(bytes))
{'append', 'copy', '__alloc__', '__imul__', 'remove', 'pop', 'insert', ...
и так далее...}

Множества также можно использовать для выполнения проверок на равенство, нейтральное к порядку, за счет предварительного преобразования во множество, потому что порядок в нем не имеет значения. Говоря более формально, два множества равны тогда и только тогда, когда каждый элемент одного множества содержится в другом, т.е. одно является подмножеством другого независимо от порядка. Например, такой прием можно применять для сравнения выводов из программ, которые должны работать одинаково, но способны генерировать результаты, расположенные в разном порядке. Сортировка перед проверкой на равенство обеспечивает аналогичный эффект, но множества не полагаются на затратную сортировку, которая упорядочивает результаты для поддержки дополнительных проверок величин, чего не делают множества (больше, меньше и т.д.):

>>> L1, L2 = [1, 3, 5, 2, 4], [2, 5, 3, 4, 1]
>>> L1 == L2    # В последовательностях порядок имеет значение
False
>>> set(L1) == set(L2)    # Проверка на равенство, нейтральное к порядку
True
>>> sorted(L1) == sorted(L2)    # Похожая проверка, но результаты упорядочены
True
>>> 'spam' == 'asmp', set('spam') == set('asmp'), sorted('spam') == sorted('asmp')
(False, True, True)

Множества также можно использовать для отслеживания того, где вы уже были, при обходе графа или другой циклической структуры. Скажем, в примерах с транзитивной перезагрузкой модулей и выводом деревьев наследования, которые будут исследоваться в главах 25 и 31 соответственно, посещенные элементы должны отслеживаться во избежание возникновения циклов, как обсуждается в главе 19 с теоретической точки зрения. Применение в данном контексте списка неэффективно, поскольку поиск требует прямолинейного просмотра. Хотя регистрация посещенных состояний в виде ключей в словаре эффективна, множества предлагают альтернативу, которая по существу эквивалентна (и может быть более или менее понятной в зависимости от того, кого вы спрашиваете).

В заключение отметим, что множества удобны и в ситуации, когда приходится иметь дело с крупными наборами данных (например, результатами запросов к базам данных); пересечение двух множеств содержит объекты, общие в обоих множествах, а объединение — все элементы в том и другом множестве. В целях иллюстрации рассмотрим более реалистичный пример работы операций над множествами, применяемых к спискам сотрудников гипотетической компании, с использованием литералов множеств Python 3.x/2.7 и отображения результатов Python 3.x (в Python 2.6 и предшествующих версиях применяйте set):

>>> engineers = {'bob', 'sue', 'ann', 'vic'}
>>> managers = {'tom', 'sue'}
>>> 'bob' in engineers    # Является ли сотрудник bob инженером (engineer)?
True
>>> engineers & managers    # Кто одновременно инженер и менеджер (manager)?
{'sue'}