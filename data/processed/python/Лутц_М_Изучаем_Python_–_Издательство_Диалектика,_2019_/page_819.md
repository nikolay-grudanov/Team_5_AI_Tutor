---
source_image: page_819.png
page_number: 819
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 34.18
tokens: 7818
characters: 2773
timestamp: 2025-12-24T01:32:47.589469
finish_reason: stop
---

форм (например, применять ср и vi вместо сору и notepad). Прием работает в любом каталоге (я использую здесь собственный каталог code), и часть действий можно выполнять в графическом пользовательском интерфейсе проводника.

Когда все было сделано, у меня появился подкаталог mypkg, содержащий файлы __init__.py и mymod.py. До того, как в Python 3.3 было введено расширение пакетов пространств имен, требовалось наличие файла __init__.py в mypkg, но не в родительском каталоге; формально mypkg находится в компоненте домашнего каталога внутри пути поиска модулей. Обратите внимание, что оператор print, помещенный в файл __init__.py каталога, выполняется только при его импортировании в первый раз, но не во второй; кроме того, в коде применяются неформатированные строки, чтобы избежать проблем с управляющими символами внутри пути к файлу:

C:\code> mkdir mypkg
C:\code> copy mymod.py mypkg\mymod.py
C:\code> notepad mypkg\__init__.py
...поместить оператор print...
C:\code> python
>>> import mypkg.mymod
initializing mypkg
>>> mypkg.mymod.countLines(r'mypkg\mymod.py')
13
>>> from mypkg.mymod import countChars
>>> countChars(r'mypkg\mymod.py')
346

6. Перезагрузки. В этом упражнении вам просто предлагается поэкспериментировать с изменением примера changer.py из книги, так что показывать здесь нечего.

7. Циклические операции импортирования. Короткая история сводится к тому, что импортирование модуля recur2 первым работает, поскольку рекурсивная операция импортирования затем происходит в операторе import внутри recur1, а не в операторе from brecur2.

Длинная история выглядит следующим образом: импортирование модуля recur2 первым работает из-за того, что рекурсивная операция импортирования из recur1 в recur2 извлекает recur2 как единое целое вместо получения специфических имен. Модуль recur2 является незавершенным, когда он импортируется из recur1, но поскольку в нем используется оператор import, а не from, все проходит благополучно: Python находит и возвращает уже созданный объект модуля recur2 и продолжает выполнять остаток модуля recur1 без каких-либо затруднений. Когда импортирование recur2 возобновляется, второй оператор from находит имя Y в модуле recur1 (он выполнился полностью), а потому ни о каких ошибках не сообщается.

Запуск файла как сценафия — не то же самое, что его импортирование в качестве модуля; такие случаи аналогичны выполнению первого оператора import или from из сценария в интерактивном сеансе. Например, запуск recur1 как сценафия работает, поскольку это то же, что и импортирование recur2 в интерактивном сеансе, т.к. recur2 является первым модулем, импортированным в recur1. Запуск recur2 как сценафия терпит неудачу по той же причине — это то же самое, что и выполнение его первого импортирования в интерактивном сеансе.