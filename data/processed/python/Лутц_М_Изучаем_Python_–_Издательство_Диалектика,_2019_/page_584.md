---
source_image: page_584.png
page_number: 584
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 31.62
tokens: 7744
characters: 2490
timestamp: 2025-12-24T01:25:26.939066
finish_reason: stop
---

вые двойные подчеркивания (__X__); в Python 2.X соблюдается та же схема, но некоторые имена начинаются с func_X:

c:\code> py -3
>>> def f(): pass
>>> dir(f)
...запустите самостоятельно, чтобы просмотреть...
>>> len(dir(f))
35
>>> [x for x in dir(f) if not x.startswith('__')]
[]
c:\code> py -2
>>> def f(): pass
>>> dir(f)
...запустите самостоятельно, чтобы просмотреть...
>>> len(dir(f))
31
>>> [x for x in dir(f) if not x.startswith('__')]
['func_closure', 'func_code', 'func_defaults', 'func_dict', 'func_doc', 'func_globals', 'func_name']

Если вы старайтесь не именовать атрибуты одинаково, тогда можете благополучно использовать пространство имен функции, как если бы оно было собственным пространством имен или областью видимости.

В главе было показано, что такие атрибуты могут применяться для присоединения информации о состоянии непосредственно к объектам функций вместо использования других методик, подобных глобальным переменным, нелокальным переменным и классам. В отличие от нелокальных переменных атрибуты доступны везде, где доступна сама функция, даже извне ее кода.

В определенном смысле это также способ эмуляции "статических локальных переменных" в других языках — переменных, имена которых локальны для функции, но значения предохраняются после окончания работы функции. Атрибуты относятся к объектам, а не к областям видимости (и на них нужно ссылаться через имя функции внутри ее кода), но совокупный эффект похож.

Более того, как было показано в главе 17, когда атрибуты присоединяются к функциям, генерируемым другими фабричными функциями, они также поддерживают сохранение состояния с возможностью записи и множеством копий для каждого вызова во многом подобно нелокальным замыканиям и атрибутам экземпляров классов.

Аннотации функций в Python 3.X

В Python 3.X (но не в Python 2.X) также допускается присоединять к объекту функции аннотирующую информацию — произвольные определяемые пользователем данные об аргументах и результате функции. Для указания аннотаций Python предлагает специальный синтаксис, но он ничего не делает с самими аннотациями; они совершенно необязательны и когда присутствуют, то просто присоединяются к атрибуту __annotations__ объекта функции для применения другими инструментами. Например, такие инструменты могут использовать аннотации в контексте проверки на предмет ошибок.

В предыдущей главе мы узнали об аргументах с передачей только по ключевым словам в Python 3.X; аннотации дополнительно обобщают синтаксис заголовков фун-