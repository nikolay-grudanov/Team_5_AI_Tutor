---
source_image: page_521.png
page_number: 521
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 32.05
tokens: 7821
characters: 2880
timestamp: 2025-12-24T01:23:37.889160
finish_reason: stop
---

def f2():
    print(X)  # Ссылка во вложенном def
f2()
f1()        # Выводит 88: локальное имя объемлющего def

Первым делом это законный код Python: def представляет собой просто исполняемый оператор, который может появляться везде, где допускается любой другой оператор — в том числе быть вложенным в другой def. Здесь вложенный оператор def запускается, пока выполняется функция f1; он создает объект функции и присваивает его имени f2, т.е. локальной переменной внутри локальной области видимости f1. В определенном смысле f2 представляет собой временную функцию, которая существует только в период выполнения (и видима только в коде) объемлющей функции f1.

Но взгляните, что происходит внутри функции f2: когда она выводит переменную X, то ссылается на X, которая существует в локальной области видимости объемлющей функции f1. Поскольку функции могут получать доступ к именам во всех физически объемлющих операторах def, согласно правилу поиска LEGB имя X в f2 автоматически отображается на имя X в f1.

Поиск в объемлющей области видимости работает, даже если уже произошел возврат из объемлющей функции. Скажем, в следующем коде определена функция, которая создает и возвращает объект другой функции, представляя более распространенный шаблон использования:

def f1():
    X = 88
    def f2():
        print(X)  # Помнит значение X из области видимости объемлющего def
        return f2  # Возвращает объект функции f2, но не вызывает функцию
    action = f1()
    action()   # Создает и возвращает объект функции
                # Вызов функции: выводит 88

Вызов action на самом деле выполняет функцию по имени f2, которая была создана во время выполнения f1. Прием работает, потому что подобно всему остальному функции в Python являются объектами и могут передаваться как возвращаемые значения из других функций. Что еще более важно, f2 помнит значение X из объемлющей области видимости функции f1, хотя f1 больше не активна — это подводит нас к следующей теме.

Фабричные функции: замыкания

В зависимости от того, у кого вы спросите, поведение такого вида называют замыканием или фабричной функцией — первый термин описывает методику функционального программирования, а второй обозначает паттерн проектирования. Как бы он ни назывался, указанный объект функции помнит значения из объемлющих областей видимости, невзирая на то, присутствуют ли еще эти области видимости в памяти. Фактически он имеет присоединенные пакеты данных из памяти (известные как сохранение состояния), которые локальны для каждой созданной копии вложенной функции и часто выступают в качестве простой альтернативы классам в такой роли.

Простая фабричная функция

Фабричные функции (они же замыкания) иногда применяются в программах, которым необходимо генерировать обработчики событий на лету в ответ на условия, сложившиеся во время выполнения. Например, представим себе графический пользо-