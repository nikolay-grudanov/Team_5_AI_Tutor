---
source_image: page_461.png
page_number: 461
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 23.21
tokens: 7604
characters: 1696
timestamp: 2025-12-24T01:21:37.158808
finish_reason: stop
---

Ниже представлен сценарий для встроенной функции map, которую мы встречали в предыдущей главе. Как и с другими итерируемыми объектами, при необходимости с помощью list(...) можно принудительно получить список, но стандартное поведение позволяет сэкономить значительный объем памяти в случае крупных результирующих наборов:

```python
>>> M = map(abs, (-1, 0, 1)) # map возвращает итерируемый объект, а не список
>>> M
<map object at 0x0000000029B75C0>
>>> next(M)      # Использование итератора вручную: результаты израсходуются
1
# len() или индексация не поддерживается
>>> next(M)
0
>>> next(M)
1
>>> next(M)
StopIteration
>>> for x in M: print(x)    # Итератор map теперь пуст: только один проход
...
>>> M = map(abs, (-1, 0, 1)) # Создать новый итерируемый объект/итератор для повторного просмотра
>>> for x in M: print(x) # Итерационные контексты автоматически вызывают next()
...
1
0
1
>>> list(map(abs, (-1, 0, 1))) # При необходимости можно принудительно преобразовать в список
[1, 0, 1]

Встроенная функция zip, представленная в предыдущей главе, сама по себе является итерационным контекстом, но также возвращает итерируемый объект с итератором, который работает таким же образом:

>>> Z = zip((1, 2, 3), (10, 20, 30)) # zip тоже итератор с одним проходом
>>> Z
<zip object at 0x000000002951108>
>>> list(Z)
[(1, 10), (2, 20), (3, 30)]
>>> for pair in Z: print(pair) # После одного прохода результаты израсходованы
...
>>> Z = zip((1, 2, 3), (10, 20, 30))
>>> for pair in Z: print(pair) # Итератор используется автоматически или вручную
...
(1, 10)
(2, 20)
(3, 30)
>>> Z = zip((1, 2, 3), (10, 20, 30)) # Ручная итерация (iter() не требуется)
>>> next(Z)
(1, 10)
>>> next(Z)
(2, 20)
```