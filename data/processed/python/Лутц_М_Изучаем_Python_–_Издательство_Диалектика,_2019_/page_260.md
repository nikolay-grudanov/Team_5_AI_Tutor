---
source_image: page_260.png
page_number: 260
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 28.46
tokens: 7801
characters: 2252
timestamp: 2025-12-24T01:15:12.606864
finish_reason: stop
---

стыми решениями вручную, которые можно импортировать и применять в версиях, предшествующих Python 3.1 и 2.7. В программировании это довольно характерная ситуация — проще самостоятельно реализовать новую функциональность в вызываемой, многократно используемой и настраиваемой функции, а не полагаться на фиксированный набор встроенных инструментов:

```python
>>> from formats import commas, money
>>> '%s' % commas(999999999999)
'999,999,999,999'
>>> '%s %s' % (commas(9999999), commas(8888888))
'9,999,999 8,888,888'
>>> '%s' % money(296999.2567)
'$296,999.26'
```

Как обычно, простая функция вроде commas может применяться и в более сложных контекстах, таких как инструменты итерации, которые мы встречали в главе 4 и полностью изучим в последующих главах:

```python
>>> [commas(x) for x in (9999999, 8888888)]
['9,999,999', '8,888,888']
>>> '%s %s' % tuple(commas(x) for x in (9999999, 8888888))
'9,999,999 8,888,888'
>>> ''.join(commas(x) for x in (9999999, 8888888))
'9,999,9998,888,888'
```

Хорошо это или плохо, но разработчики на Python зачастую предпочитают добавлять встроенные инструменты для специальных случаев, а не использовать обобщенные методики разработки — компромисс, который мы исследуем в следующем разделе.

Для чего используется метод format?

Теперь, когда пройден такой путь, для сравнения и противопоставления двух методик форматирования я хочу также объяснить, почему временами у вас может возникать желание применять метод format. Короче говоря, невзирая на то, что метод форматирования иногда требует больше кода, он также:

• располагает несколькими дополнительными возможностями, отсутствующими в самом выражении % (хотя выражение % может использовать альтернативы);
• обладает более гибким синтаксисом ссылки на значения (хотя он может оказаться излишним, а выражение % часто имеет эквиваленты);
• может делать ссылки на значения для подстановки более явными (хотя теперь это необязательно);
• обменивает операцию на более значащее имя метода (хотя это и более многословно);
• не допускает разного синтаксиса для одиночных и множественных значений (хотя практика наводит на мысль, что это тривиально);
• как функция может применяться в местах, где выражение не может (хотя односторочная функция разрешает этот спор).