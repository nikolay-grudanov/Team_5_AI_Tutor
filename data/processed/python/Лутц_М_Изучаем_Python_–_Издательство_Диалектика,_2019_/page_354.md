---
source_image: page_354.png
page_number: 354
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 31.02
tokens: 7858
characters: 2816
timestamp: 2025-12-24T01:18:25.898031
finish_reason: stop
---

Другое специальное правило для операторов по существу является противоположностью: вы можете разнести одиночный оператор на множество строк. Для этого понадобится лишь поместить часть оператора внутрь пары скобок — круглых ( () ), квадратных ( [ ] ) или фигурных ( { } ). Любой код, заключенные в такие скобки, может занимать несколько строк: оператор не закончится до тех пор, пока Python не достигнет закрывающей скобки из пары. Например, вот как записать списковый литерал в нескольких строках:

mylist = [1111,
          2222,
          3333]

Поскольку код заключен в пару квадратных скобок, Python просто переходит на следующую строку до тех пор, пока не встретит закрывающую квадратную скобку. Фигурные скобки, окружающие словари (а также литералы множеств и включения словарей и множеств в Python 3.x/2.7), позволяют им распространяться на несколько строк, а круглые скобки делают это для кортежей, вызовов функций и выражений. Отступы в строках продолжения роли не играют, хотя здравый смысл подсказывает, что строки должны каким-то образом выравниваться ради читабельности.

Круглые скобки представляют собой универсальное средство — из-за того, что в них можно помещать любое выражение, вставка открывающей круглой скобки дает возможность продолжить оператор в следующей строке:

X = (A + B +
     C + D)

Кстати, такая методика работает также и с составными операторами. Везде, где нужно записать крупное выражение, просто поместите его в круглые скобки, чтобы перенести на следующую строку:

if (A == 1 and
    B == 2 and
    C == 3):
    print('spam' * 3)

Более старое правило позволяет продолжать оператор в следующей строке, если предыдущая строка заканчивается на обратную косую черту:

X = A + B + \
    C + D   # Подверженная ошибкам более старая альтернатива

Однако такая альтернативная методика вышла из употребления и в наши дни не одобряется, потому что замечать и сохранять обратные косые черты нелегко. Она также довольно хрупкая и подвержена ошибкам. Дело в том, что после обратной косой черты не должно быть пробелов, а случайный пропуск обратной косой черты может приводить к неожиданным эффектам, если следующая строка будет ошибочно воспринята как новый оператор. (В показанном выше примере C + D — сам по себе допустимый оператор, если он не имеет отступа.) Такое правило также является еще одним отголоском языка С, где оно обычно используется в макросах #define; если вы находитесь в мире Python, то и поступайте, как принято в Python, а не в С.

Специальные правила для блоков

Как упоминалось ранее, операторы во вложенном блоке кода обычно ассоциируются по их отступам на одно и то же расстояние вправо. В качестве одного специального случая здесь тело составного оператора может взамен находиться в той же самой строке, что и строка заголовка оператора Python, после двоеточия: