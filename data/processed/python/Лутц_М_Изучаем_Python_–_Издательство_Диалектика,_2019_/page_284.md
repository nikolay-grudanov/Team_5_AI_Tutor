---
source_image: page_284.png
page_number: 284
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 27.42
tokens: 7766
characters: 2465
timestamp: 2025-12-24T01:16:00.904484
finish_reason: stop
---

>>> D
{'eggs': 3, 'spam': 2, 'ham': ['grill', 'bake', 'fry']}
>>> del D['eggs']        # Удаление элемента
>>> D
{'spam': 2, 'ham': ['grill', 'bake', 'fry']}
>>> D['brunch'] = 'Bacon'    # Добавление нового элемента
>>> D
{'brunch': 'Bacon', 'spam': 2, 'ham': ['grill', 'bake', 'fry']}

Как и в списках, присваивание по существующему индексу в словаре изменяет ассоциированное с индексом значение. Однако в отличие от списков всякий раз, когда выполняется присваивание по новому ключу словаря (по которому присваивание еще не производилось), в словаре создается новый элемент, что в предыдущем примере происходило для ключа 'brunch'. Для списков это не работает, т.к. разрешено присваивать только по существующим смещениям в списках — Python считает смещение, выходящее за конец списка, запрещенным и генерирует ошибку. Для расширения списка понадобится использовать инструменты вроде метода append или присваивания по срезу.

Дополнительные словарные методы

Словарные методы предлагают разнообразные инструменты, специфичные для типа. Например, словарные методы values и items возвращают соответственно значения словаря и кортежи с парами (ключ, значение); вместе с методом keys их удобно применять в циклах, которые нужны для прохода по элементам по очереди (примеры таких циклов начнут приводиться в следующем разделе). Как и keys, в Python 3.x указанные два метода возвращают итерируемые объекты, поэтому они помещены в вызов list для сбора всех значений с целью отображения:

>>> D = {'spam': 2, 'ham': 1, 'eggs': 3}
>>> list(D.values())
[3, 2, 1]
>>> list(D.items())
[('eggs', 3), ('spam', 2), ('ham', 1)]

В реальных программах, которые накапливают данные в ходе своего выполнения, часто невозможно предугадать, что будет находиться в словаре, до запуска программы и тем более при написании кода. Извлечение по несуществующему ключу обычно является ошибкой, но метод get возвращает стандартное значение — None или переданное ему значение, если ключ не существует. Таким способом легко предоставить стандартное значение для ключа, который не существует, и избежать ошибки, связанной с отсутствующим ключом, когда предугадать заранее содержимое в программе невозможно:

>>> D.get('spam')        # Ключ присутствует
2
>>> print(D.get('toast'))    # Ключ отсутствует
None
>>> D.get('toast', 88)
88

Метод update предлагает своего рода конкатенацию для словарей, хотя он ничего не делает в плане упорядочения слева направо (в словарях такое понятие отсутствует).