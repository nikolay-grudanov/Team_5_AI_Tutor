---
source_image: page_149.png
page_number: 149
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 34.86
tokens: 7941
characters: 3172
timestamp: 2025-12-24T01:11:37.278212
finish_reason: stop
---

>>> rec['jobs']
['dev', 'mgr']
>>> rec['jobs'][-1]
'mgr'
>>> rec['jobs'].append('janitor') # Расширение списка названий
# должностей на месте
>>> rec
{'age': 40.5, 'jobs': ['dev', 'mgr', 'janitor'], 'name': {'last': 'Smith', 'first': 'Bob'}}

Обратите внимание на то, как последняя операция расширяет вложенный список названий должностей — поскольку список находится в области памяти, отдельной от словаря, который его содержит, он может свободно увеличиваться и уменьшаться (схема размещения объектов в памяти будет подробно обсуждаться позже в книге).

Настоящая причина, по которой показан этот пример, связана с демонстрацией гибкости основных типов данных Python. Вы можете заметить, что вложение позволяет строить сложные информационные структуры непосредственно и легко. Построение похожей структуры на низкоуровневом языке вроде C было бы утомительным и требовало бы гораздо большего объема кода: пришлось бы планировать и объявлять структуры и массивы, заполнять их значениями, увязывать все вместе и т.д. В Python все происходит автоматически — выполнение выражения создает целую структуру вложенных объектов. На самом деле это одно из главных преимуществ языков написания сценариев, подобных Python.

Не менее важно и то, что в случае языка более низкого уровня мы должны обеспечить очистку области памяти, занимаемой всеми объектами, когда они больше не нужны. В случае Python, когда утрачивается последняя ссылка на объект (скажем, за счет присваивания его переменной чего-нибудь другого), то вся область памяти, занимаемая структурой этого объекта, очищается автоматически:

>>> rec = 0 # Теперь область памяти, занимаемая объектом, восстановлена

Говоря формально, в Python имеется средство, называемое сборкой мусора, которое очищает неиспользуемую память во время выполнения программы и освобождает вас от обязанности заниматься такими деталями в своем коде. В стандартном Python (CPython) область памяти восстанавливается немедленно после того, как удаляется последняя ссылка на объект. Мы исследуем работу сборки мусора в главе 6, а пока достаточно знать, что объекты можно свободно использовать, не беспокоясь о выделении им области памяти или ее очистке, когда необходимость в них исчезает.

Также наблюдайте за структурой записи, подобной той, что реализуется в главах 8, 9 и 27, которая будет применяться для сравнения и противопоставления списков, словарей, кортежей, именованных кортежей и классов — массив вариантов структур данных с компромиссами, полностью раскрываемый позже4.

4 Два замечания касательно применимости. Во-первых, только что созданная запись rec действительно может быть реальной записью базы данных, когда мы эксплуатируем систему постоянства объектов Python (легкий способ хранения собственных объектов Python в простых файлах или базах данных с доступом по ключу), которая автоматически транслирует объекты в и из байтовых потоков. Здесь мы не будем погружаться в детали, но дождитесь рассмотрения модулей Python для постоянства pickle и shelve в главах 9, 28, 31 и 37, где они исследуются в контексте файлов, сценария использования в объектно-ориентированном программировании, классов и изменений Python 3.x соответственно.