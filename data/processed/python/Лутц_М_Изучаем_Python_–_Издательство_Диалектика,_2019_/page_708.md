---
source_image: page_708.png
page_number: 708
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 31.93
tokens: 7768
characters: 2656
timestamp: 2025-12-24T01:29:21.807718
finish_reason: stop
---

Межфайловое изменение имен

Вспомните из предыдущего примера, что присваивание x в интерактивном сеансе изменяет только имя x в этой области видимости, но не x в файле — не существует какой-либо связи между именем, скопированным с помощью from, и файлом, откуда оно поступило. Чтобы действительно изменить глобальное имя в другом файле, потребуется использовать оператор import:

% python
>>> from small import x, y    # Скопировать два имени
>>> x = 42                     # Изменяет только локальное имя x
>>> import small               # Получить имя модуля
>>> small.x = 42               # Изменяет x в другом модуле

Явление было впервые представлено в главе 17. Поскольку такого рода изменение переменных в других модулях является распространенным источником путаницы (и часто неудачным проектным решением), мы снова вернемся к данной методике позже в этой части книги. Важно понимать, что изменение y[0] в предыдущем сеансе отличается; оно изменяет объект, не имя, а имя в обоих модулях ссылается на один и тот же измененный объект.

Эквивалентность import и from

В предыдущем примере обратите внимание на то, что для доступа к имени модуля small вообще мы обязаны выполнить оператор import после from. Оператор from только копирует имена из одного модуля в другой; он не присваивает само имя модуля. По крайней мере, концептуально оператор from следующего вида:

from module import name1, name2    # Копировать указанные два имени (только)

эквивалентен такой последовательности операторов:

import module
name1 = module.name1                # Извлечь объект модуля
name2 = module.name2
del module                           # Избавиться от имени модуля

Подобно всем присваиваниям оператор from создает в импортере новые переменные, которые изначально ссылаются на объекты с теми же самыми именами в импортируемом файле. Однако копируются только имена, но не объекты, на которые они ссылаются, и не имя самого модуля. Когда мы применяем форму from * данного оператора (from module import *), то эквивалентная последовательность остается такой же, но в область видимости импортера копируются все имена верхнего уровня из модуля.

Как видите, на первом шаге оператора from запускается нормальная операция import со всей семантикой, очерченной в предыдущей главе. По этой причине from всегда импортирует целый модуль в память, если он еще не был импортирован, независимо от того, сколько имен будет копироваться из файла. Возможность загрузки только части файла модуля (скажем, какой-то одной функции) отсутствует, но из-за того, что модули в Python представлены как байт-код, а не машинный код, то влияние на производительность обычно незначительно.