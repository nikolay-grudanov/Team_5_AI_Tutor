---
source_image: page_579.png
page_number: 579
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 40.10
tokens: 7956
characters: 2957
timestamp: 2025-12-24T01:25:30.246789
finish_reason: stop
---

Код последних двух примеров (и еще одного варианта) находится в файле sumtree2.py в пакете примеров для книги. В него добавлено отслеживание элементов списка, чтобы можно было наблюдать за его ростом в обеих схемах, и вывод чисел по мере их посещения, что позволяет видеть порядок поиска. Например, варианты с обходом сначала в ширину и сначала в глубину посещают элементы в тех же трех тестовых списках, которые использовались в рекурсивной версии, в следующих порядках (суммы отображаются последними):

c:\code> sumtree2.py
1, 6, 2, 5, 7, 8, 3, 4, 36
1, 2, 3, 4, 5, 15
5, 4, 3, 2, 1, 15

-----------------------------
1, 2, 3, 4, 5, 6, 7, 8, 36
1, 2, 3, 4, 5, 15
1, 2, 3, 4, 5, 15

-----------------------------

Но в целом, как только вы освоитесь с рекурсивными вызовами, они станут более естественными, чем списки с явным планированием, которые они автоматизируют, и обычно более предпочтительными, если только вам не нужно обходить структуру специализированными способами. Скажем, определенные программы выполняют поиск по первому наилучшему совпадению, при котором требуется явное дерево поиска, упорядоченное по значимости или по другим критериям. Если вы подумаете о поисковом агенте, который оценивает посещенные веб-страницы по их содержимому, то приложения могут стать гораздо яснее.

Циклы, пути и границы стека

В том виде, как есть, представленных выше программ вполне достаточно в качестве примеров, но крупные рекурсивные приложения временами могут требовать чуть большей инфраструктуры, чем показанная здесь: возможно, понадобится избегать циклов или повторений, записывать пройденные пути для последующего применения и расширять пространство стека, когда используются рекурсивные вызовы вместо явных очередей либо стеков.

Скажем, в рассмотренных примерах с рекурсивными вызовами и явными очередями/стеками ничего не делалось для того, чтобы избежать циклов — посещения мест, которые уже были посещены. Здесь это не обязательно, т.к. мы обходили строго иерархические деревья списковых объектов. Тем не менее, если данные могут принимать вид циклического графа, тогда обе схемы потерпят неудачу: версия с рекурсивными вызовами попадет в бесконечный рекурсивный цикл (и привести к исчерпанию пространства в стеке вызовов), а в остальных версиях образуются простые бесконечные циклы, многократно добавляющие те же самые элементы в свои списки (что вполне может вызвать нехватку общей памяти). В некоторых программах необходимо также избегать повторяющейся обработки состояния, достигнутого более одного раза, даже если это не приводит к зациклыванию.

Чтобы добиться успеха, версия с рекурсивными вызовами могла бы просто поддерживать множество, словарь или список состояний, посещенных до сих пор, и в ходе работы проверять его на предмет повторений. Мы будем применять такую схему в примерах с рекурсией позже в книге:

if state not in visited:
    visited.add(state)   # x.add(state), x[state]=True или x.append(state)
    ...обработка...