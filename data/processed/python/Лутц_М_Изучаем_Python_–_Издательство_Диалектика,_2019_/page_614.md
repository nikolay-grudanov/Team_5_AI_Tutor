---
source_image: page_614.png
page_number: 614
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 30.39
tokens: 7786
characters: 2754
timestamp: 2025-12-24T01:26:24.021386
finish_reason: stop
---

Формально yield теперь имеет форму не оператора, а выражения, которое возвращает элемент, переданный send (хотя yield можно вызывать любым из двух способов — yield X или A = (yield X)). Выражение должно заключаться в круглые скобки, если только оно не является единственным элементом в правой части оператора присваивания, например, X = yield Y и X = (yield Y) + 42.

Когда используется такой расширенный протокол, значения отправляются генератору G путем вызова G.send(значение). Затем код генератора возобновляет выполнение, и выражение yield в генераторе возвращает значение, переданное send. Если вызывается обычный метод G.__next__() (или его эквивалент next(G)) для продвижения вперед, тогда yield просто возвращает None. Вот пример:

```python
>>> def gen():
...     for i in range(10):
...         X = yield i
...         print(X)
...
>>> G = gen()
>>> next(G)      # Сначала должен вызываться next(), чтобы запустить генератор
0
>>> G.send(77)   # Продвигается вперед и отправляет значение выражению yield
77
1
>>> G.send(88)
88
2
>>> next(G)      # next() и X.__next__() отправляют None
None
3
```

Метод send можно применять, например, для написания генератора, который разрешает прекращать свою работу за счет отправки кода завершения либо изменять направление путем передачи новой позиции в данных, обрабатываемых внутри генератора.

Вдобавок генераторы в Python 2.5 и последующих версиях также поддерживают метод throw(тип), предназначенный для инициирования исключения внутри генератора в самом последнем yield, и метод close, который инициирует специальное исключение GeneratorExit внутри генератора, чтобы полностью прекратить итерацию. Указанные методы представляют собой расширенные средства, которые здесь подробно не рассматриваются; за дополнительными сведениями обращайтесь к справочникам и стандартным руководствам по Python, а сами исключения детально обсуждаются в части VII.

Обратите внимание, что в то время, как Python 3.x предлагает удобную встроенную функцию next(X), которая вызывает метод X.__next__() объекта, другие методы генераторов наподобие send должны вызываться напрямую как методы объектов генераторов (скажем, G.send(X)). Смысл станет понятным, если вы осознаете, что эти добавочные методы реализованы только во встроенных объектах генераторов, тогда как метод __next__ применяется ко всем итерируемым объектам — встроенных типов или определяемых пользователем классов.

Также следует отметить, что в Python 3.3 было введено расширение yield — конструкция from, которая позволяет генераторам делегировать работу вложенным генераторам. Поскольку это расширение темы, которая сама по себе довольно сложная, мы вынесем ее в отдельную врезку и займемся инструментом, достаточно близким, чтобы называться двойником.