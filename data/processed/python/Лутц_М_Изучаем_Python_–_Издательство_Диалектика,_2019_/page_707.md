---
source_image: page_707.png
page_number: 707
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 32.95
tokens: 7820
characters: 2638
timestamp: 2025-12-24T01:29:22.563148
finish_reason: stop
---

Операторы import и from являются присваиваниями

Подобно def операторы import и from являются исполняемыми, а не объявлениями на стадии компиляции. Они могут вкладываться внутрь проверок if для выбора среди нескольких вариантов; находиться внутри операторов def функций, чтобы загружать только по вызову (см. предыдущую врезку "На заметку!"); использоваться в операторах try для обеспечения стандартных значений и т.д. Они не распознаются и не запускаются до тех пор, пока Python не встретит их во время выполнения программы. Другими словами, импортируемые модули и имена не будут доступны, пока не выполняются связанные с ними операторы import или from.

Модификация изменяемых объектов в модулях

Кроме того, как и def, операторы import и from являются явными присваиваниями:

• оператор import присваивает одиночному имени объект целого модуля;
• оператор from присваивает одному или нескольким именам объекты с такими же именами из другого модуля.

Все, что уже обсуждалось относительно присваивания, применимо также к доступу к модулям. Скажем, имена, копируемые с помощью from, становятся ссылками на разделяемые объекты. Как и с присваиванием функций, повторное присваивание скопированному имени не оказывает влияния на модуль, из которого было скопировано имя, но модификация разделяемого изменяемого объекта через скопированное имя может также изменить его в модуле, откуда оно копировалось. В целях иллюстрации рассмотрим следующий файл small.py:

x = 1
y = [1, 2]

При импортировании посредством from мы копируем имена в область видимости импортера, что изначально разделяет объекты, на которые ссылались имена модуля:

% python
>>> from small import x, y # Копировать два имени
>>> x = 42 # Изменяет только локальное имя x
>>> y[0] = 42 # Модифицирует изменяемый объект на месте

В данном примере x не является разделяемым изменяемым объектом, но y является. Имена y в импортируемом и импортирующем модулях ссылаются на тот же самый списоковый объект, а потому его модификация в одном месте приводит к изменению в другом:

>>> import small # Получить имя модуля (from этого не позволяет)
>>> small.x # x из small - не то же, что x здесь
1
>>> small.y # Но мы разделяем модифицированный изменяемый объект
[42, 2]

Дополнительные сведения были даны в главе 6. Графическое представление того, что присваивания делают со ссылками, было предложено на рис. 18.1 (передача аргументов функции); мысленно поменяйте "вызывающий код" и "функция" на "импортируемый модуль" и "импортер". Результат будет таким же за исключением того, что мы имеем дело с именами в модулях, а не в функциях. Присваивания работают одинаково повсюду в Python.