---
source_image: page_659.png
page_number: 659
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 32.03
tokens: 7837
characters: 2752
timestamp: 2025-12-24T01:27:48.313096
finish_reason: stop
---

def total(func, *pargs, _reps=1000, **kargs):
    start = timer()
    for i in range(_reps):
        ret = func(*pargs, **kargs)
        elapsed = timer() - start
        return (elapsed, ret)

def bestof(func, *pargs, _reps=5, **kargs):
    best = 2 ** 32
    for i in range(_reps):
        start = timer()
        ret = func(*pargs, **kargs)
        elapsed = timer() - start
        if elapsed < best: best = elapsed
    return (best, ret)

def bestoftotal(func, *pargs, _reps1=5, **kargs):
    return min(total(func, *pargs, **kargs) for i in range(_reps1))

Версия timer3.py применяется таким же способом, как предыдущая, и производит идентичные результаты, поэтому здесь не имеет смысла повторять вывод тех же самых тестов; при желании поэкспериментируйте с модулем timer3.py самостоятельно. Уделайте внимание правилам упорядочения аргументов в вызовах. Например, вот как вызывать функцию bestof, которая запускает total:

(elapsed, ret) = total(func, *pargs, _reps=1, **kargs)

Аргументы с передачей только по ключевым словам в Python 3.x обсуждались в главе 18; они способны упростить код конфигурируемых инструментов, подобных функциям из модуля timer3.py, но не имеют обратной совместимости с Python 2.x. Если вы хотите сравнивать скорости в Python 2.x и Python 3.x или обеспечить для программистов возможность использования любой из двух линеек Python, тогда предыдущая версия модуля (timer2) вероятно будет наилучшим выбором.

Также имейте в виду, что для тривиальных функций вроде некоторых из тестируемых с помощью предыдущей версии модуля, затраты кода измерения времени иногда могут быть настолько же существенными, как затраты простых хронометрируемых функций, поэтому вы не должны воспринимать результаты хронометража чересчур буквально. Однако результаты хронометража могут помочь в оценке относительных скоростей выполнения кодовых альтернатив и быть более значащими для операций, которые выполняются дольше или повторяются чаще.

Другие варианты

Чтобы получить больше информации, попробуйте модифицировать счетчики повторений, применяемые этими модулями, либо исследуйте альтернативный модуль timeit из стандартной библиотеки Python, который автоматизирует хронометраж кода, поддерживает режим использования в командной строке и обходит специфичные к платформам проблемы — на самом деле мы задействуем его в следующем разделе.

У вас также может возникнуть желание взглянуть на стандартный библиотечный модуль profile, представляющий собой законченный инструмент для профилирования исходного кода. Мы будем его исследовать в главе 36 в контексте инструментов разработки для крупных проектов. В целом вы должны профилировать код с целью изоляции узких мест еще до переписывания и хронометража кодовых альтернатив, как делось здесь.