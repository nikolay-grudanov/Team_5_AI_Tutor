---
source_image: page_183.png
page_number: 183
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 36.22
tokens: 8085
characters: 2867
timestamp: 2025-12-24T01:12:44.916205
finish_reason: stop
---

>>> (5 // 2), (5 // 2.0), (5 // -2.0), (5 // -2) # Деление с округлением
# в меньшую сторону в Python 3.x
(2, 2.0, -3.0, -3)
>>> (9 / 3), (9.0 / 3), (9 // 3), (9 // 3.0) # Одинаково в Python 3.x и 2.x
(3.0, 3.0, 3, 3.0)

Для пользователей Python 2.x деление работает следующим образом (три выделенных полужирным результата в выводе отличаются от Python 3.x):

>>> (5 / 2), (5 / 2.0), (5 / -2.0), (5 / -2) # Классическое деление
# в Python 2.x (отличается)
(2, 2.5, -2.5, -3)
>>> (5 // 2), (5 // 2.0), (5 // -2.0), (5 // -2) # Деление с округлением
# в меньшую сторону в Python 2.x (такое же)
(2, 2.0, -3.0, -3)
>>> (9 / 3), (9.0 / 3), (9 // 3), (9 // 3.0) # Одинаково в Python 2.x и 3.x
(3, 3.0, 3, 3.0)

Вполне возможно, что поведение операции / из Python 3.x, не предусматривающее усечения, способно нарушить работу значительного количества программ Python 2.x. Вероятно, из-за наследия языка С многие программисты полагаются на усечение при делении для целых чисел, поэтому им придется научиться применять в таких контекстах операцию //. На сегодняшний день вы должны поступать так при написании всего нового кода Python 2.x и Python 3.x — в первом случае для обеспечения совместимости с Python 3.x, а во втором случае из-за того, что операция / не производит усечение в Python 3.x. Дождитесь примера с циклом while, определяющим простые числа, в главе 13 и соответствующего упражнения в конце части IV, которые иллюстрируют разновидность кода, подверженного влиянию изменений в поведении /. Кроме того, в главе 25 будет дополнительно обсуждаться команда from, используемая в настоящем разделе.

Точность целых чисел

Деление может слегка отличаться между выпусками Python, но все равно оно довольно-таки стандартно. Есть кое-что чуть более экзотическое. Как упоминалось ранее, целые числа Python 3.x поддерживают неограниченный размер:

>>> 99999999999999999999999999999999 + 1 # Python 3.x
100000000000000000000000000000000

В Python 2.x для длинных целых имеется отдельный тип, но в него производится автоматическое преобразование любого числа, которое слишком велико, чтобы храниться как нормальное целое. Следовательно, для применения длинных целых не требуется какой-то специальный синтаксис и единственный способ, которым можно указать, что используются длинные целые Python 2.x, предусматривает их написание с хвостовой буквой L:

>>> 99999999999999999999999999999999 + 1 # Python 2.x
100000000000000000000000000000000L

Целые числа с неограниченной точностью — удобный встроенный инструмент. Например, вы можете применять их для подсчета государственного долга США в центах прямо в Python (если вам интересно и компьютер располагает достаточным объемом памяти). Благодаря целым числам с неограниченной точностью мы также получили возможность возводить 2 в настолько большие степени в примерах главы 3. Ниже представлены случаи для Python 3.x и Python 2.x: