---
source_image: page_516.png
page_number: 516
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 32.70
tokens: 7803
characters: 2866
timestamp: 2025-12-24T01:23:25.864679
finish_reason: stop
---

Переменные x, y и z являются глобальными в функции all_global. Переменные y и z глобальны из-за того, что они не присваиваются внутри функции; переменная x is глобальна оттого, что она была указана в операторе global с целью явного отображения на область видимости модуля. Если бы оператор global отсутствовал, тогда благодаря присваиванию переменная x считалась бы локальной.

Обратите внимание, что переменные y и z не объявлены глобальными; Python согласно правилу поиска LEGB ищет их в модуле автоматически. Кроме того, до выполнения функции all_global переменная x даже не существует во включающем модуле; в данном случае первое присваивание внутри функции создает переменную x в модуле.

Проектирование программы: минимизируйте количество глобальных переменных

Функции в целом и глобальные переменные в частности поднимают некоторые более широкие вопросы, касающиеся проектирования. Как должны взаимодействовать наши функции? Хотя ответы на часть вопросов станут более очевидными, когда вы начнете самостоятельно писать крупные функции, несколько рекомендаций сейчас могут уберечь от возможных проблем в будущем. В общем случае функции должны полагаться на аргументы и возвращаемые значения, а не на глобальные переменные, но причины требуют пояснений.

По умолчанию имена, присваиваемые в функциях, являются локальными, поэтому если вы хотите изменять имена, существующие за пределами функций, то вам придется писать дополнительный код (например, операторы global). Так было задумано — как принято в Python, чтобы сделать что-то потенциально "неправильное", необходимо написать добавочный код. Несмотря на то что встречаются ситуации, когда глобальные переменные удобны, присваиваемые внутри def переменные по умолчанию будут локальными, поскольку так предусмотрено наилучшей стратегией. Изменение глобальных переменных может привести к общеизвестным проблемам при разработке программного обеспечения: из-за того, что значения переменных зависят от порядка вызовов произвольно отдаленных функций, программы могут стать трудными для отладки и вообще для восприятия.

Возьмем в качестве примера следующий файл модуля, который импортируется и применяется где-то в другом месте:

x = 99
def func1():
    global X
    X = 88
def func2():
    global X
    X = 77

Предположим, что необходимо модифицировать или повторно использовать данный код. Каким будет значение X? По правде говоря, вопрос не имеет смысла, если только не привязать его ко времени — значение X обусловлено выбранным моментом времени, т.к. оно зависит от того, которая из функций вызывалась последней (чего мы не можем определить по приведенному одному файлу).

Совокупный эффект заключается в том, что для понимания кода вам понадобится отследить поток управления через целую программу. И если необходимо повторно применить или модифицировать код, тогда вам придется держать в уме всю программу