---
source_image: page_458.png
page_number: 458
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 28.65
tokens: 7746
characters: 2294
timestamp: 2025-12-24T01:21:40.284844
finish_reason: stop
---

>>> f(*open('script2.py'))    # Также выполняет итерацию по строкам!
import sys
&print(sys.path)
&x = 2
&print(x ** 32)

В действительности из-за того, что данный синтаксис распаковки аргументов в вызовах принимает итерируемые объекты, становится возможным также применение встроенной функции zip для развертывания сжатых кортежей, делая предшествующие или вложенные результаты zip аргументами для другого вызова zip (предостережение: вам вряд ли стоит изучать следующий пример, если вам предстоит вскоре заняться тяжеловесными механизмами!):

>>> X = (1, 2)
>>> Y = (3, 4)
>>>
>>> list(zip(X, Y))        # Сжатие кортежей: возвращает итерируемый объект
[(1, 3), (2, 4)]
>>>
>>> A, B = zip(*zip(X, Y))   # Развертывание сжатых кортежей!
>>> A
(1, 2)
>>> B
(3, 4)

Еще несколько инструментов в Python, такие как встроенная функция range и объекты словарных представлений, возвращают итерируемые объекты вместо того, чтобы обрабатывать их. В следующем разделе вы увидите, каким образом они задействуют протокол итерации в Python 3.x.

Новые итерируемые объекты в Python 3.x

Одним из фундаментальных отличий линейки Python 3.x является более сильный акцент на итераторах, чем в Python 2.x. Наряду с моделью Unicode и обязательными классами нового стиля это представляет собой одно из самых радикальных изменений Python 3.x.

В частности, вдобавок к итераторам, ассоциированным со встроенными типами вроде файлов и словарей, словарные методы keys, values и items в Python 3.x возвращают итерируемые объекты, как и встроенные функции range, map, zip и filter. В предыдущем разделе было показано, что последние три функции не только возвращают итерируемые объекты, но и обрабатывают их. Все инструменты подобного рода в Python 3.x производят результаты по запросу, а не создают списки результатов, как было в Python 2.x.

Влияние на код Python 2.x: доводы за и против

Хотя все это приводит к экономии пространства памяти, оно может повлиять на стиль написания кода в ряде контекстов. Скажем, до сих пор в разных местах книги мы должны были помещать результаты вызовов некоторых функций и методов внутрь вызова list(...), чтобы заставить их выдать все результаты сразу для отображения:

>>> zip('abc', 'xyz') # Итерируемый объект в Python 3.x (список в Python 2.x)
<zip object at 0x000000000294c308>