---
source_image: page_287.png
page_number: 287
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 31.24
tokens: 7813
characters: 2703
timestamp: 2025-12-24T01:16:09.905089
finish_reason: stop
---

ся ранее итераторов, которые позволяют операции членства in работать также со словарями; итераторы будут подробно описаны позже в книге.

Обзор: отображение значений на ключи

Обратите внимание, что предыдущая таблица отображает годы на названия, но не наоборот. Если вы хотите отображать в противоположном направлении, т.е. названия на годы, то можете либо организовать словарь по-другому, либо использовать методы вроде items, который дает последовательности с возможностью поиска, хотя их эффективное применение требует большего объема знаний, чем имеется в текущий момент:

>>> table = {'Holy Grail': '1975',      # Ключ=>Значение (название=>год)
...           'Life of Brian': '1979',
...           'The Meaning of Life': '1983'}
>>>
>>> table['Holy Grail']
'1975'
>>> list(table.items())                # Значение=>Ключ (год=>название)
[('The Meaning of Life', '1983'), ('Holy Grail', '1975'), ('Life of Brian', '1979')]
>>> [title for (title, year) in table.items() if year == '1975']
['Holy Grail']

Последняя команда отчасти является иллюстрацией синтаксиса включения, который был введен в главе 4 и полностью раскрывается в главе 14. Он просматривает пары кортежей (ключ, значение) словаря, возвращенные методом items, выбирая ключи с указанным значением. Совокупным эффектом будет индексация в обратном направлении, т.е. от значения к ключу, а не от ключа к значению. Такая индексация удобна, когда данные желательно сохранить только раз и отображать в обратном направлении лишь редко (подобного рода поиск в последовательностях обычно выполняется гораздо медленнее, чем прямая индексация по ключу).

На самом деле, хотя словари по своей природе отображают ключи на значения однонаправлено, существует множество способов отображения значений обратно на ключи посредством чуть более обобщенного кода:

>>> K = 'Holy Grail'
>>> table[K]                          # Ключ=>Значение (нормальное использование)
'1975'
>>> v = '1975'
>>> [key for (key, value) in table.items() if value == v]    # Значение=>Ключ
['Holy Grail']
>>> [key for key in table.keys() if table[key] == v]         # То же самое
['Holy Grail']

Имейте в виду, что последние две команды возвращают список названий: в словарях есть только одно значение на ключ, но может быть много ключей на значение. Заданное значение может быть сохранено под множеством ключей (выдавая много ключей на значение), и само значение может быть коллекцией (поддерживая много значений на ключ). Также дождитесь функции обращения словаря в примере mapattrs.py из главы 32 — код, который непременно растянул бы настоящий обзор до критических размеров, будь он включен здесь. Преследуя цели текущей главы, давайте продолжим исследование основ словарей.