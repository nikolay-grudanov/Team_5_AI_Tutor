---
source_image: page_503.png
page_number: 503
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 31.54
tokens: 7724
characters: 2631
timestamp: 2025-12-24T01:23:05.792151
finish_reason: stop
---

И снова, когда мы передаем объекты, которые не поддерживают такие интерфейсы (скажем, числа), Python автоматически обнаруживает несоответствие и генерирует исключение — именно то, что нам нужно, и лучшее, что мы могли бы сделать самостоятельно, если бы явно записывали проверки на предмет типов. Не записывая проверки на предмет типов и позволяя Python обнаруживать несоответствия, мы сокращаем объем кода, подлежащего написанию, и увеличиваем гибкость итогового кода.

Локальные переменные

Пожалуй, самой интересной частью рассмотренного примера являются его имена. Дело в том, что переменная res внутри intersect представляет собой так называемую локальную переменную — имя, которое видно только в коде внутри оператора def функции и существует лишь на период выполнения функции. Фактически из-за того, что все имена, тем или иным образом присваиваемые внутри функции, по умолчанию классифицируются как локальные переменные, почти все имена в функции intersect оказываются локальными переменными:

• переменной res производится очевидное присваивание, так что она локальная;
• аргументы передаются по присваиванию, поэтому seq1 и seq2 тоже локальные;
• цикл for присваивает элементы переменной, а потому имя x — также локальная переменная.

Все перечисленные локальные переменные начинают свое существование, когда функция вызывается, и исчезают при выходе из функции — оператор return в конце intersect посылает обратно результирующий объект, но имя res прекращает существовать. По этой причине переменные функции не запоминают свои значения между вызовами; хотя возвращаемый функцией объект остается, сохранение прочих видов информации о состоянии требует других методик. Однако для полного понимания локальных переменных и состояния нам необходимо перейти к исследованию областей видимости в главе 17.

Резюме

В главе были представлены ключевые идеи, лежащие в основе определения функций: синтаксис и работа операторов def и return, поведение выражений вызова функций, а также понятие и преимущества полиморфизма в функциях Python. Вы узнали, что оператор def является исполняемым кодом, который создает объект функции во время выполнения. Когда функция позже вызывается, объекты передаются ей по присваиванию (вспомните, что присваивание в Python подразумевает ссылку на объект и внутренне означает указатель, как объяснялось в главе 6), а вычисленные значения отправляются обратно оператором return. Мы также начали исследование концепций локальных переменных и областей видимости, но отложили более подробное рассмотрение данных тем до главы 17. А теперь закрепите полученные знания, ответив на контрольные вопросы главы.