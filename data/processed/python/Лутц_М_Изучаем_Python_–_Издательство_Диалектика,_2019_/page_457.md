---
source_image: page_457.png
page_number: 457
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 35.41
tokens: 7822
characters: 2460
timestamp: 2025-12-24T01:21:45.353496
finish_reason: stop
---

строят множества и словари, но мы получаем много работы "даром", комбинируя синтаксис итерации файлов и включений. Позже в книге встретится родственный включениям инструмент — генераторные выражения, которые используют тот же самый синтаксис и работают на итерируемых объектах, но вдобавок сами являются итерируемыми:

>>> list(line.upper() for line in open('script2.py'))   # См. главу 20
['IMPORT SYS\n', 'PRINT(SYS.PATH)\n', 'X = 2\n', 'PRINT(X ** 32)\n']

Другие встроенные функции также поддерживают протокол итерации, но, к сожалению, некоторые из них труднее задействовать в интересных примерах, имеющих отношение к файлам! Например, sum вычисляет сумму всех чисел в любом итерируемом объекте; any и all возвращают True, если соответственно любой или все элементы в итерируемом объекте истинны, а max и min возвращают соответственно наибольший или наименьший элемент в итерируемом объекте. Подобно reduce все инструменты в приведенных далее примерах принимают в аргументе любой итерируемый объект и применяют протокол итерации для его просмотра, но возвращают одиночный результат:

>>> sum([3, 2, 4, 1, 5, 0])   # sum ожидает только числа
15
>>> any(['spam', '', 'ni'])
True
>>> all(['spam', '', 'ni'])
False
>>> max([3, 2, 5, 1, 4])
5
>>> min([3, 2, 5, 1, 4])
1

Строго говоря, функции max и min могут также применяться к файлам — они автоматически используют протокол итерации для просмотра файла и отбора строк соответственно с наибольшим или наименьшим строковым значением (хотя я оставляю допустимые сценарии применения целиком на ваше воображение):

>>> max(open('script2.py'))   # Строка с максимальным/минимальным
# строковым значением
'x = 2\n'
>>> min(open('script2.py'))
'import sys\n'

Есть еще последний итерационный контекст, заслуживающий упоминания, пусть даже и краткого: в главе 18 будет показано, что в вызовах функций можно применять специальную форму *аргумент для распаковки коллекции значений в индивидуальные аргументы. Как вы вероятно уже можете предугадать, здесь подойдет также любой итерируемый объект, в том числе и файлы (ищите в главе 18 дополнительные сведения по такому синтаксису вызовов, в главе 20 раздел, в котором эта идея распространяется на генераторные выражения, и в главе 11 советы по использованию следующего оператора print из Python 3.X обычным образом в Python 2.X):

>>> def f(a, b, c, d): print(a, b, c, d, sep='&')
...
>>> f(1, 2, 3, 4)
1&2&3&4
>>> f(*[1, 2, 3, 4])   # Распаковывает в аргументы
1&2&3&4