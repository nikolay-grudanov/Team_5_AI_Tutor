---
source_image: page_710.png
page_number: 710
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 28.87
tokens: 7762
characters: 2667
timestamp: 2025-12-24T01:29:21.818519
finish_reason: stop
---

# N.py
def func():
    ...делать что-то другое...

и вам нужно применять в программе обе версии имени, то оператор from потерпит неудачу — в области видимости можно иметь только одно присваивание имени:

# O.py
from M import func
from N import func    # Переписывает имя func, извлеченное из M
func()                # Вызывает только N.func!

Тем не менее, оператор import здесь работает, потому что указание имени включающего модуля делает два имени уникальными:

# O.py
import M, N           # Получить модули целиком, не только их имена
M.func()               # Теперь мы можем обращаться к обоим именам
N.func()               # Указание имен модулей обеспечивает уникальность

Такой случай довольно необычен, так что вы вряд ли будете его часто встречать на практике. Однако если вы все-таки с ним столкнетесь, тогда оператор import позволит избежать конфликта имен. Другой выход из затруднительного положения предусматривает использование расширения as, которое мы рассмотрим в главе 25, но оно достаточно простое, чтобы представить его ниже:

# O.py
from M import func as mfunc    # Переименование с помощью as
from N import func as nfunc
mfunc(); nfunc()                # Вызов одного или другого

Расширение as функционирует в операторах import и from как инструмент переименования (его также можно применять для назначения короткого псевдонима длинному имени модуля в import); более подробно о такой форме речь пойдет в главе 25.

Пространства имен модулей

Модули вероятно лучше всего воспринимать как пакеты имен, т.е. места для определения имен, которые желательно сделать видимыми остальной части системы. Формально модули обычно соответствуют файлам, и Python создает объект модуля, содержащий все имена, которым выполнялось присваивание в файле модуля. Но говоря упрощенно, модули являются всего лишь пространствами имен (местами, где создаются имена), а существующие в модуле имена называются его атрибутами. В текущем разделе мы детально исследуем такую модель.

Файлы генерируют пространства имен

Ранее упоминалось, что файлы превращаются в пространства имен, но как это на самом деле происходит? Короткий ответ: каждое имя, которому присваивается значение на верхнем уровне файла модуля (т.е. не внутри тела функции или класса), становится атрибутом данного модуля.

Например, при наличии оператора присваивания X = 1 на верхнем уровне файла модуля M.py имя X становится атрибутом модуля M, на который мы можем ссылаться за пределами модуля как M.X. Имя X также становится глобальной переменной для остального кода внутри M.py, но для понимания причины нам необходимо чуть более формально рассмотреть понятие загрузки модулей и областей видимости.