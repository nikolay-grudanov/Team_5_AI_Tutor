---
source_image: page_763.png
page_number: 763
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 11.42
tokens: 7708
characters: 2558
timestamp: 2025-12-24T01:30:42.074259
finish_reason: stop
---

3.Х в главе 24. В предшествующих изданиях книги эта форма оператора использовалась для демонстрации генераторных функций, требующих ключевого слова, которое еще не было по умолчанию включено (на месте название_средства указывалось generators).

Все изменения такого рода могут нарушить работу существующего кода в Python 2.Х, поэтому они внедрялись постепенно или предлагались как необязательные расширения, включаемые с помощью описанного выше специального оператора import. В то же самое время определенные средства доступны для того, чтобы сделать возможным написание кода, обладающего прямой совместимостью с более поздними выпусками, куда вы когда-нибудь перенесете код.

Для просмотра списка будущих языковых средств, которые можно импортировать, выполните вызов dir на модуле _future_ после его импортирования или поищите соответствующие сведения в руководстве по библиотеке. Согласно его документации названия будущих средств никогда не удалятся, поэтому совершенно безопасно оставлять импортирование _future_ даже в коде, запускаемом под управлением версии Python, где такие средства присутствуют как нормальные.

Смешанные режимы использования: __name__ и __main__

Следующий трюк, связанный с модулем, позволяет вам импортировать файл как модуль и запускать его как автономную программу; он широко применяется в файлах Python. В действительности он настолько прост, что некоторые поначалу упускают его из виду: каждый модуль имеет встроенный атрибут по имени __name__, который Python автоматически создает и присваивает, как описано ниже.

• Если файл запускается как программа верхнего уровня, тогда во время старта атрибут __name__ устанавливается в строку "__main__".
• Если взамен файл импортируется, то атрибут __name__ устанавливается в имя модуля, как известно его клиентам.

Результатом будет то, что модуль может проверять собственный атрибут __name__ для выяснения, запущен он или импортирован. Например, пусть создан следующий файл модуля по имени runme.py, экспортирующий единственную функцию tester:

def tester():
    print("It's Christmas in Heaven...")
if __name__ == '__main__':
    tester()  # Только тогда, когда запущен
    # Не тогда, когда импортирован

В модуле определена функция для импортирования и использования клиентами обычным образом:

c:\code> python
>>> import runme
>>> runme.tester()
It's Christmas in Heaven...

Но модуль в самом конце также содержит код, который настроен на автоматический вызов функции tester, когда данный файл запускается как программа:

c:\code> python runme.py
It's Christmas in Heaven...