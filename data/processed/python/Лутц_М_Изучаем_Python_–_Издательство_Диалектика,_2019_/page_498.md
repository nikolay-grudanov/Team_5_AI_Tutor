---
source_image: page_498.png
page_number: 498
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 27.60
tokens: 7675
characters: 2512
timestamp: 2025-12-24T01:22:48.942632
finish_reason: stop
---

else:
    def func():        # Иначе другое определение func
    ...
    ...
func()                # Вызов выбранной и созданной версии

Один из способов понять этот код — осознать, что оператор def во многом похож на оператор =: он просто присваивает имя во время выполнения. В отличие от компилируемых языков вроде С функции Python не нуждаются в полном определении перед запуском программы. В более общем плане операторы def не оцениваются до тех пор, пока не будут достигнуты и выполнены, и код внутри операторов def не выполняется до вызова функций.

Из-за того, что определение функций происходит во время выполнения, в имени функции нет ничего особенного. Важен объект, на который оно ссылается:

othername = func        # Присваивание объекта функции
othername()             # Снова вызывает func

Здесь функция была присвоена другому имени и вызвана через него. Как и все остальное в Python, функции — это просто объекты; они явно записываются в память во время выполнения программы. На самом деле кроме вызовов функции позволяют присоединять произвольные атрибуты для регистрации информации с целью более позднего использования:

def func(): ...         # Создание объекта функции
func()                  # Вызов объекта функции
func.attr = value       # Присоединение атрибутов

Первый пример: определения и вызовы

Не считая таких концепций времени выполнения (которые кажутся наиболее уникальными в основном программистам с опытом работы на традиционных компилируемых языках), функции Python прямолинейны в применении. Давайте напишем код первого реального примера, чтобы продемонстрировать основы. Вы увидите, что у функции есть две стороны: определение (оператор def, создающий функцию) и вызов (выражение, которое сообщает Python о необходимости выполнения тела функции).

Определение

Ниже показано интерактивно набранное определение функции по имени times, которое возвращает произведение двух аргументов:

>>> def times(x, y):      # Создание и присваивание функции
...     return x * y      # Тело выполняется при вызове
...

Когда Python достигает и выполняет этот оператор def, он создает новый объект функции, умещающий в себе код функции, и присваивает его имени times. Обычно такой оператор находится в файле модуля и выполняется при его импортировании; однако для чего-нибудь небольшого вполне достаточно интерактивной подсказки.

Вызов

Оператор def создает функцию, но не вызывает ее. После выполнения def функцию можно вызывать (выполнять) в своей программе, добавляя к имени функции