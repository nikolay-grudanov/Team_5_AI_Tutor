---
source_image: page_525.png
page_number: 525
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 34.11
tokens: 7818
characters: 2851
timestamp: 2025-12-24T01:23:46.628360
finish_reason: stop
---

значения ненужными в данной роли — в наше время Python автоматически запоминает любые значения в объемлющей области видимости, которые требуется применять во вложенных операторах def.

Разумеется, наилучшая рекомендация для большей части кода заключается в том, чтобы избегать вложения операторов def внутрь def, т.к. тогда программа станет гораздо проще — согласно духу Python плоский код, как правило, лучше вложенного. Ниже приведен эквивалент предыдущего примера, в котором вложение вообще отсутствует. Обратите внимание на опережающую ссылку в коде — вполне нормально вызывать функцию, определенную после функции, где она вызывается, при условии, что второй оператор def выполняется перед фактическим вызовом первой функции. Код внутри def никогда не выполняется до тех пор, пока функция не будет действительно вызвана:

```python
>>> def f1():
    x = 88      # Передача x вместо вложения
    f2(x)       # Опережающая ссылка допустима

>>> def f2(x):
    print(x)    # Плоский код все еще нередко лучше вложенного!

>>> f1()
88
```

Если вы избегаете вложения подобным способом, то можете в основном забыть о концепции вложенных областей видимости в Python. С другой стороны, вложенные функции фабричных функций (замыканий) довольно распространены в современном коде Python как функции lambda, которые почти естественно встречаются вложенными в операторы def и часто полагаются на уровень вложенных областей видимости, что будет обсуждаться в следующем разделе.

Вложенные области видимости, стандартные значения и выражения lambda

Несмотря на растущее использование в операторах def в наше время, наиболее вероятно, что вас будут заботить области видимости вложенных функций, когда вы начнете писать код или читать выражения lambda. Мы уже бегло встречались с конструкцией lambda ранее и подробно опишем ее в главе 19, а пока отметим, что это выражение, которое генерирует новую функцию для вызова в будущем, почти как оператор def. Однако будучи выражением, lambda может применяться в местах, где оператор def не допускается, скажем, внутри списковых и словарных литералов.

Подобно def выражение lambda также вводит новую локальную область видимости для функции, которую создает. Благодаря уровню поиска в объемлющих областях видимости выражения lambda могут видеть все переменные, существующие в функциях, в которых эти выражения записаны. Таким образом, следующий код — вариация ранее показанной фабрики — работает, но только по причине применения правил поиска во вложенных областях видимости:

```python
def func():
    x = 4
    action = (lambda n: x ** n)      # x запоминается из объемлющего def
    return action
x = func()
print(x(2))                          # Выводит 16, 4 ** 2
```

До того, как появились области видимости вложенных функций, для передачи значений из объемлющей области видимости в выражения lambda программисты