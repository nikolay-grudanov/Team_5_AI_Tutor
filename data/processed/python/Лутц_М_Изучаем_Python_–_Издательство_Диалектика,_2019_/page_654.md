---
source_image: page_654.png
page_number: 654
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 34.66
tokens: 7943
characters: 2556
timestamp: 2025-12-24T01:27:41.534387
finish_reason: stop
---

на компьютере Windows XP для третьего издания, результаты были относительно похожими — списковые включения оказались в два раза быстрее эквивалентных операторов цикла for, а map чуть быстрее списковых включений при отображении встроенной функции вроде abs (модуль числа). Абсолютные показания времени в Python 2.5 были примерно в четыре-пять раз больше, чем в текущем выводе Python 3.7, но вероятно на результаты больше повлиял высокопроизводительный компьютер, нежели какие-либо усовершенствования в Python.

На самом деле почти все результаты в Python 2.7 для данного сценария оказываются более быстрыми, чем в Python 3.7 — вызов list из map был удален во избежание двукратного создания списка результатов, но даже если его оставить, то он увеличит показание времени на небольшую постоянную величину:

c:\code> c:\python27\python timeseqs.py
2.7.3 (default, Apr 10 2012, 23:24:47) [MSC v.1500 64 bit (AMD64)]
forLoop : 1.24902 => [0...9999]
listComp : 0.66970 => [0...9999]
mapCall : 0.57018 => [0...9999]
genExpr : 0.90339 => [0...9999]
genFunc : 0.90542 => [0...9999]

Для сравнения ниже приведены результаты измерения скорости выполнения тех же тестов в PyPy — оптимизированной реализации Python, обсуждавшейся в главе 2, версия 1.9 которой реализует язык Python 2.7. Здесь версия PyPy 1.9 почти в 10 раз (на порядок) быстрее; она покажет себя даже еще лучше, когда мы возвратимся к сравнению версий Python позже в главе, применяя инструменты с отличающимися кодовыми структурами (правда, PyPy также и отстает на ряде других тестов):

c:\code> c:\PyPy\pypy-1.9\pypy.exe timeseqs.py
2.7.2 (341e1e3821ff, Jun 07 2012, 15:43:00)
[PyPy 1.9.0 with MSC v.1500 32 bit]
forLoop : 0.10106 => [0...9999]
listComp : 0.05629 => [0...9999]
mapCall : 0.10022 => [0...9999]
genExpr : 0.17234 => [0...9999]
genFunc : 0.17519 => [0...9999]

В самой реализации PyPy списковые включения быстрее map, но более важным представляется тот факт, что все результаты PyPy оказались настолько быстрее. В CPython функция map до сих пор была самой быстрой.

Влияние вызовов функций: map

Тем не менее, давайте посмотрим, что произойдет, если мы изменим сценарий с целью выполнения на каждой итерации внутристрочной операции, такой как сложение, а не вызова встроенной функции наподобие abs (опущенные части кода остались неизменными, а вызов list вокруг map нужен только для Python 3.7):

# Файл timeseqs2.py (отличающиеся части)
...
def forLoop():
    res = []
    for x in repslist:
        res.append(x + 10)
    return res
def listComp():
    return [x + 10 for x in repslist]