---
source_image: page_102.png
page_number: 102
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 35.92
tokens: 7938
characters: 3218
timestamp: 2025-12-24T01:10:12.894328
finish_reason: stop
---

Другие ограничения, связанные со щелчками на значках

Даже когда применяется трюк с input, описанный в предыдущем разделе, щелчки на значках файлов не обходятся без возникновения опасностей. Вы также можете не получить сообщения об ошибках от Python. Если ваш сценарий генерирует ошибку, то текст ее сообщения выводится во всплывающем консольном окне, которое затем немедленно исчезает! Хуже того, добавление в файл вызова input на этот раз не поможет, потому что сценарий прервет работу вероятно задолго до достижения данного вызова. Другими словами, вы не будете в состоянии сказать, что именно пошло не так.

Из обсуждения исключений позже в книге вы узнаете, что возможно написание кода для перехвата, обработки и восстановления после ошибок, чтобы они не приводили к прекращению работы программ. При обсуждении оператора try далее в книге будет показан альтернативный способ недопущения закрытия консольного окна в случае возникновения ошибок. Когда будут рассматриваться операции print, вы также научитесь перенаправлять выводимый текст в файлы для исследования в более позднее время. Тем не менее, за исключением такой поддержки в коде сообщения об ошибках и вывод теряются для программ, запускаемых щелчком на их значках.

Из-за описанных ограничений щелчки на значках, пожалуй, лучше всего считать способом запуска программ лишь после их отладки или оснащения инструментами для записи их вывода в файл и перехвата и обработки любых важных ошибок. Рекомендуется, особенно поначалу, использовать другие приемы, такие как командная строка системы и IDLE (обсуждается в разделе "Пользовательский интерфейс IDLE" далее в главе), что позволит вам видеть генерируемые сообщения об ошибках и обычный вывод, не прибегая к написанию добавочного кода.

Импортирование и повторная загрузка модулей

До сих пор я говорил об "импортировании модулей", не вдаваясь в подробности, что этот термин означает. Модули и более крупные программные архитектуры будут исследованы в части V, но поскольку импортирование также является способом запуска программ, в текущем разделе представлены основы модулей, которых должно быть достаточно для начала.

Основы импортирования и повторной загрузки

Выражаясь простыми словами, каждый файл исходного кода Python, чье имя заканчивается расширением .py, является модулем. Чтобы сделать файл модулем, никакого специального кода или синтаксиса не требуется: модулем будет любой файл такого рода. Другие файлы могут получать доступ к элементам, определенным в модуле, импортируя этот модуль — операции импорта по существу загружают другой файл и предоставляют доступ к его содержимому. Содержимое модуля делается доступным внешнему миру через его атрибуты (термин, который объясняется в следующем разделе).

Такая модель служб на основе модулей оказывается основной идеей программной архитектуры в Python. Более крупные программы обычно принимают форму множества файлов модулей, которые импортируют инструменты из других файлов модулей. Один из модулей предназначен быть главным файлом либо файлом верхнего уровня, или "сценарием" — файлом, запускаемым для старта целой программы, которая выполняется строка за строкой обычным образом. Ниже данного уровня все модули импортируют другие модули.