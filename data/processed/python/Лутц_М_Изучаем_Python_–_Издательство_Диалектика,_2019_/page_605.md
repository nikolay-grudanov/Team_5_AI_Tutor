---
source_image: page_605.png
page_number: 605
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 36.10
tokens: 7869
characters: 2265
timestamp: 2025-12-24T01:26:11.044484
finish_reason: stop
---

>>> L
[[11, 12, 13], [14, 15, 16]]

В действительносии мы не в состоянии сделать то же самое с помощью списковых включений, т.к. они создают новые списки, но всегда могли бы присвоить их результаты исходному имени, добившись похожего эффекта. Например, мы можем применить операцию к каждому элементу в матрице, производя результаты в простом векторе или матрице той же формы:

>>> [col + 10 for row in M for col in row]    # Присваивание M для сохранения
# нового значения
[11, 12, 13, 14, 15, 16, 17, 18, 19]
>>> [[col + 10 for col in row] for row in M]
[[11, 12, 13], [14, 15, 16], [17, 18, 19]]

Чтобы понять такой код, его следует преобразовать к виду простых операторов с отступами частей, находящихся правее в выражении (как в первом цикле ниже), и создать новый список, когда включения вкладываются слева (подобно второму циклу ниже). Как прояснил операторный эквивалент, второе выражение в предыдущем коде работает из-за того, что итерация по строкам является внешним циклом — для каждой строки она запускает вложенную итерацию по столбцам, чтобы построить одну строку результирующей матрицы:

>>> res = []
>>> for row in M:
    for col in row:
        res.append(col + 10)
>>> res
[11, 12, 13, 14, 15, 16, 17, 18, 19]

>>> res = []
>>> for row in M:
    tmp = []    # Вложенное слева включение начинает новый список
    for col in row:
        tmp.append(col + 10)
    res.append(tmp)
>>> res
[[11, 12, 13], [14, 15, 16], [17, 18, 19]]

Наконец, проявив толику творческого подхода, мы также можем использовать списковые включения для комбинирования значений множества матриц. В показанном далее коде сначала строится плоский список, который содержит результат попарного перемножения матриц, а затем структура вложенного списка, имеющая те же самые значения, снова за счет вложения списковых включений:

>>> M
[[1, 2, 3], [4, 5, 6], [7, 8, 9]]
>>> N
[[2, 2, 2], [3, 3, 3], [4, 4, 4]]
>>> [M[row][col] * N[row][col] for row in range(3) for col in range(3)]
[2, 4, 6, 12, 15, 18, 28, 32, 36]
>>> [[M[row][col] * N[row][col] for col in range(3)] for row in range(3)]
[[2, 4, 6], [12, 15, 18], [28, 32, 36]]

И опять последнее выражение работает из-за того, что итерация по строкам является внешним циклом; оно эквивалентно следующему коду на основе операторов: