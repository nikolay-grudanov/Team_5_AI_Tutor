---
source_image: page_520.png
page_number: 520
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 33.58
tokens: 7848
characters: 2857
timestamp: 2025-12-24T01:23:37.787525
finish_reason: stop
---

Код иллюстрирует эквивалентность глобальных переменных и атрибутов модуля, но требует гораздо большего объема работы по сравнению с использованием оператора global для пояснения своих намерений.

Как мы видели, оператор global позволяет изменять имена из модуля, внешнего по отношению к функции. Он имеет близкородственный оператор по имени nonlocal, который можно применять для изменения имен из объемлющих функций, но прежде чем выяснить, какую пользу из этого можно извлечь, необходимо исследовать объемлющие функции вообще.

Области видимости и вложенные функции

До сих пор я нарочно опустил одну часть правил, касающихся областей видимости Python, потому что она относительно редко встречается на практике. Тем не менее, пришло время внимательнее посмотреть на букву E в правиле поиска LEGB. Уровень E был добавлен в версии Python 2.2; он принимает форму локальных областей видимости любых объемлющих функций. Объемлющие области видимости временами также называются статически вложенными областями видимости. Вообще говоря, вложение является лексическим — вложенные области видимости соответствуют физически и синтаксически вложенным кодовым структурам в исходном тексте программы.

Детали вложенных областей видимости

С добавлением вложенных областей видимости слегка усложняются правила поиска переменных. Вот что происходит внутри функции.

• Ссылка (X) ищет имя X сначала в текущей локальной области видимости (функция); затем в локальных областях видимости любых лексически объемлющих функций в исходном коде, от внутренней до наружной; далее в текущей глобальной области видимости (файл модуля); и, наконец, во встроенной области видимости (модуль builtins). Объявления global заставляют поиск взамен начинаться в глобальной области видимости (файл модуля).

• Присваивание (X = значение) по умолчанию создает либо изменяет имя X в текущей локальной области видимости. Если имя X объявлено глобальным внутри функции, тогда присваивание создает или изменяет имя X в области видимости включающего модуля. Если же имя X объявлено нелокальным внутри функции в Python 3.x (только), то присваивание изменяет имя X в локальной области видимости ближайшей объемлющей функции.

Обратите внимание, что объявление global по-прежнему отображает переменные на область видимости включающего модуля. Когда присутствуют вложенные функции, на переменные из объемлющих функций можно ссылаться, но для их изменения в Python 3.x требуются объявления nonlocal.

Примеры вложенных областей видимости

Чтобы прояснить моменты, указанные в предыдущем разделе, давайте обратимся к реальному коду. Вот на что похожа область видимости объемлющей функции (для запуска кода поместите его в файл сценария или наберите в интерактивной подсказке):

X = 99        # Имя в глобальной области видимости: не используется
def f1():
    X = 88        # Локальное имя объемлющего def