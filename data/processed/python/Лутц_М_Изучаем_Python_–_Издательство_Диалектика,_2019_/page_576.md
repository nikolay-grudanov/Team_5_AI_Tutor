---
source_image: page_576.png
page_number: 576
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 29.94
tokens: 7690
characters: 2263
timestamp: 2025-12-24T01:25:16.087987
finish_reason: stop
---

def mysum(L):
    return 0 if not L else L[0] + mysum(L[1:])      # Использование
                                                    # тернарного выражения

def mysum(L):
    return L[0] if len(L) == 1 else L[0] + mysum(L[1:])  # Любой тип,
                                                    # предполагая наличие хотя бы одного элемента

def mysum(L):
    first, *rest = L
    return first if not rest else first + mysum(rest)  # Применение расширенного
                                                    # присваивания последовательностей Python 3.x

Последние два варианта потерпят неудачу для пустых списков, но допускают последовательности объектов любых типов, поддерживающих операцию +, а не только чисел:

>>> mysum([1])        # mysum([]) терпит неудачу в последних двух версиях
1
>>> mysum([1, 2, 3, 4, 5])
15
>>> mysum(('s', 'p', 'a', 'm'))   # Но теперь разрешены разнообразные типы
'spam'
>>> mysum(['spam', 'ham', 'eggs'])
'spamhameggs'

Для лучшего понимания запустите все версии самостоятельно. Ниже описано, что выяснится в результате исследования трех вариантов.

• Последние два варианта также работают с одиночным строковым аргументом (например, mysum('spam')), т.к. строки представляют собой последовательности односимвольных строк.

• Третий вариант работает с произвольными итерируемыми объектами, включая открытые входные файлы (mysum(open(имя)) ), но остальные — нет, потому что они выполняют индексацию (в главе 14 демонстрировалось расширенное присваивание последовательностей на файлах).

• Несмотря на сходство с третьим вариантом, заголовок функции def mysum(first, *rest) вообще не будет работать, поскольку он ожидает передачи отдельных аргументов, а не одиночного итерируемого объекта.

Имейте в виду, что рекурсия может быть прямой, как было показано в примерах до сих пор, или косвенной, как в следующем примере (функция, вызывающая другую функцию, которая снова вызывает первую функцию). Совокупный эффект оказывается таким же, хотя на каждом уровне есть два вызова функций вместо одного:

>>> def mysum(L):
    if not L: return 0
    return nonempty(L)      # Вызов функции nonempty, которая вызывает mysum

>>> def nonempty(L):
    return L[0] + mysum(L[1:])      # Косвенная рекурсия

>>> mysum([1.1, 2.2, 3.3, 4.4])
11.0