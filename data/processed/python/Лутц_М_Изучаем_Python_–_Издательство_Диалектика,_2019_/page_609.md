---
source_image: page_609.png
page_number: 609
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 34.48
tokens: 7922
characters: 3175
timestamp: 2025-12-24T01:26:17.661647
finish_reason: stop
---

Генераторные функции и выражения

В наши дни Python поддерживает откладывание гораздо больше, чем было в прошлом — он предоставляет инструменты, которые производят результаты, только когда необходимо, а не все одновременно. Мы видели откладывание при работе встроенных инструментов: файлов, которые читают строки по запросу, и функции наподобие map и zip, производящие элементы по требованию в Python 3.x. Однако такой ленивый подход не ограничивается самим Python. В частности, есть две языковые конструкции, которые откладывают создание результатов всякий раз, когда это возможно, в определяемых пользователем операциях.

• Генераторные функции (доступные, начиная с версии Python 2.3) записываются как нормальные операторы def, но в них применяются операторы yield, чтобы возвращать по одному результату за раз, приостанавливать выполнение с сохранением состояния и возобновлять его между выдачами.

• Генераторные выражения (доступные, начиная с версии Python 2.4) похожи на списковые включения, описанные в предыдущем разделе, но они не строят результирующий список, а возвращают объекты, которые производят результаты по запросу.

Из-за того, что ни та, ни другая конструкция не создает сразу весь результирующий список, они экономят пространство памяти и позволяют распределить время вычислений по запросам результатов. Как мы увидим, обе конструкции в конечном итоге делают свою магию отложенных результатов за счет реализации протокола итерации, который обсуждался в главе 14.

Указанные средства не новы (генераторные функции были доступны на выбор раньше Python 2.2) и в наши дни довольно распространены в коде Python. Понятие генераторов Python многим обязано другим языкам программирования, особенно Icon. Хотя поначалу они могут показаться необычными в случае, если вы привыкли к более простым программным моделям, в подходящих ситуациях вы наверняка сочтете генераторы мощным инструментом. Кроме того, поскольку они являются естественным расширением исследованных ранее идей функций, включений и итерации, вы уже знаете намного больше о написании генераторов, чем могли бы ожидать.

Генераторные функции: yield или return

В этой части книги мы выяснили, как писать код нормальных функций, которые принимают входные параметры и незамедлительно отправляют обратно одиночный результат. Тем не менее, можно также писать функции, которые способны отправлять обратно значение и позже возобновлять работу с места, которое они оставили. Такие функции, доступные в Python 2.x и 3.x, известны как генераторные функции, потому что они генерируют последовательность значений с течением времени.

Генераторные функции во многих отношениях похожи на нормальные функции и фактически записываются с помощью обычных операторов. Однако при их создании они специально компилируются в объект, который поддерживает протокол итерации. Когда генераторные функции вызываются, они возвращают не результат, а генератор результатов, который может появляться в любом итерационном контексте. Мы исследовали итерируемые объекты в главе 14, и на рис. 14.1 представили формальный и графический обзор их работы. Здесь мы снова к ним вернемся, чтобы посмотреть, как они связаны с генераторами.