---
source_image: page_691.png
page_number: 691
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 35.10
tokens: 7925
characters: 3038
timestamp: 2025-12-24T01:28:52.892898
finish_reason: stop
---

Поскольку это главная часть операции импортирования, о которой программисты должны знать, вскоре мы возвратимся к данной теме.

2. Компиляция файла модуля (возможная)

После того, как посредством обхода пути поиска модулей найден файл исходного кода, соответствующий оператору import, Python при необходимости компилирует его в байт-код. Мы кратко обсуждали байт-код в главе 2, но процесс несколько интереснее, чем объяснялось там. Во время операции импортирования Python проверяет время модификации файлов исходного кода и байт-кода, а также номер версии Python байт-кода, чтобы решить, как поступать. В первом случае используются "отметки времени" файлов, а во втором в зависимости от выпуска Python применяется либо "магическое" число, встроенное в байт-код, либо имя файла. Действие выбирается следующим образом.

Компилировать

Если файл байт-кода старше файла исходного кода (т.е. исходный код был модифицирован) или был создан другой версией Python, тогда Python автоматически заново генерирует байт-код при запуске программы.

Как будет обсуждаться далее, в Python 3.2 и последующих версиях данная модель несколько изменилась — файлы байт-кода вынесены в отдельный подкаталог __pycache__ и содержат в своих именах версию Python во избежание конфликтов и перекомпиляции, когда в системе установлено множество версий Python. В результате устраняется необходимость в проверке номеров версий в байт-коде, но проверка отметок времени по-прежнему используется для обнаружения изменений в исходном коде.

Не компилировать

С другой стороны, если Python обнаруживает файл байт-кода .рус, который не старше соответствующего файла исходного кода .ру и создан той же версией Python, тогда он пропускает шаг компиляции исходного кода в байт-код.

Вдобавок, когда Python находит в пути поиска модулей только файл байт-кода, но не файл исходного кода, он просто напрямую загружает байт-код; таким образом, вы можете поставлять программу в виде только файлов байт-кода, не отправляя файлы исходного кода. Другими словами, шаг компиляции пропускается, если возможно ускорение начального запуска программы.

Обратите внимание, что компиляция происходит во время импортирования файла. Из-за этого вы обычно не будете видеть файл байт-кода .рус для файла верхнего уровня своей программы, если только он также не импортируется где-то в другом месте — лишь импортированные файлы оставляют после себя файлы .рус на компьютере. Байт-код файлов верхнего уровня применяется внутренне и отбрасывается; байт-код импортированных файлов сохраняется в файлах для ускорения будущих операций импортирования.

Файлы верхнего уровня часто спроектированы для выполнения напрямую и не импортируются вообще. Позже мы увидим, что можно спроектировать файл, который будет служить как кодом верхнего уровня программы, так и модулем инструментов, предназначенных для импортирования. Такой файл может выполняться и импортироваться, а потому для него создается файл .рус. При обсуждении специального атрибута __name__ и __main__ в главе 25 будет показано, как это работает.