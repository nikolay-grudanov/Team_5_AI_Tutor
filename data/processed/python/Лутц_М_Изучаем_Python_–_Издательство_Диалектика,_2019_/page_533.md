---
source_image: page_533.png
page_number: 533
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 28.66
tokens: 7684
characters: 2404
timestamp: 2025-12-24T01:23:54.583639
finish_reason: stop
---

>>> def tester(start):
    state = start      # Каждый вызов получает собственное значение state
    def nested(label):
        nonlocal state  # Запоминает state из объемлющей области видимости
        print(label, state)
        state += 1      # Нелокальную переменную разрешено изменять
    return nested

>>> F = tester(0)
>>> F('spam')           # Переменная state видима только внутри замыкания
spam 0
>>> F.state
AttributeError: 'function' object has no attribute 'state'
Ошибка атрибута: объект function не имеет атрибута state

Нам необходимо объявлять переменные нелокальными, только если они должны изменяться (остальные ссылки на имена из объемлющих областей видимости автоматически сохраняются как обычно), и нелокальные имена по-прежнему не будут видимыми за пределами объемлющей функции.

К сожалению, такой код работает только в Python 3.x. Если вы используете Python 2.x, тогда в зависимости от преследуемых целей доступны другие варианты. В следующих трех разделах описаны альтернативы. В коде местами применяются инструменты, которые пока еще не были раскрыты и отчасти предназначены для предварительного обзора, но мы сохраняем примеры простыми, чтобы вы могли попутно сравнивать их друг с другом.

Состояние с помощью глобальных переменных:
только одиночная копия

Распространенная рекомендация для достижения в Python 2.x и предшествующих версиях эффекта, подобного nonlocal, предусматривает просто вынесение состояния в глобальную область видимости (включающий модуль):

>>> def tester(start):
    global state      # Вынести в модуль, чтобы можно было изменять
    state = start     # global делает возможными изменения
    # в области видимости модуля
    def nested(label):
        global state
        print(label, state)
        state += 1
    return nested

>>> F = tester(0)
>>> F('spam')   # Каждый вызов инкрементирует разделяемое глобальное состояние
spam 0
>>> F('eggs')
eggs 1

Прием в данном случае работает, но требует объявлений global в обеих функциях и предрасположен к конфликтам имен в глобальной области видимости (что, если имя state уже задействовано?). Худшая и более тонкая проблема заключается в том, что он допускает единственную разделяемую копию информации о состоянии в области видимости модуля — если мы вызовем tester снова, то инициируем переустановку переменной state модуля, так что предыдущие вызовы увидят свои переменные state перезаписанными: