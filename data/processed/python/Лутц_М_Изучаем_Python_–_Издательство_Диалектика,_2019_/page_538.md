---
source_image: page_538.png
page_number: 538
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 37.98
tokens: 7876
characters: 3035
timestamp: 2025-12-24T01:24:15.822470
finish_reason: stop
---

ляются инструментом, по своей природе связанным с многоуровневым сохранением состояния. Варианты поддержки состояния обладают дополнительными характеристиками, влияющими на их выбор (например, производительность), которые в настоящей главе не раскрыты из-за нехватки места (в главе 21 мы покажем, как измерять скорость выполнения кода). А теперь пришло время заняться режимами передачи аргументов.

Что потребует внимания: настройка open

Рассмотрим еще один пример замыканий в работе. Предположим, что необходимо заменить встроенный вызов open специальной версией, как упоминалось во врезке "Разрушение мироздания в Python 2.X" ранее в главе. Если специальная версия должна вызывать оригинал, тогда она обязана сохранить его перед изменением и удерживать для дальнейшего применения — классический сценарий с сохранением состояния. Кроме того, если желательно поддерживать множество настроенных версий для той же самой функции, то глобальные переменные не помогут: нас интересует состояние для каждой настроенной версии.

В следующем далее коде Python 3.X, находящемся в файле makeopen.py, иллюстрируется один из способов решения задачи (в Python 2.X понадобится изменить имя встроенной области видимости и вывод). В нем с использованием замыкания вложенной области видимости запоминается значение для применения в будущем, не полагаясь на глобальные переменные, которые могут привести к конфликту имен и допускают только одно значение, а также не прибегая к услугам класса, который может потребовать написания большего объема кода, чем здесь оправдано:

import builtins
def makeopen(id):
    original = builtins.open
    def custom(*pargs, **kargs):
        print('Custom open call %r:' % id, pargs, kargs)
        return original(*pargs, **kargs)
    builtins.open = custom

Чтобы изменить вызов open для каждого модуля внутри процесса, в коде ему приравнивается специальная версия, написанная с помощью вложенного оператора def, после сохранения оригинала в объемлющей области видимости, так что настроенная версия сможет обращаться к нему позже. Код еще служит и предварительной демонстрацией, т.к. при сборе и дальнейшей распаковке произвольных позиционных и ключевых аргументов, предназначенных для open, он полагается на формы аргументов, снабженных звездочкой — тема следующей главы. Однако большая часть магии скрыта в замыканиях вложенных областей видимости: специальная версия open, найденная правилами поиска в областях видимости, удерживает в себе оригинал для будущего использования:

>>> F = open('script2.py')   # Вызов встроенной функции open в builtins
>>> F.read()
'import sys\nprint(sys.path)\nx = 2\nprint(x ** 32)\n'

>>> from makeopen import makeopen  # Импортирование функции переустановки open
>>> makeopen('spam')                # Специальная версия open вызывает встроенную
                                    # версию open

>>> F = open('script2.py')   # Вызов специальной версии open в builtins
Custom open call 'spam': ('script2.py',) {}
>>> F.read()
'import sys\nprint(sys.path)\nx = 2\nprint(x ** 32)\n'