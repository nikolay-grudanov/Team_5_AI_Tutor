---
source_image: page_154.png
page_number: 154
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 32.16
tokens: 7848
characters: 2662
timestamp: 2025-12-24T01:11:44.726705
finish_reason: stop
---

всегда можно переписать в виде эквивалентного цикла for, который строит результирующий список вручную, дополняя его на каждом шаге:

```python
>>> squares = []
>>> for x in [1, 2, 3, 4, 5]:
    squares.append(x ** 2)
# Это то, что делает списковое включение
# Оба инструмента внутренне следуют
# протоколу итерации

>>> squares
[1, 4, 9, 16, 25]
```

Оба инструмента внутренне задействуют протокол итерации и производят тот же самый результат. Однако списковое включение и связанные инструменты функционального программирования вроде map и filter в наши дни часто будут выполняться быстрее цикла for в коде определенных видов (возможно даже в два раза) — характеристика, которая может быть значимой в программах, обрабатывающих крупные наборы данных. Но после сказанного я должен отметить, что показатели производительности в языке Python — вещи не особо надежные, потому что он оптимизирует слишком многое, и они могут меняться от выпуска к выпуску.

Основное эмпирическое правило в Python таково: писать код, заботясь в первую очередь о простоте и читабельности, а о производительности беспокоиться позже, когда программа заработала, и после того, как вы докажете наличие подлинной проблемы с производительностью. Почти всегда ваш код будет достаточно быстрым в том виде, как есть. Тем не менее, если вам нужно подстроить код ради достижения более высокой производительности, то в состав Python входят модули time и timeit для измерения скорости альтернатив и модуль profile для устранения узких мест.

Более подробно о таких темах вы узнаете позже в книге (особенно в учебном примере оценочного испытания из главы 21) и в руководствах Python. А сейчас мы переходим к следующему основному типу данных.

Кортежи

Объект кортежа примерно похож на список, который нельзя изменять — кортежи являются последовательностями подобно спискам, но они неизменяемые подобно строками. Функционально они используются для представления фиксированных коллекций элементов: скажем, компонентов специфической даты в календаре. Синтаксически они записываются в круглых, а не квадратных скобках и поддерживают произвольные типы, произвольное вложение и обычные операции над последовательностями:

```python
>>> T = (1, 2, 3, 4)      # Кортеж из 4 элементов
>>> len(T)                # Длина
4
>>> T + (5, 6)            # Конкатенация
(1, 2, 3, 4, 5, 6)
>>> T[0]                  # Индексация, нарезание и т.д.
1
```

Кортежи в Python 2.6 и 3.0 также имеют вызываемые методы, специфичные для типа, но далеко не так много, как списки:

```python
>>> T.index(4)            # Методы кортежей: 4 обнаруживается по смещению 3
3
>>> T.count(4)            # 4 обнаруживается один раз
1
```