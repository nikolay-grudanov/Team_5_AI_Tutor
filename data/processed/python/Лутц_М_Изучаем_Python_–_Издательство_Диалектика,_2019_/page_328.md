---
source_image: page_328.png
page_number: 328
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 31.18
tokens: 7787
characters: 2474
timestamp: 2025-12-24T01:17:34.563937
finish_reason: stop
---

• выражения срезов с пустыми границами (L[:]) копируют последовательности;
• метод copy словаря, множества и списка (X.copy()) копирует словарь, множество и список (метод copy доступен в списках, начиная с версии Python 3.3);
• некоторые встроенные функции, такие как list и dict, делают копии (list(L), dict(D), set(S));
• стандартный библиотечный модуль copy при необходимости создает полные копии.

Например, пусть имеется список и словарь, и вы не хотите, чтобы их значения изменялись через другие переменные:

```python
>>> L = [1,2,3]
>>> D = {'a':1, 'b':2}
```

Для этого просто присвойте другим переменным копии, а не ссылки на данные объекты:

```python
>>> A = L[:]                # Вместо A = L (или list(L))
>>> B = D.copy()            # Вместо B = D (то же самое для множеств)
```

В таком случае изменения, сделанные через другие переменные, будут воздействовать на копии, а не на оригинал:

```python
>>> A[1] = 'Ni'
>>> B['c'] = 'spam'
>>>
>>> L, D
([1, 2, 3], {'a': 1, 'b': 2})
>>> A, B
([1, 'Ni', 3], {'a': 1, 'c': 'spam', 'b': 2})
```

Что касается первоначального примера, то избежать побочных эффектов от ссылок можно путем указания среза исходного списка вместо просто его имени:

```python
>>> X = [1, 2, 3]
>>> L = ['a', X[:], 'b']   # Встраивание копий объекта X
>>> D = {'x':X[:], 'y':2}
```

В итоге картина на рис. 9.2 меняется — L и D теперь указывают на другие списки, отличающиеся от того, на который указывает X. Конечный результат заключается в том, что изменения, производимые через X, будут влиять только на X, но не на L и D; аналогично изменения в L или D не окажут воздействие на X.

Последнее замечание относительно копий: срезы с пустыми границами и словарный метод copy создают только копии верхнего уровня, т.е. не копируют вложенные структуры данных, если они присутствуют. Когда требуется полная независимая копия структуры данных с глубоким вложением (вроде различных структур записей из предшествующих глав), применяйте стандартный библиотечный модуль copy, представленный в главе 6:

import copy
X = copy.deepcopy(Y) # Полная копия объекта Y с произвольно глубоким вложением

Вызов copy.deepcopy рекурсивно обходит объекты с целью копирования всех их частей. Тем не менее, такая ситуация возникает гораздо реже — вот почему для использования данной схемы приходится писать больше кода. Как правило, ссылки будут тем, что необходимо; если это не так, то срезы и метод copy скопируют столько, сколько обычно требуется для работы.