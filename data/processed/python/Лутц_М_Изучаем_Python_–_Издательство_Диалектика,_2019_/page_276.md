---
source_image: page_276.png
page_number: 276
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 34.30
tokens: 7941
characters: 3119
timestamp: 2025-12-24T01:15:52.791674
finish_reason: stop
---

>>> L.sort()        # Сортировка элементов списка ('S' < 'e')
>>> L
['SPAM!', 'eat', 'more', 'please']

Методы были представлены в главе 7. Вкратце они являются функциями (на самом деле атрибутами объекта, которые ссылаются на функции), ассоциированными и действующими на определенных объектах. Методы предоставляют инструменты, специфические к типу; например, рассматриваемые здесь списковые методы большей частью доступны только для списков.

Пожалуй, самым ходовым списковым методом следует считать append, который просто прикрепляет одиночный элемент (ссылку на объект) в конец списка. В отличие от конкатенации append ожидает, что ему будет передан одиночный объект, а не список. Эффект L.append(X) аналогичен L+[X], но тогда как первый вариант изменяет L на месте, второй создает новый список3. Метод sort упорядочивает элементы в списке и заслуживает отдельного раздела.

Дополнительные сведения о сортировке списков

Еще один распространенный метод, sort, упорядочивает список на месте; он использует стандартные критерии сравнения Python (здесь строковые сравнения, но он применим к любому типу) и по умолчанию сортирует в возрастающем порядке. Модифицировать поведение сортировки можно путем передачи ключевых аргументов — специального синтаксиса "имя=значение" в вызовах функций, который указывает передачу по имени и часто применяется для задания параметров конфигурации.

В методе sort аргумент reverse позволяет делать сортировку в убывающем порядке вместо возрастающего, а key задает функцию с одним аргументом, которая возвращает значение, подлежащее использованию при сортировке — стандартный преобразователь регистра символов lower строкового объекта в следующем примере (хотя более новый преобразователь casefold мог бы лучше обрабатывать некоторые типы текста Unicode):

>>> L = ['abc', 'ABD', 'aBe']
>>> L.sort()
# Сортировка со смешанным регистром символов
>>> L
['ABD', 'aBe', 'abc']
>>> L = ['abc', 'ABD', 'aBe']
>>> L.sort(key=str.lower)
# Приведение к нижнему регистру
>>> L
['abc', 'ABD', 'aBe']
>>> L = ['abc', 'ABD', 'aBe']
>>> L.sort(key=str.lower, reverse=True)    # Изменение порядка сортировки
>>> L
['aBe', 'ABD', 'abc']

Аргумент key метода sort также может быть полезен при сортировке списков словарей для выбора ключа сортировки путем индексирования каждого словаря. Словари будут исследоваться позже в главе, а о ключевых аргументах функций вы узнаете в части IV.

3 В отличие от конкатенации + метод append не обязан генерировать новые объекты, поэтому обычно он тоже быстрее +. Метод append можно также имитировать с помощью искусственных присваиваний по срезам из предыдущего раздела: L[len(L):]=[X] похоже на L.append(X), а L[:0]=[X] — на дополнение в начало списка. Оба присваивания удаляют пустой срез и вставляют X, быстро изменяя L на месте подобно append. Однако оба они возможно сложнее вызова списковых методов. Например, вызов L.insert(0, X) способен добавлять элемент также в начало списка и выглядит значительно понятней; вызов L.insert(len(L), X) вставит один объект в конец списка, но с таким же успехом можно применять L.append(X), уменьшив объем набираемого кода!