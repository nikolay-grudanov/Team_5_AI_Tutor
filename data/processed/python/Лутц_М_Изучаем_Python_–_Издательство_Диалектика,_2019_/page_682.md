---
source_image: page_682.png
page_number: 682
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 31.08
tokens: 7719
characters: 2085
timestamp: 2025-12-24T01:28:28.621142
finish_reason: stop
---

def f1(a, b): print(a, b)        # Нормальные аргументы
def f2(a, *b): print(a, b)       # Переменное количество позиционных аргументов
def f3(a, **b): print(a, b)       # Переменное количество ключевых аргументов
def f4(a, *b, **c): print(a, b, c) # Смешанные режимы
def f5(a, b=2, c=3): print(a, b, c) # Стандартные значения
def f6(a, b=2, *c): print(a, b, c) # Стандартные значения и переменное
                                    # количество позиционных аргументов

Протестируйте приведенные далее вызовы в интерактивной подсказке и попробуйте объяснить каждый результат; в некоторых случаях, возможно, придется обратиться за помощью к алгоритму сопоставления, описанному в главе 18. Считаете ли вы смешанные режимы сопоставления в целом хорошей идеей? Можете ли вы придумать ситуации, когда они были бы полезными?

>>> f1(1, 2)
>>> f1(b=2, a=1)
>>> f2(1, 2, 3)
>>> f3(1, x=2, y=3)
>>> f4(1, 2, 3, x=2, y=3)
>>> f5(1)
>>> f5(1, 4)
>>> f6(1)
>>> f6(1, 3, 4)

8. Снова простые числа. Вспомните показанный ниже фрагмент кода из главы 13, который упрощенно определял, является ли положительное целое число простым:

x = y // 2                        # Для значений y > 1
while x > 1:
    if y % x == 0:                 # Остаток от деления
        print(y, 'has factor', x)   # Имеет сомножитель
        break                       # Пропуск else
    x -= 1
else:                              # Нормальный выход
    print(y, 'is prime')           # Является простым

Упакуйте данный код как многократно используемую функцию в файле модуля (имя y должно быть передаваемым аргументом) и добавьте в конец файла несколько вызовов функции. Пока вы делаете это, поэкспериментируйте с заменой операции // в первой строке операцией /, чтобы посмотреть, как настоящее деление изменяет поведение операции / в Python 3.x и нарушает работу кода (обратитесь в главу 5, если требуется напоминание). Что можно сделать с отрицательными числами и значениями 0 и 1? Как насчет ускорения работы функции? Вывод должен выглядеть примерно так:

13 is prime
13.0 is prime
15 has factor 5
15.0 has factor 5.0