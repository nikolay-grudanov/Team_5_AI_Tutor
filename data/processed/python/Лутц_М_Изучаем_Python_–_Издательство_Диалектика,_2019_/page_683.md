---
source_image: page_683.png
page_number: 683
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 35.51
tokens: 7917
characters: 2936
timestamp: 2025-12-24T01:28:36.651276
finish_reason: stop
---

9. Итерации и включения. Напишите код для построения нового списка, содержащего квадратные корни всех чисел из следующего списка: [2, 4, 9, 16, 25]. Сначала запишите его как цикл for, затем как вызов map, далее как списковое включение и наконец как генераторное выражение. Для вычисления квадратного корня применяйте функцию sqrt из встроенного модуля math (например, импортируйте math и вызовите math.sqrt(x)). Какой из четырех подходов вам представляется наилучшим?

10. Измерение времени выполнения инструментов. В главе 5 были показаны три способа вычисления квадратного корня: math.sqrt(X), X ** .5 и pow(X, .5). Если в ваших программах присутствует много таких вычислений, тогда может стать важной их относительная производительность. Чтобы выяснить, какой способ является самым быстрым, переделайте сценарий timersegs.py, написанный ранее в главе, чтобы измерить время каждого из этих трех инструментов. При тестировании используйте функции bestof или bestoftotal, определенные в одном из модулей timer данной главы (вы можете применять либо первоначальный вариант с аргументами, передаваемыми только по ключевым словам, который поддерживается лишь в Python 3.x, либо версию для Python 2.x/3.x, а также использовать модуль timeit из Python). Вы также можете принять решение перепаковать код тестирования в этом сценарии, чтобы повысить удобство многократного применения — скажем, передавать универсальной тестовой функции кортеж функций, подлежащих тестированию (в текущем упражнении вполне достаточно подхода с копированием и модификацией кода). Какой из имеющихся трех инструментов для вычисления квадратного корня выполняется быстрее всех на вашем компьютере и версии Python? Как бы вы измеряли скорость выполнения включений словарей по сравнению с циклами for в интерактивной подсказке?

11. Рекурсивные функции. Напишите простую рекурсивную функцию по имени countdown, которая выводит числа в ходе обратного отсчета до нуля. Например, вызов countdown(5) должен вывести 5 4 3 2 1 stop. Нет очевидных причин решать задачу с помощью явного стека или очереди, но как насчет подхода без использования функции? Имеет ли смысл здесь применять генератор?

12. Вычисление факториалов. И напоследок классика компьютерных наук (но оттого не менее иллюстративная). При обсуждении перестановок в главе 20 мы использовали понятие факториалов: N!, вычисляемое как N* (N-1) * (N-2) * ... 1. Например, 6! равно 6*5*4*3*2*1, или 720. Напишите и хронометрируйте четыре функции, каждая из которых для вызова fact(N) возвращает N!. Реализуйте эти четыре функции (1) как рекурсивный обратный отсчет согласно главе 19; (2) применяя вызов функции reduce согласно главе 19; (3) с помощью простого цикла с подсчетом согласно главе 13; (4) используя библиотечный инструмент math.factorial согласно главе 20. Для измерения времени выполнения каждой функции применяйте модуль timeit из главы 21. Какие выводы вы смогли сделать из полученных результатов?