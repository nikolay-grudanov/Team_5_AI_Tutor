---
source_image: page_436.png
page_number: 436
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 33.11
tokens: 7737
characters: 2478
timestamp: 2025-12-24T01:21:03.118923
finish_reason: stop
---

В коде запускается команда вывода списка файлов каталога (dir) в Windows, но подобным образом можно запустить любую программу, которая допускает запуск из командной строки. Мы могли бы использовать такую схему, например, для отображения вывода команды systeminfo в Windows — os.system просто запускает команду оболочки, но os.popen также подключается к ее потокам; оба показанных далее фрагмента показывают вывод команды оболочки в простом консольном окне, но первый может не отобразиться в графическом пользовательском интерфейсе, таком как IDLE:

```python
>>> os.system('systeminfo')
... вывод в консоли, всплывающее окно в IDLE...
0
>>> for line in os.popen('systeminfo'): print(line.rstrip())
Host Name:        MARK-VAIO
OS Name:          Microsoft Windows 7 Professional
OS Version:       6.1.7601 Service Pack 1 Build 7601
... дополнительный текст со сведениями о системе...
```

К полученному выводу команды в текстовой форме применим любой инструмент или методика обработки строк, включая форматирование для отображения и разбор содержимого:

# Форматирование, ограниченное отображение
>>> for (i, line) in enumerate(os.popen('systeminfo')):
...     if i == 4: break
...     print('%05d) %s' % (i, line.rstrip()))
...
00000)
00001) Host Name:        MARK-VAIO
00002) OS Name:          Microsoft Windows 7 Professional
00003) OS Version:       6.1.7601 Service Pack 1 Build 7601

# Разбор для специфических строк, нейтральный к регистру символов
>>> for line in os.popen('systeminfo'):
...     parts = line.split(':')
...     if parts and parts[0].lower() == 'system type':
...         print(parts[1].strip())
...
x64-based PC

Мы увидим метод os.popen в действии в главе 21, когда прибегнем к нему при чтении результатов сконструированной командной строки, которая фиксирует продолжительность выполнения вариантов кода, и в главе 25, где он будет использоваться при сравнении выводов тестируемых сценариев.

Инструменты наподобие os.popen и os.system (а также не показанный здесь модуль subprocess) позволяют задействовать любую программу командной строки на компьютере, но можно также писать эмуляторы с внутрипроцессным кодом. Скажем, эмуляция способности Unix-утилиты awk по извлечению столбцов из текстовых файлов в Python почти тривиальна и может стать многократно применяемой функцией в процессе:

# Эмуляция awk: извлечение столбца 7 из файла с разделителями
# в виде пробельных символов
for val in [line.split()[6] for line in open('input.txt')]:
    print(val)