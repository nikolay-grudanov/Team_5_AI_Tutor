---
source_image: page_187.png
page_number: 187
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 31.56
tokens: 7922
characters: 2407
timestamp: 2025-12-24T01:12:49.384922
finish_reason: stop
---

входят операции, которые трактуют целые числа как строки двоичных битов и могут пригодиться, если ваш код Python должен иметь дело с такими вещами, как сетевые пакеты, последовательные порты или упакованные двоичные данные, производимые программой C.

Мы не можем здесь подробно останавливаться на основах булевской математики (тем, кто обязан ее использовать, скорее всего, уже известно, как она работает, а другие могут вообще отложить изучение данной темы), но они прямолинейны. Например, ниже демонстрируются выражения Python, выполняющие побитовый сдвиг и булевые операции на целых числах:

```python
>>> x = 1           # Десятичное значение 1 в битах выглядит как 0001
>>> x << 2          # Сдвиг влево на 2 бита: 0100
4
>>> x | 2           # Побитовое ИЛИ (один из битов = 1): 0011
3
>>> x & 1           # Побитовое И (оба бита = 1): 0001
1
```

В первом выражении двоичная 1 (по основанию 2, 0001) сдвигается влево на две позиции, чтобы породить двоичную 4 (0100). Последние две операции выполняют двоичное "ИЛИ" для объединения битов (0001 | 0010 = 0011) и двоичное "И" для выбора общих битов (0001 & 0001 = 0001). Такие операции побитового маскирования позволяют декодировать и извлекать множество флагов и других значений внутри одиночного целого числа.

Это одна из областей, где поддержка двоичных и шестнадцатеричных чисел в Python, начиная с версий 3.0 и 2.6, становится особенно полезной — она позволяет записывать и инспектировать числа по битовым строкам:

```python
>>> X = 0b0001      # Двоичные литералы
>>> X << 2          # Сдвиг влево
4
>>> bin(X << 2)     # Строка двоичных цифр
'0b100'
>>> bin(X | 0b010)  # Побитовое ИЛИ: один из битов = 1
'0b11'
>>> bin(X & 0b1)    # Побитовое И: оба бита = 1
'0b1'
```

Сказанное также справедливо для значений, которые начинают свое существование как шестнадцатеричные литералы или подвергаются базовым преобразованиям:

```python
>>> X = 0xFF        # Шестнадцатеричные литералы
>>> bin(X)
'0b11111111'
>>> X ^ 0b10101010  # Побитовое исключающее ИЛИ: один из битов = 1, но не оба
85
>>> bin(X ^ 0b10101010)
'0b1010101'
>>> int('01010101', 2)  # Цифры => число: строка в целое по указанному основанию
85
>>> hex(85)         # Число => цифры: строка шестнадцатеричных цифр
'0x55'
```

Также в этом плане версии Python 3.1 и 2.7 предложили для целых чисел новый метод bit_length, который позволяет запрашивать количество битов, требующееся для