---
source_image: page_367.png
page_number: 367
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 33.94
tokens: 7877
characters: 2543
timestamp: 2025-12-24T01:18:55.942292
finish_reason: stop
---

Для большей гибкости мы можем выполнять срезы в Python 2.x и 3.x. Задействовать нарезание для того, чтобы предыдущий случай заработал, можно разными способами:

```python
>>> a, b, c = string[0], string[1], string[2:]    # Индексация и нарезание
>>> a, b, c
('S', 'P', 'AM')
>>> a, b, c = list(string[:2]) + [string[2:]]    # Нарезание и конкатенация
>>> a, b, c
('S', 'P', 'AM')
>>> a, b = string[:2]                             # То же самое, но проще
>>> c = string[2:]
>>> a, b, c
('S', 'P', 'AM')
>>> (a, b), c = string[:2], string[2:]            # Вложенные последовательности
>>> a, b, c
('S', 'P', 'AM')
```

Как демонстрирует последний пример во взаимодействии выше, мы даже можем присваивать вложенные последовательности, и Python ожидаемым образом распакует их части согласно их формам. В этом случае мы присваиваем кортеж из двух элементов, где первый элемент является вложенной последовательностью (строкой), в точности, как если бы мы записали его в следующем виде:

```python
>>> ((a, b), c) = ('SP', 'AM')    # Попарно соединяются по форме и по позиции
>>> a, b, c
('S', 'P', 'AM')
```

Python попарно соединяет первую строку справа ('SP') с первым кортежем слева ((a, b)) и присваивает по одному символу за раз до присваивания целой второй строки ('AM') переменной с одновременно. В таком случае форма вложенной последовательности объекта слева должна совпадать с формой объекта справа. Присваивание вложенной последовательности подобного рода встречается редко, но оно может оказаться удобным для выборки частей структур данных с известными формами.

Скажем, в главе 13 мы увидим, что такая методика также работает в циклах for, потому что элементы цикла присваиваются цели, указанной в заголовке цикла:

```python
for (a, b, c) in [(1, 2, 3), (4, 5, 6)]: ...   # Простое присваивание кортежей
for ((a, b), c) in [((1, 2), 3), ((4, 5), 6)]: ...   # Присваивание вложенных кортежей
```

В первой врезке "На заметку!" в главе 18 мы узнаем, что эта форма распаковывающего присваивания вложенного кортежа (на самом деле последовательности) работает и для списков аргументов функций в Python 2.x (хотя не в Python 3.x), т.к. аргументы функций тоже передаются путем присваивания:

```python
def f(((a, b), c)): ... # Работает для аргументов в Python 2.x, но не в Python 3.x
f(((1, 2), 3))
```

Распаковывающие присваивания последовательностей также дают начало еще одной распространенной кодовой идиоме в Python — присваивание серии целых чисел набору переменных:

```python
>>> red, green, blue = range(3)
>>> red, blue
(0, 2)
```