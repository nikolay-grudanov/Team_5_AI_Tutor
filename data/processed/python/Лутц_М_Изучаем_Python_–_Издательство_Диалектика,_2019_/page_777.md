---
source_image: page_777.png
page_number: 777
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 31.61
tokens: 7732
characters: 2620
timestamp: 2025-12-24T01:31:13.732647
finish_reason: stop
---

>>> modname = 'string'
>>> exec('import ' + modname)    # Выполнение строки кода
>>> string                        # Импортируется в это пространство имен
<module 'string' from 'F:\\Python37\\lib\\string.py'>

Мы встречали функцию exec (и родственный ей вариант для выражений, eval) ранее в главах 3 и 10. Она компилирует строку кода и передает ее на выполнение интерпретатору Python. В Python компилятор байт-кода доступен во время выполнения, так что вы можете писать программы, которые создают и запускают другие программы. По умолчанию функция exec выполняет код в текущей области видимости, но при необходимости вы можете указать более конкретную информацию, передавая ей необходимые словари пространств имен. Она также порождает упомянутую ранее в книге проблему в плане безопасности, которая может быть незначительной в строке с кодом, создаваемой вами самостоятельно.

Прямые вызовы: два варианта

Единственный реальный недостаток применения функции exec в данной ситуации связан с тем, что при каждом выполнении она должна компилировать оператор import, что может быть медленным. Предварительная компиляция в байт-код посредством встроенной функции compile может помочь выполнять строки с кодом много раз, но в большинстве случаев вероятно проще использовать встроенную функцию __import__, чтобы загрузить модуль, имя которого указано в строке; вдобавок она может выполняться быстрее (см. главу 22). Эффект будет похожим, но функция __import__ возвращает объект модуля, поэтому для сохранения потребуется присваивание:

>>> modname = 'string'
>>> string = __import__(modname)
>>> string
<module 'string' from 'F:\\Python37\\lib\\string.py'>

В главе 22 также отмечалось, что более новый вызов importlib.import_module делает ту же самую работу, и в недавних версиях Python он, как правило, предпочтительнее для прямых вызовов импортирования по строке с именем:

>>> import importlib
>>> modname = 'string'
>>> string = importlib.import_module(modname)
>>> string
<module 'string' from 'F:\\Python37\\lib\\string.py'>

Вызов import_module принимает строку с именем модуля и необязательный второй аргумент, в котором указывается пакет, применяемый в качестве места поиска для операций относительного импортирования и по умолчанию устанавливаемый в None. Этот вызов работает так же, как и __import__ в своих основных ролях; за дополнительными сведениями обращайтесь в руководства по Python.

Хотя оба вызова работают, в версиях Python, где они доступны оба, первоначальная функция __import__ в целом предназначена для настройки операций импортирования за счет повторных присваиваний во встроенной области видимости.