---
source_image: page_589.png
page_number: 589
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 34.15
tokens: 7825
characters: 2594
timestamp: 2025-12-24T01:25:40.878658
finish_reason: stop
---

def f1(x): return x ** 2
def f2(x): return x ** 3
def f3(x): return x ** 4

L = [f1, f2, f3]

for f in L:
    print(f(2))

print(L[0](3))

# Определение именованных функций
# Ссылка по имени
# Выводит 4, 8, 16
# Выводит 9

Переключатели для множественного ветвления: окончание

На самом деле вы можете использовать словари и другие структуры данных в Python для построения более универсальных разновидностей таблиц действий. Вот еще один пример, выполненный в интерактивной подсказке:

>>> key = 'got'
>>> {'already': (lambda: 2 + 2),
    'got': (lambda: 2 * 4),
    'one': (lambda: 2 ** 6)}[key]()

Когда Python создает временный словарь, каждое вложенное выражение lambda генерирует и оставляет после себя функцию, подлежащую вызову в будущем. Индексация по ключу извлекает одну из функций, а круглые скобки приводят к вызову извлеченной функции. При такой реализации словарь становится более универсальным инструментом для множественного ветвления, нежели показанный в главе 12 во время обсуждения операторов if.

Чтобы написать версию кода без lambda, понадобится предусмотреть три оператора def где-то в файле за пределами словаря, в котором функции будут применяться, и ссылаться на функции по их именам:

>>> def f1(): return 2 + 2
>>> def f2(): return 2 * 4
>>> def f3(): return 2 ** 6
>>> key = 'one'
>>> {'already': f1, 'got': f2, 'one': f3}[key]()

Такой код тоже работает, но операторы def могут находиться произвольно далеко в файле, даже если они представляют собой лишь небольшие порции кода. Кодовая близость, обеспечиваемая выражениями lambda, особенно полезна для функций, которые будут использоваться только в одном контексте — если эти три функции больше нигде не нужны, то имеет смысл встроить их определения внутрь словаря как выражения lambda. Кроме того, форма def требует выбора для функций имен, которые могут конфликтовать с остальными именами в файле (маловероятно, но всегда возможно)².

² Однажды один студент заметил, что от словаря с координирующей таблицей в таком коде можно было бы избавиться, если бы имя функции совпадало со своим строковым ключом поиска — запуск eval(имя_функции) () инициирует вызов. Хотя в данном случае это справедливо и временами удобно, как было показано ранее (скажем, в главе 10), функция eval работает относительно медленно (она обязана скомпилировать и выполнить код), к тому же небезопасна (вы должны доверять источнику строки). По существу таблицы переходов обычно задействуются диспетчеризацией полиморфных методов в Python: вызов метода делает "то, что надо", основываясь на типе объекта. В части VI будет объясняться, почему.