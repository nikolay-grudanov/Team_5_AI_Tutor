---
source_image: page_663.png
page_number: 663
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 39.03
tokens: 8049
characters: 2986
timestamp: 2025-12-24T01:28:01.086519
finish_reason: stop
---

обусловлены отличиями в использовании функции range — раньше она возвращала созданный список, но здесь мы имеем дело либо с генератором Python 3.x, либо со списком Python 2.x, который заново строится на каждом внутреннем цикле. Другими словами, мы измеряем время не в точности того же самого кода, но относительные скорости проверяемых версий Python сохраняются.

Измерение времени выполнения многострочных операторов

Для измерения времени более крупных многострочных порций кода в режиме вызовов API-интерфейса необходимо применять разрывы строк и табуляции или пробелы с целью удовлетворения требованиям синтаксиса Python; код, прочитанный из файла исходного кода, уже им удовлетворяет. Поскольку в этом режиме вы передаете строковые объекты Python функции Python, то нет никаких соображений касательно командной оболочки, но нужно отменять вложенные кавычки, если они встречаются. Скажем, следующий код измеряет время альтернативных версий циклов из главы 13; ту же самую схему можно использовать при измерении времени выполнения альтернативных версий для чтения строк из файла, представленных в главе 14:

c:\code> py -3
>>> import timeit
>>> min(timeit.repeat(number=10000, repeat=3,
    stmt="L = [1, 2, 3, 4, 5]\nfor i in range(len(L)) : L[i] += 1"))
0.01397292797131814
>>> min(timeit.repeat(number=10000, repeat=3,
    stmt="L = [1, 2, 3, 4, 5]\ni=0\nwhile i < len(L):\n\tL[i] += 1\n\ti += 1"))
0.015452276471516813
>>> min(timeit.repeat(number=10000, repeat=3,
    stmt="L = [1, 2, 3, 4, 5]\nM = [x + 1 for x in L]"))
0.009464995838568635

Чтобы работать с такими многострочными операторами в режиме командной строки, понадобится передавать каждую строку оператора как отдельный аргумент с пробельными символами для отступа — модуль timeit объединяет все строки вместе с символами новой строки между ними, и позже делает отступы в собственных целях вложения операторов. В этом режиме ведущие пробелы могут работать для отступов лучше табуляций, и аргументы кода важно помещать в кавычки, если того требует командная оболочка:

c:\code> py -3 -m timeit -n 1000 -r 3 "L = [1,2,3,4,5]" "i=0" "while i < len(L) :"
    "    L[i] += 1" "    i += 1"
1000 loops, best of 3: 1.54 usec per loop
c:\code> py -3 -m timeit -n 1000 -r 3 "L = [1,2,3,4,5]" "M = [x + 1 for x in L]"
1000 loops, best of 3: 0.959 usec per loop

Другие режимы использования: настройка, суммарное время и объекты

Модуль timeit также позволяет предоставлять код настройки, который выполняется в области видимости главного оператора, но время его выполнения не учитывается в суммарном времени главного оператора. Это потенциально удобно для кода инициализации, импортирующего обязательные модули, определяющего тестируемую функцию и создающего тестовые данные, время выполнения которого желательно исключить из суммарного времени. Поскольку код настройки запускается в той же области видимости, все создаваемые им имена доступны главному оператору; имена, определяемые в интерактивной оболочке, обычно недоступны.