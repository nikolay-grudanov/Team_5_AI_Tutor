---
source_image: page_514.png
page_number: 514
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 37.18
tokens: 7949
characters: 3331
timestamp: 2025-12-24T01:23:26.296131
finish_reason: stop
---

Присваивание внутри функции создает локальную переменную X, которая полностью отличается от глобальной переменной X в модуле за пределами функции. Как следствие, изменить имя, определенное вне функции, не получится без добавления в def объявления global (или nonlocal), что объясняется в следующем разделе.

Примечание, касающееся нестыковки версий. Как ни странно, но скороговорки порой даются легче. Используемый здесь модуль builtins из Python 3.X в Python 2.X называется __builtin__. Вдобавок имя __builtins__ (с буквой s) предварительно установлено в большинстве глобальных областей видимости, включая интерактивный сеанс, для ссылки на модуль, известный как builtins в Python 3.X и __builtin__ в Python 2.X, так что часто можно применять __builtins__ без импортирования, но нельзя выполнить импортирование для самого этого имени — оно представляет собой предустановленную переменную, а не имя модуля.

То есть в Python 3.X выражение builtins is __builtins__ дает True после импортирования builtins, а в Python 2.X выражение __builtin__ is __builtins__ будет True после импортирования __builtin__. В результате мы обычно можем инспектировать встроенную область видимости, просто выполняя dir(__builtins__) без какого-либо импортирования в Python 3.X и 2.X, но рекомендуется использовать builtins для реальной работы и настройки в Python 3.X и __builtin__ для того же самого в Python 2.X. Кто сказал, что документировать такое поведение было просто?

Разрушение мироздания в Python 2.X

Есть еще одна вещь, которую вы можете делать в Python, но вероятно не должны. Из-за того, что имена True и False в Python 2.X являются всего лишь переменными во встроенной области видимости и не зарезервированы, вполне возможно присвоить их заново с помощью оператора наподобие True = False. Не волнуйтесь: поступив так, вы в действительности не нарушите логическую согласованность мироздания! Данный оператор просто переопределяет слово True для единственной области видимости, в которой он появляется, чтобы оно возвращало False. Все остальные области видимости по-прежнему ищут оригиналы во встроенной области видимости.

Однако ради еще большей забавы в Python 2.X вы могли бы выполнить __builtin__.True = False, чтобы переустановить True в False для всего процесса Python. Присваивание работает, поскольку в программе существует лишь один модуль со встроенной областью видимости, разделяемый всеми его клиентами. Увы, присваивание подобного вида в Python 3.X было запрещено, потому что True и False там трактуются как зарезервированные слова, в точности как None. Тем не менее, в Python 2.X оно переводит IDLE в странное состояние паники, сбрасывающее процесс пользовательского кода (словом, не повторяйте это дома, ребята).

Однако такая методика может быть полезной для иллюстрации лежащей в основе модели пространств имен и для разработчиков инструментов, которым требуется изменять встроенные имена вроде open с целью настройки функций. За счет переопределения имени функции во встроенной области видимости вы переустанавливаете его в настроенную версию для всех модулей в процессе. В таком случае вам, вероятно, также понадобится запомнить первоначальную версию, чтобы вызывать ее в настроенной версии — фактически один из способов создать специальную функцию open описан во врезке "Что потребует внимания: настройка open" в конце