---
source_image: page_526.png
page_number: 526
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 33.75
tokens: 7809
characters: 2853
timestamp: 2025-12-24T01:23:46.567780
finish_reason: stop
---

использовали стандартные значения в точности как для операторов def. Например, приведенный ниже код работает во всех выпусках Python:

def func():
    x = 4
    action = (lambda n, x=x: x ** n)    # Передача x вручную
    return action

Поскольку lambda являются выражениями, они естественно (и даже обычно) вкладываются внутрь объемлющих операторов def. Следовательно, видимо именно они извлекли наибольшую выгоду от добавления в правила поиска областей видимости вложенных функций; в большинстве случаев теперь отсутствует необходимость передавать значения в выражения lambda с помощью стандартных значений.

Переменные цикла могут требовать стандартные значения,
а не области видимости

Есть одно заметное исключение из только что изложенного правила (и причина, по которой была показана вышедшая из употребления методика со стандартными значениями аргументов). Если выражение lambda или оператор def, определяемый внутри функции, вкладывается в цикл, а вложенная функция ссылается на переменную из объемлющей области видимости, которая изменяется этим циклом, то все функции, генерируемые внутри цикла, будут иметь одно и то же значение — значение ссылаемой переменной на последней итерации цикла. В таких случаях для сохранения текущего значения переменной приходится применять стандартные значения.

Ситуация может показаться не вполне ясной, но на практике она встречается чаще, чем вы могли подумать, особенно в коде, который генерирует функции обработчиков обратного вызова для виджетов в графическом пользовательском интерфейсе — например, обработчики щелчков для всех кнопок в строке. Если они создаются в цикле, тогда может возникнуть необходимость в сохранении состояния посредством стандартных значений, иначе обратные вызовы всех кнопок в итоге станут выполнять одно и то же действие.

Ниже представлена упрощенная иллюстрация данного явления: здесь предпринимается попытка построить список функций, каждая из которых запоминает текущее значение переменной i из объемлющей области видимости:

>>> def makeActions():
acts = []
for i in range(5):    # Попытка запомнить каждое значение i
    acts.append(lambda x: i ** x) # Но все функции запоминают
    # последнее значение i!
return acts

>>> acts = makeActions()
>>> acts[0]
<function makeActions.<locals>.<lambda> at 0x000000002A4A400>

Тем не менее, код не работает должным образом — из-за того, что переменная из объемлющей области видимости ищется, когда функции вызываются в более позднее время, все они фактически запоминают то же самое значение: значение, которое переменная цикла имела на последней итерации цикла. То есть при передаче аргумента степени 2 в каждом из следующих вызовов мы получаем обратно 4, возведенное в степень 2, для каждой функции в списке, т.к. значение i во всех функциях одинаково — 4:

>>> acts[0](2)    # Все возвращают 4 ** 2; 4 - последнее значение i