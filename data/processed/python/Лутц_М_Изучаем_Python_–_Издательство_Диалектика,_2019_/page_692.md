---
source_image: page_692.png
page_number: 692
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 40.13
tokens: 8003
characters: 3316
timestamp: 2025-12-24T01:28:58.106592
finish_reason: stop
---

3. Выполнение файла модуля

На финальном шаге операции импортирования выполняется байт-код модуля. Все операции в файле выполняются по очереди, от начала до конца, и любые присваивания именам на данном шаге генерируют атрибуты результирующего объекта модуля. Так создаются инструменты, определяемые кодом модуля. Скажем, операторы def в файле запускаются на стадии импортирования для создания объектов функций и их присваивания атрибутам внутри объекта модуля. Функции затем вызываются в файлах, импортирующих файл модуля.

Из-за того, что последний шаг импортирования фактически выполняет код файла, если любой код верхнего уровня в файле модуля делает реальную работу, то ее результаты будут видны во время импортирования. Например, операторы print верхнего уровня в модуле отображают вывод при импортировании файла. Операторы def для функций просто определяют объекты для использования в будущем.

Как видите, операции импортирования включают в себя довольно много работы — они ищут файлы, возможно, запускают компилятор и выполняют код Python. По этой причине любой заданный модуль импортируется по умолчанию только один раз на процесс. Будущие операции импортирования пропускают все три шага и повторно используют уже загруженный модуль в памяти. Если файл нужно импортировать снова после того, как он был загружен (скажем, для поддержки динамических настроек со стороны конечного пользователя), тогда придется применить вызов imp.reload — инструмент, с которым мы встретимся в следующей главе2.

Файлы байт-кода: __pycache__ в Python 3.2+

Ранее кратко упоминалось, что способ, которым Python сохраняет файлы для запоминания байт-кода, полученного в результате компиляции исходного кода, в Python 3.2 и последующих версиях изменился. Прежде всего, если по какой-либо причине Python не удается записать файл, чтобы сохранить байт-код на компьютере, то программа все равно нормально выполнится — Python просто создает и использует байт-код в памяти и по завершении программы отбрасывает его. Однако для ускорения начального запуска он пытается сохранить байт-код в файле, чтобы в следующий раз пропустить шаг компиляции. Способ, которым это делается, зависит от версии Python.

В Python 3.1 и предшествующих версиях (включая все версии Python 2.x)

Байт-код сохраняется в файлах внутри того же самого каталога, где находятся соответствующие файлы исходного кода, обычно с расширением .pyc (например, module.pyc). Файлы байт-кода также внутренне снабжаются меткой с номером версии Python, в которой они создавались (известной разработчикам как "магическое" поле), поэтому Python известно о том, что они должны быть заново скомпилированы, когда программа запускается под управлением другой версии Python. Скажем, если вы провели модернизацию до новой версии Python, где байт-код отличается, тогда все ваши файлы байт-кода автоматически перекомпилируются из-за несовпадения номеров версий даже при отсутствии каких-либо изменений в исходном коде.

2 Как было описано ранее, Python хранит уже импортированные модули во встроенном словаре sys.modules, поэтому он в состоянии отслеживать, что было загружено. На самом деле, если вы хотите выяснить, какие модули загружены, то можете импортировать sys и вывести list(sys.modules.keys()). Другие сценарии применения внутреннего словаря sys.modules приводятся в главе 25.