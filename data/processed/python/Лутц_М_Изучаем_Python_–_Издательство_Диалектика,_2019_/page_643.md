---
source_image: page_643.png
page_number: 643
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 41.02
tokens: 8007
characters: 2505
timestamp: 2025-12-24T01:27:27.644561
finish_reason: stop
---

Расширенный синтаксис включений для множеств и словарей

Подобно списковым включениям и генераторным выражениям включения множеств и словарей поддерживают вложенные ассоциированные конструкции if для фильтрации элементов результата — в следующем примере накапливаются квадраты четных чисел (т.е. чисел, которые делятся на 2 без остатка) в диапазоне:

```python
>>> [x * x for x in range(10) if x % 2 == 0]    # Списки упорядочиваются
[0, 4, 16, 36, 64]
>>> {x * x for x in range(10) if x % 2 == 0}    # Но множества - нет
{0, 16, 4, 64, 36}
>>> {x: x * x for x in range(10) if x % 2 == 0}    # Ключи словаря тоже
# не упорядочиваются
{0: 0, 8: 64, 2: 4, 4: 16, 6: 36}
```

Вложенные циклы for также работают, хотя неупорядоченная и не допускающая дубликатов природа объектов обоих типов может сделать результаты менее прямолинейными для понимания:

```python
>>> [x + y for x in [1, 2, 3] for y in [4, 5, 6]]    # Списки сохраняют дубликаты
[5, 6, 7, 6, 7, 8, 7, 8, 9]
>>> {x + y for x in [1, 2, 3] for y in [4, 5, 6]}    # Но множества - нет
{8, 9, 5, 6, 7}
>>> {x: y for x in [1, 2, 3] for y in [4, 5, 6]}    # Ключи словаря тоже
# не сохраняют дубликаты
{1: 6, 2: 6, 3: 6}
```

Подобно списковым включениям разновидности включений множеств и словарей также могут выполнять проход по итерируемым объектам любого типа — спискам, строкам, файлам, диапазонам и всему остальному, что поддерживает протокол итерации:

```python
>>> {x + y for x in 'ab' for y in 'cd'}
{'ac', 'bd', 'bc', 'ad'}
>>> {x + y: (ord(x), ord(y)) for x in 'ab' for y in 'cd'}
{'ac': (97, 99), 'bd': (98, 100), 'bc': (98, 99), 'ad': (97, 100)}
>>> {k * 2 for k in ['spam', 'ham', 'sausage'] if k[0] == 's'}
{'sausagesausage', 'spampspam'}
>>> {k.upper(): k * 2 for k in ['spam', 'ham', 'sausage'] if k[0] == 's'}
{'SAUSAGE': 'sausagesausage', 'SPAM': 'spampspam'}
```

Для лучшего освоения описанных инструментов поэкспериментируйте с ними самостоятельно. Они могут иметь либо не иметь преимущества в плане производительности перед альтернативами в виде генераторов или циклов for, но чтобы удостовериться в этом, нам нужно явно измерить время их выполнения — и мы естественным образом переходим к тематике следующей главы.

Резюме

Глава завершает наш обзор встроенных инструментов включений и итерации. Были исследованы списковые включения в контексте инструментов функционального программирования, а также представлены генераторные функции и выражения как дополнительные инструменты протокола итерации. Вдобавок мы подытожили четы-