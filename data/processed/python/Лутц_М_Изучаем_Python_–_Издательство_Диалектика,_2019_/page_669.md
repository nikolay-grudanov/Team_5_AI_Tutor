---
source_image: page_669.png
page_number: 669
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 34.75
tokens: 7900
characters: 2708
timestamp: 2025-12-24T01:28:11.438665
finish_reason: stop
---

Как видите, в большинстве тестов версия CPython 2.7 по-прежнему быстрее CPython 3.7, а PyPy значительно быстрее обеих версий за исключением последнего теста, где PyPy в два раза медленнее CPython предположительно из-за отличий в управлении памятью. С другой стороны, результаты измерения времени часто в лучшем случае относительны. Помимо упомянутых ранее предупреждений общего характера, касающихся измерения времени, ниже перечислены дополнительные замечания.

• Модуль timeit может искажать результаты по причинам, которые выходят за рамки исследованных здесь (скажем, из-за сборки мусора).

• Существует базовый уровень издержек, отличающийся в зависимости от версии Python, который здесь игнорируется (но выглядит тривиальным).

• Сценарий выполняет очень маленькие операторы, которые могут отражать или не отражать реальный код (но все равно они действительно).

• Результаты могут изредка варьироваться по причинам, которые кажутся случайными (здесь может помочь применение времени процесса).

• Все результаты крайне подвержены изменениям с течением времени (на самом деле в каждом новом выпуске Python!).

Таким образом, вы должны выработать собственные заключения в отношении продемонстрированных выше показаний и прогонаять такие тесты на своих версиях Python и компьютерах для получения более значимых результатов. Для хронометража базового уровня издержек каждой версии Python запустите timeit, не передавая никаких операторов в аргументе, или передайте оператор pass, что эквивалентно.

Продолжаем забавляться с оценочными испытаниями

Чтобы еще лучше уловить суть, попробуйте выполнить сценарий в других версиях Python и с другими строками операторов. В файле pybench_cases2.py из пакета примеров добавлены тесты для сравнения CPython 3.7 и CPython 3.2, бета-версии PyPy 2.0 и PyPy 1.9, а также демонстрации дополнительных вариантов использования.

Выигрыш map и редкий проигрыш PyPy

Например, следующие тесты в pybench_cases2.py измеряют влияние нагрузки со стороны других итерационных операций с вызовом функции, что повышает шансы на выигрыш у map; согласно замечанию, сделанному ранее в главе, map обычно проигрывает в целом из-за своей ассоциации с вызовами функций:

# Файл pybench_cases2.py
pythons += [
    (1, 'C:\\python32\\python'),
    (0, 'C:\\pypy\\pypy-2.0-beta1\\pypy')]
stmts += [
    # Использовать вызовы функций: map выигрывает
    (0, 0, "[ord(x) for x in 'spam' * 2500]"),
    (0, 0, "res=[]\nfor x in 'spam' * 2500: res.append(ord(x))"),
    (0, 0, "$listif3(map(ord, 'spam' * 2500))"),
    (0, 0, "list(ord(x) for x in 'spam' * 2500)"),
    # Множества и словари
    (0, 0, "{x ** 2 for x in range(1000)}"),
    (0, 0, "s=set()\nfor x in range(1000): s.add(x ** 2)")],