---
source_image: page_277.png
page_number: 277
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 32.31
tokens: 7882
characters: 3077
timestamp: 2025-12-24T01:15:53.088580
finish_reason: stop
---

Сравнение и сортировка в Python 3.x. Как было отмечено в главе 5, в Python 2.x сравнение относительных величин по-разному типизированных объектов (например, строки и списка) работает — язык определяет среди разных типов фиксированный порядок, который является детерминированным, пусть и не эстетически привлекательным. Упорядочение основано на именах участвующих типов: скажем, все целые числа меньше всех строк, потому что "int" меньше, чем "str". Сравнения никогда не преобразуют типы автоматически кроме случаев, когда сравниваются объекты числовых типов.

В Python 3.x ситуация изменилась: сравнение величин объектов смешанных типов вызывает исключение, а не следование фиксированному порядку между типами. Поскольку сортировка внутренне применяет сравнения, это означает, что [1, 2, 'spam'].sort() успешно выполнится в Python 2.x, но сгенерирует исключение в Python 3.x. Сортировка не работает по определению.

Кроме того, в Python 3.x больше не поддерживается передача методу sort произвольной функции сравнения для реализации разных порядков. Обходной путь предполагает использование ключевого аргумента key=функция для кодирования трансформаций значений во время сортировки и ключевого аргумента reverse=True для изменения порядка сортировки на убывающий. Так выглядели типичные применения функций сравнения в прошлом.

Одно предостережение: помните о том, что append и sort изменяют ассоциированный списковый объект на месте, но не возвращают список в качестве результата (формально оба метода возвращают значение None). Если вы запишете что-то вроде L=L.append(X), то не получите модифицированное значение L (на самом деле вы вообще утратите ссылку на список!). Когда используются такие атрибуты, как append и sort, объекты изменяются в форме побочного эффекта, поэтому нет причин при-сваивать повторно.

Отчасти из-за таких ограничений в последних версиях Python сортировка также доступна в виде встроенной функции, которая сортирует любую коллекцию (не только списки) и возвращает в качестве результата новый список (вместо изменений на месте):

>>> L = ['abc', 'ABD', 'aBe']
>>> sorted(L, key=str.lower, reverse=True)   # Встроенная функция сортировки
['aBe', 'ABD', 'abc']
>>> L = ['abc', 'ABD', 'aBe']
>>> sorted([x.lower() for x in L], reverse=True)   # Предварительно трансформирует
# элементы: отличается!
['abe', 'abd', 'abc']

Обратите внимание на последний пример — мы можем выполнить преобразование в нижний регистр с помощью спискового включения перед сортировкой, но результат не содержит значения исходного списка, как было бы в случае аргумента key. Преобразование, указанное в аргументе key, применяется временно в течение сортировки, не изменяя исходные значения. Позже вы увидите контексты, в которых встроенная функция sorted иногда может оказываться более удобной, чем метод sort.

Другие распространенные списковые методы

Как и строки, списки располагают дополнительными методами, которые выполняют другие специализированные операции. Например, reverse меняет порядок следования элементов в списке на противоположный (обращает список) на месте,