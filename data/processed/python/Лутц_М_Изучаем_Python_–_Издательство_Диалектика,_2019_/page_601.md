---
source_image: page_601.png
page_number: 601
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 36.66
tokens: 7906
characters: 2752
timestamp: 2025-12-24T01:26:06.700621
finish_reason: stop
---

>>> res
[115, 112, 97, 109]

Списковые включения накапливают результаты применения произвольного выражения к итерируемому объекту, содержащему значения, и возвращают их в новом списке. Синтаксически списковые включения помещаются в квадратные скобки, чтобы напоминать о том, что они строят списки. В самой простой форме внутри квадратных скобок записывается выражение, указывающее переменную, за которой следует то, что выглядит похожим на заголовок цикла for, где задействована та же самая переменная. Затем Python накапливает результаты выражения для каждой итерации подразумеваемого цикла.

Эффект предыдущего примера аналогичен эффекту написанного вручную цикла for и вызова map. Однако списковые включения становятся более удобными, когда мы хотим применить к итерируемому объекту произвольное выражение, а не функцию:

>>> [x ** 2 for x in range(10)]
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

Здесь мы накапливаем квадраты чисел от 0 до 9 (мы просто позволяем интерактивной подсказке вывести результирующий списоковый объект; если хотите сохранить его, тогда присвойте какой-нибудь переменной). Чтобы выполнить подобную работу посредством вызова map, нам видимо потребуется создать небольшую функцию для операции возведения в квадрат. Из-за того, что эта функция больше нигде не нужна, она обычно (но не обязательно) записывается как внутристочная с помощью lambda, а не с использованием оператора def где-то в другом месте:

>>> list(map((lambda x: x ** 2), range(10)))
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

Код делает ту же самую работу и лишь немного длиннее эквивалентного спискового включения. Он также в самой минимальной степени сложнее (во всяком случае, если вы понимаете lambda). Но для более замысловатых разновидностей выражений списковые включения часто будут требовать гораздо меньшего объема набора. В следующем разделе показано почему.

Добавление проверок и вложенных циклов: filter

Списковые включения даже более универсальны, чем иллюстрировалось до сих пор. Скажем, как известно из главы 14, после for можно поместить конструкцию if, чтобы добавить логику выбора. Списковые включения с конструкциями if можно считать аналогом встроенной функции filter, обсуждаемой в предыдущей главе — они пропускают элементы итерируемого объекта, для которых конструкция if не дает истинное значение.

В целях демонстрации ниже показаны схемы выбора четных чисел от 0 до 4; подобно альтернативе map в виде спискового включения из предыдущего раздела версия с filter здесь должна создавать небольшую функцию lambda для проверочного выражения. Для сравнения также приведен эквивалентный цикл for:

>>> [x for x in range(5) if x % 2 == 0]
[0, 2, 4]

>>> list(filter((lambda x: x % 2 == 0), range(5)))
[0, 2, 4]

>>> res = []
>>> for x in range(5):