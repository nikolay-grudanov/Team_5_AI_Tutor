---
source_image: page_288.png
page_number: 288
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 32.87
tokens: 7830
characters: 2786
timestamp: 2025-12-24T01:16:15.013546
finish_reason: stop
---

Замечания по использованию словарей

Словари окажутся довольно-таки прямолинейными инструментами, как только вы освоитесь с ними, но ниже приведено несколько дополнительных указаний и памяток, о которых следует знать, имея дело со словарями.

• Операции над последовательностями не работают. Словари являются отображениями, не последовательностями; поскольку понятие порядка среди их элементов отсутствует, вещи вроде конкатенации (упорядоченное объединение) и нарезания (извлечение непрерывной секции) попросту неприменимы. В действительности Python инициирует ошибку во время выполнения кода, в котором предпринимается попытка сделать что-то подобное.

• Присваивание по новым индексам добавляет элементы. Ключи могут создаваться при написании словарного литерала (встраиваться в код самого литерала) либо во время присваивания значений новым ключам существующего объекта словаря на индивидуальной основе. Конечный результат будет таким же.

• Ключи не обязаны всегда быть строками. До сих пор в примерах в качестве ключей использовались строки, но допускается применять любые неизменяемые объекты. Скажем, вы можете использовать для ключей целые числа, что сделает словарь очень похожим на список (во всяком случае, при индексировании). Кортежи также могут применяться как ключи словаря, позволяя составным значениям ключей, таким как даты и IP-адреса, иметь ассоциированные значения. Ключами могут выступать объекты классов, определяемых пользователем (обсуждаются в части VI), при наличии в них подходящих протокольных методов. Грубо говоря, им необходимо сообщить Python о том, что их значения являются "хешируемыми" и потому изменяться не будут, т.к. иначе они оказались бы бесполезными как фиксированные ключи. Изменяемые объекты вроде списков, множеств и других словарей не могут быть ключами, но разрешены в качестве значений.

Использование словарей для имитации гибких списков: целочисленные ключи

Последний пункт в списке выше достаточно важен, чтобы продемонстрировать его на нескольких примерах. В случае применения списков присваивать по смещению, попадающему за конец списка, запрещено:

>>> L = []
>>> L[99] = 'spam'
Traceback (most recent call last):
    File "<stdin>", line 1, in ?
IndexError: list assignment index out of range
Трассировка (самый последний вызов указан последним):
    Файл <stdin>, строка 1, в ?
Ошибка индекса: присваивание в списке по индексу, выходящему за допустимые пределы

Несмотря на то что вы можете использовать повторение для предварительного выделения такого объема памяти, который необходим для списка (например, [0]*100), что-то похожее можно делать со словарями, не требующими такого выделения памяти. За счет применения целочисленных ключей словари способны имитировать списки, которые увеличиваются при присваивании по смещению: