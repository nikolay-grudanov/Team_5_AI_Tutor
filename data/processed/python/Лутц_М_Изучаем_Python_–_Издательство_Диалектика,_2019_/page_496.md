---
source_image: page_496.png
page_number: 496
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 36.26
tokens: 7894
characters: 3035
timestamp: 2025-12-24T01:22:52.892559
finish_reason: stop
---

• yield отправляет результирующий объект вызывающему коду, но запоминает место, где он остановился. В функциях, известных как генераторы, можно также использовать оператор yield, чтобы посылать обратно значение и предохранять их состояние, так что они смогут возобновлять работу позже для производства серии результатов с течением времени. Это еще одна сложная тема, которая раскрывается в последующих главах данной части книги.

• global объявляет переменные уровня модуля, предназначенные для присваивания. По умолчанию все имена, присваиваемые в функции, являются локальными для функции и существуют только во время ее выполнения. Чтобы присвоить значение имени из включающего модуля, необходимо указать его в операторе global внутри функции. В более общем смысле имена всегда ищутся в областях видимости — местах хранения переменных — и присваивания привязывают имена к областям видимости.

• nonlocal объявляет переменные объемлющей функции, предназначенные для присваивания. Подобным образом оператор nonlocal, появившийся в Python 3.x, позволяет функции присваивать имя, которое существует в области видимости синтаксически объемлющего оператора def. В итоге объемлющие функции могут служить местом сохранения состояния, т.е. информации, запоминаемой между вызовами функции, без потребности в применении разделяемых глобальных имен.

• Аргументы передаются по присваиванию (по ссылкам на объекты). В Python аргументы передаются функциям по присваиванию (которое, как вы знаете, означает ссылку на объект). Вы увидите, что в модели Python вызывающий код и функция разделяют объекты по ссылкам, но псевдонимы имен отсутствуют. Изменение имени аргумента внутри функции не приводит к изменению соответствующего имени в вызывающем коде, но модификация на месте переданных изменяемых объектов может изменить объекты, разделяемые с вызывающим кодом, и служит результатом функции.

• Аргументы передаются по позиции, если только не указано иначе. Значения, передаваемые вызову функции, по умолчанию сопоставляются с именами аргументов в определении функции слева направо. Ради гибкости вызовам функций можно также передавать аргументы по имени с помощью синтаксиса ключевых слов имя=значение и распаковывать произвольно много аргументов для отправки посредством снабжения аргументов звездочками — *позиционные_аргументы и **ключевые_аргументы. Определения функций используют те же две формы для указания стандартных значений аргументов и сбора произвольно большого количества получаемых аргументов.

• Аргументы, возвращаемые значения и переменные не объявляются. Как и абсолютно все в Python, на функции не налагается никаких ограничений по типам. Фактически объявлять заранее о чем-либо, касающемся функции, не нужно: можно передавать аргументы любого типа, возвращать объект любого вида и т.д. Отсюда следует, что единственный вызов функции часто может применяться к разнообразным типам объектов — подойдут любые объекты, которые поддерживают совместимый интерфейс (методы и операции выражений), независимо от их специфических типов.