---
source_image: page_259.png
page_number: 259
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 30.45
tokens: 7877
characters: 2578
timestamp: 2025-12-24T01:15:10.735626
finish_reason: stop
---

На практике жесткое кодирование ссылок в программах встречается с меньшей вероятностью, чем выполнение кода, который заблаговременно создает набор данных для подстановки (например, накапливает данные из формы ввода или базы данных с целью подстановки в HTML-шаблон всех за раз). Когда мы учитываем общую практику в примерах, сравнение между методом format и выражением % становится даже более ясным:

# Заблаговременное создание данных двумя способами
>>> data = dict(platform=sys.platform, kind='laptop')
>>> 'Му {kind:<8} runs {platform:>8}'.format(**data)
'My laptop runs win32'
>>> 'Му %(kind)-8s runs %(platform)8s' % data
'My laptop runs win32'

Как будет показано в главе 18, здесь **data в вызове метода является специальным синтаксисом, который распаковывает словарь ключей и значений в индивидуальные присваивания ключевых слов "имя=значение", так что на них можно ссылаться по имени в строке формата. Это еще одна неизбежная и крайне концептуальная опережающая ссылка на инструменты вызова функций, что может быть очередным недостатком метода format в целом, особенно для новичков.

Однако, как обычно, сообществу языка Python придется решать, что с течением времени зарекомендовало себя лучше — выражения %, вызовы метода format или же инструментальный набор с обеими методиками. Самостоятельно поэкспериментируйте с методиками, чтобы получить представление о том, что они предлагают, и обязательно просмотрите руководства по библиотеке для Python 2.6, 3.0 и последующих версий.

Улучшения строкового метода format в версиях Python 3.1 и 2.7. В версиях Python 3.1 и 2.7 добавился синтаксис разделителя тысяч для чисел, который позволяет вставлять запятые между группами из трех цифр. Чтобы разделитель тысяч заработал, поместите запятую перед кодом типа, а также между шириной и точностью, если они присутствуют:

>>> '{0:d}'.format(999999999999)
'999999999999'
>>> '{0:,d}'.format(999999999999)
'999,999,999,999'

Кроме того, в версиях Python 3.1 и 2.7 целям подстановки автоматически назначаются относительные номера, если они не указываются явно, хотя такое расширение неприменимо во всех сценариях использования и может нивелировать одно из главных преимуществ метода форматирования — более ясный код:

>>> '{:,d}'.format(999999999999)
'999,999,999,999'
>>> '{:,d} {:,d}'.format(99999999, 88888888)
'9,999,999 8,888,888'
>>> '{:.2f}'.format(296999.2567)
'296,999.26'

Дополнительные сведения ищите в пояснениях к выпуску Python 3.1. Также просмотрите примеры функций вставки запятых и форматирования денежных величин formats.py в главе 25 для ознакомления с про-