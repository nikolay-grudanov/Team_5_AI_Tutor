---
source_image: page_764.png
page_number: 764
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 28.78
tokens: 7905
characters: 3050
timestamp: 2025-12-24T01:31:01.353689
finish_reason: stop
---

В сущности, переменная __name__ модуля служит флагом режима использования, позволяющим его коду быть задействованным как импортируемая библиотека и как сценарий верхнего уровня. Несмотря на простоту, вы увидите, что такая привязка применяется в большинстве программных файлов Python, с которыми вам придется сталкиваться в реальном мире — для тестирования и для двойного использования.

Скажем, пожалуй, самый распространенный вид применения проверки атрибута __name__ предназначен для кода самотестирования. Выражаясь кратко, вы можете упаковать код, который тестирует экспортимые средства модуля, в сам модуль за счет его помещения внутрь проверки атрибута __name__ в конце файла. Таким образом, файл можно использовать в клиентах, импортируя его, но также тестировать его логику, запуская файл в командной оболочке или посредством другой схемы запуска.

Размещение кода самотестирования в конце файла внутри проверки атрибута __name__ является, вероятно, наиболее часто применяемым и простым протоколом модульного тестирования в Python. Это гораздо удобнее, чем повторно набирать все тесты в интерактивной подсказке. (В главе 36 будут обсуждаться другие распространенные варианты для тестирования кода Python — как вы увидите, стандартные библиотечные модули unittest и doctest предлагают много расширенных инструментов тестирования.)

Вдобавок трюк с атрибутом __name__ также часто используется при создании файлов, которые могут применяться как утилиты командной строки и как библиотеки инструментов. Например, предположим, что вы пишете на Python сценарий для поиска файлов. Вы можете извлечь из своего кода больше пользы, если упакуете его в функции и добавите в файл проверку атрибута __name__ для автоматического вызова этих функций при запуске файла как автономной программы. В результате код сценария становится многократно используемым в других программах.

Модульное тестирование с помощью __name__

На самом деле в книге уже приводился хороший пример ситуации, где проверка атрибута __name__ оказывается удобной. При рассмотрении аргументов в главе 18 мы писали сценарий, который вычислял минимальное значение из множества переданных аргументов (файл minmax.py в разделе "Функция min"):

def minmax(test, *args):
    res = args[0]
    for arg in args[1:]:
        if test(arg, res):
            res = arg
    return res

def lessthan(x, y): return x < y
def grtrthan(x, y): return x > y

print(minmax(lessthan, 4, 2, 1, 5, 6, 3))   # Тестовый код
print(minmax(grtrthan, 4, 2, 1, 5, 6, 3))

Сценарий содержит в конце код самотестирования, поэтому его можно тестировать, не набирая при каждом запуске аргументы в командной оболочке. Тем не менее, проблема такой реализации заключается в том, что результаты самотестирования будут выводиться всякий раз, когда файл импортируется в другом файле с целью применения в качестве инструмента — не вполне дружественная к пользователю особенность! Чтобы улучшить положение дел, мы можем поместить код самотестирования внутрь проверки атрибута __name__, так что он будет выполняться только в случае