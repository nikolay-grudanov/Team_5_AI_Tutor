---
source_image: page_107.png
page_number: 107
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 40.51
tokens: 7965
characters: 3363
timestamp: 2025-12-24T01:10:26.130447
finish_reason: stop
---

ременных, т.е. пространством имен. Не менее важно и то, что каждый модуль представляет собой автономное пространство имен: один файл модуля не может видеть имена, определенные в другом файле, до тех пор, пока явно не импортирует другой файл. Из-за этого модули содействуют минимизации конфликтов имен в коде — поскольку каждый файл является автономным пространством имен, имена в одном файле не могут конфликтовать с именами в другом файле, даже если они написаны одинаково.

Фактически модули — один из немногих способов, которыми Python делает все возможное, чтобы упаковать ваши переменные в группы во избежание конфликтов имен. Позже в книге мы еще будем обсуждать модули и другие конструкции пространств имен, в том числе локальные области видимости, определяемые классами и функциями. А пока модули пригодятся в качестве способа многократного выполнения кода без необходимости в его повторном наборе и предотвращения непредумышленного замещения имен, определенных в файлах.

import или from. Важно отметить, что оператор from в некотором смысле аннулирует цель разделения на пространства имен, преследуемую модулями. Поскольку from копирует переменные из одного файла в другой, он безо всякого предупреждения может привести к переписыванию одинаково именованных переменных в файле, в который производится импорт. Такое действие по существу объединяет вместе пространства имен, во всяком случае, с точки зрения копируемых переменных.

По указанной причине некоторые рекомендуют всегда применять import, а не from. Тем не менее, я не буду заходить настолько далеко; оператор from не только требует меньшего клавиатурного набора (ценное качество при работе в интерактивной подсказке), но и описанная выше проблема на практике возникает довольно редко. Вдобавок это именно то, что вы контролируете, перечисляя желаемые переменные в операторе from. До тех пор, пока вы осознаете, что им будут присвоены значения в целевом модуле, такое действие не более опасно, чем операторы присваивания — еще одно средство, которым вы непременно будете пользоваться!

Замечания по использованию: import и reload

Почему-то когда люди узнают о выполнении файлов с применением операторов import и reload, то многие ограничиваются только ими и забывают о других вариантах запуска, которые всегда выполняют текущую версию кода (например, щелчки на значках, пункты меню IDLE и командная строка системы). Однако такой подход может быстро привести к путанице — вам необходимо помнить при импортировании, можете ли вы перезагружать, не забывать использовать круглые скобки в случае вызова reload (только) и помнить о применении в первую очередь reload для получения текущей версии выполняемого кода. Кроме того, перезагрузка не обладает переходным характером; перезагрузка воздействует только на указанный модуль, но не на модули, которые он может импортировать, поэтому иногда приходится перезагружать множество файлов.

Из-за описанных сложностей (и других, которые мы исследуем позже, в том числе проблемы reload/from, кратко упомянутой во врезке "На заметку!" ранее в главе) пока что в целом неплохо не поддаваться соблазну запускать файлы с помощью импортирования и перезагрузки. Например, описанный в следующем разделе пункт меню Run⇒Run Module (Выполнить⇒Выполнить модуль) в IDLE предоставляет более простой и менее подверженный ошибкам способ запуска файлов и всегда выполняет