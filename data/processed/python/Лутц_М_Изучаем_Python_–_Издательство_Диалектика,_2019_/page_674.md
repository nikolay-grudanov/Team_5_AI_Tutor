---
source_image: page_674.png
page_number: 674
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 39.07
tokens: 7973
characters: 2808
timestamp: 2025-12-24T01:28:24.163190
finish_reason: stop
---

Он предлагает еще один способ для измерения относительных скоростей выполнения реализаций Python и, кажется, в целом поддерживает наши выводы:

c:\Python37\Lib\test> cd C:\python37\lib\test
c:\Python37\Lib\test> py -3 pystone.py
Pystone(1.1) time for 50000 passes = 0.685303
This machine benchmarks at 72960.4 pystones/second
Pystone(1.1) время для 50000 проходов = 0.685303
Эталонные тесты на этой машине прошли со скоростью 72960.4 единиц pystone/c

c:\Python37\Lib\test> cd c:\python27\lib\test
c:\Python27\Lib\test> py -2 pystone.py
Pystone(1.1) time for 50000 passes = 0.463547
This machine benchmarks at 107864 pystones/second
Pystone(1.1) время для 50000 проходов = 0.463547
Эталонные тесты на этой машине прошли со скоростью 107864 единиц pystone/c

c:\Python27\Lib\test> c:\pypy\pypy-1.9\pypy pystone.py
Pystone(1.1) time for 50000 passes = 0.099975
This machine benchmarks at 500125 pystones/second
Pystone(1.1) время для 50000 проходов = 0.099975
Эталонные тесты на этой машине прошли со скоростью 500125 единиц pystone/c

Поскольку наступило время завершить главу, последнего должно быть достаточно для независимого подтверждения результатов выполненных тестов. Исследование смысла результатов теста pystone оставлено в качестве упражнения; его код не идентичен в версиях Python 3.x и 2.x, но похоже отличается лишь в том, что касается операций вывода и инициализации. Также имейте в виду, что оценочные испытания являются всего лишь одним из многих аспектов анализа кода Python; подсказки о вариантах в связанных предметных областях (например, тестировании) ищите в обзоре инструментов разработки на Python в главе 36.

Затруднения, связанные с функциями

Теперь, когда мы добрались до конца истории о функциях, давайте проанализируем связанные с ними распространенные затруднения. Функции обладают рядом тонких особенностей, о существовании которых вы можете даже не подозревать. Все они относительно малоизвестны, а некоторые полностью ушли в сторону от языка в последних выпусках, но большинство их продолжают сбивать с толку новичков.

Локальные имена распознаются статически

Как вам уже известно, по умолчанию Python классифицирует имена, присваиваемые в функции, как локальные, они существуют в области видимости функции только в период, пока она выполняется. Но вы можете не осознавать тот факт, что Python распознает локальные имена статически, когда компилирует код def, а не во время встречи присваиваний именам на стадии выполнения. Это приводит к одной из наиболее распространенных странностей, публикуемых в новостных группах начинающими. Обычно имя, которое не было присвоено в функции, ищется во включающем модуле:

>>> x = 99
>>> def selector():    # Имя X используется, но не присваивается
    print(x)           # Имя X найдено в глобальной области видимости
>>> selector()
99