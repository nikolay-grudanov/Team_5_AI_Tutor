---
source_image: page_499.png
page_number: 499
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 34.98
tokens: 7877
characters: 2977
timestamp: 2025-12-24T01:22:59.158097
finish_reason: stop
---

круглые скобки. Круглые скобки могут дополнительно содержать один и более объектов-аргументов, подлежащих передаче (присваиванию) именам в заголовке функции:

    >>> times(2, 4)        # Аргументы в круглых скобках
    8

Выражение вызова передает в times два аргумента. Как упоминалось ранее, аргументы передаются по присваиванию, так что в рассматриваемом случае имени x в заголовке функции присваивается значение 2, y присваивается значение 4 и тело функции выполняется. Телом функции times является всего лишь оператор return, который отправляет обратно результат в качестве значения выражения вызова. Возвращаемый объект был выведен интерактивно (как и в большинстве языков, в Python значением 2 * 4 будет 8), но если объект необходимо использовать позже, тогда его можно присвоить переменной. Вот пример:

    >>> x = times(3.14, 4)    # Сохранение результирующего объекта
    >>> x
    12.56

Давайте посмотрим, что происходит, когда функция вызывается с передачей объектов очень разных видов:

    >>> times('Ni', 4)        # Функции "лишены типов"
    'NiNiNiNi'

Теперь наша функция означает нечто совсем другое (здесь на ум приходит кинофильм "Монти Пайтон: а теперь нечто совсем другое"). В последнем вызове x и y вместо двух чисел передаются строка и целое число. Вспомните, что операция * работает с числами и последовательностями; поскольку в Python мы никогда не объявляем типы переменных, аргументов или возвращаемых значений, то в состоянии применять функцию times либо для умножения чисел, либо для повторения последовательностей.

Другими словами, смысл и работа функции times зависят от того, что мы ей передаем. В этом и заключается основная идея (и вероятно побудительная причина использовать язык), которая заслуживает некоторой детализации.

Полиморфизм в Python

Как только что выяснилось, сам смысл выражения x * y в нашей простой функции times зависит целиком от видов объектов, указываемых для x и y; таким образом, также самая функция способна выполнять умножение в одной ситуации и повторение в другой. Python оставляет на усмотрение объектов делать что-то разумное с точки зрения синтаксиса. Вообще говоря, операция * представляет собой всего лишь координирующий механизм, который передает контроль обрабатываемым объектам.

Поведение с зависимостью от типов подобного рода известно как полиморфизм — термин, впервые упомянутый в главе 4, который по существу означает, что смысл операции зависит от обрабатываемых ею объектов. Из-за того, что Python является динамически типизируемым языком, полиморфизм в нем буквально процветает. Фактически каждая операция в Python обладает полиморфизмом: вывод, индексация, операция * и многие другие.

Такое поведение неслучайно и в большой степени объясняет лаконичность и гибкость языка. Например, единственная функция обычно может применяться к целой категории типов объектов автоматически. До тех пор, пока объекты поддерживают ожидаемый интерфейс (он же протокол), функция в состоянии обрабатывать их.