---
source_image: page_774.png
page_number: 774
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 33.72
tokens: 7737
characters: 2569
timestamp: 2025-12-24T01:31:13.733244
finish_reason: stop
---

жением, которое выдает строку во время выполнения. Из-за этого все перечисленные далее выражения попадают на тот же самый атрибут и объект¹:

M.name                # Уточнение объекта атрибутом
M.__dict__['name']     # Ручная индексация словаря пространства имен
sys.modules['M'].name  # Ручная индексация таблицы загруженных модулей
getattr(M, 'name')     # Вызов встроенной функции извлечения

Делая видимыми внутренности модулей подобным образом, Python помогает строить программы о программах. Скажем, ниже показан код файла модуля по имени mydir.py, который воплощает описанные идеи в реализации настроенной версии встроенной функции dir. В нем определяется функция listing, которая принимает в качестве аргумента объект модуля и выводит форматированный листинг пространства имен этого модуля с сортировкой по имени:

#!/python
"""
mydir.py: модуль, который выводит листинг пространства имен другого модуля
"""
from __future__ import print_function    # Совместимость с Python 2.x
seplen = 60
sepchr = '-'

def listing(module, verbose=True):
    sepline = sepchr * seplen
    if verbose:
        print(sepline)
        print('name:', module.__name__, 'file:', module.__file__)
        print(sepline)
    count = 0
    for attr in sorted(module.__dict__):    # Просмотр ключей пространств
        # имен (или перечисление)
        print('%02d) %s' % (count, attr), end = ' ')
        if attr.startswith('__'):
            print('<built-in name>')      # Пропуск __file__ и т.д.
        else:
            print(getattr(module, attr))   # То же, что и .__dict__[attr]
        count += 1
    if verbose:
        print(sepline)
        print(module.__name__, 'has %d names' % count)
        print(sepline)
    if __name__ == '__main__':
        import mydir
        listing(mydir)    # Код самотестирования: список для самого себя

¹ Как кратко упоминалось в разделе "Другие способы доступа к глобальным переменным" главы 17, поскольку функция может получать доступ к ее включающему модулю через таблицу sys.modules вроде этой, она также может использоваться для эмуляции эффекта от оператора global. Например, эффект от global X; X=0 можно эмулировать (хотя и за счет набора намного большего объема кода!), поместив внутрь функции следующие операторы: import sys; glob=sys.modules[__name__]; glob.X=0. Не забывайте, что каждый модуль получает атрибут __name__ бесплатно; он является видимым как глобальное имя внутри функций в рамках модуля. Данный трюк предоставляет еще один способ изменения локальных и глобальных переменных с теми же самыми именами внутри функции.