---
source_image: page_156.png
page_number: 156
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 28.58
tokens: 7710
characters: 2473
timestamp: 2025-12-24T01:11:44.987508
finish_reason: stop
---

Код создает файл в текущем каталоге и записывает в него текст (имя файла может содержать полный путь к каталогу, если нужно получить доступ к файлу где-то в другом месте на компьютере). Чтобы прочитать то, что было записано, необходимо повторно открыть файл в режиме обработки 'r' для чтения текстового ввода (он выбирается по умолчанию, если в вызове строки режима не указана). Затем следует прочитать содержимое файла в строку и отобразить ее. В сценарии содержимое файла всегда будет строкой независимо от типа находящихся в нем данных:

```python
>>> f = open('data.txt')    # 'r' (чтение) - стандартный режим обработки
>>> text = f.read()         # Прочитать все содержимое файла в строку
>>> text
'Hello\nworld\n'
>>> print(text)             # print интерпретирует управляющие символы
Hello
world
>>> text.split()            # Содержимое файла - всегда строка
['Hello', 'world']
```

Другие методы объектов файлов поддерживают дополнительные возможности, которые здесь раскрываться не будут. Например, объекты файлов предоставляют больше способов чтения и записи (read принимает необязательный максимальный размер в байтах/символах, readline читает по одной строке за раз и т.д.), а также другие инструменты (seek перемещает в новую позицию внутри файла). Однако как вы увидите позже, лучший способ чтения файла в наше время — вообще его не читать, поскольку файлы предлагают итератор, который автоматически производит чтение строки за строкой в циклах for и других контекстах:

```python
>>> for line in open('data.txt'): print(line)
```

Мы будет сталкиваться с полным набором методов файлов в последующих главах, но если вы хотите получить краткий обзор прямо сейчас, тогда вызовите dir для любого открытого файла и help для любого имени метода, выведенного dir:

```python
>>> dir(f)
[...много имен не показано...
'buffer', 'close', 'closed', 'detach', 'encoding', 'errors', 'fileno', 'flush',
'isatty', 'line_buffering', 'mode', 'name', 'newlines', 'read', 'readable',
'readline', 'readlines', 'seek', 'seekable', 'tell', 'truncate',
'writable',
'write', 'writelines']
>>> help(f.seek)
...попробуйте и просмотрите...
```

Файлы с двоичными байтами

Примеры в предыдущем разделе иллюстрировали основы, которых во многих ситуациях вполне достаточно. Тем не менее, формально они полагаются либо на кодировку Unicode платформы, стандартную в Python 3.x, либо на 8-битную природу байтов в файлах Python 2.x. Текстовые файлы всегда кодируют строки в Python 3.x и слепо