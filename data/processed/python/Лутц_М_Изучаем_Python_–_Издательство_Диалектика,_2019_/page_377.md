---
source_image: page_377.png
page_number: 377
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 29.27
tokens: 7860
characters: 2782
timestamp: 2025-12-24T01:19:06.783204
finish_reason: stop
---

Зарезервированные слова в табл. 11.3 специфичны для Python 3.x. В Python 2.x набор зарезервированных слов слегка отличается:

• print — зарезервированное слово, потому что print является оператором, а не встроенной функцией (о чем пойдет речь позже в главе);
• exec — зарезервированное слово, т.к. exec является оператором, а не встроенной функцией;
• nonlocal — не зарезервированное слово, поскольку такой оператор отсутствует.

В более старых версиях Python положение дел более-менее такое же, но с несколькими вариациями:

• with и as не были зарезервированными словами до версии Python 2.6, когда официально стали доступными диспетчеры контекстов;
• yield не было зарезервированным словом до версии Python 2.3, когда появились генераторные функции;
• yield трансформировалось из оператора в выражение в версии Python 2.5, но по-прежнему является зарезервированным словом, а не встроенной функцией.

Как видите, большинство зарезервированных слов Python записано в нижнем регистре символов. Кроме того, они все по-настоящему зарезервированы — в отличие от имен во встроенной области видимости, которые встретятся в следующей части книги, вы не можете переопределять зарезервированные слова путем присваивания (например, and = 1 приводит к синтаксической ошибке)3.

Помимо представления в смешанном регистре символов первые три элемента в табл. 11.3, True, False и None, имеют несколько необычный смысл — они также обнаруживаются во встроенной области видимости, описанной в главе 17, и формально являются именами, которым присваиваются объекты. Однако в Python 3.x указанные зарезервированные слова действительно зарезервированы во всех отношениях и не могут использоваться для каких-либо других целей в сценарии кроме объектов, которые они представляют. Все остальные зарезервированные слова жестко вшиты в синтаксис Python и могут появляться только в специфических контекстах, для которых они предназначены.

Более того, поскольку имена модулей в операторах import становятся переменными в ваших сценариях, ограничения имен переменных также распространяются на имена файлов модулей. Скажем, вы можете иметь файлы кода с именами and.py и my-code.py и запускать их как сценарии верхнего уровня, но не можете импортировать их: имена файлов без расширения .py становятся переменными в коде, а потому обязаны следовать только что обрисованным правилам именования переменных. Зарезервированные слова не разрешены, так что символы — не допускаются, хотя подчеркивания применять можно. Мы вернемся к этой концепции, связанной с модулями, в части V книги.

3 Во всяком случае, в стандартном CPython. Альтернативные реализации Python могут разрешать именам переменных совпадать с зарезервированными словами Python. Обзор альтернативных реализаций, таких как Jython, приводился в главе 2.