---
source_image: page_513.png
page_number: 513
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 34.08
tokens: 7886
characters: 3005
timestamp: 2025-12-24T01:23:23.073680
finish_reason: stop
---

встроенные. Например, функция в состоянии создать локальную переменную по имени open, выполнив ее присваивание:

def hider():
    open = 'spam'      # Локальная переменная, скрывает здесь встроенное имя
    ...
    open('data.txt')   # Ошибка: open в этой области видимости
    # больше не открывает файл!

Однако созданная локальная переменная скроет встроенную функцию open, которая существует во встроенной (внешней) области видимости, так что имя open внутри данной функции больше не будет открывать файлы — теперь оно является строкой, а не функцией открытия. Это не проблема, если в функции не нужно открывать файлы, но попытка открытия файла через имя open приведет к ошибке.

Попасть в такую ситуацию еще проще в интерактивной подсказке, которая работает как глобальная область видимости модуля:

>>> open = 99      # Присваивание в глобальной области видимости
# здесь также скрывает встроенное имя

По существу нет ничего неправильного в том, чтобы применять встроенное имя для собственных переменных при условии, что первоначальная встроенная версия не требуется. В конце концов, если бы это было по-настоящему запрещено, то нам пришлось бы запомнить целый список встроенных имен и трактовать их как зарезервированные. Учитывая наличие свыше 150 имен внутри модуля builtins в Python 3.7, положение оказалось бы слишком ограничивающим и обескураживающим:

>>> len(dir(builtins)), len([x for x in dir(builtins) if not x.startswith('__')])
(154, 146)

Между прочим, при написании более сложных программ иногда возникают ситуации, когда на самом деле желательно заменять встроенное имя, переопределяя его в своем коде — скажем, чтобы определить специальную функцию open, которая контролирует попытки доступа (см. врезку "Разрушение мироздания в Python 2.x" далее в главе).

Тем не менее, переопределение встроенного имени часто является ошибкой и к тому же опасной, т.к. Python не будет выдавать предупреждение о ней. Инструменты вроде PyChecker (поищите информацию о нем в веб-сети) способны предупреждать о таких недоразумениях, но наилучшей защитой в данном вопросе может послужить знание: не переопределяйте встроенное имя, в котором нуждаетесь. Если вы случайно переопределили встроенное имя в интерактивной подсказке, тогда можете либо перезапустить свой сеанс, либо выполнить оператор del имя и удалить переопределение из своей области видимости, тем самым восстановив оригинал из встроенной области видимости.

Обратите внимание, что функции могут аналогичным образом скрывать глобальные переменные, имена которых совпадают с именами локальных переменных. Однако поступать так полезно и фактически во многом это и есть сущность локальных областей видимости — поскольку они минимизируют возможность возникновения конфликта имен, ваши функции являются самодостаточными пространствами имен:

X = 88      # Глобальная переменная X
def func():
    X = 99      # Локальная переменная X: скрывает глобальную,
    # но именно это и желательно
func()
print(X)    # Выводит 88: значение не изменилось