---
source_image: page_612.png
page_number: 612
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 28.57
tokens: 7674
characters: 2166
timestamp: 2025-12-24T01:26:18.110405
finish_reason: stop
---

Для удобства встроенная функция next(X) вызывает метод X.__next__() объекта в Python 3.X (и X.next() в Python 2.X):

```python
>>> next(x)    # То же, что и x.__next__() в Python 3.x
0
>>> next(x)    # Используйте x.next() или next() в Python 2.x
1
>>> next(x)
4
>>> next(x)
9
>>> next(x)
Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
Трассировка (самый последний вызов указан последним):
    Файл <stdin>, строка 1, в <модуль>
StopIteration
```

Как выяснилось в главе 14, циклы for (и другие итерационные контексты) работают с генераторами одинаково — многократно вызывая метод __next__, пока не возникнет исключение. Для генератора результатом является производство выдаваемых значений с течением времени. Если подлежащий итерации объект не поддерживает такой протокол, то циклы for взамен применяют протокол индексирования.

Обратите внимание, что вызов iter верхнего уровня в протоколе итерации здесь необязателен, поскольку генераторы сами являются итераторами, поддерживающими только один активный просмотр во время итерации. Говоря по-другому, генераторы возвращают для iter самих себя, т.к. они поддерживают next напрямую. Сказанное также остается справедливым для генераторных выражений, которые мы обсудим позже в главе:

```python
>>> y = gensquares(5)    # Возвращает генератор, который сам по себе является итератором
>>> iter(y) is y        # iter() не требуется: здесь ничего не делает
True
>>> next(y)             # Можно запускать next() непосредственно
0
```

Для чего используются генераторные функции?

С учетом простых примеров, применяемых для иллюстрации основ, вас может интересовать, зачем вообще писать код генератора. Скажем, в примере текущего раздела можно было бы просто построить сразу весь список выданных значений:

```python
>>> def buildsquares(n):
    res = []
    for i in range(n): res.append(i ** 2)
    return res

>>> for x in buildsquares(5): print(x, end=' : ')
0 : 1 : 4 : 9 : 16 :
```

По существу мы могли бы использовать любую методику с циклом for, функцией map или списковым включением:

```python
>>> for x in [n ** 2 for n in range(5)]:
    print(x, end=' : ')
0 : 1 : 4 : 9 : 16 :
```