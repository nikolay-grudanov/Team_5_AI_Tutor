---
source_image: page_433.png
page_number: 433
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 33.96
tokens: 7758
characters: 2283
timestamp: 2025-12-24T01:21:00.402077
finish_reason: stop
---

Примечание, касающееся нестыковки версий. Вырожденная форма map, использующая None для аргумента функции, в Python 3.x больше не поддерживается, поскольку она в значительной степени совпадает с zip (и откровенно говоря, несколько не в ладах с прикладным назначением самой функции map). В Python 3.x либо применяйте zip, либо пишите код цикла, чтобы самостоятельно дополнять результаты. Фактически мы посмотрим, как писать такой код цикла в главе 20 после того, как проясним ряд дополнительных концепций, связанных с итерацией.

Создание словарей с помощью zip

Давайте взглянем на еще один сценарий использования zip. В главе 8 было высказана мысль, что применяемый здесь вызов zip также может оказаться удобным для генерации словарей, когда наборы ключей и значений должны вычисляться во время выполнения. Теперь, когда мы освоились с функцией zip, имеет смысл посмотреть, каким образом она соотносится с созданием словарей. Как вам известно, словарь всегда можно создавать, записывая словарный литерал или присваивая по ключам:

```python
>>> D1 = {'spam':1, 'eggs':3, 'toast':5}
>>> D1
{'eggs': 3, 'toast': 5, 'spam': 1}

>>> D1 = {}
>>> D1['spam'] = 1
>>> D1['eggs'] = 3
>>> D1['toast'] = 5
```

Тем не менее, что делать, если программа получает ключи и значения словаря в списках во время выполнения, т.е. после того, как сценарий написан? Скажем, пусть имеются следующие списки ключей и значений, собранные от пользователя, полученные в результате разбора содержимого файла либо извлеченные из другого динамического источника:

```python
>>> keys = ['spam', 'eggs', 'toast']
>>> vals = [1, 3, 5]
```

Одно из решений по превращению таких списков в словарь предусматривало бы вызов zip для списков и проход по ним параллельно посредством цикла for:

```python
>>> list(zip(keys, vals))
[('spam', 1), ('eggs', 3), ('toast', 5)]

>>> D2 = {}
>>> for (k, v) in zip(keys, vals): D2[k] = v
...
>>> D2
{'eggs': 3, 'toast': 5, 'spam': 1}
```

Однако оказывается, что в Python 2.2 и последующих версиях можно вообще опустить цикл for и просто передать объединенные с помощью zip списки ключей/значений вызову встроенного конструктора dict:

```python
>>> keys = ['spam', 'eggs', 'toast']
>>> vals = [1, 3, 5]

>>> D3 = dict(zip(keys, vals))
>>> D3
{'eggs': 3, 'toast': 5, 'spam': 1}
```