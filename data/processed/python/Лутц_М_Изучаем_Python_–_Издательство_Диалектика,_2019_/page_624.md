---
source_image: page_624.png
page_number: 624
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 25.54
tokens: 7620
characters: 2053
timestamp: 2025-12-24T01:26:36.650554
finish_reason: stop
---

Генерация во встроенных типах, инструментах и классах

Наконец, хотя основное внимание в текущем разделе сосредоточено на написании самих генераторов значений, не следует забывать о том, что многие встроенные типы ведут себя похожим образом — например, как было показано в главе 14, словари являются итерируемыми объектами с итераторами, которые выдают ключи на каждой итерации:

```python
>>> D = {'a':1, 'b':2, 'c':3}
>>> x = iter(D)
>>> next(x)
'c'
>>> next(x)
'b'
```

Подобно значениям, производимым самостоятельно написанными генераторами, по ключам словаря можно проходить вручную и с применением автоматических итерационных средств, в том числе циклов for, вызовов map, списковых включений и многих других контекстов, встречавшихся в главе 14:

```python
>>> for key in D:
    print(key, D[key])
c 3
b 2
a 1
```

Как уже известно, для файловых итераторов Python просто загружает строки из файла по запросу:

```python
>>> for line in open('temp.txt'):
    print(line, end='')
Tis but
a flesh wound.
```

В то время как итерируемые объекты встроенных типов привязаны к специфическому виду генерации значений, концепция подобна многоцелевым генераторам, которые мы пишем с использованием выражений и функций. Итерационные контексты вроде циклов for принимают любой итерируемый объект, который имеет ожидаемые методы, будь он определяемым пользователем или встроенным.

Генераторы и библиотечные средства: инструменты прохода по каталогам

Хотя это выходит за рамки тематики книги, следует отметить, что в наши дни многие стандартные библиотечные средства Python тоже генерируют значения, включая анализаторы сообщений электронной почты и стандартный инструмент прохода по каталогам, который на каждом уровне дерева каталогов выдает кортеж с текущим каталогом, его подкаталогами и имеющимися файлами:

```python
>>> import os
>>> for (root, subs, files) in os.walk('.'):
    # Генератор инструмента прохода по каталогам
    for name in files:
        if name.startswith('call'):
            print(root, name)
.callables.py
\dualpkg callables.py
```