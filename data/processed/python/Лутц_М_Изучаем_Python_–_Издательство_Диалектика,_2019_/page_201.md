---
source_image: page_201.png
page_number: 201
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 35.92
tokens: 7908
characters: 2742
timestamp: 2025-12-24T01:13:22.717785
finish_reason: stop
---

>>> S
{1.23}
>>> S.add([1, 2, 3])    # Во множестве работают только неизменяемые объекты
TypeError: unhashable type: 'list'
Ошибка типа: нежешируемый тип: list
>>> S.add({'a':1})
TypeError: unhashable type: 'dict'
Ошибка типа: нежешируемый тип: dict
>>> S.add((1, 2, 3))
>>> S                # Списки и словари не допускаются, но кортежи разрешены
{1.23, (1, 2, 3)}
>>> S | {(4, 5, 6), (1, 2, 3)}   # Объединение: то же, что и S.union(...)
{1.23, (4, 5, 6), (1, 2, 3)}
>>> (1, 2, 3) in S             # Членство: по полным значениям
True
>>> (1, 4, 3) in S
False

Кортежи во множестве могут использоваться, например, для представления дат, записей, IP-адресов и т.п. (кортежи подробно рассматриваются позже в этой части книги). Множества могут также содержать модули, объекты типов и многое другое. Сами множества изменяемы и соответственно не могут вкладываться в другие множества напрямую. Если нужно хранить множество внутри другого множества, то встроенная функция frozenset работает в точности как set, но создает неизменяемое множество, которое не допускает модификацию и потому может быть внедрено в другие множества.

Включения множеств в Python 3.X и 2.7

В дополнение к литералам в версии Python 3.X появилась конструкция включения множеств, которая была также перенесена в версию Python 2.7. Подобно литералам множеств Python 3.X версия Python 2.7 принимает их синтаксис, но отображает результаты с применением системы обозначения множеств Python 2.X. Выражение включения множеств по форме похоже на списковое включение, кратко рассмотренное в главе 4, но записывается в фигурных, а не квадратных скобках и выполняется для создания множества вместо списка. Включения множеств запускают цикл и на каждой итерации накапливают результат выражения; переменная цикла предоставляет доступ к значению текущей итерации для использования в накапливающем выражении. Результатом будет новое множество, созданное за счет выполнения кода, с обычным поведением множества. Ниже демонстрируется включение множества в Python 3.3 (отображение результата и порядок в Python 2.7 будут отличаться):

>>> {x ** 2 for x in [1, 2, 3, 4]}   # Включение множества в Python 3.X/2.7
{16, 1, 4, 9}

В этом выражении цикл записывается справа, а накапливающее выражение — слева (x ** 2). Как и для списковых включений, мы получаем по существу то, о чем говорит данное выражение: "предоставить новое множество, содержащее квадраты x для каждого x в списке". Включения могут также выполнять проход по объектам других видов, таких как строки (первый из приведенных далее примеров иллюстрирует основанный на включениях способ создания множества из существующего итерируемого объекта):

>>> {x for x in 'spam'}           # То же, что и set('spam')
{'m', 's', 'p', 'a'}