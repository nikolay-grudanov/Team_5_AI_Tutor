---
source_image: page_334.png
page_number: 334
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 33.75
tokens: 7878
characters: 3017
timestamp: 2025-12-24T01:17:47.860434
finish_reason: stop
---

Вы не обязаны применять только булевский тип в логических операторах вроде if; все объекты по своему существу представляют собой истину или ложь, и если вы используете другие типы, то все булевские концепции, упомянутые в настоящей главе, по-прежнему работают, как здесь описано. Python также предлагает встроенную функцию bool, которая может применяться для проверки булевского значения объекта, когда это желательно сделать явным (например, является ли истинным, т.е. ненулевым или непустым):

```python
>>> bool(1)
True
>>> bool('spam')
True
>>> bool({})
False
```

Тем не менее, на практике вы редко будете обращать внимание на булевский тип, производимый логическими проверками, поскольку булевские результаты автоматически используются операторами if и другими инструментами выбора. Мы продолжим исследовать булевские значения при изучении логических операторов в главе 12.

Иерархии типов Python

В качестве сводки и справки на рис. 9.3 приведена упрощенная схема всех встроенных типов Python и отношений между ними. Мы рассмотрели наиболее заметные из них; большинство других видов объектов на рис. 9.3 соответствует программным единицам (например, функции и модули) или открытым внутренним свойствам интерпретатора (скажем, стековые фреймы и скомпилированный код).

Здесь важнее всего отметить, что в системе Python абсолютно все является типом объекта и может обрабатываться вашими программами на Python. Например, вы можете передавать класс функции, присваивать его переменной, помещать его в список или словарь и т.д.

Объекты type

В действительности в Python даже сами типы представляют собой объекты: тип объекта является объектом типа type. Строго говоря, вызов встроенной функции type(X) возвращает объект типа для объекта X. Практическое применение этого заключается в том, что объекты типов могут использоваться для ручных сравнений типов в операторах if языка Python. Однако по причинам, которые приводились в главе 4, проверка типов вручную обычно не считается правильным действием в Python, т.к. она ограничивает гибкость кода.

Одно замечание по поводу имен типов: начиная с версии Python 2.2, каждый основной тип имеет встроенное имя, добавленное для поддержки настройки типов через объектно-ориентированное создание производных классов: dict, list, str, tuple, int, float, complex, bytes, type, set и т.д. В Python 3.x эти имена ссылаются на классы, а в Python 2.x, но не в Python 3.x, имя file также является именем типа и синонимом для функции open. Обращения к указанным именам на самом деле представляют собой вызовы конструкторов объектов, а не просто функций преобразования, хотя при элементарном применении вы можете трактовать их как простые функции.

Вдобавок стандартный библиотечный модуль types в Python 3.x предлагает дополнительные имена типов для типов, которые не доступны в виде встроенных (скажем, тип функции; в Python 2.x, но не в Python 3.x, модуль types также включает синонимы для имен встроенных типов), и делает возможными проверки типов с помощью функции isinstance.