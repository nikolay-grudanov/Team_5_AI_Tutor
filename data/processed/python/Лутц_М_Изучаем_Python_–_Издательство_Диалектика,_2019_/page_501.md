---
source_image: page_501.png
page_number: 501
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 28.67
tokens: 7678
characters: 2369
timestamp: 2025-12-24T01:22:56.891715
finish_reason: stop
---

и не может быть повторно выполнен позже. Конечно, мы могли бы скопировать код и вставить во все места, где его необходимо выполнять, но такое решение нельзя оценить как хорошее или универсальное. Нам по-прежнему пришлось бы редактировать каждую копию для поддержки разных имен последовательностей, а изменение алгоритма потребовало бы тогда внесения изменений в многочисленные копии.

Определение

К этому времени, вероятно, вы уже догадались, что выход из затруднительного положения предусматривает упаковку цикла for внутрь функции. Такое решение обладает несколькими преимуществами.

• Помещение кода в функцию делает его инструментом, который можно запускать столько раз, сколько нужно.
• Поскольку вызывающий код может передавать произвольные аргументы, функции достаточно универсальны для того, чтобы работать с любыми двумя последовательностями (или другими итерируемыми объектами), пересечение которых необходимо получить.
• Когда логика упакована внутрь функции, в случае изменения реализации пересечения код придется модифицировать только в одном месте.
• Помещение кода функции в файл модуля означает, что ее можно импортировать и многократно применять в любой программе, выполняемой на компьютере.

В действительности помещение кода в функцию превращает ее в универсальную утилиту пересечения:

def intersect(seq1, seq2):
    res = []
    for x in seq1:
        if x in seq2:
            res.append(x)
    return res

Трансформация простого кода из главы 13 в приведенную выше функцию прямо-линейна; мы просто помещаем первоначальную логику ниже заголовка def и делаем объекты, на которых она оперирует, передаваемыми именами параметров. Из-за того, что функция вычисляет результат, мы также добавляем оператор return для отправки результирующего объекта обратно вызывающему коду.

Вызов

Прежде чем можно будет вызывать функцию, ее потребуется создать. Необходимо выполнить оператор def функции, для чего либо набрать его в интерактивной подсказке, либо поместить в файл модуля и импортировать модуль. После выполнения def функцию можно вызывать, передавая ей любые два объекта последовательностей в круглых скобках:

>>> s1 = "SPAM"
>>> s2 = "SCAM"
>>> intersect(s1, s2)      # Строчки
['S', 'A', 'M']

Здесь мы передаем две строки и получаем обратно список, содержащий общие символы. Алгоритм, используемый функцией, прост: "для каждого элемента в первом