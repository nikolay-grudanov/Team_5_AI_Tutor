---
source_image: page_137.png
page_number: 137
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 35.39
tokens: 7977
characters: 3094
timestamp: 2025-12-24T01:11:16.359401
finish_reason: stop
---

>>> '%s, eggs, and %s' % ('spam', 'SPAM!')    # Выражение форматирования
# (все версии)
'spam, eggs, and SPAM!'
>>> '{0}, eggs, and {1}'.format('spam', 'SPAM!')    # Метод форматирования
# (2.6+, 3.0+)
'spam, eggs, and SPAM!'
>>> '{}, eggs, and {}'.format('spam', 'SPAM!')    # Номера необязательны
# (2.7+, 3.1+)
'spam, eggs, and SPAM!'

Форматирование богато возможностями, обсуждение которых мы отложим до будущих глав книги и которые особенно важны при генерации числовых отчетов:

>>> '{:.2f}'.format(296999.2567)    # Разделители, десятичные цифры
'296,999.26'
>>> '%.2f | %+05d' % (3.14159, -42)    # Цифры, дополнение, знаки
'3.14 | -0042'

Здесь следует сделать одно замечание: хотя операции над последовательностями являются универсальными, методы — нет; несмотря на то, что некоторые типы совместно используют ряд имен методов, строковые методы обычно работают только на строках и ни на чем другом. В качестве эмпирического правила запомните, что инструментальный набор Python делится на уровни: универсальные операции, охватывающие множество типов, выглядят как встроенные функции или выражения (например, len(X), X[0]), но операции, специфичные для типа, представляют собой вызовы методов (скажем, aString.upper()). По мере все большего освоения Python поиск необходимых инструментов в этих категориях станет более естественным, а в следующем разделе даются советы, которыми вы можете воспользоваться прямо сейчас.

Получение справки

Представленные в предыдущем разделе методы — репрезентативная, но небольшая выборка того, что доступно для объектов строк. В целом эта книга не является исчерпывающей в плане рассмотрения методов объектов. Для получения дополнительных деталей вы всегда можете вызвать встроенную функцию dir. Когда функция dir вызывается без аргументов, она выводит список переменных, присвоенных в области видимости вызывающего объекта. Более полезно то, что функция dir возвращает список всех атрибутов, доступных для любого переданного ей объекта. Поскольку методы являются функциональными атрибутами, они будут присутствовать в таком списке. Предполагая, что S — все еще строка, вот ее атрибуты в Python 3.3 (в Python 2.x они немного отличаются):

>>> dir(S)
['__add__', '__class__', '__contains__', '__delattr__', '__dir__', '__doc__',
'__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__',
'__getnewargs__', '__gt__', '__hash__', '__init__', '__iter__', '__le__',
'__len__', '__lt__', '__mod__', '__mul__', '__ne__', '__new__', '__reduce__',
'__reduce_ex__', '__repr__', '__rmod__', '__rmul__', '__setattr__', '__sizeof__',
'__str__', '__subclasshook__', 'capitalize', 'casefold', 'center', 'count',
'encode', 'endswith', 'expandtabs', 'find', 'format', 'format_map', 'index',
'isalnum', 'isalpha', 'isdecimal', 'isdigit', 'isidentifier', 'islower',
'isnumeric', 'isprintable', 'isspace', 'istitle', 'isupper', 'join', 'ljust',
'lower', 'lstrip', 'maketrans', 'partition', 'replace', 'rfind', 'rindex',
'rjust', 'rpartition', 'rsplit', 'rstrip', 'split', 'splitlines', 'startswith',
'strip', 'swapcase', 'title', 'translate', 'upper', 'zfill']