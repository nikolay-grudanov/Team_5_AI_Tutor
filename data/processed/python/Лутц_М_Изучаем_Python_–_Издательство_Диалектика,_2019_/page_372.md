---
source_image: page_372.png
page_number: 372
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 31.03
tokens: 7816
characters: 2345
timestamp: 2025-12-24T01:19:00.634731
finish_reason: stop
---

Так как синтаксис расширенной распаковки последовательностей не только проще, но возможно естественнее, вполне вероятно, что со временем он станет более широко распространенным в коде Python.

Употребление в циклах for

Поскольку переменной цикла в операторе цикла for может быть любая цель присваивания, присваивание последовательности с расширенной распаковкой здесь также работает. Мы кратко упоминали инструмент итерации в форме цикла for в главе 4 и формально представим его в главе 13. В Python 3.x присваивание с расширенной распаковкой может появляться после слова for, где чаще всего используется простое имя переменной:

for (a, *b, c) in [(1, 2, 3, 4), (5, 6, 7, 8)]:

...

При использовании в таком контексте на каждой итерации Python просто присваивает кортежу имен очередной кортеж значений. Например, первая итерация выглядит так, как если бы мы выполнили следующий оператор присваивания:

a, *b, c = (1, 2, 3, 4) # b получает [2, 3]

Имена a, b и c можно применять внутри кода цикла для ссылки на извлеченные компоненты. По правде говоря, это вообще не специальный случай, а просто пример универсального присваивания в работе. Как было показано ранее в главе, то же самое мы можем делать посредством простого присваивания кортежа в Python 2.x и 3.x:

for (a, b, c) in [(1, 2, 3), (4, 5, 6)]: # a, b, c = (1, 2, 3), ...

И мы всегда можем эмулировать поведение присваивания с расширенной распаковкой Python 3.x в Python 2.x за счет ручного нарезания:

for all in [(1, 2, 3, 4), (5, 6, 7, 8)]:
    a, b, c = all[0], all[1:3], all[3]

Мы вернемся к этой теме в главе 13 при рассмотрении синтаксиса циклов for.

Групповые присваивания

Групповое присваивание просто присваивает всем заданным именам объект, указанный справа. Скажем, в следующем примере трем переменным a, b и c присваивается строка 'spam':

>>> a = b = c = 'spam'
>>> a, b, c
('spam', 'spam', 'spam')

Такая форма эквивалентна трем присваиваниям (но легче для записи):

>>> c = 'spam'
>>> b = c
>>> a = b

Групповое присваивание и разделяемые ссылки

Имейте в виду, что здесь есть всего лишь один объект, разделяемый тремя переменными (все они в итоге указывают на тот же самый объект в памяти). Такое поведение хорошо подходит для неизменяемых типов — например, при инициализации нулем набора счетчиков (вспомните, что переменным в Python должны быть присвоены зна-