---
source_image: page_463.png
page_number: 463
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 33.75
tokens: 7800
characters: 2496
timestamp: 2025-12-24T01:21:53.319806
finish_reason: stop
---

>>> next(I1)
(2, 11)
>>> next(I2)      # (Python 3.x) I2 находится не в том же месте, что и I1!
(3, 12)
>>> M = map(abs, (-1, 0, 1))    # То же самое для результата map (и filter)
>>> I1 = iter(M); I2 = iter(M)
>>> print(next(I1), next(I1), next(I1))
1 0 1
>>> next(I2)      # (Python 3.x) Одиночный проход исчерпал элементы!
StopIteration
>>> R = range(3)    # Но результат range допускает множество итераторов
>>> I1, I2 = iter(R), iter(R)
>>> [next(I1), next(I1), next(I1)]
[0 1 2]
>>> next(I2)      # Множество активных проходов подобно спискам Python 2.x
0

Когда мы будем писать код собственных итерируемых объектов с помощью классов позже в книге (в главе 30), то заметим, что множество итераторов обычно поддерживаются за счет возвращения новых объектов для вызова iter; одиночный итератор, как правило, означает возвращение объектом самого себя. В главе 20 также обнаружится, что генераторные функции и выражения в этом отношении ведут себя подобно map и zip, а не range, поддерживая только один активный проход. Там мы увидим ряд тонких последствий итераторов с одним проходом в циклах, пытающихся выполнить проход несколько раз — код, который раньше обходился с такими объектами как со списками, потерпит неудачу без ручного преобразования их в списки.

Итерируемые словарные представления

Наконец, как было кратко показано в главе 8, словарные методы keys, values и items в Python 3.x возвращают итерируемые объекты представлений, которые генерируют элементы результата по одному за раз вместо выработки полных списков результатов в памяти. Представления также доступны в Python 2.7 как вариант, но со специальными именами методов во избежание влияния на существующий код. Элементы представлений поддерживают такое же физическое упорядочение, как у словаря, и отражают изменения, вносимые в лежащий в основе словарь. Теперь, зная больше об итерируемых объектах, рассмотрим остаток истории — в Python 3.3 (порядок следования ключей у вас может быть другим):

>>> D = dict(a=1, b=2, c=3)
>>> D
{'a': 1, 'b': 2, 'c': 3}
>>> K = D.keys()      # Объект представления в Python 3.x, не список
>>> K
dict_keys(['a', 'b', 'c'])
>>> next(K)      # Представления сами по себе не являются итераторами
TypeError: dict_keys object is not an iterator
Ошибка типа: объект dict_keys не является итератором
>>> I = iter(K)      # Итерируемые объекты представлений имеют итератор,
>>> next(I)      # который может использоваться вручную,
'a'      # но не поддерживают len() и индексацию
>>> next(I)
'b'