---
source_image: page_392.png
page_number: 392
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 32.29
tokens: 7825
characters: 2844
timestamp: 2025-12-24T01:19:39.129202
finish_reason: stop
---

в круглые скобки. Тем не менее, отображение вложенных объектов может отличаться еще больше для объектов других типов, особенно для объектов классов, которые определяют альтернативное отображение с помощью перегрузки операций — данную тему мы рассмотрим в целом в части VI и в частности в главе 30.

Чтобы обеспечить подлинную переносимость, не включая повсюду операции print из Python 3.X, и обойти отличия в отображении вложенных экземпляров, вы всегда можете форматировать выводимую строку как одиночный объект для унификации ее отображения разными версиями, используя выражение или вызов метода форматирования строк либо другие инструменты, которые были описаны в главе 7:

    >>> print('%s %s %s' % ('spam', 'ham', 'eggs'))
    spam ham eggs
    >>> print('{0} {1} {2}'.format('spam', 'ham', 'eggs'))
    spam ham eggs
    >>> print('answer: ' + str(42))
    answer: 42

Разумеется, если у вас есть возможность работать исключительно в Python 3.X, то вы можете совершенно не думать о таких сопоставлениях, но многим программистам на Python в течение некоторого времени придется минимум сталкиваться, а то и писать код Python 2.X. Мы будем применять from __future__ import и нейтральный к версии код для обеспечения переносимости Python 2.X/3.X во многих примерах, приводимых в настоящей книге.

Я использую вызовы функции print из Python 3.X повсеместно в книге. Я часто делаю операции print нейтральными к версии и обычно предупреждаю, когда результаты могут отличаться в Python 2.X, но иногда не предупреждаю, поэтому считайте данную врезку всеохватывающим предупреждением. Если в Python 2.X вы видите в выводимом тексте добавочные круглые скобки, тогда либо уберите круглые скобки из операторов print, импортируйте операции print из Python 3.X посредством from __future__ import, перепишите операции print с применением обрисованной здесь схемы нейтральности к версии либо научитесь любить излишний текст.

Что потребует внимания: print и stdout

Эквивалентность операции print и метода write объекта sys.stdout важна. Она делает возможным переназначение sys.stdout в любой определяемый пользователем объект, который предоставляет тот же самый метод write, что и файловые объекты. Поскольку оператор print всего лишь отправляет текст методу sys.stdout.write, вы можете захватывать выводимый текст в своих программах, присваивая sys.stdout объект, метод write которого обрабатывает текст произвольными способами.

Скажем, выводимый текст можно передать окну графического пользовательского интерфейса либо направить его по многим назначениям, определяя объект с методом write, который не требует маршрутизации. Пример такого трюка будет приведен во время исследования классов в части VI книги, но абстрактно он выглядит следующим образом:

class FileFaker:
    def write(self, string):
        # Делать что-то с выводимым текстом в строке