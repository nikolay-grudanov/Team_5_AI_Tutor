---
source_image: page_677.png
page_number: 677
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 26.86
tokens: 7676
characters: 2415
timestamp: 2025-12-24T01:28:17.736159
finish_reason: stop
---

Кроме того, изменяемые стандартные значения нелегко запомнить (и вообще понять). Они зависят от распределения во времени моментов создания объектов для стандартных значений. В предыдущем примере был только один объект списка для стандартного значения — он создавался при выполнении def. Каждый раз, когда функция вызывается, вы не получаете новый список, поэтому существующий список растет с каждым новым добавлением к нему элемента; он не сбрасывается в пустое состояние при каждом вызове.

Если вы заинтересованы в другом поведении, тогда просто создайте копию стандартного значения в начале тела функции или перенесите выражение для стандартного значения внутрь тела функции. Так как значение находится в коде, который действительно выполняется при каждом запуске функции, вы будете получать каждый раз новый объект:

```python
>>> def saver(x=None):
    if x is None:      # Аргумент не передавался?
        x = []         # Каждый раз выполнять код для создания нового объекта списка
        x.append(1)    # Изменяет новый объект списка
    print(x)
>>> saver([2])
[2, 1]
>>> saver()           # Здесь список не растет
[1]
>>> saver()
[1]
```

Кстати, оператор if в рассматриваемом примере можно было бы почти заменить присваиванием x = x or [], которое извлекает преимущество из того факта, что операция or в Python возвращает один из объектов своих операндов: если аргумент не передавался, то x получает стандартное значение None, поэтому or возвратит новый пустой список в правой части операции.

Однако мы получаем не совсем то же самое. В случае передачи пустого списка выражение or приведет к тому, что функция расширит и возвратит заново созданный список, а не расширит и возвратит переданный список подобно версии с оператором if. (Выражение приобретает вид [] or [] и результатом его вычисления будет новый пустой список в правой части; см. раздел "Значения истинности и булевские проверки" в главе 12, если не можете вспомнить почему.) Требования в реальных программах могут диктовать любое из двух линий поведения.

В наши дни еще один способ достижения эффекта с предохранением изменяемых объектов, выбранных для стандартных значений, который вероятно меньше сбивает с толку, предусматривает использование атрибутов функций, обсуждавшихся в главе 19:

```python
>>> def saver():
    saver.x.append(1)
    print(saver.x)
>>> saver.x = []
>>> saver()
[1]
>>> saver()
[1, 1]
>>> saver()
[1, 1, 1]
```