---
source_image: page_430.png
page_number: 430
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 27.52
tokens: 7661
characters: 2016
timestamp: 2025-12-24T01:20:48.720550
finish_reason: stop
---

Изменение списков: range или включения

Еще одним распространенным местом, где может применяться комбинация range/len с оператором for, являются циклы, которые изменяют список по мере его обхода. В качестве примера предположим, что необходимо добавить 1 к каждому элементу в списке (возможно, обеспечивая повышение каждому сотруднику в списке из базы данных отдела кадров). Вы можете попробовать решить задачу с помощью простого цикла for, но результат, вероятно, окажется не совсем таким, который желательно получить:

```python
>>> L = [1, 2, 3, 4, 5]

>>> for x in L:
...     x += 1
...
>>> L
[1, 2, 3, 4, 5]
>>> x
6
```

Код не вполне работоспособен — он изменяет переменную цикла x, но не список L. Причина довольно тонкая. При каждом проходе цикла x ссылается на очередное целое число, уже извлеченное из списка. Скажем, на первой итерации x — целое число 1. На следующей итерации тело цикла устанавливает x в другой объект, целое число 2, но не обновляет список, откуда первоначально поступило значение 1; переменная x занимает отдельный от списка участок памяти.

Для действительно изменения списка во время прохода по нему нам придется использовать индексы, чтобы можно было присвоить обновленное значение в каждой проходимой позиции. Требуемые индексы способна производить комбинация range/len:

```python
>>> L = [1, 2, 3, 4, 5]

>>> for i in range(len(L)):
...     L[i] += 1
...
>>> L
[2, 3, 4, 5, 6]
```

При таком подходе список изменяется по мере выполнения цикла. Нет никакой возможности сделать то же самое посредством простого цикла в стиле for x in L:, потому что такой цикл проходит по фактическим элементам, а не по позициям списка. Но как насчет эквивалентного цикла while? Он потребует чуть большей работы с нашей стороны и может выполнять медленнее в зависимости от версии (медленнее в Python 2.7 и 3.3, хотя не до такой степени в Python 3.3 — мы увидим, как это проверить, в главе 21):

```python
>>> i = 0
>>> while i < len(L):
...     L[i] += 1
...     i += 1
...
>>> L
[3, 4, 5, 6, 7]
```