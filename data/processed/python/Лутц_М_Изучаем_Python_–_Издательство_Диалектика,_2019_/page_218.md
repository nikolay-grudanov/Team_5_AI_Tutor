---
source_image: page_218.png
page_number: 218
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 36.87
tokens: 7937
characters: 3210
timestamp: 2025-12-24T01:13:53.707845
finish_reason: stop
---

Данный объект кешируется и его повторное применение не имеет отношения к вашему коду (если только вы не выполняете проверку is!). Из-за невозможности модификации неизменяемых чисел и строк на месте совершенно не играет роли, сколько ссылок имеется на тот же самый объект — каждая ссылка всегда будет видеть одно и то же неизменяемое значение. Однако такое поведение отражает один из многих способов, которыми Python оптимизирует свою модель для обеспечения высокой скорости выполнения.

Динамическая типизация вездесуща

Конечно, на самом деле вам не придется рисовать диаграммы имен/объектов с окружностями и стрелками, чтобы использовать Python. Тем не менее, когда вы только начинаете программировать на Python, понять необычные случаи иногда помогает отслеживание структур их ссылок, как мы делали здесь. Например, если изменяемый объект модифицируется при передаче внутри программы, то вполне вероятно, что вы воочию сталкиваетесь с тем, о чем шла речь в настоящей главе.

Более того, даже если на этом этапе динамическая типизация кажется немного абстрактной, то со временем вы наверняка уладите вопрос. Поскольку в Python, похоже, абсолютно все взаимодействует через присваивание и ссылки, базовое понимание такой модели полезно во многих контекстах. Как вы увидите, динамическая типизация работает одинаково в операторах присваивания, аргументах функций, переменных циклов for, импортах модулей, атрибутах классов и т.д. Хорошая новость заключается в том, что в Python существует только одна модель присваивания; однажды овладев динамической типизацией, вы обнаружите, что она работает одинаково повсюду в языке.

На утилитарном уровне динамическая типизация означает для вас необходимость написания меньшего объема кода. Однако в равной степени важно и то, что динамическая типизация является корнем полиморфизма Python — концепции, которая была представлена в главе 4, и еще будет обсуждаться позже в книге.

Поскольку мы не ограничиваем типы в коде Python, он оказывается лаконичным и чрезвычайно гибким. Как вы увидите, при правильном применении динамическая типизация и вытекающий из нее полиморфизм производят код, который автоматически адаптируется к новым требованиям по мере развития ваших систем.

"Слабые" ссылки

В мире Python вы можете порой встречать термин "слабые ссылки" — довольно развитый инструмент, который связан с исследованной здесь моделью ссылок и подобно операции is без нее не может быть по-настоящему понят.

Вкратце слабая ссылка, реализуемая стандартным библиотечным модулем weakref, представляет собой ссылку на объект, которая сама по себе не препятствует выполнению сборки мусора в отношении этого объекта. Если последними оставшимися ссылками на объект оказываются слабые ссылки, тогда выделенная под объект память освобождается, а слабые ссылки автоматически удаляются (или уведомляются об освобождении как-то иначе).

Слабые ссылки могут быть удобными, скажем, в кешах для крупных объектов на основе словарей; без них одна лишь ссылка кеша приводила бы к хранению объекта в памяти бесконечно долго. Тем не менее, в действительности это просто специализированное расширение модели ссылок. За дополнительными сведениями обращайтесь в руководство по библиотеке Python.