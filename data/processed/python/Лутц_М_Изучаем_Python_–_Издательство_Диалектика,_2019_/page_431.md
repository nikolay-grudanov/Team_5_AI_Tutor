---
source_image: page_431.png
page_number: 431
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 32.30
tokens: 7830
characters: 2615
timestamp: 2025-12-24T01:20:55.679531
finish_reason: stop
---

Однако и здесь решение с range также может оказаться не самым идеальным. Списковое включение вида:

[x + 1 for x in L]

в наши дни, вероятно, выполняется быстрее и делает похожую работу, хотя и без изменения исходного списка на месте (мы могли бы присвоить новый списковый объект выражения обратно L, но это не обновило бы любые другие ссылки на исходный список). Списковые включения будут детально исследоваться в следующей главе.

Параллельные обходы: zip и map

Рассматриваемая в настоящем разделе методика расширяет область действия цикла. Как вы видели, встроенная функция range позволяет обходить последовательности с помощью цикла for в неполной манере. В том же духе встроенная функция zip дает возможность применять циклы for для просмотра множества последовательностей параллельно — без совмещения во времени, но в течение того же самого цикла. В базовом виде функция zip принимает одну или большее количество последовательностей в качестве аргументов и возвращает серию кортежей, объединяющих в пары параллельные элементы из указанных последовательностей. Предположим, что мы работаем с двумя списками (возможно, списком имен и списком адресов, согласующихся по позициям):

>>> L1 = [1,2,3,4]
>>> L2 = [5,6,7,8]

Чтобы объединить элементы в таких списках, мы можем использовать zip для создания списка кортежей с парами. Подобно range функция zip является списком в Python 2.x, но итерируемым объектом в Python 3.x, где ее придется помещать внутрь вызова list для отображения сразу всех результатов (итерируемые объекты более подробно обсуждаются в следующей главе):

>>> zip(L1, L2)
<zip object at 0x026523C8>
>>> list(zip(L1, L2))   # list() требуется в Python 3.x, но не в Python 2.x
[(1, 5), (2, 6), (3, 7), (4, 8)]

Такой результат может быть полезен и в других контекстах, но в сочетании с циклом for он поддерживает параллельные итерации:

>>> for (x, y) in zip(L1, L2):
...     print(x, y, '--', x+y)
...
1 5 -- 6
2 6 -- 8
3 7 -- 10
4 8 -- 12

Здесь мы проходим по результату вызова zip, т.е. по парам элементов, извлеченных из двух списков. Обратите внимание, что данный цикл for снова применяет представленную ранее форму присваивания кортежей для распаковки каждого кортежа в результате zip. При первом проходе получается так, как если бы мы выполняли оператор присваивания (x, y) = (1, 5).

Совокупный эффект заключается в том, что мы просматриваем в цикле оба списка, L1 и L2. Похожего результата можно было бы добиться с помощью цикла while, который поддерживает индексацию вручную, но он потребовал бы большего объема набора и почти наверняка выполнялся бы медленнее, чем подход с for/zip.