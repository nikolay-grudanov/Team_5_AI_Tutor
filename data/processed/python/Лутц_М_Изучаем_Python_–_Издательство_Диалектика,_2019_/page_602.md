---
source_image: page_602.png
page_number: 602
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 34.26
tokens: 7858
characters: 2537
timestamp: 2025-12-24T01:26:04.560011
finish_reason: stop
---

if x % 2 == 0:
    res.append(x)

>>> res
[0, 2, 4]

Для обнаружения четных чисел все они используют операцию % деления по модулю (нахождения остатка от деления): если остаток от деления числа на 2 равен нулю, тогда число должно быть четным. Вызов filter также не намного длиннее, чем списковое включение. Тем не менее, в списковом включении мы можем скомбинировать конструкцию if и произвольное выражение, чтобы добиться эффекта filter и map в единственном выражении:

>>> [x ** 2 for x in range(10) if x % 2 == 0]
[0, 4, 16, 36, 64]

На этот раз мы накапливаем квадраты четных чисел от 0 до 9: цикл for пропускает числа, для которых присоединенная справа конструкция if дает ложное значение, и выражение слева вычисляет квадраты. Эквивалентный вызов map потребовал бы намного большей работы с нашей стороны — нам пришлось бы скомбинировать выбор с помощью filter и итерацию посредством map, создавая заметно более сложное выражение:

>>> list(map((lambda x: x**2), filter((lambda x: x % 2 == 0), range(10))))
[0, 4, 16, 36, 64]

Формальный синтаксис включений

В действительноности списковые включения даже более универсальны. Их простейшая форма предусматривает указание накапливающего выражения и одиночной конструкции for:

[ выражение for цель in итерируемый_объект ]

Несмотря на необязательность всех остальных частей, они позволяют выражать более развитые итерации — в списковом включении допускается записывать любое количество вложенных циклов for, каждое из которых может иметь необязательную ассоциированную проверку if, действующую в качестве фильтра. Общая структура списковых включений выглядит следующим образом:

[ выражение for цель1 in итерируемый_объект1 if условие1
    for цель2 in итерируемый_объект2 if условие2 ...
    for цельN in итерируемый_объектN if условиеN ]

Такой же синтаксис унаследован включениями множеств и словарей, а также появившимися позже генераторными выражениями, хотя они используют другие объемлющие символы (фигурные скобки или часто необязательные круглые скобки), а включение словаря начинается с двух выражений, разделенных двоеточием (для ключа и значения).

Мы экспериментировали с конструкцией фильтрации if в предыдущем разделе. Когда конструкции for вкладываютя внутри спискового включения, они работают подобно эквивалентным вложенными операторам цикла for. Вот пример:

>>> res = [x + y for x in [0, 1, 2] for y in [100, 200, 300]]
>>> res
[100, 200, 300, 101, 201, 301, 102, 202, 302]

Эффект будет таким же, как у показанного ниже существенно более многословного эквивалента: