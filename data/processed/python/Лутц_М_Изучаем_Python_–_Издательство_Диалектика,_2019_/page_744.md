---
source_image: page_744.png
page_number: 744
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 35.67
tokens: 7956
characters: 3202
timestamp: 2025-12-24T01:30:28.181240
finish_reason: stop
---

Проблема может показаться не вполне ясной, но она довольно скоро может стать важной после того, как вы начнете создавать собственные пакеты.

Вы уже видели, что синтаксис относительного импортирования и принимаемое по умолчанию правило поиска по абсолютному пути в Python 3.x делают внутрипакетные операции импортирования явными, а потому более легкими для выявления и сопровождения, и делают возможным явный выбор в ряде сценариев с конфликтами имен. Однако эта модель имеет два важных последствия, о которых вы должны знать.

• В Python 3.x и 2.x применение операторов импортирования относительно пакетов неявно привязывает файл к каталогу и роли пакета и препятствует его использованию другими способами.

• В Python 3.x новое изменение правила поиска по относительному пути означает, что файл больше не может служить в качестве сценария и модуля пакета настолько же легко, как было бы в Python 2.x.

Причины указанных ограничений неуловимы, но это потому, что одновременно справедливо и следующее.

• Python 3.x и 2.x не разрешают применять синтаксис относительного импортирования from ., если только импортер не используется как часть пакета (т.е. импортируется из какого-то другого места).

• Python 3.x не выполняет поиск модуля в собственном каталоге пакета для операций импортирования, если только не применяется синтаксис относительного импортирования from . (или модуль не находится в текущем рабочем каталоге либо в домашнем каталоге главного сценария).

Использование операций относительного импортирования препятствует созданию каталогов, которые служат в качестве места размещения исполняемых программ и внешне импортируемых пакетов в Python 3.x и 2.x. Кроме того, в Python 3.x некоторые файлы больше не могут служить сценариями и модулями пакетов, как было бы в Python 2.x. Что касается операторов импортирования, то правила выглядят показанным далее образом (первое предназначено только для пакетного режима в обеих линейках Python, а второе — для программного режима только в Python 3.x):

from . import mod    # Не разрешен в непакетном режиме в Python 2.x and 3.x
import mod           # Не производит поиск в собственном каталоге файла
                      #   в пакетном режиме в Python 3.x

Совокупный эффект в том, что для применения файлов в любой из линеек Python 2.x или Python 3.x, может потребоваться выбрать один режим использования — пакетный (с операциями относительного импортирования) или программный (с простым импортированием), а также изолировать настоящие файлы модулей пакетов в подкаталоге отдельно от файлов сценариев верхнего уровня.

В качестве альтернативы вы можете попытаться вручную изменять sys.path (в целом ненадежная и подверженная ошибкам задача) или всегда применять полные пути пакетов в операциях абсолютного импортирования вместо либо синтаксиса импортирования относительно пакетов, либо простого импортирования и предполагать наличие корня пакета в пути поиска модулей:

from system.section.mypkg import mod   # Работает в программном и пакетном режимах

Из всех описанных схем последняя — импортирование с полными путями пакетов — может быть самой переносимой и функциональной, но чтобы понять почему, нужно обратиться к более конкретному коду.