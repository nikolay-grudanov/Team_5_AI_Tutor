---
source_image: page_453.png
page_number: 453
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 33.52
tokens: 7829
characters: 2769
timestamp: 2025-12-24T01:21:36.725371
finish_reason: stop
---

Вложенные циклы: for

При необходимости списковые включения могут становиться даже еще сложнее — например, содержать вложенные циклы, записанные в виде серии конструкций for. В действительности их полный синтаксис разрешает указывать любое количество конструкций for, каждая из которых может иметь необязательную связанную конструкцию if.

Скажем, следующее списковое включение строит список результатов конкатенации x + y для каждого элемента x в одной строке и каждого элемента y в другой. Оно фактически собирает все упорядоченные комбинации символов в двух строках:

```python
>>> [x + y for x in 'abc' for y in 'lmn']
['al', 'am', 'an', 'bl', 'bm', 'bn', 'cl', 'cm', 'cn']
```

И снова понять такое выражение проще, если преобразовать в форму оператора с добавлением отступов к его частям. Ниже показан эквивалентный, хотя более медленный способ достижения того же результата:

```python
>>> res = []
>>> for x in 'abc':
...     for y in 'lmn':
...         res.append(x + y)
...
>>> res
['al', 'am', 'an', 'bl', 'bm', 'bn', 'cl', 'cm', 'cn']
```

Но при менее высоком уровне сложности списковые включения часто могут становиться весьма компактными, что говорит, несомненно, в их пользу. В целом они предназначены для простых видов итерации; для более сложной работы структуру с оператором for вероятно будет легче понять и модифицировать в будущем. Это обычная ситуация в программировании: если решение оказывается сложным для понимания, то оно, скорее всего, неудачно.

Поскольку списковые включения лучше усваиваются небольшими порциями, мы здесь не будем продолжать историю, а возвратимся к ним в главе 20 в контексте инструментов функционального программирования. Там мы более формально определим их синтаксис и рассмотрим дополнительные примеры. Вы увидите, что списковые включения в такой же степени связаны с функциями, как они связаны с операторами цикла.

Общая оценка для всех заявлений о производительности в этой книге, касающихся списковых включений или других инструментов: относительная скорость выполнения кода во многом зависит от конкретного тестируемого кода и используемой версии Python, а также предрасположена к изменениям от выпуска к выпуску.

Например, в CPython 2.7 и 3.3 списковые включения по-прежнему могут быть в два раза быстрее соответствующих циклов for в одних тестах, но лишь минимально быстрее в других и возможно даже слегка медленнее в случае применения конструкций фильтров if.

В главе 21 мы выясним, как измерять время выполнения кода, и научимся интерпретировать файл listcomp-speed.txt в пакете примеров для книги, который фиксирует время выполнения кода из этой главы. А пока примите к сведению, что абсолютные показатели в оценках производительности столь же труднодостижимы, как единодушие в проектах с открытым кодом!