---
source_image: page_715.png
page_number: 715
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 30.63
tokens: 7824
characters: 2632
timestamp: 2025-12-24T01:29:28.786844
finish_reason: stop
---

Х = 2
import mod3
print(X, end=' ')    # Собственное глобальное имя X
print(mod3.X)        # X из mod3

В модуле mod1.py также определяется собственное имя X, затем импортируется mod2 и извлекаются атрибуты из первого и второго модулей:

X = 1
import mod2
print(X, end=' ')    # Собственное глобальное имя X
print(mod2.X, end=' ')    # X из mod2
print(mod2.mod3.X)    # X из вложенного mod3

На самом деле, когда mod1 импортирует mod2, он устанавливает двухуровневое вложение пространств имен. За счет использования пути имен mod2.mod3.X он может спуститься к модулю mod3, который вложен в импортируемый модуль mod2. Совокупный эффект заключается в том, что mod1 может видеть имена X во всех трех файлах и потому имеет доступ ко всем трем глобальным областям видимости:

% python mod1.py
2 3
1 2 3

Однако обратное утверждение неверно: mod3 не может видеть имена в mod2, а mod2 не может видеть имена в mod1. Возможно, пример будет легче понять, если вы не будете думать в терминах пространств имен и областей видимости, а взамен сконцентрируетесь на задействованных объектах. mod2 внутри mod1 — это всего лишь имя, которое ссылается на объект с атрибутами, часть которых может ссылаться на другие объекты с атрибутами (import является присваиванием). Для путей вроде mod2.mod3.X интерпретатор Python просто производит оценку слева направо, попутно извлекая атрибуты из объектов. Обратите внимание, что в mod1 можно записать import mod2 и затем mod2.mod3.X, но нельзя записать import mod2.mod3 — такой синтаксис инициирует то, что называется импортированием пакетов (каталогов), описанное в следующей главе. Импортирование пакетов также создает вложение пространств имен модулей, но его операторы import служат для отражения деревьев каталогов, а не простых цепочек импортирования файлов.

Перезагрузка модулей

Как объяснялось ранее, по умолчанию код модуля выполняется только один раз на процесс. Чтобы принудительно перезагрузить и повторно выполнить код модуля, понадобится явно запросить у Python такие действия, вызвав встроенную функцию reload. В этом разделе мы исследуем, как с помощью перезагрузок делать свои системы более динамичными. Вот краткое изложение.

• Операции импортирования (посредством операторов import и from) загружают и выполняют код модуля только при первом импортировании модуля в процессе.
• Последующие операции импортирования применяют объект уже загруженного модуля, не перезагружая и не выполняя повторно код из файла модуля.
• Функция reload вынуждает код уже загруженного модуля перезагрузиться и повторно выполниться. Присваивания в новом коде файла изменяют существующий объект модуля на месте.