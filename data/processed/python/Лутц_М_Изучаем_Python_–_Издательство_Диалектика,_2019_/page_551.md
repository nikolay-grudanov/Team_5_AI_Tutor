---
source_image: page_551.png
page_number: 551
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 29.81
tokens: 7844
characters: 2636
timestamp: 2025-12-24T01:24:24.755102
finish_reason: stop
---

1. Присваивание неключевых аргументов по позиции.
2. Присваивание ключевых аргументов по совпадающим именам.
3. Присваивание добавочных неключевых аргументов кортежу *имя.
4. Присваивание добавочных ключевых аргументов словарю **имя.
5. Присваивание стандартных значений неприсвоенным аргументам в заголовке.

Затем Python проверяет, передается ли каждому аргументу только одно значение; если нет, тогда возникает ошибка. Когда сопоставление завершено, Python присваивает именам аргументов переданные для них объекты.

Действительный алгоритм сопоставления, который применяется Python, несколько сложнее (скажем, он обязан также учитывать аргументы с передачей только по ключевым словам в Python 3.X), поэтому за более точным описанием обращайтесь в руководство по языку Python. Читать его не обязательно, но отслеживание алгоритма сопоставления аргументов в Python может содействовать пониманию ряда запутанных ситуаций, особенно когда режимы смешиваются.

В Python 3.X имена аргументов в заголовке функции могут также снабжаться аннотациями, указываемыми как имя:значение (или имя:значение=стандартное_значение, когда присутствуют стандартные значения). Это просто добавочный синтаксис для аргументов, который не дополняет и не изменяет описанные здесь правила упорядочения аргументов. Сама функция может также иметь значение аннотации, заданной как def f() -> значение. Python присоединяет значения аннотаций к объекту функции. Дополнительные сведения ищите в обсуждении аннотирования функций в главе 19.

Примеры ключевых слов и стандартных значений

В коде все выглядит проще, чем может вытекать из предшествующих описаний. Если вы не используете какой-то специальный синтаксис сопоставления, то Python сопоставляет имена по позиции слева направо подобно большинству других языков. Например, если вы определили функцию, которая требует трех аргументов, тогда должны вызывать ее с тремя аргументами:

>>> def f(a, b, c): print(a, b, c)
>>> f(1, 2, 3)
1 2 3

Мы передаем аргументы по позиции — a соответствует 1, b — 2 и т.д. (сопоставление работает одинаково в Python 3.X и 2.X, но в Python 2.X для кортежа отображаются добавочные круглые скобки, потому что мы снова применяем вызовы print из Python 3.X).

Ключевые слова

Тем не менее, в Python вы можете быть более точными в отношении того, что происходит при вызове функции. Ключевые аргументы делают возможным сопоставление по имени, а не по позиции. Ниже используется та же самая функция:

>>> f(c=3, b=2, a=1)
1 2 3

Здесь c=3 означает отправку значения 3 аргументу по имени с. Более формально Python сопоставляет имя с в вызове с аргументом по имени с в заголовке определения