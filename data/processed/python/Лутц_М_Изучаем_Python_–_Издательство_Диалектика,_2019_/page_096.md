---
source_image: page_096.png
page_number: 96
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 37.93
tokens: 7928
characters: 3267
timestamp: 2025-12-24T01:09:59.063991
finish_reason: stop
---

Также обратите внимание, что файл называется просто brian без суффикса .py, применяемого для файла модуля ранее. Добавление .py к имени не навредит (и может помочь запомнить, что это файл программы Python), но поскольку импортирование кода в данном файле другими модулями не планируется, имя файла несущественно. Если вы назначите файлу права на выполнение посредством команды оболочки chmod +x brian, то сможете запускать его в командной оболочке операционной системы, как если бы он был двоичным исполняемым файлом (чтобы показанная далее команда выполнилась, необходимо либо удостовериться в наличии . , т.е. текущего каталога, в переменной среды PATH, либо запускать файл сценария как ./brian):

% brian
The Bright Side of Life...

Трюк с поиском посредством env в Unix

В некоторых системах Unix можно избежать жесткого кодирования в файле сценария пути к интерпретатору Python за счет написания в первой строке специального комментария следующего вида:

#!/usr/bin/env python
...здесь находится код сценария...

В данном случае программа env определяет местоположение интерпретатора Python согласно настройкам пути поиска в системе (в большинстве командных оболочек Unix за счет просмотра всех каталогов, перечисленных в переменной среды PATH). Подобная схема может быть более переносимой, т.к. нет нужды жестко кодировать путь, где установлен Python, в первой строке всех сценариев. Таким образом, даже если сценарии перемещаются на другой компьютер или Python переносится в новое местоположение, то придется обновить только переменную среды PATH, а не все сценарии.

При наличии доступа к env откуда угодно ваши сценарии будут выполняться независимо от того, где в системе установлен Python. На самом деле продемонстрированная форма с env в целом теперь является рекомендуемой вместо чего-то общего вроде /usr/bin/python, потому что на некоторых платформах Python может быть установлен в другом месте. Разумеется, это предполагает, что программа env везде находится в том же самом местоположении (/sbin, /bin или где-нибудь еще); если же нет, тогда о переносимости можно и не мечтать!

Запускающий модуль для Windows в версии Python 3.3:
#! приходит в Windows

Примечание для пользователей Windows, работающих с Python 3.2 и предшествующими версиями: описанный здесь метод представляет собой трюк для Unix и на вашей платформе может не работать. Не переживайте; просто используйте показанный ранее базовый прием с командной строкой. Укажите имя файла в явной строке команды python1:

1 Как обсуждалось при исследовании командной строки, все последние версии Windows позволяют набирать в командной строке системы только имя файла .py — они применяют ассоциации расширений файлов для определения, что файл должен быть открыт с помощью Python (например, набор brian.py эквивалентен набору python brian.py). Такой режим командной строки похож по духу на #! из Unix, хотя он действует в масштабе всей системы, а не на основе файлов. Он также требует наличия у файла расширения .py: без него ассоциации расширений файлов не работают. В действительности некоторые программы в Windows способны интерпретировать первую строку с #! почти как в Unix (включая запускающий модуль для Windows из Python 3.3), но сама по себе командная строка в Windows просто игнорирует ее.