---
source_image: page_656.png
page_number: 656
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 29.83
tokens: 7872
characters: 2711
timestamp: 2025-12-24T01:27:37.213522
finish_reason: stop
---

Чтобы копнуть еще глубже, модифицируйте код для применения простой определяемой пользователем функции во всех пяти хронометрируемых методиках итерации. Скажем, поступите так (код взят из файла timeseqs2B.py в пакете примеров):
def F(x): return x
def listComp():
    return [F(x) for x in repslist]
def mapCall():
    return list(map(F, repslist))
Результаты (приведенные в файле timeseqs-results.txt) относительно похожи на использование встроенной функции вроде abs — по крайней мере, в CPython функция map оказывается самой быстрой. В более общем смысле среди пяти методик итерации на сегодняшний день map будет самой быстрой, если во всех пяти вызывается любая функция, встроенная или нет, но самой медленной, когда остальные этого не делают.
То есть map кажется медленнее всего лишь из-за того, что она требует вызовов функций, а вызовы функций являются относительно медленными во-общем. Поскольку map не способна избежать вызова функций, она может проиграть просто по ассоциации! Другие итерационные инструменты выигрывают оттого, что они в состоянии действовать без вызовов функций. Мы подтверждим это открытие в предстоящих тестах, выполняемых с применением модуля timeit.

Альтернативные версии модуля для измерения времени

Модуль для измерения времени из предыдущего раздела нормально работает, но он мог бы быть чуть более дружественным к пользователю. Совершенно очевидно, что его функции требуют передачи счетчика повторений как первого аргумента и не предлагают для него какого-то стандартного значения — возможно мелочь, но далеко не идеальное решение в универсальном инструменте. Мы также могли бы задействовать показанную ранее методику с min, чтобы немного упростить возвращаемое значение и убрать из результирующего времени небольшие накладные расходы.
Ниже приведена альтернативная реализация модуля timer, которая решает указанные задачи, позволяя передавать счетчик повторений в виде ключевого аргумента по имени _reps:

# Файл timer2.py (Python 2.x и 3.x)
"""
total(spam, 1, 2, a=3, b=4, _reps=1000) вызывает и хронометрирует spam(1, 2, a=3, b=4) _reps раз и возвращает суммарное время для всех прогонов с финальным результатом.
bestof(spam, 1, 2, a=3, b=4, _reps=5) запускает тест лучшего из N в попытке избавиться от влияния колебаний загрузки системы и возвращает лучшее время среди _reps тестов.
bestoftotal(spam, 1, 2, a=3, b=4, _reps1=5, _reps=1000) запускает тест лучшего суммарного времени, который берет лучший из _reps1 прогонов (суммарного времени _reps прогонов);
"""
import time, sys
timer = time.clock if sys.platform[:3] == 'win' else time.time
def total(func, *pargs, **kargs):
    _reps = kargs.pop('_reps', 1000)  # Переданное или стандартное
    # количество повторений