---
source_image: page_150.png
page_number: 150
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 32.59
tokens: 7870
characters: 2944
timestamp: 2025-12-24T01:11:37.375873
finish_reason: stop
---

Недостающие ключи: проверки if

Как отображения, словари обеспечивают доступ к элементам только по ключу посредством только что показанных операций. Тем не менее, они дополнительно поддерживают операции, специфические для типа, через вызовы методов, которые полезны в разнообразных ситуациях. Например, несмотря на то, что мы можем выполнять присваивание новому ключу для расширения словаря, извлечение несуществующего ключа по-прежнему расценивается как ошибка:

```python
>>> D = {'a': 1, 'b': 2, 'c': 3}
>>> D
{'a': 1, 'c': 3, 'b': 2}
>>> D['e'] = 99    # Присваивание новому ключу увеличивает словари
>>> D
{'a': 1, 'c': 3, 'b': 2, 'e': 99}
>>> D['f']        # Ссылка на несуществующий ключ приводит к ошибке
...текст сообщения об ошибке не показан...
KeyError: 'f'
```

Это именно то, что нужно — извлечение чего-то несуществующего обычно является программной ошибкой. Но в некоторых общих программах при написании кода мы не всегда можем знать, какие ключи будут присутствовать в словарях во время выполнения. Как обрабатывать такие сценарии, чтобы избежать ошибок? Одно из решений предусматривает заблаговременную проверку. Выражение проверки членства в словаре, in, позволяет запрашивать существование ключа и организовать ветвление в зависимости от результата с помощью Python-оператора if. Во время ввода следующего кода не забудьте нажать клавишу <Enter> два раза для интерактивного выполнения оператора if (как объяснялось в главе 3, пустая строка в интерактивной подсказке означает "выполнить"). Кроме того, как и при вводе примеров многострочных словарей и списков ранее в главе, в некоторых интерфейсах приглашение изменяется на ... для второй строки и далее:

```python
>>> 'f' in D
False
>>> if not 'f' in D:    # Единственный оператор выбора Python
    print('missing')
missing
```

Оператор if еще будет обсуждаться в более поздних главах книги, но применяемая здесь форма прямолинейна: она состоит из слова if, за которым следует выражение, дающее истинный или ложный результат, и блок кода, подлежащий выполнению в случае истинного результата проверки.

Во-вторых, если вы знакомы с JSON (JavaScript Object Notation — система обозначений для объектов JavaScript), который представляет собой развивающийся формат обмена данными, применяемый для баз данных и передачи по сети, тогда этот пример также может выглядеть на удивление похожим, хотя поддержка переменных, произвольные выражения и изменения Python могут сделать его структуры данных более универсальными. Библиотечный модуль Python по имени json поддерживает создание и разбор текста JSON, но трансляция в объекты Python часто тривиальна. Созданная запись res будет задействована в примере использования JSON в главе 9 при изучении файлов. За более крупным сценарием применения обратитесь к системе управления базами данных MongoDB, которая хранит данные с использованием нейтральной к языкам двоичной сериализации JSON-подобных документов, и ее интерфейсу PyMongo.