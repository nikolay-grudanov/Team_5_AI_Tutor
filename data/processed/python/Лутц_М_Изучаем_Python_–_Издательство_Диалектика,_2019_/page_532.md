---
source_image: page_532.png
page_number: 532
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 29.14
tokens: 7707
characters: 2562
timestamp: 2025-12-24T01:23:52.276974
finish_reason: stop
---

abc 0
>>> state
0

Во-вторых, оператор nonlocal ограничивает поиск в областях видимости только объемлющими def; нелокальные переменные не ищутся в глобальной области видимости включающего модуля или во встроенной области видимости за пределами всех def, даже если они там находятся:

>>> spam = 99
>>> def tester():
    def nested():
        nonlocal spam   # Должна быть в def, а не в модуле!
        print('Current=', spam)
        spam += 1
    return nested

SyntaxError: no binding for nonlocal 'spam' found
Синтаксическая ошибка: не найдена привязка для нелокальной переменной spam

Такие ограничения обретут смысл, как только вы осознаете, что в противном случае Python вообще не знал бы, в какой объемлющей области видимости создавать совершенно новое имя. Где в предыдущем примере должна присваиваться переменная spam — внутри tester или во включающем модуле? Поскольку это неоднозначно, Python вынужден распознавать нелокальные переменные на этапе создания функций, а не во время вызова функций.

Для чего используются оператор nonlocal?
Варианты сохранения состояния

Учитывая дополнительную сложность вложенных функций, вас может интересовать, для чего они нужны. Хотя это трудно разглядеть в наших небольших примерах, во многих программах информация о состоянии становится критически важной. Несмотря на то что функции способны возвращать результаты, их локальные переменные обычно не сохраняют остальные значения, которые должны существовать между вызовами. Более того, многочисленные приложения требуют, чтобы такие значения отличались в зависимости от контекста применения.

Ранее уже упоминалось, что в Python доступны разнообразные способы "запоминания" информации между вызовами функций и методов. Невзирая на наличие компромиссов, связанных со всеми способами, оператор nonlocal улучшает положение дел для ссылок на переменные из объемлющих областей видимости — nonlocal позволяет хранить в памяти множество копий изменяемого состояния. Он решает простую задачу сохранения состояния, когда использование классов может быть не оправданным, а глобальные переменные неприменимы, хотя атрибуты функций часто могут исполнять похожие роли более переносимым образом. Ниже приведен обзор возможных вариантов.

Состояние с помощью оператора nonlocal: только Python 3.x

Как было показано в предыдущем разделе, представленный далее код позволяет сохранять и модифицировать состояние из объемлющей области видимости. Каждый вызов tester создает самодостаточный пакет изменяемой информации, а имена пакетов не конфликтуют с любой другой частью программы: