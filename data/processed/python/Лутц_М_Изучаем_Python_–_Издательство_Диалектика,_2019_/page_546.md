---
source_image: page_546.png
page_number: 546
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 37.35
tokens: 7879
characters: 2928
timestamp: 2025-12-24T01:24:24.038131
finish_reason: stop
---

кация которых вызывает проблему. Скажем, попытка изменения кортежей приводит к генерации исключения:

L = [1, 2]
changer(X, tuple(L)) # Передача кортежа, так что изменения приведут к ошибкам

В коде применяется встроенная функция tuple, которая строит новый кортеж из всех элементов в последовательности (на самом деле в любом итерируемом объекте). Решение выглядит чрезмерным. Поскольку функцию приходится писать так, чтобы она никогда не изменяла передаваемые аргументы, наложенных на нее ограничений может оказаться больше, чем должно быть, и потому в целом такого подхода следует избегать (изменение аргументов вполне может пригодиться в будущем). Использование указанной методики также приведет к тому, что функция будет лишена возможности вызывать на аргументе любые методы, специфичные для списков, включая те, которые не изменяют объект на месте.

Здесь важно помнить, что функции могут обновлять передаваемые им изменяемые объекты, подобные спискам и словарям. Когда такой эффект ожидается, он не обязательно считается проблемой и часто преследует полезные цели. Более того, функции, модифицирующие передаваемые им изменяемые объекты на месте, возможно, были спроектированы и предназначены делать именно это — вполне вероятно, что изменение является частью четко определенного API-интерфейса, который не должен нарушаться созданием копий.

Однако вы обязаны знать о таком свойстве — если объекты изменяются неожиданно для вас, тогда проверьте, несет ли за это ответственность вызываемая функция, и при необходимости создавайте копии при передаче объектов.

Эмуляция выходных параметров и множественных результатов

Мы уже обсуждали оператор return и применяли его в нескольких примерах. Существует еще один способ использования этого оператора: из-за того, что return способен отправлять обратно объект любого вида, он может возвращать множественные значения, упаковывая их в кортеж или коллекцию другого типа. На самом деле, хотя Python не поддерживает то, что в некоторых языках называется передачей аргументов по ссылке, мы обычно можем эмулировать его, возвращая кортежи и присваивая результаты исходным именам аргументов в вызывающем коде:

>>> def multiple(x, y):
    x = 2                # Изменяет только локальные имена
    y = [3, 4]
    return x, y          # Возвращение множества новых значений в кортеже

>>> x = 1
>>> L = [1, 2]
>>> X, L = multiple(X, L)  # Присваивание результатов именам в вызывающем коде
>>> X, L
(2, [3, 4])

Выглядит так, будто код возвращает два значения, но в действительности значение только одно — двухэлементный кортеж, в котором опущены необязательные окружающие круглые скобки. После возврата управления из вызова можно применить присваивание кортежей для распаковки частей возвращенного кортежа. (Если вы забыли, почему оно работает, перечитайте разделы "Кортежи" в главах 4 и 9, а также раздел "Операторы присваивания" в главе 11.) Совокупный эффект такого кодового шаблона