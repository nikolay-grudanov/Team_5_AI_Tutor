---
source_image: page_432.png
page_number: 432
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 41.55
tokens: 7902
characters: 2625
timestamp: 2025-12-24T01:21:07.692774
finish_reason: stop
---

Строго говоря, функция zip более универсальна, чем вытекает из приведенного примера. Скажем, она принимает последовательность любого типа (на самом деле любой итерируемый объект, включая файлы) и допускает передачу более двух аргументов. В случае трех аргументов, как в следующем примере, она строит список трехэлементных кортежей с элементами из каждой последовательности, по существу проецируя по столбцам (формально для N аргументов мы получаем N-арный кортеж):

```python
>>> T1, T2, T3 = (1,2,3), (4,5,6), (7,8,9)
>>> T3
(7, 8, 9)
>>> list(zip(T1, T2, T3))      # Три кортежа для трех аргументов
[(1, 4, 7), (2, 5, 8), (3, 6, 9)]
```

Кроме того, zip усекает результирующие кортежи по длине самой короткой последовательности, когда длины аргументов отличаются. В показанном ниже коде мы используем функцию zip для двух строк, чтобы выбирать символы параллельно, но результат будет содержать столько кортежей, сколько символов в более короткой строке:

```python
>>> S1 = 'abc'
>>> S2 = 'xyz123'
>>> 
>>> list(zip(S1, S2))      # Усекает по длине более короткой строки
[('a', 'x'), ('b', 'y'), ('c', 'z')]
```

**Эквивалентность map в Python 2.x**

В Python 2.x имеется связанная встроенная функция map, которая объединяет в пары элементы из последовательностей в похожей манере при передаче ей None в первом аргументе (для функции), но она дополняет более короткие последовательности с помощью None, если длины аргументов отличаются, а не усекает до наименьшей длины:

```python
>>> S1 = 'abc'
>>> S2 = 'xyz123'
>>> map(None, S1, S2)      # Python 2.x: дополняет до наибольшей длины
[('a', 'x'), ('b', 'y'), ('c', 'z'), (None, '1'), (None, '2'), (None, '3')]
```

В примере применяется вырожденная форма встроенной функции map, которая больше не поддерживается в Python 3.x. Обычно map принимает функцию и один или более аргументов последовательностей и накапливает результаты, вызывая функцию с параллельными элементами, которые извлекаются из последовательности (последовательностей).

Функция map будет детально исследоваться в главах 19 и 20, но в качестве короткого примера в показанном ниже коде map применяет встроенную функцию ord ко всем элементам в строке и накапливает результаты (подобно zip, функция map является генератором значений в Python 3.x и потому должна быть помещена в вызов list для отображения сразу всех результатов):

```python
>>> list(map(ord, 'spam'))
[115, 112, 97, 109]
```

Код работает точно так же, как следующий оператор цикла, но map часто выполняется быстрее, как вы увидите в главе 21:

```python
>>> res = []
>>> for c in 'spam': res.append(ord(c))
>>> res
[115, 112, 97, 109]
```