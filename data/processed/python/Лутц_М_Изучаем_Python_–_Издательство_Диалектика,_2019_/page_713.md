---
source_image: page_713.png
page_number: 713
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 30.66
tokens: 7826
characters: 2559
timestamp: 2025-12-24T01:29:28.572663
finish_reason: stop
---

чение атрибутов похоже на индексацию словарей, но в классах задействовано наследование:

    >>> module2.name, module2.__dict__['name']
    (42, 42)

Уточнение имен атрибутов

Говоря об извлечении атрибутов, поскольку вы уже лучше знакомы с модулями, настало время более формально закрепить понятие уточнения имен. В Python доступ к атрибутам любого объекта, имеющего атрибуты, производится с применением синтаксиса уточнения объект.атрибут (также известного как извлечение атрибутов).

Уточнение на самом деле представляет собой выражение, возвращающее значение, которое было присвоено имени атрибута, ассоциированного с объектом. Скажем, выражение module2.sys в предыдущем примере извлекает значение, присвоенное sys в module2. Подобным же образом, если есть встроенный списковый объект L, тогда L.append возвратит объект метода append, ассоциированный с этим списком.

Важно помнить о том, что уточнение атрибутов не имеет ничего общего с правилами поиска в областях видимости, рассмотренными в главе 17; оно является независимой концепцией. Когда уточнение используется для доступа к именам, Python дается явный объект, из которого необходимо извлечь указанные имена. Правило поиска в областях видимости LEGB применяется только к неуточненным именам — его можно использовать для крайнего слева имени в пути, но имена, находящиеся дальше после точек, взамен ищут специфические объекты. Ниже описаны принятые правила.

Простые переменные

Х означает поиск имени Х в текущих областях видимости (следуя правилу LEGB из главы 17).

Уточнение

Х.У означает поиск Х в текущих областях видимости, затем поиск атрибута У в объекте Х (не в областях видимости).

Пути уточнения

Х.У.З означает поиск имени У в объекте Х, затем поиск З в объекте Х.У.

Всеобщность

Уточнение работает для всех объектов с атрибутами: модулей, классов, типов расширений C и т.д.

В части VI мы увидим, что уточнение атрибутов имеет чуть большее значение для классов (она также является местом, где действует то, что называется наследованием), но в целом кратко описанные здесь правила применяются ко всем именам в Python.

Импортирование или области видимости

Как мы выяснили, доступ к именам, определенным в другом файле модуля, невозможен без первоначального импортирования этого файла. То есть вы никогда автоматически не увидите имена в другом файле безотносительно структуры операций импортирования или вызовов функций в своей программе. Смысл переменной всегда определяется местоположениями присваиваний в исходном коде, а атрибуты всегда запрашиваются с явным указанием объекта.