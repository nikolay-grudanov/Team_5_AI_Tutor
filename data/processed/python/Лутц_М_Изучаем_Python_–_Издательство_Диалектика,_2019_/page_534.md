---
source_image: page_534.png
page_number: 534
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 28.53
tokens: 7701
characters: 2472
timestamp: 2025-12-24T01:23:54.883103
finish_reason: stop
---

>>> G = tester(42)    # Сбрасывает единственную копию state в глобальной
#    области видимости
>>> G('toast')
toast 42
>>> G('bacon')
bacon 43
>>> F('ham')        # Но мой счетчик был перезаписан!
ham 44

Как было показано ранее, когда вместо global используется оператор nonlocal и замыкания вложенных функций, каждый вызов tester запоминает собственную уникальную копию объекта state.

Состояние с помощью классов:
явные атрибуты (предварительный обзор)

Еще одна рекомендация для поддержки изменяемой информации о состоянии в Python 2.x и предшествующих версиях заключается в применении классов с атрибутами, чтобы сделать доступ к информации о состоянии более явным, чем скрытая магия правил поиска в областях видимости. В качестве добавочного преимущества каждый экземпляр класса получает новую копию информации о состоянии как естественный побочный продукт объектной модели Python. Классы также поддерживают наследование, множество линий поведения и другие инструменты.

Мы пока не рассматривали классы подробно, но для сравнения и краткого обзора ранее показанные функции tester/nested переделаны в класс, который явно регистрирует состояние в объектах при их создании. Чтобы понять код, необходимо знать, что оператор def внутри class работает в точности как нормальный def за исключением того, что аргумент self функции автоматически получает подразумеваемый объект вызова (экземпляр, созданный обращением к самому классу). При обращении к классу автоматически запускается функция по имени __init__:

>>> class tester:                # Альтернатива на основе класса (см. часть VI)
    def __init__(self, start):   # При создании объектов состояние
        self.state = start       # явно сохраняется в новом объекте
    def nested(self, label):
        print(label, self.state) # Явная ссылка на состояние
        self.state += 1           # Изменения также разрешены
>>> F = tester(0)
>>> F.nested('spam')
spam 0
>>> F.nested('ham')
ham 1

В классе мы сохраняем каждый атрибут явно, изменяется он или на него производится ссылка, и атрибуты доступны за пределами класса. Подобно вложенным функциям и оператору nonlocal альтернатива в форме класса поддерживает множество копий сохраненных данных:

>>> G = tester(42)                # Каждый экземпляр получает новую копию состояния
>>> G.nested('toast')             # Изменение одного не влияет на остальные
toast 42
>>> G.nested('bacon')
bacon 43
>>> F.nested('eggs')              # Состояние F осталось прежним