---
source_image: page_189.png
page_number: 189
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 35.35
tokens: 7956
characters: 2461
timestamp: 2025-12-24T01:12:56.204059
finish_reason: stop
---

>>> math.floor(2.567), math.floor(-2.567)    # Округление в меньшую сторону
# (до меньшего целого)
(2, -3)

>>> math.trunc(2.567), math.trunc(-2.567)    # Усечение (отбрасывание
# десятичных цифр)
(2, -2)

>>> int(2.567), int(-2.567)    # Усечение (преобразование
# в целое число)
(2, -2)

>>> round(2.567), round(2.467), round(2.567, 2)    # Округление (версия Python 3.x)
(3, 2, 2.57)
>>> '%.1f' % 2.567, '{0:.2f}'.format(2.567)    # Округление для отображения
# (глава 7)
('2.6', '2.57')

Как уже известно, последний оператор производит строки, которые мы обычно выводим, и поддерживает разнообразные варианты форматирования. Как было описано ранее, вторая с конца проверка также выведет (3, 2, 2.57) в версиях, предшествующих Python 2.7 и 3.1, если поместить ее в вызов print для запрашивания более дружественного к пользователю отображения. Тем не менее, форматирование строк по-прежнему слегка отличается даже в Python 3.x; функция round округляет и отбрасывает десятичные цифры, но производит число с плавающей точкой в памяти, тогда как форматирование строк выдает строку, а не число:

>>> (1 / 3.0), round(1 / 3.0, 2), ('%.2f' % (1 / 3.0))
(0.3333333333333333, 0.33, '0.33')

Интересно отметить, что в Python доступны три способа вычисления квадратных корней: с использованием функции из модуля, выражения и встроенной функции (мы обратимся к ним в упражнении и его решении в конце части IV, чтобы посмотреть, какой способ обеспечивает более быстрое выполнение):

>>> import math
>>> math.sqrt(144)    # Функция из модуля
12.0
>>> 144 ** .5    # Выражение
12.0
>>> pow(144, .5)    # Встроенная функция
12.0
>>> math.sqrt(1234567890)    # Более крупные числа
35136.41828644462
>>> 1234567890 ** .5
35136.41828644462
>>> pow(1234567890, .5)
35136.41828644462

Обратите внимание, что стандартные библиотечные модули вроде math требуетсся импортировать, но встроенные функции, такие как abs и round, доступны всегда безо всякого импорта. Другими словами, модули являются внешними компонентами, а встроенные функции находятся в подразумеваемом пространстве имен, в котором Python автоматически осуществляет поиск имен, применяемых в программе. Такое пространство имен просто соответствует стандартному библиотечному модулю, называемому builtins в Python 3.x (и __builtin__ в Python 2.x). В частях книги, посвященных функциям и модулям, распознавание имен будет обсуждаться более подробно, но пока, когда вы слышите о модуле, сразу думайте об импортировании.