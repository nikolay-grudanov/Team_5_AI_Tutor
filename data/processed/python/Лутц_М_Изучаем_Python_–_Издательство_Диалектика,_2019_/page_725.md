---
source_image: page_725.png
page_number: 725
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 34.83
tokens: 7791
characters: 2782
timestamp: 2025-12-24T01:29:56.700023
finish_reason: stop
---

талог, который не имеет никакого отношения к вашему коду, просто потому, что он оказался вложенным в каталог, находящийся раньше в пути поиска. Как мы увидим позже, пакеты пространств имен, появившиеся в Python 3.3, позволяют в основном избавиться от этой роли, но достигают похожего эффекта алгоритически за счет просмотра вперед пути для поиска более поздних файлов.

Инициализация пространства имен модуля

В модели импортирования пакетов пути к каталогам в сценарии после импорта становятся реальными цепочками вложенных объектов. Скажем, в предыдущем примере после импортирования выражение dir1.dir2 работает и возвращает объект модуля, который содержит все имена, присвоенные инициализационным файлом __init__.py в каталоге dir2. Такие файлы предоставляют пространство имен для объектов модулей, созданных на основе каталогов, которые иначе не имели бы реального ассоциированного файла модуля.

Поведение оператора from *

В качестве расширенной возможности вы можете использовать в файлах __init__.py списки __all__ для определения, что экспортитьвать, когда каталог импортируется с помощью формы оператора from *. В файле __init__.py список __all__ представляет собой перечень имен подмодулей, которые должны автоматически импортироваться в случае применения from * для имени пакета (каталога). Если список __all__ не установлен, тогда оператор from * не загружает автоматически подмодули, вложенные в каталог; взамен он загружает только имена, которые определены присваиваниями в файле __init__.py каталога, в том числе любые подмодули, явно импортируемые кодом в данном файле. Например, оператор from подмодуль import X в файле __init__.py каталога делает имя X доступным в пространстве имен этого каталога. (В главе 25 будут показаны дополнительные роли для списка __all__: он обеспечивает объявление экспортирования from * простых файлов.)

Вы также можете оставить файлы __init__.py пустыми, если их роли выходят за рамки имеющихся потребностей (и откровенно говоря, на практике они часто пусты). Тем не менее, файлы __init__.py должны существовать, чтобы операции импортирования каталогов вообще работали.

Не путайте файлы __init__.py пакетов и методы __init__ конструкторов классов, с которыми мы встретимся в следующей части книги. Первые являются файлами кода, который выполняется, когда операции импортирования проходят через каталог пакета в первый раз во время выполнения программы, тогда как вторые вызываются при создании экземпляра. Оба средства исполняют роли, связанные с инициализацией, но в остальном они совершенно разные.

Пример импортирования пакетов

Давайте рассмотрим пример, который продемонстрирует в работе инициализационные файлы и пути. Следующие три файла находятся в каталоге dir1 и его подкаталоге dir2 — пути к ним указаны в комментариях: