---
source_image: page_653.png
page_number: 653
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 43.38
tokens: 8078
characters: 3280
timestamp: 2025-12-24T01:27:45.015037
finish_reason: stop
---

избежать добавления излишних накладных расходов на создание списка к тестируемой функции (хотя в большинстве тестов его влияние пренебрежимо мало).

Аналогичным образом результат range внутреннего цикла выносится в начало модуля, чтобы убрать затраты на его создание из суммарного времени, и помещается внутрь вызова list, а потому его затраты на обход не будут отклоняться из-за того, что он представляет собой генератор в Python 3.x (почти так же, как мы поступали в модуле timer). Результат может быть омрачен затратами внутреннего цикла итераций, но лучше удалить как можно больше переменных.

Кроме того, взгляните, как код в конце проходит по кортежу из пяти объектов функций и выводит атрибут __name__ каждого: вам уже известно, что это встроенный атрибут, который дает имя функции¹.

Результаты измерения времени

Запустив сценарий из предыдущего раздела в Python 3.7 на компьютере Windows 7, мы получаем следующие результаты — map быстрее списковых включений, они оба быстрее циклов for, а генераторные выражения и функции находятся посередине (показания времени здесь представляют собой суммарное время в секундах):

C:\code> c:\python37\python timeseqs.py
3.7.3 (v3.7.3:ef4ec6ed12, Mar 25 2019, 21:26:53) [MSC v.1916 32 bit (Intel)]
forLoop : 2.34160 => [0...9999]
listComp : 1.31783 => [0...9999]
mapCall : 0.41968 => [0...9999]
genExpr : 1.92063 => [0...9999]
genFunc : 1.93672 => [0...9999]

Если вы достаточно долго исследуете код сценария timeseqs.py и его вывод, то заметите, что в наши дни генераторные выражения выполняются медленнее списковых включений. Несмотря на то что помещение генераторного выражения внутрь вызова list делает его функционально эквивалентным списковому включению в квадратных скобках, внутренние реализации двух выражений видимо отличаются (правда, мы фактически учитываем для генератора также и время вызова list):

return [abs(x) for x in repslist]      # 1.32 секунды
return list(abs(x) for x in repslist)   # 1.92 секунды: внутренне отличаются

Хотя выяснение точной причины потребовало бы более глубокого анализа (и возможно изучения исходного кода), похоже, это имеет смысл, учитывая тот факт, что генераторное выражение должно делать дополнительную работу по сохранению и восстановлению своего состояния во время выпуска значений. Списковое включение в такой работе не нуждается и выполняется несколько быстрее здесь и в более поздних тестах.

Интересно отметить, что когда я запускал сценарий timeseqs.py в версии Python 3.0 на компьютере Windows Vista для четвертого издания книги и в версии Python 2.5

¹ Предварительный обзор: обратите внимание, что здесь мы обязаны передавать функции в timer вручную. В главах 39 и 40 второго тома мы увидим альтернативные таймеры на основе декораторов, посредством которых хронометрируемые функции вызываются обычным образом, но требуют дополнительного синтаксиса @ в местах, где они определяются. Декораторы могут быть более удобными для снабжения функций логикой измерения времени, когда они уже используются внутри крупной системы, и они не настолько легко поддерживают предполагаемые здесь более изолированные схемы вызова тестов. Если функция декорирована, тогда каждый ее вызов запускает логику измерения времени, что в зависимости от преследуемых целей может быть плюсом или минусом.