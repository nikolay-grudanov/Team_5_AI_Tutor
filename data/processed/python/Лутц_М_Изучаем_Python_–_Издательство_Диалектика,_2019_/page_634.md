---
source_image: page_634.png
page_number: 634
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 42.88
tokens: 8047
characters: 2845
timestamp: 2025-12-24T01:27:12.876051
finish_reason: stop
---

В следующем примере каждый вызов permute2 и next возвращает управление немедленно, как и ранее, но вызов permute1 зависает:

```python
>>> import random
>>> math.factorial(20)    # permute1 здесь не подойдет
2432902008176640000
>>> seq = list(range(20))
>>> random.shuffle(seq)    # Предварительно перетасовать последовательность
# случайным образом
>>> p = permute2(seq)
>>> next(p)
[10, 17, 4, 14, 11, 3, 16, 19, 12, 8, 6, 5, 2, 15, 18, 7, 1, 0, 13, 9]
>>> next(p)
[10, 17, 4, 14, 11, 3, 16, 19, 12, 8, 6, 5, 2, 15, 18, 7, 1, 0, 9, 13]
>>> random.shuffle(seq)
>>> p = permute2(seq)
>>> next(p)
[16, 1, 5, 14, 15, 12, 0, 2, 6, 19, 10, 17, 11, 18, 13, 7, 4, 9, 8, 3]
>>> next(p)
[16, 1, 5, 14, 15, 12, 0, 2, 6, 19, 10, 17, 11, 18, 13, 7, 4, 9, 3, 8]
```

Суть здесь в том, что генераторы иногда способны производить результаты из крупных наборов решений, тогда как построители списков — нет. В то же время неясно, насколько распространены такие сценарии использования в реальном мире, и это не обязательно служит оправданием неявной природы генерации значений, которую привносят генераторные функции и выражения. Как будет показано в части VI, генерацию значений можно также реализовать в виде итерируемых объектов, создаваемых посредством классов. Итерируемые объекты, основанные на классах, тоже могут выпускать элементы по запросу, к тому же они гораздо более явные, чем магические объекты и методы, производимые для генераторных функций и выражений.

Одной из задач программирования является нахождение баланса между подобного рода компромиссами, и каких-то абсолютных правил не существует. Хотя преимущества генераторов могут временами оправдывать их применение, удобство сопровождения всегда должно иметь высший приоритет. Подобно включениям генераторы также предлагают выразительность и экономию кода, перед чем трудно устоять, если вы понимаете, как генераторы работают, но это нужно соотнести с возможным разочарованием коллег, имеющих иное мнение.

Пример: эмуляция zip и map с помощью итерационных инструментов

Чтобы помочь в дальнейшей оценке ролей генераторов, давайте рассмотрим еще один пример их в действии, который продемонстрирует, насколько они могут быть выразительными. Как только вы узнаете о включениях, генераторах и других итерационных инструментах, сразу выяснится, что эмуляция работы многих встроенных функций Python оказывается прямолинейной и поучительной. Скажем, мы уже видели, что встроенные функции zip и map соответственно объединяют итерируемые объекты и проецируют на них функции. При множестве итерируемых аргументов map проецирует функцию на элементы, взятые из каждого итерируемого объекта, во многом таким же способом, которым zip объединяет их в пары (функция map в Python 3.x усекает до более короткого итерируемого объекта, а в Python 2.x дополняет более короткие итерируемые объекты значением None):