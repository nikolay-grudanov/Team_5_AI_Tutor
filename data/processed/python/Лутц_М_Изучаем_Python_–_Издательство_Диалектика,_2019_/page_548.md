---
source_image: page_548.png
page_number: 548
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 28.41
tokens: 7800
characters: 2675
timestamp: 2025-12-24T01:24:20.751923
finish_reason: stop
---

Основы сопоставления аргументов

Прежде чем углубляться в детали синтаксиса, следует подчеркнуть, что эти специальные режимы необязательны и имеют дело только с сопоставлением объектов с именами; лежащим в основе механизмом после того, как сопоставление произошло, по-прежнему является присваивание. В действительноности некоторые инструменты такого рода предназначены в большей степени для тех, кто создает библиотеки, а не для разработчиков приложений. Но поскольку вы можете столкнуться с данными режимами, даже если сами не применяете их в своем коде, ниже представлен краткий обзор доступных инструментов.

Позиционные: сопоставляются слева направо
Нормальный сценарий, который мы главным образом использовали до сих пор, предусматривает сопоставление переданных значений аргументов с именами аргументов в заголовке функции по позиции, слева направо.

Ключевые: сопоставляются по имени аргумента
В качестве альтернативы в вызывающем коде можно указывать, какой аргумент в функции получает значение, за счет применения имени аргумента в вызове посредством синтаксиса имя=значение.

Стандартные: указывают значения для необязательных аргументов, которым значения не передавались
Сами функции могут задавать стандартные значения для аргументов, которые они получат, если в вызове передается слишком мало значений, снова с использованием синтаксиса имя=значение.

Сбор переменного количества аргументов: собирает произвольно много позиционных и ключевых аргументов
В функциях могут применяться специальные аргументы, предваренные одним или двумя символами *, для сбора произвольного количества возможных добавочных аргументов. Такую возможность часто называют переменным количеством аргументов (varargs) в честь списка аргументов переменной длины в языке C; в Python аргументы собираются в нормальный объект.

Распаковка переменного количества аргументов:
передает произвольно много позиционных и ключевых аргументов
В вызывающем коде синтаксис * можно также использовать для распаковки коллекций аргументов в отдельные аргументы. Это противоположность * в заголовке функции — синтаксис * в заголовке означает сбор произвольно большого числа аргументов, тогда как в вызове он означает распаковку произвольно большого количества аргументов и их передачу по отдельности как обособленных значений.

Аргументы с передачей только по ключевым словам:
аргументы, которые должны передаваться по имени
В Python 3.x (но не в Python 2.x) функции также допускают указание аргументов, которые должны передаваться по имени с помощью ключевых аргументов, а не по позиции. Такие аргументы обычно применяются для определения конфигурационных параметров в дополнение к фактическим аргументам.