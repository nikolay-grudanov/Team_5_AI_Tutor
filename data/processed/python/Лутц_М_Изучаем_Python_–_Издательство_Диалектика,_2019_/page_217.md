---
source_image: page_217.png
page_number: 217
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 29.78
tokens: 7775
characters: 2621
timestamp: 2025-12-24T01:13:46.564718
finish_reason: stop
---

ношения к ним не имеет. Скажем, из-за особенностей модели ссылок Python есть два разных способа проверки на равенство в программе Python. В целях демонстрации создадим разделяемую ссылку:

```python
>>> L = [1, 2, 3]
>>> M = L        # M и L ссылаются на один и тот же объект
>>> L == M       # Одинаковые значения
True
>>> L is M       # Одинаковые объекты
True
```

Первый прием, операция ==, предусматривает проверку, имеют ли два ссылаемых объекта одинаковые значения; такой метод почти всегда используется для проверок на предмет равенства в Python. Второй прием, операция is, проверяет идентичность — она возвращает True, только если оба имени указывают на точно тот же самый объект, поэтому операция is является гораздо более строгой формой проверки равенства и редко применяется в большинстве программ.

На самом деле операция is просто сравнивает указатели, которые реализуют ссылки, и при необходимости служит способом обнаружения разделяемых ссылок в коде. Она возвращает False, если имена указывают на эквивалентные, но разные объекты, как в случае выполнения двух разных литеральных выражений:

```python
>>> L = [1, 2, 3]
>>> M = [1, 2, 3]    # M и L ссылаются на разные объекты
>>> L == M           # Одинаковые значения
True
>>> L is M           # Разные объекты
False
```

А теперь посмотрим, что произойдет, когда мы выполним те же операции на небольших числах:

```python
>>> X = 42
>>> Y = 42           # Должны быть двумя разными объектами
>>> X == Y
True
>>> X is Y           # Как бы то ни было, тот же самый объект: кеширование в действии!
True
```

В последнем взаимодействии X и Y должны давать True в операции == (то же самое значение), но не в операции is (тот же самый объект), потому что мы выполняли два разных литеральных выражения (42). Однако поскольку небольшие целые числа и строки кешируются и используются повторно, операция is сообщает о том, что они ссылаются на тот же самый одиночный объект.

Если вы действительно хотите заглянуть "за кулисы", то всегда можете поинтересоваться у Python, сколько ссылок на объект имеется: функция getrefcount из стандартного модуля sys возвращает счетчик ссылок объекта. Скажем, когда я запрашиваю счетчик ссылок целочисленного объекта 1 в графическом пользовательском интерфейсе IDLE, то получаю отчет о его 647 повторных применениях (большинство которых относится к системному коду IDLE, а не моему); тем не менее, за пределами IDLE возвращается информация о 173 повторных использованиях, так что Python и сам накапливает объекты 1):

```python
>>> import sys
>>> sys.getrefcount(1)   # 647 указателя на этот разделяемый участок памяти
647
```