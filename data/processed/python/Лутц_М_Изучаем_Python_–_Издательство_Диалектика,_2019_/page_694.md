---
source_image: page_694.png
page_number: 694
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 28.81
tokens: 7847
characters: 2463
timestamp: 2025-12-24T01:28:49.848594
finish_reason: stop
---

c:\code\py3x> C:\python33\python
>>> import script0
hello world
1267650600228229401496703205376
>>> ^Z

c:\code\py3x> dir
05/31/2019  10:58 AM           39 script0.py
05/31/2019  11:00 AM   <DIR>    __pycache__

c:\code\py3x> dir __pycache__
05/31/2019  11:00 AM           184 script0.cpython-33.pyc

Критически важно то, что в рамках модели Python 3.2 и последующих версий импортирование того же самого файла с помощью другой версии Python создает другой файл байт-кода вместо переписывания одиночного файла, как делается в модели, принятой до Python 3.2. В более новой модели каждая версия и реализация Python имеет собственные файлы байт-кода, готовые к загрузке при следующем запуске программы (ранние версии Python будут благополучно использовать свою схему на том же самом компьютере):

c:\code\py3x> C:\python32\python
>>> import script0
hello world
1267650600228229401496703205376
>>> ^Z

c:\code\py3x> dir __pycache__
05/31/2019  12:28 PM           178 script0.cpython-32.pyc
05/31/2019  11:00 AM           184 script0.cpython-33.pyc

Более новая модель файлов байт-кода Python 3.2 вероятно лучше, т.к. она избегает повторной компиляции, когда на компьютере установлено более одной версии Python — частая ситуация в современном смешанном мире Python 2.X/3.X. С другой стороны, не обошлось без потенциальных несовместимостей в программах, которые полагаются на прежнюю структуру файлов и каталогов. Скажем, проблема несовместимости может возникать в определенных инструментальных программах, хотя большинство правильно ведущих себя инструментов должны работать, как и ранее. Возможное влияние описано в разделе документации Python 3.2, посвященном нововведениям.

Также имейте в виду, что данный процесс полностью автоматический — он является побочным эффектом выполнения программ — и большинство программистов, скорее всего, даже не будут заботиться или замечать разницу помимо более быстрого начального запуска из-за меньшего количества повторных компиляций.

Путь поиска модулей

Как упоминалось ранее, большинству программистов обычно придется беспокоиться только о первой части процедуры импортирования — поиске необходимого файла. Из-за того, что может возникнуть потребность сообщить Python, где искать файлы, подлежащие импортированию, вы должны знать, каким образом расширять путь поиска.

Во многих случаях вы можете положиться на автоматическую природу пути поиска модулей для импортирования и вообще не нуждаться в конфигурировании этого пути.