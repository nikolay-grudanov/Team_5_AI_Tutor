---
source_image: page_531.png
page_number: 531
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 23.71
tokens: 7643
characters: 2244
timestamp: 2025-12-24T01:23:46.413173
finish_reason: stop
---

spam 0
>>> F('ham')
ham 1
>>> F('eggs')
eggs 2

Как обычно со ссылками на переменные из объемлющих областей видимости, мы можем вызывать фабричную функцию (замыкание) tester много раз для получения множества копий ее состояния в памяти. Объект state из объемлющей области видимости по существу присоединен к возвращаемому объекту функции nested; каждый вызов создает новый, несовпадающий объект state, так что обновление состояния одной функции не оказывает влияния на состояние остальных функций. Ниже продолжается предыдущее взаимодействие:

>>> G = tester(42)    # Создание нового объекта функции tester,
# который начинает с 42
>>> G('spam')
spam 42
>>> G('eggs')        # Информация о состоянии обновилась на 43
eggs 43
>>> F('bacon')       # Но функция F осталась там, где и была: 3
bacon 3             # Каждый вызов имеет разную информацию о состоянии

В этом смысле нелокальные переменные Python более утилитарны, чем локальные переменные функции, типичные для ряда других языков. В функции замыкания нелокальные переменные являются данными с множеством копий для каждого вызова.

Граничные случаи

Несмотря на полезность, с нелокальными переменными связан ряд тонкостей, о которых следует знать. Во-первых, в отличие от оператора global к моменту выполнения оператора nonlocal перечисленным в нем именам действительно должны быть присвоены значения в области видимости объемлющего def, иначе возникнет ошибка — их нельзя создавать динамически, присваивая заново во вложенной области видимости. На самом деле они проверяются на этапе определения функций перед вызовом либо объемлющей, либо вложенной функции:

>>> def tester(start):
    def nested(label):
        nonlocal state    # Нелокальные переменные уже должны
        # существовать в объемлющем def!
        state = 0
        print(label, state)
    return nested
SyntaxError: no binding for nonlocal 'state' found
Синтаксическая ошибка: не найдена привязка для нелокальной переменной state
>>> def tester(start):
    def nested(label):
        global state    # Глобальные переменные не обязаны существовать
        # до их объявления
        state = 0      # Создает имя в области видимости модуля
        print(label, state)
    return nested
>>> F = tester(0)
>>> F('abc')