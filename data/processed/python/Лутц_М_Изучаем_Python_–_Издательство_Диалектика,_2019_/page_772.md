---
source_image: page_772.png
page_number: 772
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 43.79
tokens: 7771
characters: 2730
timestamp: 2025-12-24T01:31:21.387453
finish_reason: stop
---

нения программы в памяти присутствует только одна копия отдельно взятого модуля — вот для чего существует функция reload). Фактически список sys.path можно произвольно изменять:

```python
>>> sys.path = [r'd:\temp']    # Изменение пути поиска модулей
>>> sys.path.append('c:\\1p5e\\examples')    # Только для этого запуска (процесса)
>>> sys.path.insert(0, '..')
>>> sys.path
['..', 'd:\\temp', 'c:\\1p5e\\examples']
>>> import string
Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
ModuleNotFoundError: No module named 'string'
Трассировка (самый последний вызов указан последним):
    Файл <stdin>, строка 1, в <модуль>
Ошибка отсутствия модуля: модуль по имени string не найден
```

Таким образом, вы можете использовать эту методику для динамического конфигурирования пути поиска внутри программы Python. Однако будьте осторожны: если вы удалите критически важный каталог из пути поиска, то можете утратить доступ к нужным служебным средствам. Скажем, в предыдущем примере мы больше не имеем доступа к модулю string, потому что удалили из пути поиска каталог библиотеки Python!

Кроме того, не забывайте о том, что такие настройки sys.path сохраняются только на протяжении функционирования сеанса или программы Python (формально процесса), где они были сделаны; после выхода из Python они утрачиваются. Напротив, конфигурации пути поиска в переменной PYTHONPATH и файлах .pth находятся в среде операционной системы, а не в выполняющейся программе Python, и потому более глобальны: они подхватываются каждой программой на компьютере и существуют после ее завершения. В некоторых системах первый вариант может быть организован на основе пользователей, а второй охватывать всю установку.

Расширение as для операторов import и from

Со временем операторы import и from были расширены, чтобы позволить назначать импортированному имени другое имя в сценарии. Мы применяли это расширение раньше, но есть ряд дополнительных деталей. Следующий оператор import:

import modulename as name    # Использовать name, не modulename

эквивалентен приведенному ниже коду, который переименовывает модуль только в области видимости импортера (другим файлам модуль будет известен под своим первоначальным именем):

import modulename
name = modulename
del modulename    # Не сохранять первоначальное имя

После такого оператора import для ссылки на модуль вы можете — и фактически должны — использовать имя, указанное после as. Прием также работает в операторе from, позволяя назначать имени, которое импортировано из файла, другое имя в области видимости импортера; как и ранее, вы получите только указанное новое имя, но не первоначальное:

from modulename import attrname as name    # Использовать name, не attrname