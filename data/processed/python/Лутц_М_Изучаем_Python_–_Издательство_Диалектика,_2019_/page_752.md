---
source_image: page_752.png
page_number: 752
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 30.37
tokens: 7881
characters: 2729
timestamp: 2025-12-24T01:30:36.733801
finish_reason: stop
---

грузка обычного пакета происходит немедленно, как только он найден в пути поиска. Что касается пакетов пространств имен, то прежде чем пакет будет создан, должны быть просмотрены все элементы в пути поиска. Выражаясь более формально, обычные пакеты останавливают алгоритм, описанный в предыдущем разделе, на шаге 1, а пакеты пространств имен — нет.

Согласно документу PEP для данного изменения убирать поддержку обычных пакетов не планируется — по крайней мере, на сегодняшний день. Тем не менее, в проектах с открытым кодом изменение возможно всегда (на самом деле, в предыдущем издании книги цитировались планы относительно строкового форматирования и операций относительного импортирования в Python 2.x, которые позже были отменены), так что следите за будущей разработкой. Однако с учетом преимущества, связанного с производительностью, и кода автоматической инициализации обычных пакетов маловероятно, что такие пакеты когда-либо исчезнут.

Пакеты пространств имен в действии

Чтобы посмотреть, как работают пакеты пространств имен, создадим следующие два модуля и вложенную структуру каталогов — с двумя подкаталогами по имени sub, расположенными в разных родительских каталогах, dir1 и dir2:

C:\code\ns\dir1\sub\mod1.py
C:\code\ns\dir2\sub\mod2.py

Если мы добавим каталоги dir1 и dir2 в путь поиска модулей, то sub станет пакетом пространства имен, охватывающим оба каталога, с двумя файлами модулей, доступными под этим именем, несмотря на то, что они находятся в разных физических каталогах. Ниже приведено содержимое файлов и обязательная настройка пути в Windows: здесь нет никаких файлов __init__.py — на самом деле они не могут существовать в пакетах пространств имен, т.к. это их главное физическое отличие:

c:\code> mkdir ns\dir1\sub        # Два каталога с одинаковыми именами
c:\code> mkdir ns\dir2\sub        # в разных каталогах
c:\code> type ns\dir1\sub\mod1.py # Аналогично за рамками Windows
print(r'dir1\sub\mod1')
c:\code> type ns\dir2\sub\mod2.py # Файлы модулей в разных каталогах
print(r'dir2\sub\mod2')
c:\code> set PYTHONPATH=C:\code\ns\dir1;C:\code\ns\dir2

Теперь при импортировании напрямую в Python 3.3 и последующих версиях пакет пространства имен является виртуальным сцеплением своих индивидуальных компонентов-каталогов и делает возможным доступ к более вложенным частям через единое составное имя с помощью нормальных операций импортирования:

c:\code> C:\Python37\python
>>> import sub
>>> sub                # Пакеты пространств имен: вложенные пути поиска
<module 'sub' (namespace)>
>>> sub.__path__
_NamespacePath(['C:\\code\\ns\\dir1\\sub', 'C:\\code\\ns\\dir2\\sub'])
>>> from sub import mod1
dir1\sub\mod1
>>> import sub.mod2    # Содержимое из двух разных каталогов
dir2\sub\mod2