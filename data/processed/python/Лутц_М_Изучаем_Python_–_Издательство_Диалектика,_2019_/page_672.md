---
source_image: page_672.png
page_number: 672
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 30.11
tokens: 7824
characters: 2751
timestamp: 2025-12-24T01:28:11.556145
finish_reason: stop
---

основанном на любительском таймере, не только производится вызов функции для цикла измерения суммарного времени и привносятся небольшие издержки со стороны логики нахождения лучшего времени самого таймера, но в его внутреннем цикле также применяется готовый список, а не генератор range из Python 3.x. Видимо это в итоге делает его чуть быстрее на сопоставимых тестах (я бы назвал данный пример "контролем корректности", но не уверен, что такой термин применим при оценочных испытаниях).

Простор для улучшений: настройка

Подобно большинству программного обеспечения программа в настоящем разделе открыта и может произвольно расширяться. Как один пример, в файлах pybench2.py и pybench2_cases.py внутри пакета примеров добавлена поддержка описанной ранее возможности указания операторов настройки для модуля timeit в режимах API-вызовов и командной строки.

Первоначально эта возможность была опущена ради краткости и, откровенно говоря, из-за того, что тестам она, похоже, не требовалась — измерение времени выполнения кода большого объема дает более законченное представление при сравнении версий Python, а действия по настройке влекут за собой одинаковые затраты, когда проводится хронометраж альтернатив в одной версии Python. Даже при этих условиях иногда полезно предоставлять код настройки, который выполняется однократно в области видимости тестируемого кода, но затраченное время не учитывается в суммарном времени — скажем, импортирование модулей, инициализация объектов или определение функций.

Полностью содержимое указанных двух файлов приводиться не будет, но в качестве примера развития программного обеспечения ниже показаны их важные варьирующиеся части. Что касается тестируемого оператора, то оператор кода настройки передается в том виде, как есть, в режиме вызовов API-интерфейса, но он разделяется и снабжается отступами в режиме командной строки с передачей по одной строке в аргументе -s ($listif3 не используется, т.к. код настройки не хронометрируется):

# Файл pybench2.py
...
def runner(stmts, pythons=None, tracecmd=False):
    for (number, repeat, setup, stmt) in stmts:
        if not pythons:
            best = min(timeit.repeat(
                setup=setup, stmt=stmt, number=number, repeat=repeat))
        else:
            setup = setup.replace('\t', ' ' * 4)
            setup = ' '.join('-s "%s"' % line for line in setup.split('\n'))
        ...
        for (ispy3, python) in pythons:
            ...
            cmd = '%s -m timeit -n %s -r %s %s %s' %
                (python, number, repeat, setup, args)
# Файл pybench2_cases.py
import pybench2, sys
...
stmts = [ # (num,rpt,setup,stmt)
    (0, 0, "", "[x ** 2 for x in range(1000)]"),
    (0, 0, "", "res=[]\nfor x in range(1000): res.append(x ** 2)")],