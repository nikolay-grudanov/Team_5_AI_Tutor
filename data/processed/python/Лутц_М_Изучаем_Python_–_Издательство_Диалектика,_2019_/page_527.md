---
source_image: page_527.png
page_number: 527
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 29.42
tokens: 7718
characters: 2466
timestamp: 2025-12-24T01:23:46.500239
finish_reason: stop
---

16
>>> acts[1](2)      # Здесь должно быть 1 ** 2 (1)
16
>>> acts[2](2)      # Здесь должно быть 2 ** 2 (4)
16
>>> acts[4](2)      # И только здесь должно быть 4 ** 2 (16)
16

Мы столкнулись с ситуацией, когда по-прежнему приходится явно сохранять значения переменной из объемлющей области видимости с помощью стандартных значений аргументов, а не ссылок на переменную в объемлющей области видимости. Таким образом, чтобы обеспечить работу подобного кода, мы должны передавать текущее значение переменной из объемлющей области видимости посредством стандартного значения. Поскольку стандартные значения оцениваются при создании вложенных функций (а не их вызове в более позднее время), каждая запоминает собственное значение i:

    >>> def makeActions():
        acts = []
        for i in range(5):
            acts.append(lambda x, i=i: i ** x)   # Использование стандартных значений
        return acts

    >>> acts = makeActions()
    >>> acts[0](2)                        # 0 ** 2
    0
    >>> acts[1](2)                        # 1 ** 2
    1
    >>> acts[2](2)                        # 2 ** 2
    4
    >>> acts[4](2)                        # 4 ** 2
    16

Подход может выглядеть как предрасположенный к изменениям артефакт реализации, важность которого возрастает при написании более крупных программ. Стандартные значения более подробно обсуждаются в главе 18, а lambda — в главе 19; после чтения указанных глав можете еще раз пересмотреть текущий раздел3.

Произвольное вложение областей видимости

Прежде чем закончить обсуждение, следует отметить, что области видимости могут вкладываться произвольно глубоко, но при ссылке на имена их поиск производится только в операторах def объемлющих функций (не классов, описанных в части VI):

    >>> def f1():
        x = 99

3 В разделе "Затруднения, связанные с функциями" главы 21 мы также увидим, что существует похожая проблема с использованием изменяемых объектов вроде списков и словарей для стандартных значений аргументов (например, def f(a=[]) ) — поскольку стандартные значения реализованы как одиночные объекты, присоединенные к функциям, изменяемые объекты в качестве стандартных сохраняют состояние от вызова к вызову, а не инициализируются заново при каждом вызове. В зависимости от того, у кого вы спросите, это считается либо средством, поддерживающим еще один способ реализации хранения состояния, либо странной особенностью языка; более подробно данный аспект обсуждается в конце главы 21.