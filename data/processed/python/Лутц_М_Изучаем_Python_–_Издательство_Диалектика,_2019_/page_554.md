---
source_image: page_554.png
page_number: 554
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 30.96
tokens: 7757
characters: 2284
timestamp: 2025-12-24T01:24:36.381999
finish_reason: stop
---

Заголовки: сбор аргументов

Когда расширение * применяется в определении функции, оно обеспечивает сбор несопоставленных позиционных аргументов в кортеж:

>>> def f(*args): print(args)

При вызове такой функции Python собирает все позиционные аргументы в новый кортеж и присваивает его переменной args. Поскольку это нормальный объект кортежа, он допускает индексацию, проход в цикле for и т.д.:

>>> f()
()
>>> f(1)
(1,)
>>> f(1, 2, 3, 4)
(1, 2, 3, 4)

Расширение ** похоже, но только работает с ключевыми аргументами — оно собирает их в новый словарь, который затем можно обрабатывать с помощью обычных инструментов для словарей. В известном смысле форма ** позволяет преобразовывать ключевые слова в словари, которые затем можно проходить посредством вызовов keys, словарных итераторов и т.п. (приблизительно так поступает вызов dict при передаче ему ключевых слов, но он возвращает новый словарь):

>>> def f(**args): print(args)
>>> f()
{}
>>> f(a=1, b=2)
{'a': 1, 'b': 2}

Наконец, в заголовках функций можно комбинировать нормальные аргументы с расширениями * и **, чтобы реализовывать очень гибкие сигнатуры вызовов. Например, в следующем взаимодействии значение 1 передается по позиции, 2 и 3 собираются в кортеж pargs с позиционными аргументами, а x и y попадают в словарь kargs с ключевыми аргументами:

>>> def f(a, *pargs, **kargs): print(a, pargs, kargs)
>>> f(1, 2, 3, x=1, y=2)
1 (2, 3) {'y': 2, 'x': 1}

Такой код встречается редко, но он обнаруживается в функциях, которым необходимо поддерживать множество шаблонов вызова (скажем, для обратной совместимости). На самом деле эти расширения допускается комбинировать даже более сложными способами, которые на первый взгляд могут показаться неоднозначными — мы вернемся к этой идее позже в главе. Но сначала давайте посмотрим, что происходит, когда * и ** присутствуют в вызовах функций, а не в их определениях.

Вызовы: распаковка аргументов

Во всех последних выпусках Python мы можем использовать синтаксис * также при вызове функции. В таком контексте данный синтаксис имеет смысл, противоположный его смыслу в определении функции — он распаковывает коллекцию аргументов, а не собирает ее. Например, мы можем передать функции четыре аргумента в кортеже и позволить Python распаковать их в индивидуальные аргументы: