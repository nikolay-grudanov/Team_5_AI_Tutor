---
source_image: page_794.png
page_number: 794
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 33.75
tokens: 7964
characters: 3176
timestamp: 2025-12-24T01:32:03.632299
finish_reason: stop
---

Попробуйте написать код обеих вариаций в myclient и проведите тестирование в интерактивном сеансе, импортируя модуль myclient и инспектируя его атрибут __dict__.

5. Операции импортирования пакетов. Импортируйте свой файл из пакета. Создайте подкаталог по имени mypkg внутри каталога из пути поиска импортируемых модулей, скопируйте или переместите в новый подкаталог файл модуля mymod.py, созданный в упражнении 1 или 3, и попробуйте импортировать его с помощью операции импортирования пакета в форме import mypkg.mymod, после чего вызовите функции модуля. Попробуйте извлечь функции подсчета и посредством from тоже.

Чтобы все заработало, потребуется добавить файл __init__.py в подкаталог, куда был перемещен ваш файл модуля, но результат должен работать на всех основных платформах Python (это одна из причин использования точки в качестве разделителя внутри путей в Python). Создаваемым подкаталогом пакета может быть просто подкаталог внутри вашего рабочего каталога; в таком случае он будет найден через компонент домашнего каталога в пути поиска и вам не придется конфигурировать путь. Поместите в __init__.py какой-нибудь код и посмотрите, выполняется ли он в течение каждой операции импортирования.

6. Перезагрузки. Поэкспериментируйте с перезагрузками модуля: выполните тесты из примера changer.py главы 23, периодически изменяя сообщение и/или поведение вызываемой функции без остановки интерпретатора Python. В зависимости от вашей системы вы можете быть в состоянии редактировать модуль changer в другом окне или приостанавливать интерпретатор Python и редактировать в том же самом окне (в Unix текущий процесс обычно приостанавливают нажатием клавиатурной комбинации <Ctrl+Z> и возобновляют его работу посредством команды fg, хотя окно текстового редактора, вероятно, будет работать с тем же успехом).

7. Циклические операции импортирования. В разделе о затруднениях, связанных с рекурсивными (или циклическими) операциями импортирования, импортирование recur1 приводило к возникновению ошибки. Но если вы перезапустите Python и импортируете recur2 в интерактивном сеансе, тогда ошибка не возникает; проверьте это и убедитесь самостоятельно. Как вы думаете, почему импортирование recur2 нормально работает, а импортирование recur1 — нет? (Подсказка: Python сохраняет новые модули во встроенной таблице sys.modules — словаре — перед выполнением их кода; последующие операции импортирования сначала извлекают модуль из упомянутой таблицы, "завершен" модуль или еще нет.) Теперь попробуйте запустить recur1 как сценарий верхнего уровня: python recur1.py. Получите ли вы ту же самую ошибку, которая возникает при импортировании recur1 в интерактивном сеансе? Почему? (Подсказка: когда модули запускаются как программы, они не импортируются, поэтому данный случай дает тот же эффект, что и импортирование recur2 в интерактивном сеансе; recur2 является первым импортированным модулем.) Что происходит, когда вы запускаете recur2 как сценарий? Циклические операции импортирования на практике встречаются редко. С другой стороны, если вы сумеете понять, почему они представляют собой потенциальную проблему, то узнаете много нового о семантике импортирования Python.