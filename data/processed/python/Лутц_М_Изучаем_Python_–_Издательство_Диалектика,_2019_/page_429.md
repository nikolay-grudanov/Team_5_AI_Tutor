---
source_image: page_429.png
page_number: 429
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 32.92
tokens: 7794
characters: 2523
timestamp: 2025-12-24T01:20:52.229362
finish_reason: stop
---

>>> for i in range(len(S)):
...     X = S[i:] + S[:i]
...     print(X, end=' ')
...
spam pams amsp mspa

Отследите приведенные циклы по одной итерации за раз, если они кажутся непонятными. Второй цикл создает те же результаты, что и первый, но в другом порядке, не изменяя в ходе дела исходную переменную. Из-за того, что оба производят нарезание, чтобы получить части для объединения, они также работают на последовательности любого типа и возвращают последовательности того же типа, что и тасуемые — когда вы тасуете список, то создаете переупорядоченный список:

>>> L = [1, 2, 3]
>>> for i in range(len(L)):
...     X = L[i:] + L[:i]    # Работает на последовательности любого типа
...     print(X, end=' ')
...
[1, 2, 3] [2, 3, 1] [3, 1, 2]

Мы будем применять код подобного рода для тестирования функций с разными упорядочениями аргументов в главе 18 и распространим его на функции, генераторы и более искусные перестановки в главе 20 — это крайне полезный инструмент.

Неполный обход: range или срезы

Случаи вроде приведенных в предыдущем примере являются эффективными приложениями для комбинации range/len. Мы можем также использовать такую методику для пропускания элементов по мере продвижения:

>>> S = 'abcdefghijklmnopqrstuvwxyz'
>>> list(range(0, len(S), 2))
[0, 2, 4, 6, 8, 10]
>>> for i in range(0, len(S), 2): print(S[i], end=' ')
...
acegik

Здесь мы посещаем каждый второй элемент в строке S за счет перехода согласно списку, сгенерированному функцией range. Для посещения каждого третьего элемента измените третий аргумент range на 3 и т.д. Фактически применение range подобным образом позволяет пропускать элементы в циклах, по-прежнему сохраняя простоту циклической конструкции for.

Тем не менее, в наши дни это также вряд ли можно считать рекомендуемой методикой в Python. Если вы действительно намереваетесь пропускать элементы в последовательности, то расширенная форма выражения среза с тремя пределами, представленная в главе 7, обеспечивает более простой способ достижения той же цели. Например, для посещения каждого второго символа в S нарезайте со страйдом 2:

>>> S = 'abcdefghijklmnopqrstuvwxyz'
>>> for c in S[::2]: print(c, end=' ')
...
acegik

Результат будет таким же, но код значительно легче для написания и восприятия другими. Потенциальное преимущество использования range связано с занимаемым пространством: срез создает копию строки в Python 2.x и 3.x, тогда как range в Python 3.x и xrange в Python 2.x не создают список; в случае очень больших строк удается сэкономить память.