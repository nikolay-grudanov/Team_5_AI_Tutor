---
source_image: page_189.png
page_number: 189
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 24.87
tokens: 8458
characters: 1671
timestamp: 2025-12-24T02:20:48.109661
finish_reason: stop
---

EXPOSE 8080

COPY . /app

CMD ["python", "main.py"]

Давайте пройдемся по инструкциям, содержащимся в предыдущем файле Dockerfile, одну за другой:

• Первая инструкция, которую выполняет Dockerfile, — установить базовый образ для нашего собственного образа с помощью ключевого слова FROM. Другие варианты этого образа можно найти по адресу https://hub.docker.com/_/python.

• В следующей строке ключевое слово WORKDIR используется для задания рабочего каталога /app. Рабочий каталог помогает организовать структуру проекта, построенного на образе.

• Затем мы копируем файл requirements.txt из локального каталога в рабочий каталог контейнера Docker, используя ключевое слово COPY.

• Следующая инструкция — это команда RUN, которая используется для обновления пакета pip и последующей установки зависимостей из файла requirements.txt.

• Следующая команда предоставляет ПОРТ, через который к нашему приложению можно получить доступ из локальной сети.

• Следующая команда копирует остальные файлы и папки в рабочий каталог контейнера Docker.

• Наконец, последняя команда запускает приложение с помощью команды CMD.

Каждый набор инструкций, перечисленных в Dockerfile, создается как отдельный уровень. Docker выполняет интеллектуальную работу по кэшированию каждого слоя во время сборки, чтобы сократить время сборки и исключить повторение. Если слой, который по сути является инструкцией, остается нетронутым, этот слой пропускается и используется ранее созданный. То есть Docker использует систему кэширования при сборке образов.

Давайте создадим файл .dockerignore, прежде чем приступить к сборке образа:

(venv) $ touch .dockerignore

.dockerignore

Venv
.env
.git