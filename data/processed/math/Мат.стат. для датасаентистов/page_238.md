---
source_image: page_238.png
page_number: 238
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 92.98
tokens: 12207
characters: 2393
timestamp: 2025-12-24T06:17:13.618643
finish_reason: stop
---

inc_ratio, равным 8,0, то мы приходим к крайнему левому листу и предсказываем, что ссуда будет погашена.

Сгенерировать структурно распечатанную версию дерева тоже не представляет труда:

loan_tree
n= 3000

node), split, n, loss, yval, (yprob)
    * denotes terminal node

1) root 3000 1467 paid off (0.5110000 0.4890000)
   2) borrower_score>=0.525 1283 474 paid off (0.6305534 0.3694466)
      4) payment_inc_ratio< 8.772305 845 249 paid off (0.7053254 0.2946746) *
      5) payment_inc_ratio>=8.772305 438 213 default (0.4863014 0.5136986)
         10) borrower_score>=0.625 149 60 paid off (0.5973154 0.4026846) *
         11) borrower_score< 0.625 289 124 default (0.4290657 0.5709343) *
   3) borrower_score< 0.525 1717 724 default (0.4216657 0.5783343)
      6) payment_inc_ratio< 9.73236 1082 517 default (0.4778189 0.5221811)
         12) borrower_score>=0.375 784 384 paid off (0.5102041 0.4897959) *
         13) borrower_score< 0.375 298 117 default (0.3926174 0.6073826) *
      7) payment_inc_ratio>=9.73236 635 207 default (0.3259843 0.6740157) *

Глубина дерева показана отступом. Каждый узел соответствует предварительной классификации, определяемой преобладающим исходом в данном сегменте. "Потеря" — это число неправильных результатов классификации, производимое предварительной классификацией в сегменте. Например, в узле 2 было 474 неправильных результатов классификации из общего числа 1467 записей. Значения в круглых скобках представляют собой долю записей соответственно о погашенных и невозвратных ссудах. Например, в узле 13, который предсказывает невозврат, более 60% записей — это невозвратные ссуды.

Алгоритм рекурсивного сегментирования

Алгоритм рекурсивного сегментирования для построения дерева решений достаточно прямолинеен и интуитивно понятен. Данные многократно делятся при помощи значений предикторов, которые делают все возможное, чтобы разложить данные на относительно однородные сегменты. На рис. 6.4 представлено изображение сегментов, созданных для дерева на рис. 6.3. Первое правило borrower_score >= 0.525 на графике обозначено под номером 1. Второе правило payment_inc_ratio < 9.732 делит правостороннюю область на две.

Предположим, что у нас есть переменная отклика Y и набор из P предикторных переменных X_j для j = 1, ..., P. Для сегмента A с записями алгоритм рекурсивного сегментирования найдет лучший способ разбить A на два подсегмента: