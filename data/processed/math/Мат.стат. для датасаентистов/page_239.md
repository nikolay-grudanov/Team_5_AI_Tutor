---
source_image: page_239.png
page_number: 239
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 37.02
tokens: 11640
characters: 1343
timestamp: 2025-12-24T06:16:25.451887
finish_reason: stop
---

1. Для каждой предикторной переменной \( X_j \):

• для каждого значения \( s_j \) из \( X_j \):
  ▫ отнести записи в \( A \) со значениями \( X_j < s_j \) в один сегмент и оставшиеся записи, где \( X_j \geq s_j \), — в другой сегмент;
  ▫ измерить однородность классов в каждом подсегменте \( A \);
• выбрать значение \( s_j \), которое порождает максимальную внутрисегментную однородность класса.

2. Выбрать переменную \( X_j \) и значение разбиения \( s_j \), которое порождает максимальную внутрисегментную однородность класса.

Теперь наступает очередь рекурсивной части:
1. Инициализировать \( A \) всем набором данных.
2. Применить алгоритм сегментирования, чтобы разбить \( A \) на два подсегмента, \( A_1 \) и \( A_2 \).
3. Повторить шаг 2 на подсегментах \( A_1 \) и \( A_2 \).
4. Алгоритм завершается, когда невозможно создать никакой дальнейший сегмент, который в достаточной мере улучшает однородность сегментов.

![Правила для простой древовидной модели, подогнанной к данным о ссудах](https://i.imgur.com/3Q5z5QG.png)

Рис. 6.4. Правила для простой древовидной модели, подогнанной к данным о ссудах

Конечным результатом является сегментирование данных, как на рис. 6.4, за исключением \( P \)-размерностей, где каждый сегмент предсказывает результат 0 либо 1 в зависимости от мажоритарного голосования отклика в этом сегменте.