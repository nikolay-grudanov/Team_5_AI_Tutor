---
source_image: page_326.png
page_number: 326
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 28.33
tokens: 5414
characters: 2449
timestamp: 2025-12-24T07:24:18.839198
finish_reason: stop
---

грамматики, а их последовательность — структурой конкретного дерева вывода.

Опишем этот процесс более формально на примере дерева вывода для выражения \( a * b + a * c \) (рис. 7.7). На этом рисунке нетерминальные вершины выделены кружками и обозначены \( v_1, ..., v_7 \). Кроме того, каждая вершина помечена соответствующим ей правилом \( \rho_i \) грамматики; индекс \( i \) — это номер правила в порядке его упоминания в примере 7.5.

Каждому правилу \( \rho_i \) поставим в соответствие функцию \( g_i \), число аргументов которой равно числу нетерминальных символов в правой части. Для правил, использованных в дереве рис. 7.7, эти функции таковы:

\[
\begin{align*}
\rho_1 : I &\to I + T; \quad g_1(x_1, x_2) = x_1 + x_2; \\
\rho_3 : I &\to T * M; \quad g_3(x_1, x_2) = x_1 * x_2; \\
\rho_0 : T &\to T * M; \quad g_9(x_1, x_2) = x_1 * x_2; \\
\rho_{12} : T &\to a; \quad g_{12} = a,
\end{align*}
\]
кроме того, \( g_{17} = b, g_{18} = c \).

Следует иметь в виду, что знаки + и * в \( \rho_i \) и \( g_i \) имеют различное содержание. В синтаксических правилах \( \rho_i \) — это абстрактные символы, в функциях \( g_i \) — это осмысленные знаки знакомых нам арифметических операций, связанные с определенными действиями над числами \( x_1 \) и \( x_2 \).

Пусть вершине \( v_j \) соответствует правило \( \rho_i \). В нашем примере \( v_j \) имеет не более двух потомков; обозначим через \( v_{j1} \) левого потомка, а через \( v_{j2} \) — правого потомка \( v_j \). Поставим в соответствие вершине \( v_j \) функцию-признак \( h(v_j) \), определяемый следующим образом: \( h(v_j) = g_i \), если \( \rho_i \) — терминальное правило (\( i = 12, 17, 18 \)), \( h(v_j) = g_i(h(v_{j1}), h(v_{j2})) \), если \( \rho_i \) — нетерминальное правило.

Нетрудно убедиться, что формально определенный таким образом вычислительный процесс для нашего примера осуществляет вычисление элементарных арифметических операций, соответствующих вершинам, и передачу результатов от листьев к корню, т. е. работает так, как описано выше. Однако для выражений, содержащих деление, одной функции на правило недостаточно. Дело в том, что деление на 0 недопустимо; поэтому, помимо арифметических операций, необходимо проверять, не равен ли делитель нулю, и если да, то передавать наверх, к корню, сообщение о бессмысленности всего выражения в целом. Это можно сделать, поставив в соответствие правилу \( \rho_i \), кроме арифметической функции \( g_i \), еще и преди-