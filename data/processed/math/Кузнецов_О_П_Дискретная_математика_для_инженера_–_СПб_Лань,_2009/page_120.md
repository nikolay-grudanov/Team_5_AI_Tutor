---
source_image: page_120.png
page_number: 120
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 28.34
tokens: 5414
characters: 2381
timestamp: 2025-12-24T07:19:58.912181
finish_reason: stop
---

увеличивается на 1. Если на данном шаге ребро включается в уже построенный букет (п. 2, а), то полученный граф связан и не создает новых путей в прежнем букете. Поэтому он является деревом, а общее число деревьев в построенном лесе сохраняется. В случае 2, в выбранное ребро соединяет два ранее не связанных дерева в одно, и число деревьев в построенном лесе уменьшается на 1. Наконец, в случае 2, г присоединение ребра к букету образовало бы цикл; поэтому оно в букет не включается.

Таким образом, результатом работы алгоритма является покрывающий лес, т. е. лес, содержащий все вершины исходного графа. Если этот лес состоит из одного букета, то этот букет и является покрывающим деревом. В противном случае граф несвязен. Шаг 3 нужен для того, чтобы не просматривать оставшиеся ребра, когда покрывающее дерево уже построено. Без него можно обойтись, но тогда алгоритм остановится, только если просмотрены все ребра.

Пространство циклов. Пусть \( E = \{e_1, ..., e_m\} \) — множество всех поименованных ребер графа \( G \). Всякий двоичный вектор (кортеж) \( w = (w^1, ..., w^m) \) длины \( m \) определяет подмножество \( E_w \) ребер графа следующим образом: \( e_i \in E_w \), если и только если \( w^i = 1 \). В свою очередь, \( E_w \) определяет реберно-порожденный граф \( G(E_w) \), который будем обозначать \( G_w \).

Лемма 4.1. Если \( w_3 = w_1 \oplus w_2 \), где \( \oplus \) — поразрядное сложение по mod 2, то \( G_{w3} = G_{w1} \triangle G_{w2} \), где \( \triangle \) — симметрическая разность графов (см. § 4.1).

Действительно, так как \( w^i_3 = 0 \), если \( w^i_1 = w^i_2, w^i_3 = 1 \), если \( w^i_1 \neq w^i_2 \), то \( E_{w3} \) содержит только те ребра из \( E_{w1} \cup E_{w2} \), которые не являются общими для \( E_{w1} \) и \( E_{w2} \), т. е. \( E_{w3} = (E_{w1} \cup E_{w2}) \setminus (E_1 \cap E_2) = E_{w1} \triangle E_{w2} \). Но граф \( G_{w1} \triangle G_{w2} \) порожден множеством ребер \( E_{w1} \triangle E_{w2} \), т. е. совпадает с \( E_{w3} \). \( \square \)

Вектор \( w \) длины \( m \) называется циклическим вектором, если либо \( w \) состоит из одних нулей, либо \( G_w \) представляет собой один простой цикл или несколько циклов, не пересекающихся по ребрам.

Множество всех циклических векторов графа \( G \) обозначим через \( W_G \), а множество всех графов \( G_w \), порожденных циклическими векторами, — через \( C_G \).