---
source_image: page_232.png
page_number: 232
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 28.26
tokens: 5338
characters: 2203
timestamp: 2025-12-24T07:22:24.150179
finish_reason: stop
---

Таблица 5.4

<table>
  <tr>
    <th rowspan="2">Моделируемая машина B</th>
    <th colspan="3">Моделирующая машина A</th>
  </tr>
  <tr>
    <th>1МТ</th>
    <th>kМТ</th>
    <th>МДП</th>
  </tr>
  <tr>
    <td>1-ленточная МТ (1МТ)</td>
    <td>–</td>
    <td>O(f(n))</td>
    <td>O(f(n))logf(n)</td>
  </tr>
  <tr>
    <td><i>k</i>-ленточная МТ (<i>k</i>МТ)</td>
    <td>O(f^2(n))</td>
    <td>–</td>
    <td>O(f(n))logf(n)</td>
  </tr>
  <tr>
    <td>Машина произвольного доступа (МПД)</td>
    <td>O(f^3(n))</td>
    <td>O(f^2(n))</td>
    <td>–</td>
  </tr>
</table>

задача решается в три просмотра слова, т. е. со сложностью порядка \(3n\): 1) исходное слово переписывается на вторую ленту; в конце этого прохода головка видит последние символы слова на обеих лентах; 2) одна из лент сдвигается к первому символу; в конце этого прохода головка видит последний символ слова на одной ленте и первый символ — на другой; 3) ленты сдвигаются навстречу друг другу; соответствующие символы сравниваются.

Один из способов сравнивать алгоритмы, реализованные на разных машинах \(M_1\) и \(M_2\), — это моделировать на машине \(M_2\) алгоритм, реализованный на машине \(M_1\) и имеющий сложность \(f(n)\). Оценки сложности такого моделирования приведены в табл. 5.4 [7].

Как видим, и здесь оценки сложности алгоритмов на разных машинах отличаются полиномиально. То же самое можно утверждать и для задач, поскольку сложность задачи — это сложность самого эффективного алгоритма, который ее решает. Обобщает эти утверждения тезис, лежащий в основе последующей теории:

<em>Перенос задачи на детерминированную машину любой архитектуры изменяет ее сложность не более чем полиномиально</em>*.

Из этого тезиса вытекают очевидные следствия:
■ любое улучшение архитектуры машины может лишь понизить степень полинома в оценке сложности решаемых задач;
■ если задача имеет более чем полиномиальную сложность (например, сложность вида \(n^{\log n}\) или экспоненциальную сложность вида \(a^n\)), то она сохранит эту сложность на машине любой архитектуры. Можно

* Такой перенос может повлечь за собой смену схемы кодирования. Однако мы уже договорились, что эта смена изменит длину слова не более чем полиномиально.