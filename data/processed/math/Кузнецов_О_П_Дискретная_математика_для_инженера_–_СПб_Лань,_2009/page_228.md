---
source_image: page_228.png
page_number: 228
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 20.73
tokens: 5156
characters: 2094
timestamp: 2025-12-24T07:22:11.251064
finish_reason: stop
---

да, то как — разные алгоритмы, решающие одну и ту же задачу, но реализованные в разных алгоритмических моделях? И, наконец, — как отделить собственные характеристики алгоритма от характеристик машины, на которой он реализован?

Эти проблемы удобнее обсуждать в терминах абстрактных машин, в которых основные компоненты алгоритмов, участвующие в оценках (единицы памяти и элементарные шаги), представлены явно — в отличие, скажем, от представлений в виде рекурсивных описаний. Поэтому в дальнейшем мы будем говорить на языке «машинных» алгоритмических моделей.

Проще всего ответить на вопрос об измерении ресурсов. Объем памяти определяется числом единиц памяти (ячеек ленты машины Тьюринга или машинных слов в современных компьютерах), которые используются в процессе работы алгоритма. Несколько сложнее обстоит дело со временем. С прикладной точки зрения кажется естественным измерять время работы алгоритма в обычных физических единицах — секундах и долях секунды, минутах и т. д. Это время можно грубо представить величиной \( \alpha t \), где — число действий (элементарных шагов) алгоритма, а \( \alpha \) — среднее физическое время выполнения одного действия. Время \( \alpha \) определяется физическими характеристиками аппаратуры: скоростью передачи сигналов, временем записи в единицу памяти и считывания из нее. Эти параметры отсутствуют в моделях абстрактных машин и качество алгоритма никак не характеризуют. Поэтому время, затрачиваемое алгоритмом (\( \text{временную сложность алгоритма} \)), следует измерять числом действий.

Объем \( s \) памяти, используемой алгоритмом, по порядку никогда не превосходит числа его действий: если любое действие использует не более \( c \) единиц памяти, то \( s \leq ct \). Однако каждая единица памяти может использоваться неограниченное число раз, и потому \( t \) может существенно превосходить \( s \). Поэтому временная сложность алгоритма считается более важной его характеристикой, чем объем используемой памяти. Она более важна и в прикладном отношении: известно, что повышение быстродействия компьютеров — задача гораздо более слож-