---
source_image: page_198.png
page_number: 198
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 27.82
tokens: 5392
characters: 1890
timestamp: 2025-12-24T07:21:39.663842
finish_reason: stop
---

\[
f_1(x_1, ..., x_n, 0) = g_1(x_1, ..., x_n);
\]
\[
f_k(x_1, ..., x_n, 0) = g_k(x_1, ..., x_n);
\]
\[
f_1(x_1, ..., x_n, y + 1) = h_1(x_1, ..., x_n, y, f_1(x_1, ..., x_n, y), ..., f_k(x_1, ..., x_n, y));
\]
\[
f_k(x_1, ..., x_n, y + 1) = h_k(x_1, ..., x_n, y, f_1(x_1, ..., x_n, y), ..., f_k(x_1, ..., x_n, y)).
\]

По существу совместная рекурсия дает рекурсивное описание функции-вектора \((f_1, ..., f_k)\). Для того чтобы доказать примитивную рекурсивность совместной рекурсии, нужно закодировать этот вектор числом, причем так, чтобы существовала однозначная и примитивно-рекурсивная расшифровка этого кода (т. е. извлечение нужного разряда вектора). В качестве такого кода можно предложить число

\[
\varphi(x_1, ..., x_n, y) = 2^{f_1(x_1, ..., x_n, y)} \cdot 3^{f_2} \cdot 5^{f_3} \cdot ... \cdot p_{k-1}^{f_k(x_1, ..., x_n, y)},
\]

где \(p_i\) — i-е простое число (2 считается 0-м простым числом). Продемонстрируем эту идею на примере оператора \(R_{12}\). Пусть \(f_1(x, y), f_2(x, y)\) заданы совместной рекурсией:

\[
f_1(x, 0) = g_1(x);
\]
\[
f_2(x, 0) = g_2(x);
\]
\[
f_1(x, y + 1) = h_1(x, y, f_1(x, y), f_2(x, y));
\]
\[
f_2(x, y + 1) = h_2(x, y, f_1(x, y), f_2(x, y)).
\]

Определим кодирующую функцию \(F\):

\[
F(x, 0) = 2^{g_1(x)} \cdot 3^{g_2(x)};
\]
\[
F(x, y + 1) = 2^{h_1(x, y, f_1(x, y), f_2(x, y))} \cdot 3^{h_2(x, y, f_1(x, y), f_2(x, y))}.
\]

Тогда \(f_1(x, y) = \mu z_{z \ll F(x, y)}(\overline{\mathrm{Pd}}_{2^{z+1}}(F(x, y)))\), т. е. равна показателю при 2 в разложении \(F(x, y)\) на простые множители;
\[
f_2(x, y) = \mu z_{z \ll F(x, y)}(\mathrm{Pd}_{3^{z+1}}(F(x, y))),
\]
т. е. равна показателю при 3 в разложении \(F(x, y)\) на простые множители. (Определение предиката Pd см. в примере 5.12, а).

Следует иметь в виду, что такая кодировка вовсе не предлагается в качестве метода рекурсивного вычисления функций-векторов. Наоборот, предлагается прямой