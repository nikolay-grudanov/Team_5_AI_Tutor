---
source_image: page_237.png
page_number: 237
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 24.87
tokens: 5247
characters: 2125
timestamp: 2025-12-24T07:22:27.988238
finish_reason: stop
---

рождает дерево всех возможных слов в алфавите решения, ограниченных полиномом от длины n входного слова, причем просматривает параллельно (и следовательно, за полиномиальное время) каждую ветвь дерева и с полиномиальной сложностью проверяет, не является ли слово на этой ветви решением. Как только решение найдено, вычисление останавливается. Второй вариант [7] содержит недетерминированный модуль, угадывающий решение за полиномиальное время, и детерминированный блок проверки решения. Предполагается, опять-таки, что все угадывания происходят параллельно. Поэтому определение класса NP с помощью НДТМ выглядит так: задача принадлежит классу NP, если существует НДТМ, которая вычисляет его за полиномиальное время.

Поскольку НДТМ не является машиной в обычном смысле слова, и, следовательно, реализуемые на ней процедуры не являются обычными детерминированными алгоритмами, использование НДТМ в определении класса NP, на наш взгляд, не добавляет ему конструктивности и затрудняет понимание содержательного смысла этого понятия. Уже имеются современные изложения NP-теории [12, 43], которые обходятся без него.

Полиномиальная сводимость и NP-полнота. Язык L_1 полиномиально сводим к языку L_2 (обозначение L_1 \propto L_2), если существует функция f, удовлетворяющая двум условиям:
1) f имеет полиномиальную сложность;
2) для любого \( \alpha \in L_1 \), если и только если \( f(\alpha) \in L_2 \).

Функция f — это функция, преобразующая условия задачи в коде L_1 в условия задачи (быть может, содержательно другой) в коде L_2.

Теорема 5.18. Если \( L_1 \propto L_2 \), то из \( L_2 \in \mathrm{P} \) следует, что \( L_1 \in \mathrm{P} \).

Доказательство очевидно: если \( p_1(n) \) — полином, ограничивающий сложность распознавания языка \( L_2 \), а \( p_2(n) \) — полином, ограничивающий сложность функции сведения f, то \( L_1 \) распознается за время порядка \( p_1(n) + p_2(n) \). \( \Box \)

Столь же очевидно, что отношение \( \propto \) транзитивно.

Сводимость задачи Q_1 к задаче Q_2 содержательно означает, что Q_2 не проще, чем Q_1. Понятно, что легкую задачу можно свести к более трудной. Если же «трудная»