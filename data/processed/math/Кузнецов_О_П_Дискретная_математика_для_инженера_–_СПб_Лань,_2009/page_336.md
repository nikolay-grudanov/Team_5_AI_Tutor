---
source_image: page_336.png
page_number: 336
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 37.92
tokens: 5709
characters: 2714
timestamp: 2025-12-24T07:24:42.199087
finish_reason: stop
---

Теорема доказана. Однако, чтобы воспользоваться ею для нахождения минимального автомата, нужно уметь находить классы эквивалентных состояний данного автомата. Само определение неотличимости не содержит метода нахождения, так как оно предполагает перебор по бесконечному множеству входных слов. Наиболее известным алгоритмом нахождения эквивалентных состояний является алгоритм Мили, который будет описан индуктивно.

Пусть дан автомат \( S = (A, Q, V, \delta, \lambda) \) с \( n \) состояниями. На каждом шаге алгоритма будем строить некоторое разбиение \( Q \) на классы, причем разбиение на следующем шаге будет получаться расщеплением некоторых классов предыдущего разбиения. (Отметим, что шаги алгоритма в данном описании вовсе не элементарны. Это, скорее, блоки.)

Шаг 1. Два состояния \( q \) и \( q' \) относим в один класс \( C_{1j} \), если и только если для любого \( a \in A \) \( \lambda(q, a) = \lambda(q', a) \).

Шаг \( i + 1 \). Два состояния \( q \) и \( q' \) из одного класса \( C_{ij} \) относим в один класс \( C_{i+1, j} \), если и только если для любого \( a \in A \) \( \delta(q, a) \) и \( \delta(q', a) \) принадлежат одному и тому же классу \( C_{il} \). Если \( (i + 1) \)-й шаг не меняет разбиения, т. е. состояния из одного класса \( C_{ij} \) принадлежат одному классу \( C_{i+1, j} \), то алгоритм заканчивается и полученное разбиение является разбиением на классы эквивалентных состояний; иначе применяем шаг \( i + 1 \) к полученному разбиению.

Пример 8.5. Для автомата \( S \) с девятью состояниями и двумя выходными буквами, заданного табл. 8.3, алгоритм строит следующую последовательность разбиений (классы отделены точкой с запятой):

\[
\begin{array}{l}
1\ 4\ 6\ 9;\\
1\ 4\ 6;\ 9;\\
1\ 4;\ 6;\ 9;\\
1\ 4;\ 6;\ 9;
\end{array}
\qquad
\begin{array}{l}
2\ 3\ 8;\ 5\ 7\\
2\ 3\ 8;\ 5\ 7\\
2\ 3\ 8;\ 5\ 7\\
2\ 8;\ 3;\ 5\ 7
\end{array}
\]

Таблица 8.3

<table>
  <tr>
    <th>q_i</th>
    <th>a_1</th>
    <th>a_2</th>
    <th>a_3</th>
  </tr>
  <tr>
    <td>1</td>
    <td>2,0</td>
    <td>4,1</td>
    <td>4,1</td>
  </tr>
  <tr>
    <td>2</td>
    <td>1,1</td>
    <td>1,0</td>
    <td>5,0</td>
  </tr>
  <tr>
    <td>3</td>
    <td>1,1</td>
    <td>6,0</td>
    <td>5,0</td>
  </tr>
  <tr>
    <td>4</td>
    <td>8,0</td>
    <td>1,1</td>
    <td>1,1</td>
  </tr>
  <tr>
    <td>5</td>
    <td>6,1</td>
    <td>4,1</td>
    <td>3,0</td>
  </tr>
  <tr>
    <td>6</td>
    <td>8,0</td>
    <td>9,1</td>
    <td>6,1</td>
  </tr>
  <tr>
    <td>7</td>
    <td>6,1</td>
    <td>1,1</td>
    <td>3,0</td>
  </tr>
  <tr>
    <td>8</td>
    <td>4,1</td>
    <td>4,0</td>
    <td>7,0</td>
  </tr>
  <tr>
    <td>9</td>
    <td>7,0</td>
    <td>9,1</td>
    <td>7,1</td>
  </tr>
</table>