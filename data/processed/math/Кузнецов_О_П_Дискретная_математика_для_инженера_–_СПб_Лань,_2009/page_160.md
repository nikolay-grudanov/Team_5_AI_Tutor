---
source_image: page_160.png
page_number: 160
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 23.40
tokens: 5167
characters: 2130
timestamp: 2025-12-24T07:20:47.452023
finish_reason: stop
---

из которого не выходит ни одного ребра, и единственный оператор начала. Важной особенностью блок-схемы является то, что связи, которые она описывает, не зависят от того, являются ли шаги элементарными или представляют собой самостоятельные алгоритмы, — как говорят в программировании, блоки (по существу шаг 1 таковым и является). Возможность «разбlocчивать» алгоритм хорошо известна в программировании и широко там используется: большой алгоритм разбивается на блоки, которые можно раздать для программирования разным лицам. Для данного блока неважно, как устроены другие блоки; для программирования блока достаточно знать, где лежит вся исходная информация, какова форма ее представления, что должен делать блок и куда записать результат.

С помощью блок-схем можно, наоборот, несколько алгоритмов, рассматриваемых как блоки, связать в один большой алгоритм. В частности, если алгоритм \( A_1 \), вычисляющий функцию \( f_1(x) \), соединен с алгоритмом \( A_2 \), вычисляющим функцию \( f_2(x) \) (рис. 5.2), и при этом исходными данными для \( A_2 \) служит результат \( A_1 \), то полученная блок-схема задает алгоритм, вычисляющий \( f_2(f_1(x)) \), т. е. композицию \( f_1 \) и \( f_2 \) (см. § 1.2). Такое соединение алгоритмов называется композицией алгоритмов.

На блок-схеме хорошо видна разница между описанием алгоритма и процессом его реализации. Описание — это граф; процесс реализации — это путь в графе. Различные пути в одном и том же графе возникают при различных данных, которые создают разные логические условия в точках разветвлений. Отсутствие сходимости означает, что в процессе вычисления не появляется условий, ведущих к концу, и процесс идет по бесконечному пути (защелкивается).

При всей наглядности языка блок-схем не следует, однако, переоценивать его возможности. Он достаточно груб и отражает связи лишь по управлению (что делать в следующий момент. т. е. какому блоку передать управление), а не по информации (где этому блоку брать исходные данные). Например, рис. 5.2 при сделанной оговорке относительно данных изображает вычисление \( f_2(f_1(x)) \), однако он же мог изображать последовательное