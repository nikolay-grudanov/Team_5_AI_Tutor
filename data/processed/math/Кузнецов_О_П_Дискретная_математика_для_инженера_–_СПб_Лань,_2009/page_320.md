---
source_image: page_320.png
page_number: 320
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 25.98
tokens: 5394
characters: 2316
timestamp: 2025-12-24T07:24:08.863618
finish_reason: stop
---

и сделано только для того, чтобы сохранить традиционные обозначения нетерминалов):
\[
I_1 \rightarrow I_2 \mid (A + A); \quad I_2 \rightarrow C \mid b \mid I_2C \mid I_2b; \quad A \rightarrow I_2 \mid A + A;
\]
\[
C \rightarrow I_1.
\]

Блочные грамматики и сети из языков. Идея использования подстановки языка в правилах грамматики вместо подстановки конечной цепочки, как это делается в правилах обычной КС-грамматики, приводит к понятию блочной грамматики, которая определяется как пятерка объектов \( G = \langle \mathcal{A}, \mathcal{X}, \mathcal{L}, R, L^0 \rangle \), где \( \mathcal{A} = \{A_1, ..., A_m\} \) — система конечных (возможно, пересекающихся) алфавитов; \( \mathcal{X} = \{X_1, ..., X_m\} \) — система конечных алфавитов, таких, что \( X_1 \subseteq A_1, ..., X_m \subseteq A_m \) и для любых \( i, j \) \( X_i \cap (A_j \setminus X_j) = \varnothing \); \( \mathcal{L} = \{L_1, ..., L_m\} \) — конечное множество языков в алфавитах \( A_1, ..., A_m \) соответственно; \( R \) — конечное множество блочных правил вида \( x \rightarrow L_j \), где \( x \in X \);
\[
X = \bigcup_{k=1}^{m} X_k;
\]
\( L_j \in \mathcal{L}; \ L^0 \in \mathcal{L} \) — начальный язык. Алфавит \( X_i \) называется входным алфавитом языка \( L_i \) (\( i = 1, ..., m \)); \( X_i \) — это множество терминальных символов \( L_i \), вместо которых производятся подстановки в \( L_i \), указанные блочными правилами из \( R \). Алфавит \( B_i = A_i \setminus X_i \) называется внешним алфавитом \( G \); алфавит \( X \) — внутренним алфавитом \( G \), алфавит
\[
B = \bigcup_{i=1}^{m} B_i
\]
— терминальным алфавитом \( G \).

Понятие вывода в блочной грамматике (блочного вывода) аналогично понятию вывода в обычной грамматике с той лишь разницей, что роль начального символа здесь играет начальный язык \( L^0 \) (т. е. вывод может начинаться с любого слова из \( L^0 \)), а применение правила \( x \rightarrow L_j \) означает подстановку вместо некоторого вхождения \( x \) любого слова из \( L_j \). Таким образом, длина блочного вывода не учитывает сложности вывода «внутри» языков \( L_1, ..., L_m \). Язык \( L(G) \), порождаемый блочной грамматикой \( G \), — это множество всех слов в терминальном алфавите \( G \), выводимых в \( G \) из \( L^0 \). Языки \( L_i \in \mathcal{L} \) называются блоками языка \( L \).