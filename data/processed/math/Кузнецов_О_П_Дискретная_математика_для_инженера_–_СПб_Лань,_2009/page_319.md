---
source_image: page_319.png
page_number: 319
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 33.50
tokens: 5617
characters: 2675
timestamp: 2025-12-24T07:24:15.255036
finish_reason: stop
---

но конкатенации и итерации (выше была показана их представимость через подстановку в КС-языки).

Зацикливание КС-языка также может быть представлено как операция над его грамматикой. Для языка \( L_1 \) с грамматикой \( G_1 = \langle V_1, W_1, R_1, I_1 \rangle \) грамматика \( G = \langle V, W, R, I \rangle \), порождающая язык \([L_1]^*_a\), определяется следующим образом: \( V = V_1 \setminus \{a\};\ W = W_1 \cup \{a\};\ I = I_1;\ R = = R_1 \cup \{a \to I_1\} \). Доказательство того, что \( L(G) = [L_1]^*_a \), предоставляем читателю. Очевидно, что \( G \) — КС-грамматика, и, следовательно, класс КС-языков замкнут относительно зацикливания.

Порождающая способность зацикливания сильнее порождающей способности подстановки в следующем смысле: если \( L_1 \) и \( L_2 \) — конечные языки, то \( L_1 (a \to L_2) \) — конечный язык для любого \( a \), тогда как язык \( L(G) = [L_1]^*_a \) бесконечен, если в \( L_1 \) имеется цепочка длины 2, содержащая \( a \). Действительно, если в \( G\ I \Rightarrow \alpha a \beta,\ |\alpha a \beta| \geq 2 \), то по определению \( G\ I \Rightarrow \alpha I \beta \), где либо \( \alpha \), либо \( \beta \) непусто, и, следовательно, для \( L(G) \) выполнен критерий бесконечности КС-языка (описанный вслед за доказательством теоремы 7.4).

Пример 7.8. Пусть языки \( L_S \) и \( L_T \) из примера 7.7 заданы соответственно грамматиками \( G_S \) с системой правил \( R_S = \{I_1 \to a\ | (A + A),\ A \to a\ | A + A\} \), и \( G_T \) с системой правил \( R_T = \{I_2 \to a\ | I_2 a\} \). Подставим \( G_T \) в \( G_S \) вместо \( a \). Поскольку \( a \in V_T \) (т. е. нарушено условие 1), то заменяем в \( G_S \) \( a \) на \( B \), после чего получаем исходную грамматику \( G_{ST} \) с начальным символом \( I_1 \) и системой правил \( \{I_1 \to B\ | (A + A),\ A \to B\ | A + A,\ B \to I_2,\ I \to a\ | I_2 a\} \), которая порождает язык \( L_{ST} = L_S (a \to L_T) \) из примера 7.7.

Устраним теперь из \( G_{ST} \) цепное правило \( B \to I_2 \) и введем в язык \( L_{ST} \) вторую переменную \( b \) (терминальный символ), добавив правила \( I_2 \to b\ | I_2 b \). Получим грамматику \( G'_{ST} \) с правилами \( \{I_1 \to I_2\ | (A + A),\ A \to I_2\ | A + A,\ I_2 \to a\ | b\ | I_2 a\ | I_2 b\} \), порождающую язык \( \tilde{L}_{ST} \) арифметических многочленов (без вычитания и деления) над двумя переменными. Зацикливание грамматики \( \tilde{G}_{ST} \) по символу \( a \) дает язык \([\tilde{L}_{ST}]^*_a\) выражений произвольной глубины над переменной \( b \). Его грамматика, полученная зацикливанием \( \tilde{G}_{ST} \), имеет следующие правила (проведенное здесь переименование \( a \) в \( C \) необязательно