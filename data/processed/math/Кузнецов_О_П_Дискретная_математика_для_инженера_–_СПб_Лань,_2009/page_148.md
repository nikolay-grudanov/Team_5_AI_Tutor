---
source_image: page_148.png
page_number: 148
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 21.28
tokens: 5122
characters: 1706
timestamp: 2025-12-24T07:20:29.034210
finish_reason: stop
---

всех обратных ребрах — уменьшим его на ту же величину. Тогда, поскольку первое и последнее ребра цепи — прямые, на эту величину возрастет и общая величина потока. Таким образом, поток в сети можно увеличивать до тех пор, пока в сети есть увеличивающие цепи.

В нашем примере min{min{q(i, j)}, min{r(i, j)}} = 2.
Схема алгоритма поиска увеличивающей цепи.
1. Пометить s.
2. Для помеченной вершины i найти смежную с ней непомеченную вершину j, содержащуюся либо в Q, либо в R: а) если (i, j) ∈ Q, пометить j и (i, j); б) если (j, i) ∈ R, пометить j и (j, i).
3. Остановиться, если либо помечена t, либо шаг 2 невозможен. Иначе перейти к шагу 2.
Помеченные вершины и ребра образуют дерево, поскольку ребра, соединяющие две помеченные вершины, не рассматриваются. Поэтому, если t помечена, то тем самым построена единственная помеченная цепь из s в t, которая является увеличивающей. Если же шаг 3 невозможен, а t не помечена, то увеличивающих цепей нет.
Описанная схема становится конкретным алгоритмом, если зафиксировать правила выбора помеченной вершины i и непомеченной вершины j (в случае, когда для i имеется несколько вершин j, удовлетворяющих условиям п. 2). Построенное дерево зависит от выбора этого правила.
Пример 4.23. На рис. 4.32 для помеченной вершины a существуют две вершины, удовлетворяющие условию шага 2, — b и c. При выборе c получим следующее помеченное дерево (рис. 4.33), которое дает увеличивающую цепь sacbt.
Таким образом, общий алгоритм нахождения максимального потока формулируется следующим образом.

![Два графа: левый — исходный граф с помеченными вершинами и ребрами, правый — дерево, соответствующее увеличивающей цепи](https://i.imgur.com/3Q5z5QG.png)

Рис. 4.32	Рис. 4.33.