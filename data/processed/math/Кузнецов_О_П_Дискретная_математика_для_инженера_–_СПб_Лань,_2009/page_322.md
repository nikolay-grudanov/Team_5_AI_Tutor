---
source_image: page_322.png
page_number: 322
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 32.22
tokens: 5604
characters: 2891
timestamp: 2025-12-24T07:24:17.039850
finish_reason: stop
---

выхода элемента, которому приписан язык \( L_j \), к элементу \( v_k \), язык \( L(v_k) \) которого содержит \( x \) в своем входном алфавите. При такой ориентации ребер (от \( L_j \) к \( x \)) начальный язык \( L^0 \) оказывается приписанным выходному элементу сети. Формально сеть из языков (\( \Lambda\)-сеть) — это пятерка объектов \( \lambda = \langle \mathcal{A}, \mathcal{X}, \mathcal{L}, \gamma, v^0 \rangle \), где \( \{\mathcal{A} = \{A_1, ..., A_m\} \) — система конечных алфавитов; \( \mathcal{X} = \{X_1, ..., X_m\} \) — система конечных алфавитов, таких, что \( X_1 \subseteq A_1, ..., X_m \subseteq A_m \), и для любых \( i, j \) \( X_i \cap (A_i \setminus X_j) = \varnothing \); \( \mathcal{L} = \{L_1, ..., L_m\} \) — конечное множество языков в алфавитах \( A_1, ..., A_m \) соответственно; \( \gamma \) — связный ориентированный граф с множеством вершин \( V = \{v_1, ..., v_n\} \); \( v^0 \in V \) — выделенная вершина, называемая выходом сети. Каждой вершине \( v_i \) графа \( \gamma \) приписан язык \( L(v_i) \in \mathcal{L} \). Каждое ребро, входящее в \( v_i \), помечено символом из \( X(v_i) \) — входного алфавита \( L(v_i) \), причем кратные ребра имеют различные пометки. Названия алфавитов \( A, B, X \) — те же, что и в определении блочной грамматики. Записи вида \( A(G), B(\lambda), X(v_i) \) обозначают принадлежность алфавитов объектам, указанным в скобках.

Переход от блочной грамматики \( G = \langle \mathcal{A}, \mathcal{X}, \mathcal{L}, R, L^0 \rangle \) к представляющей ее \( \Lambda\)-сети \( \lambda(G) \) определяется следующим образом. Если \( \mathcal{L} = \{L_1, ..., L_m\} \), то \( \lambda(G) \) содержит \( m \) вершин \( v_1, ..., v_m \); \( L(v_i) = L_i, i = 1, ..., m \), а выходом является вершина \( v^0 \), для которой \( L(v^0) = L^0 \). Для каждого правила \( x \rightarrow L_j \) из вершины \( v_i \) проводятся ребра с пометкой \( x \) ко всем вершинам \( v_j \), таким, что терминальный алфавит \( L(v_j) \) содержит \( x \).

Обратный переход — от сети \( \lambda \) к блочной грамматике \( G(\lambda) = \langle \mathcal{A}, \mathcal{X}, \mathcal{L}, R, L^0 \rangle \) столь же прост с той разницей, что для непересечения входных алфавитов может понадобиться их переименование: \( \mathcal{L} = \{L'_1, ..., L'_m\} \) — это множество языков \( L_1, ..., L_m \) сети \( \lambda \), в которых, возможно, переименованы входные алфавиты так, чтобы они не пересекались. Ребру в \( \lambda \), ведущему от вершины \( v_j \) ко входу \( x \), ставится в соответствие блочное правило \( x' \rightarrow L'(v_j) \), где \( x' \) — либо \( x \), либо символ, заменивший \( x \) при переименовании входных алфавитов; \( R \) является объединением всех блочных правил.

\( \Lambda\)-сети \( \lambda_1 \) и \( \lambda_2 \) называются слабо эквивалентными, если они представляют один и тот же язык: \( L(G(\lambda_1)) = L(G(\lambda_2)) \),