---
source_image: page_383.png
page_number: 383
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 19.53
tokens: 5164
characters: 1960
timestamp: 2025-12-24T07:25:21.840954
finish_reason: stop
---

зались сильно преувеличенными. Это объясняется в основном следующими причинами. Во-первых, как было установлено ранее, схемы с k элементами задержки имеют \(2^k\) состояний, поэтому описание сколько-нибудь больших схем в терминах состояний и таблиц переходов оказывается довольно громоздким. Во-вторых, на разных этапах решаются разные задачи минимизации, которые плохо связаны между собой. Известны примеры, когда уменьшение числа состояний приводит к усложнению логики схемы. Кроме того, различные варианты кодирования (для k задержек существует \((2^k)!\) вариантов) приводят к разным системам канонических уравнений; предвидеть сложность их реализации заранее, на этапе кодирования, невозможно. Поэтому в практике получают все большее распространение методы, обходящие каноническую схему синтеза.

8.4.
ПРОГРАММНАЯ РЕАЛИЗАЦИЯ ЛОГИЧЕСКИХ ФУНКЦИЙ И АВТОМАТОВ

Представление автомата схемой из элементов — это исторически первый и наиболее исследованный вид структурной реализации автомата. Другой ее вид — реализация автомата программой. Здесь мы ограничимся вопросами программной реализации комбинационных логических автоматов, т. е. систем логических функций.

Под программой будем понимать пронумерованную последовательность команд \(k_1, ..., k_s\), взятых из некоторого фиксированного набора (системы команд). Программа работает над конечным множеством пронумерованных (или проименованных) двоичных ячеек. Номер (или имя) ячейки называется ее адресом; именем ячейки часто будет служить имя логической переменной, значения которой хранятся в этой ячейке.

Система команд содержит команды-операторы вида \(b := f(a_1, ..., a_p)\) (выполнить операцию \(f\) над содержимым ячеек \(a, ..., a_p\) и результат положить в ячейку \(b\)) и двухадресные условные переходы двух видов: 1) «если \(a\), то \(i\), иначе \(j\)» (если \(a = 1\), то перейти к выполнению команды \(k_i\), иначе перейти к \(k_j\)); 2) «если \(\bar{a}\) (\(a = 0\)), то \(i\), иначе \(j\)».