---
source_image: page_487.png
page_number: 487
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 65.53
tokens: 11704
characters: 2575
timestamp: 2025-12-24T06:43:31.826046
finish_reason: stop
---

Рисунок 24.4  24.4 Работа алгоритма Крускала на графе рис. 24.1. Рёбра растущего леса (A) выделены серым цветом. Рёбра рассматриваются в порядке неубывания весов (текущее ребро показано стрелкой). Если ребро соединяет два различных дерева, оно добавляется к лесу, а деревья сливаются.

концы ребра в одном дереве. Если да, то ребро нельзя добавить к лесу (не создавая цикла), и оно отбрасывается. Если нет, то ребро добавляется к A (строка 7), и два соединённых им дерева объединяются в одно (строка 8).

Подсчитаем время работы алгоритма Крускала. Будем считать, что для хранения непересекающихся множеств используется метод раздела 22.3 (с объединением по рангу и сжатием путей — самый быстрый из известных). Инициализация занимает время O(V), упорядочение рёбер в строке 4 — O(E lg E). Далее производится O(E) операций, в совокупности занимающих время O(Eα(E, V)), где α — функция, обратная к функции Аккермана (см. раздел 22.4). Поскольку α(E, V) = o(lg E), общее время работы алгоритма Крускала составляет O(E lg E) (основное время уходит на сортировку).

Алгоритм Прима

Как и алгоритм Крускала, алгоритм Прима следует общей схеме алгоритма построения минимального остова из раздела 24.1. Он похож на алгоритм Дейкстры поиска кратчайшего пути в графе (раздел 25.2). В этом алгоритме растущая часть остова представляет собой дерево (множество рёбер которого есть A). Как показано на рис. 24.5, формирование дерева начинается с произвольной корневой вершины r. На каждом шаге добавляется ребро наименьшего веса среди рёбер соединяющих вершины этого дерева с вершинами не из дерева. По следствию 24.2 такие рёбра являются безопасными для A, так что в результате получается минимальный остов.

При реализации важно быстро выбирать лёгкое ребро. Алгоритм получает на вход связный граф G и корень r минимального покрывающего дерева. В ходе алгоритма все вершины, ещё не попавшие в дерево, хранятся в очереди с приоритетами. Приоритет вершины v определяется значением key[v], которое равно минимальному весу рёбер, соединяющих v с вершинами дерева A. (Если таких рёбер нет, полагаем key[v] = ∞.) Поле π[v] для вершин дерева указывает на родителя, а для вершины v ∈ Q указывает на вершину дерева, в которую ведёт ребро веса key[v] (одно из таких рёбер, если их несколько). Мы не храним множество A вершин строимого дерева явно; его можно восстановить как

\[
A = \{ (v, \pi[v]) : v \in V \setminus \{r\} \setminus Q \}.
\]

В конец работы алгоритма очередь Q пуста, и множество

\[
A = \{ (v, \pi[v]) : v \in V \setminus \{r\} \}.
\]

есть множество вершин покрывающего дерева.