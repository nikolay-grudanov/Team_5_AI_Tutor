---
source_image: page_643.png
page_number: 643
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 47.21
tokens: 11561
characters: 2321
timestamp: 2025-12-24T06:50:44.638205
finish_reason: stop
---

Рисунок 30.5 30.5. CREW-алгоритм нахождения корней деревьев. Номера вершин расположены рядом с ними. Внутри вершин показаны значения root. Стрелки обозначают ссылки parent. (a)-(d) Состояние дерева перед каждым выполнением цикла while (строки 4–8). Заметим, что максимальная длина пути по стрелкам на каждом шаге уменьшается вдвое.

по указателям и заполняются поля root у вершин следующих (по глубине) уровней. На рис. 30.5 (b)-(d) показаны состояния деревьев после первого, второго и третьего выполнений цикла. Цикл имеет следующий инвариант: после t повторений цикла либо parent[i] = NIL и root[i] содержит правильный указатель на корень, либо parent[i] есть предок на расстоянии 2^t.

Алгоритм Find-Roots можно реализовать на CREW-машине; время работы составляет O(lg d), где d — максимальная из глубин деревьев. Действительно, все записи являются исключающими — каждый процессор производит запись только в поля своей вершины. Однако чтение в строках 7 и 8 является одновременным, поскольку одна вершина может быть предком сразу для нескольких других. Например, на рис. 30.5 (b) при втором выполнении цикла значения root[4] и parent[4] читаются процессорами 18, 2 и 7 одновременно.

Время работы составляет O(lg d) по тем же причинам, что и для алгоритма List-Rank.

Пусть теперь одновременное чтение запрещено. Тогда можно показать, что не существует алгоритма со временем работы меньше Ω(lg n) (где n — общее количество вершин). Причина тут в том, что на каждом шаге число вершин, которые знают свой корень, увеличивается не более чем вдвое, поэтому требуется Ω(lg n) шагов (для леса из одного дерева).

Если максимальная высота деревьев мала, то алгоритм Find-Roots работает асимптотически быстрее, чем любой EREW-алгоритм. Например, при высоте дерева d = O(lg n) (пусть, скажем, имеется всего одно полное дерево), CREW-алгоритм работает за время O(lg lg n), а любой EREW-алгоритм требует времени O(lg n).

Другой (более простой) пример выигрыша от параллельного чтения см. в упр. 30.2-1.

30.2.2 Польза параллельной записи

Рассмотрим задачу о нахождении максимального элемента в массиве из n действительных чисел. Можно доказать, что для этой задачи наилучший EREW-алгоритм требует времени Ω(lg n) и что одновременное чтение не позволяет уменьшить время работы. Однако существует CRCW-алгоритм со временем работы