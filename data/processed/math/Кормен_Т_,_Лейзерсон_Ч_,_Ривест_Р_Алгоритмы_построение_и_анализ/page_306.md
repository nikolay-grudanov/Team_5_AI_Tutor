---
source_image: page_306.png
page_number: 306
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 59.32
tokens: 11636
characters: 2188
timestamp: 2025-12-24T06:34:40.317154
finish_reason: stop
---

Простая оценка показывает, что время работы алгоритма MATRIX-CHAIN-ORDER есть \( O(n^3) \). В самом деле, число вложенных циклов равно трём, и каждый из индексов \( l, i \) и \( k \) принимает не более \( n \) значений. В упражнении 16.1-3 мы предложим вам показать, что время работы этого алгоритма есть \( \Theta(n^3) \). Объём памяти, необходимый для хранения таблиц \( m \) и \( s \), есть \( \Theta(n^2) \). Тем самым этот алгоритм значительно эффективнее, чем требующий экспоненциального времени перебор всех расстановок.

Шаг 4: построение оптимального решения

Алгоритм MATRIX-CHAIN-ORDER находит минимальное число умножений, необходимое для перемножения последовательности матриц. Осталось найти расстановку скобок, приводящую к такому числу умножений.

Для этого мы используем таблицу \( s[1..n, 1..n] \). В клетке \( s[i, j] \) записано место последнего умножения при оптимальной расстановке скобок; другими словами, при оптимальном способе вычисления \( A_{1..n} \) последним идёт умножение \( A_{1..s[1,n]} \) на \( A_{s[1,n]+1..n} \). Предшествующие умножения можно найти рекурсивно: значение \( s[1, s[1, n]] \) определяет последнее умножение при нахождении \( A_{1..s[1,n]} \), а \( s[s[1, n] + 1, n] \) определяет последнее умножение при вычислении \( A_{s[1,n]+1..n} \). Приведённая ниже рекурсивная процедура вычисляет произведение \( A_{i..j} \), имея следующие данные: последовательность матриц \( A = (A_1, A_2, \ldots, A_n) \), таблицу \( s \), найденную процедурой MATRIX-CHAIN-ORDER, а также индексы \( i \) и \( j \). Произведение \( A_1 A_2 \ldots A_n \) равно MATRIX-CHAIN-MULTIPLY\((A, s, 1, n)\).

MATRIX-CHAIN-MULTIPLY\((A, s, i, j)\)
1 if \( j > i \)
2 then \( X \leftarrow \) MATRIX-CHAIN-MULTIPLY\((A, s, i, s[i, j])\)
3 \( Y \leftarrow \) MATRIX-CHAIN-MULTIPLY\((A, s, s[i, j] + 1, j)\)
4 return MATRIX-MULTIPLY\((X, Y)\)
5 else return \( A_i \)

В примере на рис. 16.1 вызов MATRIX-CHAIN-MULTIPLY\((A, s, 1, 6)\) вычислит произведение шести матриц в соответствии с расстановкой скобок

\[
((A_1(A_2A_3))((A_4A_5)A_6)).
\]

(16.3)

[Техническое замечание: следует позаботиться, чтобы при передаче массива \( s \) в процедуру не происходило копирования.]