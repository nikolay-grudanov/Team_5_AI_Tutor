---
source_image: page_342.png
page_number: 342
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 62.72
tokens: 11697
characters: 2448
timestamp: 2025-12-24T06:36:34.589864
finish_reason: stop
---

17.4.2 Жадные алгоритмы для взвешенного матроида

Многие оптимизационные задачи, решаемые жадными алгоритмами, сводятся к задаче о нахождении в данном взвешенном матроиде \( M = (S, \mathcal{I}) \) независимого подмножества \( A \subseteq M \) максимального веса. Независимое подмножество максимального веса называется оптимальным (optimal) подмножеством взвешенного матроида. Поскольку веса всех элементов положительны, оптимальное подмножество автоматически будет максимальным независимым подмножеством.

Например, задача о наименьшем покрывающем дереве (minimum-spanning-tree problem) состоит в следующем. Дан связный неориентированный граф \( G = (V, E) \) и функция \( w \) из множества его рёбер во множество положительных чисел (\( w(e) \) будем называть длиной ребра \( e \)). Требуется найти множество рёбер, соединяющих все вершины и имеющих наименьшую суммарную длину. Эту задачу можно рассматривать как частный случай задачи об оптимальном подмножестве взвешенного матроида. В самом деле, выберем число \( w_0 \), строго большее длин всех рёбер, и введем на графовом матроиде \( M_G \) веса по правилу \( w'(e) = w_0 - w(e) \). Для всякого максимального независимого подмножества (т. е. покрывающего дерева) \( A \) имеем
\[
w'(A) = (|V| - 1)w_0 - w(A),
\]
где \( V \) — множество вершин графа. Стало быть, наименьшие покрывающие деревья для графа \( G \) — то же самое, что оптимальные подмножества в матроиде \( M_G \) с весовой функцией \( w' \).

Задача о наименьшем покрывающем дереве подробно рассматривается в главе 24; сейчас мы приведём жадный алгоритм, находящий оптимальное подмножество \( A \) в любом взвешенном матроиде \( M \). Если \( M = (S, \mathcal{I}) \), то мы пишем \( S = S[M] \) и \( \mathcal{I} = \mathcal{I}[M] \); весовая функция обозначается \( w \).

GREEDY(\( M, w \))
1 \( A \leftarrow \emptyset \)
2 отсортировать \( S[M] \) в порядке невозрастания весов
3 for \( x \in S[M] \) (перебираем все \( x \) в указанном порядке)
4 do if \( A \cup \{x\} \in \mathcal{I}[M] \)
5 then \( A \leftarrow A \cup \{x\} \)
6 return \( A \)

Алгоритм работает следующим образом. Полагаем \( A = \emptyset \) (строка 1; пустое множество, как мы помним, всегда независимо) и перебираем элементы \( S[M] \) в порядке убывания веса; если очередной элемент можно, не нарушая независимости, добавить к множеству \( A \), то мы это делаем. Ясно, что полученное в результате множество будет независимым. Ниже мы покажем, что оно