---
source_image: page_287.png
page_number: 287
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 70.29
tokens: 11633
characters: 2419
timestamp: 2025-12-24T06:33:57.924512
finish_reason: stop
---

ется за время \( O(1) \), так как новая вершина — лист (точнее, её дети — NIL-листья). Далее происходит \( O(\lg n) \) изменений полей на пути к корню. Итак, первый этап занимает время \( O(\log n) \). На втором этапе мы выполняем вращения (самое большое два); после каждого потребуется \( O(\lg n) \) операций для распространения изменений вверх по дереву.

Удаление также проводится в два этапа (см. разд. 14.4). На первом этапе изменения возникают, если удаляемая вершина заменяется её последователем, а также когда мы выбрасываем удаляемую вершину или её последователя. И в том и в другом случае мы изменяем поле \( f \) у одной вершины, поэтому обновление всех полей займет время \( O(\log n) \). На втором этапе мы делаем самое большое три вращения, каждое из которых требует времени \( O(\log n) \) для обновления полей на пути к корню.

Во многих случаях (в частности, для поля *size*) при вращениях все поля можно обновить за время \( O(1) \), а не \( O(\log n) \). Такая ситуация возникает в упр. 15.2-4.

**Упражнения**

15.2-1 Пополнить порядковое дерево (не ухудшив асимптотически время операций) так, чтобы минимальный и максимальный элементы, а также предшественник и последователь данного элемента отыскивались бы за время \( O(1) \).

15.2-2 Будем хранить в каждой вершине красно-чёрного дерева её чёрную высоту. Возможно ли обновлять это поле при добавлении и удалении элемента из дерева, не ухудшив (асимптотически) время работы этих операций?

15.2-3 Будем хранить в вершине её глубину. Возможно ли обновлять это поле при добавлении и удалении элемента из дерева, не ухудшив (асимптотически) время работы этих операций?

15.2-4* Пусть \( \otimes \) — ассоциативная бинарная операция на некотором множестве \( M \), и пусть в каждой вершине красно-чёрного дерева хранится некоторый элемент \( a \) множества \( M \) (свой в каждой вершине). Пусть теперь мы хотим хранить в каждой вершине \( x \) поле \( f[x] = a[x_1] \otimes a[x_2] \otimes \ldots \otimes a[x_m] \), где \( x_1, x_2, \ldots, x_m \) — все вершины поддерева с корнем \( x \) (в порядке возрастания ключей). Показать, что поле \( f \) при вращениях можно обновлять за время \( O(1) \). Провести аналогичное рассуждение для поля *size*.

15.2-5* Мы хотим реализовать для красно-чёрных деревьев операцию RB-ENUMERATE\((x, a, b)\), которая выдаёт список всех вершин в поддереве с корнем \( x \), для которых ключ \( k \) находится в проме-