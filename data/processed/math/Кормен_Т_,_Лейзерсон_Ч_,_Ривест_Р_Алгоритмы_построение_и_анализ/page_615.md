---
source_image: page_615.png
page_number: 615
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 54.60
tokens: 11665
characters: 2126
timestamp: 2025-12-24T06:49:32.939767
finish_reason: stop
---

Рисунок 29.10  29.10 Сумматор с предвычислением переносов (показан случай n = 8) состоит из n + 1 блока KPG с номерами от 0 до n. Блок KPG_i получает на вход a_i и b_i, вычисляет тип переноса x_i и обрабатывает выходное значение y_i, выдавая i-ый бит суммы s_i. Показаны значения для примера рис. 29.3

вычисляет [0, j - 1] = [0, i - 1] ⊗ [i, j - 1]. Это значение передаётся правому сыну; левому передаётся неизменённое значение [0, i - 1].

Строение корня дерева (дополнительный элемент ⊗) показано на рис. 29.9.

Если n является степенью двойки, то в параллельной префиксной схеме 2n - 1 элемент. Время работы составляет O(lg n), поскольку дерево имеет высоту lg n, а данные проходят по нему дважды (вверх и вниз).

29.2.4 Сумматор с предвычислением переносов: окончание

Полная конструкция n-разрядного сумматора с предвычислением переносов (carry-lookahead adder) показана на рис. 29.10. Кроме разобранной схемы параллельного вычисления префиксов, него входит n + 1 блок KPG. Блок KPG с индексом i вычисляет по входам a_i, b_i тип переноса x_i и передаёт его наверх, а затем, получив сверху значение y_i (которое, согласно лемме 29.1, соответствует биту переноса c_i), вычисляет с помощью сумматора FA_i значение i-го бита суммы s_i. Значения a_{n+1} = 0, b_{n+1} = 0 и x_0 = k зафиксированы. Поскольку все операции, кроме выполняемых параллельной префиксной схемой, требуют времени O(1), общее время работы схемы составляет O(lg n). Размер схемы равен Θ(n).

29.2.5 Сложение с запоминанием переносов

Как ни странно, сложение трёх чисел почти не требует дополнительных затрат по сравнению со сложением двух: глубина увеличивается всего на несколько единиц. Пусть x = ⟨x_{n-1}, x_{n-2}, ..., x_0⟩, y = ⟨y_{n-1}, y_{n-2}, ..., y_0⟩ и z = ⟨z_{n-1}, z_{n-2}, ..., z_0⟩ — три n-разрядных числа. Схема сложения с запоминанием переносов (carry-save adder) находит два числа u = ⟨u_{n-2}, u_{n-2}, ..., x_0⟩ (n битов) и v = ⟨v_n, v_{n-1}, ..., v_0⟩ (n + 1 битов), для которых

\[
u + v = x + y + z.
\]

Она делает это следующим образом (рис. 29.11 (b)):

\[
u_i = parity(x_i, y_i, z_i),
\]
\[
v_{i+1} = majority(x_i, y_i, z_i)
\]