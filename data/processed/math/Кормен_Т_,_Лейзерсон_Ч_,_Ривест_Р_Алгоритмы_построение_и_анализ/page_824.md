---
source_image: page_824.png
page_number: 824
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 65.18
tokens: 11808
characters: 3013
timestamp: 2025-12-24T06:59:09.552044
finish_reason: stop
---

Polinominalnoe vremya

\( e_1(i) \), а затем применим алгоритм, разрешающий \( e_1(Q) \), к строке \( e_1(i) \). Сколько времени займет наше вычисление? Преобразование \( e_2(i) \) в \( e_1(i) \) требует полиномиального времени. Следовательно, \( |e_1(i)| = O(n^c) \), поскольку длина выхода алгоритма не превосходит времени его работы. Решение задачи с условием \( e_1(i) \) занимает \( O(|e_1(i)|^k) = O(n^{ck}) \) времени. Итак, время вычисления оказалось полиномиальным. (Мы пропустили важный момент: получив на входе некоторую строку, мы должны сначала проверить, что она является \( e_2 \)-представлением некоторого входа; по предположению это можно сделать за полиномиальное время.)

Мы не будем подробно описывать используемое представление в конкретных задачах, считая, что оно выбрано достаточно разумно и экономно (целые числа задаются двоичной записью, конечные множества — списком элементов и т.п.) Представление объекта будем обозначать угловыми скобками: \( \langle G \rangle \) — это стандартное представление объекта \( G \). При этом множество всех строк, являющихся представлениями, оказывается полиномиальным, а различные "разумные" способы представления данных оказываются полиномиально связанными, так что можно воспользоваться леммой 36.1 и не описывать представление детально, если нас интересует лишь вопрос о полиномиальности задачи. Таким образом, в дальнейшем мы не будем делать различия между абстрактной задачей и ее строковым представлением, как это обычно и делают (кроме тех редких задач, в которых стандартное представление не очевидно — для них выбор представления может сильно повлиять на сложность решения задачи).

Формальные языки

Для задач разрешения удобно использовать терминологию теории формальных языков. Алфавитом (alphabet) \( \Sigma \) называется любой конечный набор символов. Языком \( L \) над алфавитом \( \Sigma \) (language \( L \) over \( \Sigma \)) называется произвольное множество строк символов из алфавита \( \Sigma \) (такие строки называют словами в алфавите \( \Sigma \)). Например, можно рассмотреть \( \Sigma = \{0, 1\} \) и язык \( L = \{10, 11, 101, 111, 1011, 1101, 10001, \ldots\} \), состоящий из двоичных записей простых чисел. Мы будем обозначать символом \( \varepsilon \) пустое слово (empty string), не содержащее символов, а символом \( \emptyset \) — пустой язык (empty language), не содержащий слов. Язык, состоящий из всех строк в алфавите \( \Sigma \), обозначается \( \Sigma^* \). Например, при \( \Sigma = \{0, 1\} \) имеем \( \Sigma^* = \{\varepsilon, 0, 1, 00, 01, 10, 11, 000, \ldots\} \). Таким образом, всякий язык \( L \) над \( \Sigma \) является подмножеством множества \( \Sigma^* \).

Имеется несколько стандартных операций над языками. Операции объединения (union) и пересечения (intersection) языков определяются как обычные операции объединения и пересечения множеств. Дополнением (complement) языка \( L \) называют язык \( \bar{L} = \Sigma^* \setminus L \). Конкатенацией (concatenation), или соединением, двух язы-