---
source_image: page_829.png
page_number: 829
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 56.42
tokens: 11663
characters: 2564
timestamp: 2025-12-24T06:59:14.367027
finish_reason: stop
---

**Глава 36 NP-полнота**

**Формально говоря,**

\[
\text{HAM-CYCLE} = \{\langle G \rangle : G — гамильтонов граф\}
\]

Как решать такую задачу? Можно перебрать все перестановки вершин данного графа и проверить, является ли хотя бы одна из них гамильтоновым циклом. Оценим время работы такого алгоритма. Если мы используем представление графа с помощью матрицы инцидентности, то число вершин \( n \) в графе будет \( \Omega(\sqrt{n}) \), где \( n = |\langle G \rangle| \) — длина представления графа \( G \). Имеется \( m! \) различных перестановок вершин графа, и время работы алгоритма равно \( \Omega(m!) = \Omega(\sqrt{n}!) = \Omega(2^{\sqrt{n}}) \), то есть не является полиномиальным. Таким образом, наивный алгоритм не даёт эффективного решения задачи. На самом деле, как мы покажем в разделе 36.1, задача о гамильтоновом цикле является NP-полной, и потому можно предполагать, что полиномиального алгоритма для неё вообще не существует.

**Проверка принадлежности языку**

Пусть вы заключили пари с приятелем, который утверждает, что (нарисованный перед вами на доске) граф является гамильтоновым. При этом вы не можете быстро проверить, так это или нет. Тем не менее приятель может выиграть пари, если каким-то образом отгадает гамильтонов цикл и предъявит его вам: проверка того, что данный цикл является гамильтоновым, проста. Нужно лишь проверить, что предъявленный цикл проходит через все вершины графа, и что он действительно идёт по рёбрам. Итак, доказательство существования гамильтонова цикла в графе (состоящее в предъявлении гамильтонова пути) можно проверить за полиномиальное время.

Назовем проверяющим алгоритмом (verification algorithm) алгоритм \( A \) с двумя аргументами; первый аргумент мы будем называть (как и раньше) входной строкой, а второй — сертификатом (certificate). Мы говорим, что алгоритм \( A \) с двумя аргументами допускает вход \( x \) (\( A \) verifies an input string \( x \)), если существует сертификат \( y \), для которого \( A(x, y) = 1 \). Языком, проверяемым алгоритмом \( A \) (language verified by \( A \)), мы назовём язык

\[
L = \{x \in \{0, 1\}^* : \text{существует } y \in \{0, 1\}^*, \text{для которого } A(x, y) = 1\}.
\]

Другими словами, алгоритм \( A \) проверяет язык \( L \), если для любой строки \( x \in L \) найдется сертификат \( y \), с помощью которого \( A \) может проверить принадлежность \( x \) к языку \( L \), а для \( x \notin L \) такого сертификата нет. Например, в задаче HAM-CYCLE сертификатом была последовательность вершин, образующая гамильтонов цикл.

**Сложностной класс NP**