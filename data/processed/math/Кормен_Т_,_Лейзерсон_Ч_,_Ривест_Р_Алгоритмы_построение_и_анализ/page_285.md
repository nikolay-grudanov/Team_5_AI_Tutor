---
source_image: page_285.png
page_number: 285
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 57.65
tokens: 11482
characters: 2092
timestamp: 2025-12-24T06:33:40.930017
finish_reason: stop
---

шины \( x \), за время \( O(\log n) \)?

15.1-6 Заметим, что процедуры OS-SELECT и OS-RANK используют поле size только для того, чтобы узнать порядковый номер вершины \( x \) в поддереве с корнем \( x \). Предположим, что мы храним в вершине вместо поля size этот порядковый номер. Как обновлять эту информацию при добавлении и удалении элемента? (Напомним, что добавление и удаление сопровождаются вращениями.)

15.1-7 Как, используя порядковые деревья, посчитать число инверсий (см. задачу 1-3) в массиве размера \( n \) за время \( O(n \log n) \)?

15.1-8* Рассмотрим \( n \) хорд окружности, заданных своими концами (считаем, что все \( 2n \) концевых точек различны). Придумайте алгоритм, который за время \( O(n \lg n) \) определяет, сколько пар хорд пересекаются внутри круга. (Например, если все хорды — диаметры, то ответом будет \( C_n^2 \).)

15.2 Общая схема работы с дополнительной информацией

Ситуация, когда требуется пополнить какую-либо стандартную структуру данных дополнительной информацией, довольно типична. Мы встретимся с ней снова в следующем разделе. А в этом разделе мы докажем общую теорему, облегчающую этот процесс в случае красно-чёрных деревьев.

Пополнение структуры данных делится на четыре шага:

1. выбираем базовую структуру данных;
2. решаем, какую дополнительную информацию мы будем хранить (и обновлять);
3. проверяем, что эту информацию удаётся обновлять при выполнении операций, допустимых для выбранной структуры данных;
4. реализуем новые операции.

Конечно, эти правила — всего лишь общая схема, и в конкретной ситуации надо проявлять разумную гибкость, но схема эта может быть полезной.

Давайте посмотрим на конструкции раздела 15.1 с точки зрения этих правил.

На шаге 1 мы выбрали красно-чёрные деревья в качестве базовой структуры.

На шаге 2 мы решили добавить к каждой вершине поле size. Смысл хранения дополнительной информации состоит в том, что она позволяет выполнять некоторые операции быстрее. Без поля size мы не смогли бы выполнить операции OS-SELECT и OS-RANK за время \( O(\log n) \). (Несколько иной вариант выбора дополнительной