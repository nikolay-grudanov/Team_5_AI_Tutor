---
source_image: page_758.png
page_number: 758
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 54.62
tokens: 11649
characters: 2585
timestamp: 2025-12-24T06:56:03.583710
finish_reason: stop
---

Нас будут, впрочем, интересовать оценки длины периода не по модулю n, а по модулю делителей n. Пусть s — некоторый делитель n, для которого gcd(s, n/s) = 1 (например, выделим степени некоторого одного простого множителя в разложении n на множители). Посмотрим на остатки от деления чисел x_i на число s. Эта последовательность x'_i = x_i \bmod s также можно рассматривать как заданную рекуррентным соотношением

\[
x'_{i+1} = (x'_i^2 - 1) \pmod{s},
\]

поскольку переход от модуля n к модулю s определён корректно (при s | n) и перестановочен с возведением в квадрат и вычитанием единицы.

Повторив приведённое выше вероятностное рассуждение, мы придём к заключению, что последовательность \( \langle x'_i \rangle \) становится периодичной за \( \Theta(\sqrt{s}) \) шагов. Можно ожидать, что в последовательности \( \langle x'_i \rangle \) повторение появится раньше, так как сравнимость по модулю n — более сильное условие, чем сравнимость по модулю s. (На рис. 33.7 как раз такой случай и показан.)

Теперь объясним, как используется переменная y. Пусть мы хотим найти повторяющиеся члены в последовательности \( \langle x_i \rangle \). Для этого не нужно сравнивать каждый член с каждым — вместо этого можно запоминать члены \( x_1, x_2, x_4, x_8, \ldots \) и сравнивать другие члены последовательности с ними, ища повторений. При этом, конечно, мы не гарантируем, что обнаружим самую раннюю пару повторяющихся членов. Но поскольку повторение, раз случившись, далее идёт по циклу, мы его не пропустим. При этом нам придётся просмотреть больше членов последовательности, чем если бы мы сравнивали все пары, но ненамного (не более чем в константу раз).

Процедура Pollard-Rho сравнивает текущее значение x_i с запомненным значением y — но вместо того, чтобы проверять их равенство (и тем самым искать повторения в последовательности \( \langle x_i \rangle \)) вычисляет наибольший общий делитель их разности и числа n. Смысл этого в том, что тем самым можно уловить цикл в последовательности x'_i — если x_i и y сравнимы по модулю s, то наибольший общий делитель x_i — y и n будет кратен s, и если только он не окажется равным n, то дело сделано — мы нашли нетривиальный делитель числа n. (Заметим ещё, что число s используется только в наших рассуждениях, не встречаясь в программе.)

Всё может быть не так гладко, как мы описали, по двум причинам. Во-первых, наши оценки для числа шагов — всего лишь прикидки, и алгоритм может проработать намного дольше, прежде чем будет найден общий делитель. Во-вторых, обнаруженный делитель, кратный s, может оказаться равным n и, следовательно,