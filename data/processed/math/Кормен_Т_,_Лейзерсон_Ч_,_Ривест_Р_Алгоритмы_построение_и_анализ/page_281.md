---
source_image: page_281.png
page_number: 281
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 73.29
tokens: 11669
characters: 2420
timestamp: 2025-12-24T06:33:46.592319
finish_reason: stop
---

Динамические порядковые статистики

личество вершин, не считая NIL-листьев) поддерева с корнем в \( x \) (считая и саму вершину \( x \)). Считая, что в поле \( size[NIL] \) записан 0, можно написать такое соотношение:

\[
size[x] = size[left[x]] + size[right[x]] + 1.
\]

(При реализации можно использовать фиктивный элемент \( nil[T] \), как в разделе 14.4, а можно каждый раз проверять, не равен ли указатель значению NIL, и подставлять 0 вместо значения поля \( size \).)

Поиск \( i \)-го по величине элемента

Мы должны уметь обновлять дополнительную информацию (поля \( size \)) при добавлении и удалении элементов. Но сначала объясним, как ею пользоваться. Начнём с поиска \( i \)-го элемента. Рекурсивная процедура OS-Select(\( x, i \)) возвращает указатель на \( i \)-й элемент поддерева с корнем \( x \). Найти \( i \)-й элемент во всём дереве \( T \) можно с помощью вызова OS-Select(\( root[T], i \)).

OS-Select(\( x, i \))
1 \( r \leftarrow size[left[x]] + 1 \)
2 if \( i = r \)
3 then return \( x \)
4 elseif \( i < r \)
5 then return OS-Select(\( left[x], i \))
6 else return OS-Select(\( right[x], i - r \))

Этот алгоритм использует ту же идею, что и алгоритмы поиска главы 10. В поддереве с корнем \( x \) сначала идут \( size[left[x]] \) вершин левого поддерева, меньших \( x \), затем сама вершина \( x \) (которая является (\( size[left[x]] + 1 \))-й по счёту), и затем вершины правого поддерева \( x \).

Процедура начинает с вычисления порядкового номера \( r \) вершины \( x \) (строка 1). Если \( i = r \) (строка 2), то \( x \) и есть \( i \)-й элемент, и мы возвращаем его (строка 3). Если \( i < r \), то искомый элемент находится в левом поддереве вершины \( x \), и программа рекурсивно вызывает себя (строка 5). Если же \( i > r \), то искомый элемент находится в правом поддереве вершины \( x \), но его порядковый номер внутри этого поддерева будет уже не \( i \), а \( i - r \). Этот элемент выдаётся при рекурсивном вызове в строке 6.

Покажем, как процедура OS-Select ищет 17-й элемент дерева, изображённого на рис. 15.1. Мы начинаем с корня (с ключом 26), при этом \( i = 17 \). Размер левого поддерева корня равен 12, поэтому порядковый номер корня равен 13, и искомая вершина находится в правом поддереве, имея там порядковый номер \( 17 - 13 = 4 \). Ищем 4-й элемент поддерева с корнем 41. Левое поддерево вершины 41 имеет размер 5, т.е. порядковый номер вершины 41 равен 6. Ищем