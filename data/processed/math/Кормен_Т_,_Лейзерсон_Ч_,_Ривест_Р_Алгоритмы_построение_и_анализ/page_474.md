---
source_image: page_474.png
page_number: 474
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 49.86
tokens: 11584
characters: 2233
timestamp: 2025-12-24T06:42:35.739790
finish_reason: stop
---

— для \( G \) и для \( G^T \); время работы есть \( O(V + E) \).

Strongly-Connected-Components($G$)
1 с помощью DFS($G$) найти время окончания обработки $f[u]$ для каждой вершины $u$
2 построить $G^T$
3 вызвать DFS($G^T$), при этом в его внешнем цикле перебирать вершины в порядке убывания величины $f[u]$ (вычисленной в строке 1)
4 сильно связными компонентами будут деревья поиска, построенные на шаге 3.

С первого взгляда этот алгоритм кажется несколько загадочным. Его анализ мы начнём с двух полезных наблюдений, относящихся к произвольному ориентированному графу.

Лемма 23.12
Если две вершины принадлежат одной сильно связанной компоненте, никакой путь между ними не выходит за пределы этой компоненты.
Доказательство.
Пусть вершина \( w \) лежит на пути из \( u \) и \( v \), и вершины \( u \) и \( v \) принадлежат одной сильно связанной компоненте. Тогда \( u \leadsto w, w \leadsto v \) и \( v \leadsto u \), откуда всё и следует.

Теорема 23.13
В процессе поиска в глубину вершины одной сильно связанной компоненты попадают в одно и то же дерево.
Доказательство.
Для произвольной сильно связанной компоненты рассмотрим её вершину, обнаруженную первой (обозначим её \( r \)). В этот момент все остальные вершины компоненты ещё белые и потому доступны из \( r \) по белым путям (ведущие в них пути не выходят за пределы компоненты по лемме 23.12). Поэтому по теореме о белом пути они будут закрашены при вызове DFS-Visit(\( r \)) и войдут в то же дерево поиска.

Возвращаясь к анализу алгоритма Strongly-Connected-Components, договоримся, что \( d[u] \) и \( f[u] \) будут обозначать время обнаружения и время окончания обработки вершины \( v \), найденные в строке 1 алгоритма, а запись \( u \leadsto v \) будет означать существование пути в \( G \) (а не в \( G^T \)).

Для каждой вершины \( u \) графа определим её предшественника (forefather) \( \varphi(u) \) как ту из вершин \( w \), достижимых из \( u \), для которой обработка была завершена позднее всех:

\[
\varphi(u) = \text{такая вершина } w, \text{ что } u \leadsto w \text{ и } f[w] \text{ максимально}
\]

При этом вполне может оказаться, что \( \varphi(u) = u \).
Так как любая вершина \( u \) достижима сама из себя,
\[
f[u] \leq f[\varphi(u)]
\]
(23.2)