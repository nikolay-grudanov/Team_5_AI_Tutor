---
source_image: page_503.png
page_number: 503
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 58.89
tokens: 11769
characters: 2587
timestamp: 2025-12-24T06:44:09.043097
finish_reason: stop
---

Рис. 25.5

Рисунок 25.5 Рис. 25.5. Алгоритм Дейкстры. Исходная вершина — крайняя левая. Оценки кратчайшего пути указаны в вершинах. Серым цветом выделены рёбра \((u, v)\), для которых \(\pi[v] = u\). Чёрные вершины лежат в множестве \(S\), остальные находятся в очереди \(Q = V \setminus S\). (а) Перед первой итерацией цикла while. Серая вершина имеет минимальное значение \(d\) и выбирается в качестве вершины \(u\) в строке 5 (б–е) Последовательные состояния после каждой итерации цикла while. Серая вершина выбирается в качестве вершины \(u\) при следующей итерации. Значения \(d\) и \(\pi\) на рисунке (е) — окончательные.

\(d\) меняется.

Алгоритм Дейкстры решает задачу о кратчайших путях из одной вершины для взвешенного ориентированного графа \(G = (V, E)\) с исходной вершиной \(s\), в котором веса всех ребер неотрицательны. \((w(u, v) \geq 0\) для всех \((u, v) \in E)\). В этом разделе мы рассматриваем только такие графы.

В процессе работы алгоритма Дейкстры поддерживается множество \(S \subseteq V\), состоящее из вершин \(v\), для которых \(\delta(s, v)\) уже найдено (то есть \(d[v] = \delta(s, v)\)). Алгоритм выбирает вершину \(u \in V \setminus S\) с наименьшим \(d[u]\), добавляет \(u\) к множеству \(S\) и производит релаксацию всех рёбер, выходящих из \(u\), после чего цикл повторяется. Вершины, не лежащие в \(S\), хранятся в очереди с приоритетами \(Q\), определяемыми значениями функции \(d\). Предполагается, что граф задан с помощью списков смежных вершин.

Dijkstra(G,w,s)
1 Initialize-Single-Source(G,s)
2 S \gets \emptyset
3 Q \gets V[G]
4 while Q \neq \emptyset
5   do u \gets Extract-Min(Q)
6   S \gets S \cup \{u\}
7   for (для) всех вершин v\in Adj[u]
8     do Relax(u,v,w)

Работа алгоритма Дейкстры показана на рис. 25.5. В строке 1 инициализируются \(d\) и \(\pi\), а в строках 2 и 3 инициализируются множество \(S\) (как пустое) и очередь \(Q = V \setminus S = V\). При каждом исполнении цикла в строках 4–8 из очереди \(Q = V \setminus S\) изымается вершина \(u\) с наименьшим значением \(d[u]\); она добавляется к множеству \(S\) (в первый раз имеем \(u = s\)). В строках 7–8 каждое ребро \((u, v)\), выходящее из \(u\), подвергается релаксации (при этом могут измениться оценка \(d[v]\) и предшественник \(\pi[v]\)). Заметим, что в цикле новые вершины в очередь \(Q\) не добавляются и что каждая вершина, удаляемая из \(Q\), добавляется к множеству \(S\) лишь однажды. Следовательно, число итераций цикла while равно \(|V|\).

Поскольку алгоритм Дейкстры всякий раз выбирает для обработки вершины с наименьшей оценкой кратчайшего пути, можно