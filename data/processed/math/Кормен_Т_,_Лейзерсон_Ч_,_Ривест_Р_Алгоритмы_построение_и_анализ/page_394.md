---
source_image: page_394.png
page_number: 394
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 95.00
tokens: 11863
characters: 2687
timestamp: 2025-12-24T06:39:33.956736
finish_reason: stop
---

<table>
  <tr>
    <th>Процедура</th>
    <th>Двоичные кучи<br>(в худшем случае)</th>
    <th>Биномиальные кучи<br>(в худшем случае)</th>
    <th>Фибоначчиевы кучи<br>(в среднем)</th>
  </tr>
  <tr>
    <td>MAKE-HEAP</td>
    <td>\( \Theta(1) \)</td>
    <td>\( \Theta(1) \)</td>
    <td>\( \Theta(1) \)</td>
  </tr>
  <tr>
    <td>INSERT</td>
    <td>\( \Theta(\lg n) \)</td>
    <td>\( O(\lg n) \)</td>
    <td>\( \Theta(1) \)</td>
  </tr>
  <tr>
    <td>MINIMUM</td>
    <td>\( \Theta(1) \)</td>
    <td>\( O(\lg n) \)</td>
    <td>\( \Theta(1) \)</td>
  </tr>
  <tr>
    <td>EXTRACT-MIN</td>
    <td>\( \Theta(\lg n) \)</td>
    <td>\( \Theta(\lg n) \)</td>
    <td>\( O(\lg n) \)</td>
  </tr>
  <tr>
    <td>UNION</td>
    <td>\( \Theta(n) \)</td>
    <td>\( O(\lg n) \)</td>
    <td>\( \Theta(1) \)</td>
  </tr>
  <tr>
    <td>DECREASE-KEY</td>
    <td>\( \Theta(\lg n) \)</td>
    <td>\( \Theta(\lg n) \)</td>
    <td>\( \Theta(1) \)</td>
  </tr>
  <tr>
    <td>DELETE</td>
    <td>\( \Theta(\lg n) \)</td>
    <td>\( \Theta(\lg n) \)</td>
    <td>\( O(\lg n) \)</td>
  </tr>
</table>

Рисунок 20.1 Время выполнения различных операций для трёх видов сливающихся куч (\( n \) — общее число элементов в кучах на момент операции).

номиальных куч, содержащих в сумме \( n \) элементов, требует всего лишь \( O(\lg n) \) операций.

В главе 21 мы рассматриваем "фибоначчиевые кучи", которые ещё более эффективны (третий столбец). Отметим, впрочем, что это улучшение достигается лишь для учётной стоимости операций при амортизационном анализе.

В наших процедурах мы не занимаемся выделением и освобождением памяти для элементов куч.

Все три вида куч, указанных в таблице, не позволяют эффективно реализовать поиск элемента с данным ключом (SEARCH). Поэтому процедуры DECREASE-KEY и DELETE получают в качестве параметра не ключ вершины, а указатель на неё (во многих случаях это требование не создаёт проблем).

В разделе 20.1 определяются биномиальные деревья и кучи. Там же описывается представление биномиальных куч в программе. В разделе 20.2 показано, как реализовать все перечисленные операции за указанное в таблице 20.1 время.

20.1 Биномиальные деревья и биномиальные кучи

Биномиальная куча состоит из нескольких биномиальных деревьев.

20.1.1 Биномиальные деревья

Биномиальные деревьями (binomial trees) называются упорядоченные (в смысле раздела 5.2.2) деревья \( B_0, B_1, B_2, \ldots \), определяемые индуктивно.

Дерево \( B_0 \) состоит из единственной вершины (рис. 20.2a). Дерево \( B_k \) склеено из двух экземпляров дерева \( B_{k-1} \): корень одного из них объявлен самым левым потомком корня другого. На рис. 20.2б показаны биномиальные деревья \( B_0 - B_4 \).