---
source_image: page_640.png
page_number: 640
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 57.41
tokens: 11703
characters: 2521
timestamp: 2025-12-24T06:50:44.792492
finish_reason: stop
---

чением счётчика глубины. При этом вершина глубины k достигается в момент времени k, так что время работы пропорционально высоте дерева. Для полного дерева этот алгоритм требует логарифмического времени, но бывают деревья, у которых высота равна n - 1. Метод эйлерова цикла, который мы сейчас изложим, позволяет обрабатывать любое дерево с n вершинами за время O(lg n) (независимо от его высоты).

Эйлеровым циклом в графе называется путь, проходящий ровно один раз по каждому ребру (вершины могут проходиться многократно). Согласно задаче 23-2, связный ориентированный граф имеет эйлеров цикл в том и только в том случае, когда у каждой вершины входная и выходная степени совпадают. Если преобразить связный неориентированный граф в ориентированный, заменив каждое ребро двумя противонаправленными, то такой граф, очевидно, будет иметь эйлеров цикл.

Пусть T — двоичное дерево. Будем предполагать, что его вершины занумерованы неотрицательными целыми числами. С каждой вершиной мы связываем три процессора A, B и C; узлу с номером i соответствуют процессоры с номерами 3i, 3i + 1 и 3i + 2. Рассмотрим ориентированный вариант дерева (с удвоенными рёбрами). Эйлеров цикл (или обход дерева) можно превратить в список (см. рис. 30.4(a)):

• A-процессор вершины указывает на A-процессор левого ребёнка, если он есть, а иначе на B-процессор той же вершины.
• B-процессор вершины указывает на A-процессор правого ребёнка, если он есть, а иначе на C-процессор той же вершины.
• C-процессор вершины указывает на B-процессор родителя, если это левый ребёнок, и на C-процессор родителя, если это правый ребёнок. C-процессор корневой вершины указывает на NIL.

Таким образом, список начинается в A-процессоре корневой вершины и заканчивается в её C-процессоре. Этот список может быть построен по данному дереву за время O(1).

Глубину каждой вершины можно подсчитать как сумму изменений глубин по пути к ней (по эйлеровому циклу). Более формально, пусть в каждом A-процессоре находится число 1, в каждом B-процессоре — число 0, а в каждом C-процессоре — число (-1). Произведём параллельное вычисление префиксов, используя в качестве операции обычное сложение. Его результат для дерева рис. 30.4(a) показан на рис. 30.4(b).

После этого C-процессор каждой вершины будет содержать её глубину, а A- и B-процессоры — на единицу большее значение. Это можно проверить, двигаясь вдоль эйлерова цикла. В самом деле, к A-процессору ведёт стрелка вниз по дереву с началом в A- или B-процессоре родителя; к B-процессору ведёт либо стрелка вверх