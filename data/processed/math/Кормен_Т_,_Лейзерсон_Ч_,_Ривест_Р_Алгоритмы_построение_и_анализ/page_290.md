---
source_image: page_290.png
page_number: 290
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 27.62
tokens: 11210
characters: 1083
timestamp: 2025-12-24T06:33:18.801331
finish_reason: stop
---

Рисунок 15.4 Дерево промежутков. (а) Набор из 10 отрезков (выше тот, у которого левый конец больше). (б) Дерево промежутков, хранящее эти отрезки. При этом свойство упорядоченности дерева выполняется для левых концов.

значение NIL.

Interval-Search \((T, i)\)

1 \(x \leftarrow root[T]\)
2 while \(x \neq \text{NIL}\) и \(int[x]\) не перекрывается с \(i\)
3 do if \(left[x] \neq \text{NIL}\) и \(max[left[x]] \geq low[i]\)
4 then \(x \leftarrow left[x]\)
5 else \(x \leftarrow right[x]\)
6 return \(x\)

Мы ищем отрезок, проходя дерево от корня к листу. Процедура останавливается, если отрезок найден или если значение переменной \(x\) стало равным NIL. Каждая итерация цикла требует \(O(1)\) шагов, поэтому время работы процедуры пропорционально высоте дерева (и равно \(O(\log n)\) для дерева из \(n\) вершин).

Для примера посмотрим, как процедура ищет в дереве на рис. 15.4 отрезок, перекрывающийся с отрезком \(i = [22, 25]\). Мы начинаем с корня (\(x = root[T]\)), который хранит отрезок \([16, 21]\), не перекрывающийся с \(i\). Так как \(max[left[x]] = 23\), что больше, чем