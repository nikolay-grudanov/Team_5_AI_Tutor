---
source_image: page_391.png
page_number: 391
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 79.00
tokens: 11670
characters: 2694
timestamp: 2025-12-24T06:39:13.310141
finish_reason: stop
---

При простейшей (но неэффективной) реализации стека на диске хранится всё, кроме переменной \( p \) (указатель стека), которая определяет место вершины стека на диске таким образом: вершиной будет \((p \bmod m)\)-ый элемент \([p/m]\)-го сектора диска (\(m\) — размер сектора).

Чтобы добавить элемент в стек, мы читаем соответствующий сектор, на нужное место помещаем новый элемент, увеличиваем значения указателя на единицу и снова записываем сектор на диск. Аналогично реализуется операция удаления элемента из стека. (Мы читаем сектор с диска и уменьшаем на единицу значение указателя. Так как сектор не менялся, то записывать его на диск не нужно.)

Будем учитывать количество обращений к диску, а также время вычислений, при подсчете которого каждое обращение к диску считается требующим \( \Theta(m) \) единиц времени.

а. Сколько обращений к диску требуется в худшем случае для \( n \) операций со стеком при этой реализации? Чему равно общее время? (Здесь и далее требуется ответ в терминах \( m \) и \( n \).)

Рассмотрим другую реализацию стека, при которой один сектор целиком хранится в памяти. (Кроме того, нам требуется помнить номер хранимого сектора.) По мере необходимости мы будем возвращать этот сектор на диск и считывать новый. Если нужный сектор уже находится в памяти, то обращаться к диску не нужно.

б. Сколько обращений к диску требуется для добавления \( n \) элементов в стек (в худшем случае)? Чему равно время вычислений?

в. Сколько обращений к диску требуется в худшем случае для \( n \) операций со стеком? Чему равно время вычислений?

Существует более эффективная реализация, при которой в оперативной памяти хранятся два сектора (и ещё несколько чисел).

г. Как сделать так, чтобы каждая операция требовала (при амортизационном анализе) \( O(1/m) \) обращений к диску и времени \( O(1) \)?

19-2 Объединение и разделение 2-3-4 деревьев

Операция объединения (join) получает на входе два множества \( S' \) и \( S'' \) и элемент \( x \), для которых \( key[x'] < key[x] < key[x''] \) при всех \( x' \in S' \) и \( x'' \in S'' \). Её результатом является множество \( S = S' \cup \{x\} \cup S'' \). Разделение (split) — операция, обратная объединению. Она получает на входе множество \( S \) и элемент \( x \in S \) и создаёт два других множества \( S' \) и \( S'' \), состоящих соответственно из меньших и из больших \( x \) элементов множества \( S \). В этой задаче требуется реализовать эти операции для 2-3-4 деревьев. Для удобства будем считать, что элементы состоят только из ключей, и все ключи различны.

а. Будем хранить в каждой вершине \( x \) 2-3-4 дерева поле \( height[x] \), хранящее высоту поддерева с корнем в \( x \). Показать, что эту инфор-