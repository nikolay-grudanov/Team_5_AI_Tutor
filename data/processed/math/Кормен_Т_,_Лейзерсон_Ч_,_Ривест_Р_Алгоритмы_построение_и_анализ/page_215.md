---
source_image: page_215.png
page_number: 215
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 62.34
tokens: 11617
characters: 2299
timestamp: 2025-12-24T06:30:24.920701
finish_reason: stop
---

Без строк 4–6 это был бы обычный алгоритм с последовательным перебором элементов списка. В строках 4–6 мы пытаемся перескочить на случайно выбранную позицию \( j \). Если \( key[i] < key[j] < k \), то при этом мы экономим время, так как не проверяем элементы, лежащие в позициях между \( i \) и \( j \). (Благодаря тому, что список занимает непрерывный участок массива, мы можем выбрать в нём случайный элемент.)

а Зачем нужно предполагать, что все ключи различны? Покажите, что для неубывающего списка с (возможно) совпадающими ключами случайные скачки могут не улучшить асимптотику времени поиска.

Как оценить время работы? Представим себе, что на нескольких первых шагах мы выполняем только случайные скачки, а на остальных выполняем линейный поиск. Можно оценить ожидаемое расстояние до искомого элемента после первой фазы — и тем самым длительность второй фазы. Наш алгоритм будет работать не хуже такого усечённого, и остаётся только правильно выбрать длительность первой фазы, чтобы получить оценку получше.

Сделаем это аккуратно. Для каждого \( t \geq 0 \) обозначим через \( X_t \) случайную величину, равную расстоянию (измеренному вдоль списка) от позиции \( i \) до искомого ключа \( k \) после \( t \) случайных скачков.

б Покажите, что для каждого \( t \geq 0 \) математическое ожидание времени работы алгоритма COMPACT-LIST-SEARCH есть \( O(t + E[X_t]) \).

в Покажите, что \( E(X_t) \leq \sum_{r=1}^n (1 - r/n)^t \). (Указание: воспользуйтесь формулой (6.28)).

г Покажите, что \( \sum_{r=0}^{n-1} 5 \leq n^{t+1}/(t+1) \).

д Покажите, что \( E(X_t) \leq n/(t+1) \), и объясните "на пальцах", почему это неравенство должно быть верно.

е Покажите, что математическое ожидание времени работы алгоритма COMPACT-LIST-SEARCH есть \( O(\sqrt{n}) \).

Замечания

Прекрасные справочники по структурам данных — книги Ахо, Хопкрофта и Ульмана [5] и Кнута [121]. Результаты экспериментов по сравнению эффективности различных операций на структурах данных можно найти в Гоннет [90]

Стеки и очереди использовались в математике и делопроизводстве в докомпьютерную эру. Кнут [121] отмечает, что в 1947 году Тьюринг (A.M. Turing) использовал стеки для связи подпрограмм.

Структуры данных, основанные на указателях, также, видимо, относятся к "фольклору". Согласно Кнуту, указатели использова-