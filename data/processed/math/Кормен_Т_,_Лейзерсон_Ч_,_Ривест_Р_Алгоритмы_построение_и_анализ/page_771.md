---
source_image: page_771.png
page_number: 771
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 53.36
tokens: 11627
characters: 2336
timestamp: 2025-12-24T06:56:34.221168
finish_reason: stop
---

10    do if p=t
11        then if P[1..m]=T[s+1..s+m]
12            then print 'Образец входит со сдвигом 's
13        if s<n-m
14            then t \gets (d(t-T[s+1]h) + T[s+m+1]) \bmod q

Опишем работу процедуры. Все символы рассматриваются как d-ичные цифры. В строках 1–5 переменным присваиваются начальные значения (h — это "единица старшего разряда" в d-ичной системе). В цикле в строках 6–8 с помощью схемы Горнера вычисляются значения p и t_0 (последнее присваивается переменной t). Цикл в строках 9–14 перебирает все возможные значения s; в момент исполнения строки 10 имеем t ≡ t_s (mod q). Если оказывается, что t_s ≡ p, то строки T[s + 1..s + m] и P[1..m] сравниваются и, в случае совпадения, об этом печатается сообщение (строки 11–12). Если t_s ≠ p, то программа проверяет, будет ли цикл выполняться далее (строка 13), и если будет, то обновляет значение t по формуле (34.2) — строка 14.

В худшем случае эта процедура требует времени Θ((n - m + 1)m), как и простейший алгоритм — уже потому, что для всех допустимых сдвигов происходит посимвольная проверка. Например, если P = a^m и T = a^n, то сравнение в строке 11 будет выполняться для всех значений s (и алгоритм отличается от трибунального лишь в худшую сторону за счёт дополнительных затрат на вычисление h в строке 3, на цикл в строках 6–8 и на вычисления в строке 14).

Во многих приложениях следует ожидать, что допустимых сдвигов будет немного; в этом случае время работы алгоритма Рабина — Карпа будет O(n + m) плюс небольшие дополнительные затраты на обработку холостых срабатываний. Можно сделать нестрогую прикидку, основываясь на следующих соображениях. Будем считать, что отображение редукции по модулю q — случайная функция из Σ* в Z_q. Это утверждение трудно поддается формализации и доказательству, но эмпирически подтверждается (ср. разд. 12.3.1, где мы обсуждали применение деления с остатком к хешированию). Тогда можно надеяться, что количество холостых срабатываний есть O(n/q), поскольку вероятность того, что случайное число t_s сравнимо с p по модулю q, равна 1/q. Стало быть, ожидаемое время работы алгоритма Рабина — Карпа есть

\[
O(n) + O(m(v + n/q)),
\]

где v — количество вхождений образца в текст. Если q ≥ m (то есть длина образца не превосходит выбранного значения q) и v = O(1), то получается, что алгоритм работает за время O(n + m).