---
source_image: page_613.png
page_number: 613
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 62.80
tokens: 11788
characters: 2341
timestamp: 2025-12-24T06:49:36.156553
finish_reason: stop
---

разрядов. Обозначим через \( x_i \) тип переноса в \( i \)-м разряде.

\[
x_i = \begin{cases}
k, & \text{ifa}_{i-1} = b_{i-1} = 0; \\
g, & \text{ifa}_{i-1} = b_{i-1} = 1; \\
p, & \text{ifa}_{i-1} \neq b_{i-1}.
\end{cases}
\]

Тогда зависимость, скажем, бита \( c_7 \) от \( c_4 \) определяется композицией \( x_5 \otimes x_6 \otimes x_7 \).

Поскольку в нулевой разряд переноса от младших разрядов не поступает, условно положим \( x_0 = k \). Тогда перенос на выходе \( i \) — разряда определяется композицией \( x_0 \otimes x_1 \otimes \ldots \otimes x_i : c_i = 0 \), если композиция равна \( k \), и \( c_i = 1 \), если композиция равна \( g \). (Значение \( p \) для композиции невозможно, поскольку для этого все члены должны быть равны \( p \), а это не так для \( x_0 \).)

Более формально это записывается так. Положим \( y_0 = k \) и определим \( y_1, y_2, \ldots y_n \) так:

\[
y_i = x_i \otimes y_{i-1} = x_0 \otimes x_1 \otimes \ldots \otimes x_i
\]

Другими словами, \( y_0, \ldots y_n \) называются префиксами (prefixes) выражения \( x_0 \otimes x_1 \otimes \ldots \otimes x_n \). (Общая задача о параллельном вычислении префиксов рассмотрена в гл. 30). На рис. 29.7 показаны значения \( x_i \) и \( y_i \) для примера рис. 29.3.

Рисунок 29.7 29.7. Значения \( x_i \) и \( y_i \) для примера рис. 29.3.

Теперь сказанное выше запишется так:
Лемма 29.1. При всех \( i = 0, 1, 2, \ldots, n \):
1. Если \( y_i = k \), то \( c_i = 0 \).
2. Если \( y_i = g \), то \( c_i = 1 \)
3. Случай \( y_i = p \) невозможен.
Доказательство. Индукция по \( i \). При \( i = 0 \) по определению \( y_0 = x_0 = k \) и \( c_0 = 0 \). Пусть утверждение леммы выполнено для \( i - 1 \).
Возможны три случая.
1. Если \( y_i = k \), то либо \( x_i = k \) (и тогда \( i = 0 \)), либо \( x_i = p \) и \( x_{i-1} = k \). Тогда по предположению индукции \( c_{i-1} = 0 \), а \( c_i = c_{i-1} \) (бит переноса сохраняется), поэтому и в этом случае \( c_i = 0 \).
2. Случай \( y_i = g \) аналогичен.
3. Если \( y_i = p \), то обязательно \( x_i = p \) и \( y_{i-1} = p \), но последнее равенство невозможно по предположению индукции.
Лемма доказана.
Таким образом, вычисление битов переноса \( c_i \) сводится к вычислению префиксов \( y_i \). Оставшиеся действия выполняются за время \( \Theta(1) \) — достаточно подать биты переноса на входы сумматоров.