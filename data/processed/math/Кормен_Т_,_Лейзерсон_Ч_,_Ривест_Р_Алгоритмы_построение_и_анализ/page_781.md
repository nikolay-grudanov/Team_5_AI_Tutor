---
source_image: page_781.png
page_number: 781
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 44.58
tokens: 11503
characters: 2150
timestamp: 2025-12-24T06:56:53.902123
finish_reason: stop
---

8    then k \gets k+1
9    \pi[q] \gets k
10 return \pi

Сначала мы проанализируем время работы этих процедур (в предположении их правильности), а затем докажем, что они работают правильно.

34.4.2 Время работы

Покажем, что время работы процедуры Compute-Prefix-Function есть \( O(m) \). Для этого воспользуемся методом потенциалов в амортизационном анализе (глава 18).

Процедура Compute-Prefix-Function выполняет \( m-1 \) итераций цикла в строках 4–9. Покажем, что учётную стоимость каждой из этих итераций можно считать равной \( O(1) \). Для этого в качестве потенциала будем рассматривать значение \( k \) в момент входа в цикл. Поскольку начальное значение \( k \) равно нулю, а последующие равны \( \pi[q] \geq 0 \), реальная стоимость (время выполнения) всех итераций оценивается суммой учётных стоимостей, если считать учётной стоимостью сумму реальной стоимости и изменений потенциала.

Реальная стоимость каждой итерации складывается из стоимости присваиваний в строке 6, присваивания в строке 8 и присваивания в строке 9. Поскольку \( \pi[j] < j \) для всех \( j \), при каждом присваивании в строке 6 потенциал уменьшается по крайней мере на 1, что компенсирует работу по выполнению действий в цикле while, если умножить потенциал на достаточно большую константу. Поэтому вклад цикла while в учётную стоимость есть \( O(1) \); присваивания же в строках 8 и 9 выполняются не более, чем по разу каждое, и увеличивают потенциал не более чем на две единицы. Поэтому учётная стоимость каждой итерации цикла for есть \( O(1) \), а стоимость всей процедуры есть \( O(m) \).

Аналогичное рассуждение, в котором в качестве потенциала выбирается \( q \), показывает, что время выполнения строк 5–12 процедуры КМР-Матчнер есть \( O(n) \). Стало быть, время выполнения всей процедуры КМР-Матчнер есть \( O(m + n) \). Это — выигрыш по сравнению с алгоритмом Finite-Automaton-Matcher, который даже при экономном вычислении функции \( \delta \) требует времени \( O(m|\Sigma| + n) \).

34.4.3 Префикс-функция вычисляется правильно

Начнем с важной леммы, показывающей, что, итерируя префикс-функцию, можно для данного \( q \) найти все такие \( k \),