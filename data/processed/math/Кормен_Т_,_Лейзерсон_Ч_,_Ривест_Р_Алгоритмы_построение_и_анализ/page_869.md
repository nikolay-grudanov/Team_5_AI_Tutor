---
source_image: page_869.png
page_number: 869
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 52.80
tokens: 11546
characters: 2063
timestamp: 2025-12-24T07:01:01.737154
finish_reason: stop
---

Рисунок 37.3  37.3. Пример исходных данных для задачи о покрытии множествами. Множество \( X \) состоит из 12 чёрных точек. Семейство \( \mathcal{F} \) состоит из 6 множеств \( S_1 - S_6 \). Минимальное покрытие имеет размер 3 (множества \( S_3, S_4, S_5 \)). Жадный алгоритм даёт покрытие размера 4, включая в него множества \( S_1, S_4, S_5 \) и \( S_3 \) (в указанном порядке).

ство решения ухудшается, но всё же довольно медленно (логарифм — медленно растущая функция), поэтому такой подход может быть полезен.

Исходными данными задачи о покрытии множествами (set-covering problem) являются конечное множество \( X \), а также семейство \( \mathcal{F} \) его подмножеств. При этом каждый элемент множества \( X \) принадлежит хотя бы одному из подмножеств семейства \( \mathcal{F} \):

\[
X = \bigcup_{S \in \mathcal{F}} S.
\]

Мы ищем минимальное число подмножеств из \( \mathcal{F} \), которые вместе покрывают множество \( X \), то есть семейство \( \mathcal{C} \) наименьшей мощности, для которого

\[
X = \bigcup_{S \in \mathcal{C}} S.
\] (37.8)

Такое семейство \( \mathcal{C} \) мы будем называть покрытием множества \( X \).
(Пример задачи о покрытии приведён на рис. 37.3.)

Можно представлять себе \( X \) как набор навыков, необходимых для выполнения какого-то задания; есть несколько человек, владеющих некоторыми из них. Надо сформировать минимальную группу для выполнения задания, включающую в себя носителей всех необходимых навыков.

Задачу о покрытии множествами можно сформулировать в варианте, требующем ответа да/нет: "существует ли покрытие размера не больше \( k \)" (для любого заданного \( k \)). В упражнении 37.3-2 мы попросим вас доказать, что эта задача является NP-полной.

Жадный приближённый алгоритм
Этот алгоритм основан на простой идее: в каждый момент мы выбираем множество, покрывающее максимальное число ещё не покрытых элементов.

1 U <- X
2 mathcal{C} <- 0
3 while U \neq \emptyset
4   do выбираем S \in \mathcal{F} с наибольшим |S \cap U|
5     U <- U - S
6     mathcal{C} <- mathcal{C} \cup \{S\}
7 return mathcal{C}