---
source_image: page_335.png
page_number: 335
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 62.67
tokens: 11682
characters: 2479
timestamp: 2025-12-24T06:36:10.916548
finish_reason: stop
---

Построение кода Хаффмена

Хаффмен построил жадный алгоритм, который строит оптимальный префиксный код. Этот код называется кодом Хаффмена (Huffman code). Алгоритм строит дерево \( T \), соответствующее оптимальному коду, снизу вверх, начиная с множества из \( |C| \) листьев и делая \( |C|-1 \) "слияний". Мы предполагаем, что для каждого символа \( c \in C \) задана его частота \( f[c] \). Для нахождения двух объектов, подлежащих слиянию, используется очередь с приоритетами \( Q \), использующая частоты \( f \) в качестве рангов — сливаются два объекта с наименьшими частотами. В результате слияния получается новый объект (внутренняя вершина), частота которого считается равной сумме частот двух сливаемых объектов.

\[
\text{HUFFMAN}(C)
\]
1 \( n \leftarrow |C| \)
2 \( Q \leftarrow C \)
3 for \( i \leftarrow 1 \) to \( n-1 \)
4 do \( z \leftarrow \text{ALLOCATE-NODE}() \)
5 \( x \leftarrow left[z] \leftarrow \text{EXTRACT-MIN}(Q) \)
6 \( y \leftarrow right[z] \leftarrow \text{EXTRACT-MIN}(Q) \)
7 \( f[z] \leftarrow f[x] + f[y] \)
8 \( \text{INSERT}(Q, z) \)
9 return \( \text{EXTRACT-MIN}(Q) \)

Работа этого алгоритма для нашего примера показана на рис. 17.5. Поскольку имеется всего 6 букв, первоначально очередь имеет размер \( n = 6 \), и для построения дерева нужно сделать 5 слияний. Префиксный код соответствует дереву, полученному в результате всех этих слияний.

В строке 2 алгоритма в очередь \( Q \) помещаются символы из алфавита \( C \) (с соответствующими частотами). В цикле (строки 3–8) повторяется \( n - 1 \) раз следующая операция: из очереди изымается две вершины \( x \) и \( y \) с наименьшими частотами \( f[x] \) и \( f[y] \), которые заменяются на одну вершину \( z \) с частотой \( f[x] + f[y] \) и детьми \( x \) и \( y \) (кого из них считать левым ребёнком, а кого правым — неважно: код получится другой, но его стоимость будет та же). В конце в очереди остаётся один узел — корень построенного двоичного дерева. Ссылка на него возвращается в строке 9.

Оценим время работы алгоритма, считая, что очередь \( Q \) реализована в виде двоичной кучи (см. главу 7). Инициализацию \( Q \) в строке 2 можно провести за \( O(n) \) операций с помощью процедуры Build-Heap из раздела 7.3. Цикл в строках 3–8 исполняется ровно \( n - 1 \) раз; поскольку каждая операция с кучей требует времени \( O(\log n) \), общее время будет \( O(n \log n) \). Стало быть, время работы алгоритма Huffman для алфавита из \( n \) символов будет \( O(n \log n) \).