---
source_image: page_533.png
page_number: 533
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 63.33
tokens: 11852
characters: 2371
timestamp: 2025-12-24T06:45:43.075870
finish_reason: stop
---

\[
T^{(0)} = \begin{pmatrix}
1 & 0 & 0 & 0 \\
0 & 1 & 1 & 1 \\
0 & 1 & 1 & 0 \\
1 & 0 & 1 & 1
\end{pmatrix}
\quad
T^{(1)} = \begin{pmatrix}
1 & 0 & 0 & 0 \\
0 & 1 & 1 & 1 \\
0 & 1 & 1 & 0 \\
1 & 0 & 1 & 1
\end{pmatrix}
\quad
T^{(2)} = \begin{pmatrix}
1 & 0 & 0 & 0 \\
0 & 1 & 1 & 1 \\
0 & 1 & 1 & 1 \\
1 & 0 & 1 & 1
\end{pmatrix}
\]
\[
T^{(3)} = \begin{pmatrix}
1 & 0 & 0 & 0 \\
0 & 1 & 1 & 1 \\
0 & 1 & 1 & 1 \\
1 & 1 & 1 & 1
\end{pmatrix}
\quad
T^{(4)} = \begin{pmatrix}
1 & 0 & 0 & 0 \\
1 & 1 & 1 & 1 \\
1 & 1 & 1 & 1 \\
1 & 1 & 1 & 1
\end{pmatrix}
\]

Рисунок 26.4  26.5 Ориентированный граф и матрицы \( T^{(k)} \), вычисленные алгоритмом построения транзитивного замыкания.

компьютерах логические операции выполняются быстрее, чем арифметические операции с целыми числами, поэтому процедура TRANSITIVE-Closure эффективнее алгоритма Флойда-Уоршолла. Кроме того, использование булевских переменных вместо целых сокращает объём используемой памяти.

В разделе 26.4 мы увидим, что аналогия между алгоритмами Флойда-Уоршолла и построением транзитивного замыкания не случайна: оба алгоритма основаны на алгебраической структуре, называемой "замкнутое полукольцо".

Упражнения

26.2-1 Исполните алгоритм Флойда-Уоршолла для взвешенного ориентированного графа рис. 26.2, найдя все матрицы \( D^{(k)} \).

26.2-2 В приведённом нами виде алгоритм Флойда-Уоршолла требует \( \Theta(n^3) \) памяти для хранения матриц \( D^{(k)} = (d_{ij}^{(k)}) \). Конечно, можно сэкономить место, если хранить только две соседние матрицы. Оказывается, можно пойти ещё дальше: докажите, что если в процедуре FLOYD-WARSHALL убрать верхние индексы, то она по-прежнему будет вычислять веса кратчайших путей.

{\sc Floyd-Warshall'}$(W)$\\
\verb|1 |$n \leftarrow rows[W]$\\
\verb|2 |$D \leftarrow W$\\
\verb|3 |for $k \leftarrow 1$ to $n$\\
\verb|4 |do for $i \leftarrow 1$ to $n$\\
\verb|5 |do for $j \leftarrow 1$ to $n$\\
\verb|6 |$d_{ij} \leftarrow \min(d_{ij}, d_{ik}+d_{kj})$\\
\verb|7 |return $D$

Тем самым мы сократили объём требуемой памяти до \( \Theta(n^2) \).

26.2-3 Добавьте в процедуру FLOYD-WARSHALL вычисление матриц предшествования \( \Pi^{(k)} \) по формулам (26.6) и (26.7). Докажите, что для любой вершины \( i \in V \) подграф предшествования \( G_{\pi,i} \) является деревом кратчайших путей из вершины \( i \).

26.2-4 Будет ли правильно вычислена матрица предшествования