---
source_image: page_486.png
page_number: 486
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 56.39
tokens: 11621
characters: 2240
timestamp: 2025-12-24T06:43:18.293176
finish_reason: stop
---

24.2 Алгоритмы Крускала и Прима

Оба этих алгоритма следуют описанной схеме, но по-разному выбирают безопасное ребро. В алгоритме Крускала множество рёбер \( A \) представляет собой лес, состоящий из нескольких связных компонент (деревьев). Добавляется ребро минимального веса среди всех рёбер, концы которых лежат в разных компонентах.

В алгоритме Приме множество \( A \) представляет собой одно дерево, Безопасное ребро, добавляемое к \( A \), выбирается как ребро наименьшего веса, соединяющее это уже построенное дерево с некоторой новой вершиной.

Алгоритм Крускала
В любой момент работы алгоритма Крускала множество \( A \) выбранных рёбер (часть будущего остова) не содержит циклов. Оно соединяет вершины графа в несколько связных компонент, каждая из которых является деревом. Среди всех рёре, соединяющих вершины из разных компонент, берётся ребро наименьшего веса. Надо проверить, что оно является безопасным.

Пусть \((u, v)\) — такое ребро, соединяющее вершины из компонент \(C_1\) и \(C_2\). Это ребро является лёгким ребром для разреза \(C_1, V \setminus C_1\), и можно воспользоваться теоремой 24.1 (или прямо следствием 24.2).

Реализация алгоритма Крускала напоминает алгоритм вычисления связных компонент (разд. 22.1) и использует структуры данных для непересекающихся множеств ( гл. 22 ), Элементами множеств являются вершины графа. Напомним, что FIND-SET\((u)\) возвращает представителя множества, содержащего элемент \(u\). Две вершины \(u\) и \(v\) принадлежат одному множеству (компоненте), если FIND-SET\((u) =\) FIND-SET\((v)\). Объединение деревьев выполняется процедурой UNION.

\textsc{MST-Kruskal}$(G, w)$
1 $A \leftarrow \emptyset$
2 {\bf for} $v \in V[G]$
3   {\bf do} \textsc{Make-Set}$(v)$
4 упорядочить рёбра $E$ по весам
5 {\bf for} $(u, v) \in E$ (в порядке возрастания веса)
6   {\bf do if} \textsc{Find-Set}$(u) \not= \textsc{Find-Set}$(v)$
7     {\bf then} $A \leftarrow A \cup \{(u, v)\}$
8     \textsc{Union} $(u, v)$
9 {\bf return} $A$

На рисунке 24.4 показа работа алгоритма. Сначала (строки 1–3) множество \(A\) пусто, и есть \(|V|\) деревьев, каждое из которых содержит по одной вершине. В строке 4 рёбра из \(E\) упорядочиваются по неубыванию веса. В цикле (строки 5–8) мы проверяем, лежат ли