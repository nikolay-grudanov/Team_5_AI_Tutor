---
source_image: page_311.png
page_number: 311
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 64.83
tokens: 11644
characters: 2517
timestamp: 2025-12-24T06:34:55.692343
finish_reason: stop
---

Когда применимо динамическое программирование

возвращает \( m[i, j] \), но вычисления проводятся только при первом таком вызове.

Рис. 16.2 иллюстрирует экономию, достигаемую заменой Recursive-Matrix-Chain на Memoized-Matrix-Chain. Заштрихованные вершины дерева рекурсии соответствуют тем случаям, когда значение \( m[i, j] \) не вычисляется, а берётся прямо из таблицы.

Алгоритм Memoized-Matrix-Chain требует времени \( O(n^3) \), как и алгоритм Matrix-Chain-Order. В самом деле, каждая из \( \Theta(n^2) \) позиций таблицы один раз инициализируется (строка 4 процедуры Memoized-Matrix-Chain) и один-единственный раз заполняется — при первом вызове Lookup-Chain\((p, i, j)\) для данных \(i\) и \(j\). Все вызовы Lookup-Chain\((p, i, j)\) делятся на первые и повторные. Каждый из \( \Theta(n^2) \) первых вызовов требует времени \( O(n) \) (не включая времени работы рекурсивных вызовов Lookup-Chain для меньших участков); общее время работы есть \( O(n^3) \). Каждый из повторных вызовов требует времени \( O(1) \); их число есть \( O(n^3) \) (вычисления для каждой из \( O(n^2) \) клеток таблицы порождают \( O(n) \) вызовов). Тем самым рекурсивный алгоритм, требующий времени \( \Omega(2^n) \), превратился в полиномиальный, требующий времени \( O(n^3) \).

Подведём итоги: задача об оптимальном порядке умножения \( n \) матриц может быть решена за время \( O(n^3) \) либо "сверху вниз" (рекурсивный алгоритм с запоминанием ответов), либо "снизу вверх" (динамическое программирование). Оба алгоритма основаны на перекрытии подзадач; число подзадач есть \( \Theta(n^2) \), и оба алгоритма решают каждую из подзадач лишь единожды.

Вообще говоря, если каждая из подзадач должна быть решена хоть раз, метод динамического программирования ("снизу вверх") обычно эффективнее, чем рекурсия с запоминанием ответов, поскольку реализация рекурсии (а также проверка, есть ответ в таблице или ещё нет) требует дополнительного времени. Но если для нахождения оптимума не обязательно решать все подзадачи, подход "сверху вниз" имеет то преимущество, что решаются лишь те подзадачи, которые действительно нужны.

Упражнения

16.2-1 Сравните неравенство (16.4) с формулой (8.4), использованной при оценке времени работы алгоритма быстрой сортировки. В чём причина того, что оценки, получающиеся из этих двух рекуррентных соотношений, столь различны?

16.2-2 Как лучше искать оптимальный порядок перемножения матриц: перебирая все расстановки скобок и вычисляя количество умножений для каждой из них, или же с помощью алгоритма