---
source_image: page_866.png
page_number: 866
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 48.49
tokens: 11519
characters: 1905
timestamp: 2025-12-24T07:00:48.583971
finish_reason: stop
---

Задача коммивояжёра

найденного с помощью нашего алгоритма. Удаляя любое ребро из цикла \( H^* \), мы получаем покрывающее дерево. Его стоимость не превосходит \( c(H^*) \). Тем более это верно для оптимального покрывающего дерева \( T \):

\[
c(T) \leq c(H^*)
\] (37.4)

Пусть мы обходим вершины дерева \( T \), посещая каждую вершину дважды — до посещения её потомков и после. Для дерева на рис. 37.2 этот полный обход \( W \) включает в себя вершины

\[
a, b, c, b, h, b, a, d, e, f, e, g, e, d, a
\]

При этом каждое ребро дерева проходит дважды, поэтому суммарная стоимость всех рёбер \( c(W) \) будет вдвое больше \( c(T) \)

\[
c(W) = 2c(T).
\] (37.5)

Из неравенств (37.4) и (37.5) следует, что

\[
c(W) = 2c(H^*).
\] (37.5)

тем самым стоимость обхода вершин в порядке \( W \) не более чем вдвое превосходит оптимальную.

Однако это ещё не всё: \( W \) не является циклом, так как мы бываем дважды в одной и той же вершине. Ничего страшного — мы можем удалить лишние вершины, при этом стоимость может только уменьшиться. Если в пути \( ... \to u \to w \to ... \) мы удаляем вершину \( v \), остаётся ребро \( (u, w) \), длина которого по неравенству треугольника не больше суммы длин удалённых рёбер \( (u, v) \) и \( (v, w) \). Когда мы удалили из пути \( W \) повторно проходимые вершины (оставив только первое вхождение каждой), получится цикл

\[
a, b, c, h, d, e, f, g.
\]

который как раз и соответствует обходу дерева в порядке "вершина-потомки". Этот цикл \( H \) и будет результатом работы алгоритма Approx-TSP-Tour. При этом

\[
c(H) \leq c(W),
\] (37.7)

так как \( H \) получен из \( W \) удалением вершин. Это неравенство вместе с (37.6) завершает доказательство теоремы.

Хотя алгоритм Approx-TSP-Tour и гарантирует ошибку не более чем в 2 раза, для практических целей он, как правило, недостаточно хорош, и применяются другие алгоритмы. (Соответствующие ссылки даны в конце главы.)