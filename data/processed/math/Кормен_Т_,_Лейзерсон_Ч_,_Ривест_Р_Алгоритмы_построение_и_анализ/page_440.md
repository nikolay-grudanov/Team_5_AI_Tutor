---
source_image: page_440.png
page_number: 440
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 48.83
tokens: 11412
characters: 1795
timestamp: 2025-12-24T06:40:55.751695
finish_reason: stop
---

Рис. 22.5

Рисунок 22.4 Сжатие путей в процессе операции FIND-SET. а) Дерево перед выполнением операции FIND-SET(a). Треугольниками обозначены поддеревья с корнями в изображенных вершинах. б) После исполнения FIND-SET(a).

22.2.1 Программы

Приводимые ниже программы операций Make-Set, Find-Set и Union включают в себя индуктивное определение ранга, но для удобства мы перескажем его словесно. При создании множества с помощью Make-Set единственной вершине дерева присваивается ранг 0. Операция Find-Set (со сжатием путей) не меняет рангов. При выполнении операции Union с деревьями, ранги корней которых различны, проводится новая стрелка от корня меньшего ранга к корню большего ранга, а ранги опять-таки не меняются. Если, наконец, операция Union проводится с деревьями, ранги корней которых равны, то от одного из корней (все равно, какого) проводится стрелка к другому, и при этом ранг корня объединённого дерева увеличивается на единицу (остальные ранги не меняются). Легко видеть, что определённый таким образом ранг вершины является верхней оценкой для высоты поддерева с корнем в этой вершине.

Ниже p[x] обозначает родителя вершины x, а rank[x] — ее ранг; параметрами процедуры Link, вызываемой из процедуры Union, являются корни двух деревьев.

Make-Set(x)
1 p[x] \gets x
2 rank[x] \gets 0

Union(x,y)
1 Link(Find-Set(x),Find-Set(y))

Link(x,y)
1 if rank[x] > rank[y]
2 then p[y] \gets x
3 else p[x] \gets y
4 if rank[x]=rank[y]
5 then rank[y] \gets rank[y]+1

Find-Set(x)
1 if x \neq p[x]
2 then p[x] \gets Find-Set(p[x])
3 return p[x]

Рекурсивная процедура Find-Set работает в два прохода: сначала она идет к корню дерева, а затем проходит этот путь в обратном порядке, "переводя стрелки" у встречающихся вершин на корень дерева. Если x — не корень, то Find-Set вызывает саму себя,