---
source_image: page_333.png
page_number: 333
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 68.64
tokens: 11767
characters: 2557
timestamp: 2025-12-24T06:36:11.451588
finish_reason: stop
---

<table>
  <tr>
    <th></th>
    <th>a</th>
    <th>b</th>
    <th>c</th>
    <th>d</th>
    <th>e</th>
    <th>f</th>
  </tr>
  <tr>
    <td>Количество (в тысячах)</td>
    <td>45</td>
    <td>13</td>
    <td>12</td>
    <td>16</td>
    <td>9</td>
    <td>5</td>
  </tr>
  <tr>
    <td>Равномерный код</td>
    <td>000</td>
    <td>001</td>
    <td>010</td>
    <td>011</td>
    <td>100</td>
    <td>101</td>
  </tr>
  <tr>
    <td>Неравномерный код</td>
    <td>0</td>
    <td>101</td>
    <td>100</td>
    <td>111</td>
    <td>1101</td>
    <td>1100</td>
  </tr>
</table>

Рисунок 17.3 Задача о выборе кода. В файле длиной 100 000 символов встречаются только латинские буквы от a до f (в таблице указано, по скольку раз каждая). Если каждую букву закодировать тремя битами, то всего будет 300 000 битов. Если использовать неравномерный код (нижняя строка), то достаточно 224 000 битов.

(45 · 1 + 13 · 3 + 12 · 3 + 16 · 3 + 9 · 4 + 5 · 4) · 1000 = 224 000

битов, что даёт около 25% экономии. (Далее мы увидим, что этот код будет оптимальным.)

Префиксные коды

Мы будем рассматривать только коды, в которых из двух последовательностей битов, представляющих различные символы, ни одна не является префиксом другой. Такие коды называются префиксными кодами (prefix codes; таков общепринятый термин, хотя логичнее было бы называть их "беспрефиксными" кодами). Можно показать (мы этого делать не будем), что для любого кода, обеспечивающего однозначное восстановление информации, существует не худший его префиксный код, так что мы ничего не теряем.

При кодировании каждый символ заменяется на свой код. Например, для неравномерного кода рис. 17.3 строка abc запишется как 0101100. Для префиксного кода декодирование однозначно и выполняется слева направо. Первый символ текста, закодированного префиксным кодом, определяется однозначно, так как кодирующая его последовательность не может быть началом кода какого-то иного символа. Найдя этот первый символ и отбросив кодировавшую его последовательность битов, мы повторяем процесс для оставшихся битов, и так далее. Например, строка 001011101 (при использовании неравномерного кода рис. 17.3) разбивается на части 0 0 101 1101 и декодируется как aabe.

Для эффективной реализации декодирования надо хранить информацию о коде в удобной форме. Одна из возможностей — представить код в виде двоичного дерева, листья которого соответствуют кодируемым символам. При этом путь от вершины дерева до кодируемого символа определяет кодирующую последовательность битов: поворот налево даёт 0, а поворот направо — 1.