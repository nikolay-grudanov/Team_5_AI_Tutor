---
source_image: page_016.png
page_number: 16
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 95.06
tokens: 11624
characters: 2479
timestamp: 2025-12-24T06:20:55.923889
finish_reason: stop
---

1.3.1 Принцип "разделяй и властвуй"

Многие алгоритмы по природе рекурсивны (recursive algorithms): решая некоторую задачу, они вызывают самих себя для решения её подзадач. Идея метода "разделяй и властвуй" состоит как раз в этом. Сначала задача разбивается на несколько подзадач меньшего размера. Затем эти задачи решаются (с помощью рекурсивного вызова — или непосредственно, если размер достаточно мал). Наконец, их решения комбинируются и получается решение исходной задачи.

Для задачи сортировки эти три этапа выглядят так. Сначала мы разбиваем массив на две половины меньшего размера. Затем мы сортируем каждую из половин отдельно. После этого нам остаётся соединить два упорядоченных массива половинного размера в один. Рекурсивное разбиение задачи на меньше происходит до тех пор, пока размер массива не дойдёт до единицы (любой массив длины 1 можно считать упорядоченным).

Нетривиальной частью является соединение двух упорядоченных массивов в один. Оно выполняется с помощью вспомогательной процедуры Merge(A, p, q, r). Параметрами этой процедуры являются массив A и числа p, q, r, указывающие границы сливаемых участков. Процедура предполагает, что p ≤ q < r и что участки A[p..q] и A[q + 1..r] уже отсортированы, и сливает (merges) их в один участок A[p..r].

Мы оставляем подробную разработку этой процедуры читателю (упр. 1.3-2), но довольно ясно, что время работы процедуры Merge есть Θ(n), где n — общая длина сливаемых участков (n = r - p + 1). Это легко объяснить на картах. Пусть мы имеем две стопки карт, и в каждой карты идут сверху вниз в возрастающем порядке. Как сделать из них одну? На каждом шаге мы берём меньшую из двух верхних карт и кладём её (рубашкой вверх) в результирующую стопку. Когда одна из исходных стопок становится пустой, мы добавляем все оставшиеся карты второй стопки к результирующей стопке. Ясно, что каждый шаг требует ограниченного числа действий, и общее число действий есть Θ(n).

Теперь напишем процедуру сортировки слиянием Merge-Sort(A, p, r), которая сортирует участок A[p..r] массива A, не меняя остальную часть массива. При p ≥ r участок содержит максимум один элемент, и тем самым уже отсортирован. В противном случае мы отыскиваем число q, которое делит участок на две примерно равные части A[p..q] (содержит ⌊n/2⌋ элементов) и A[q + 1..r] (содержит ⌊n/2⌋ элементов). Здесь через ⌊x⌋ мы обозначаем целую часть x (наибольшее целое число, меньшее или равное x), а через ⌊x⌋ — наименьшее целое число, большее или равное x.