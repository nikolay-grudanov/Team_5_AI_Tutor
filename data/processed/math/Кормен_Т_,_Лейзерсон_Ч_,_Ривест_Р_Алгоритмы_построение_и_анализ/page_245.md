---
source_image: page_245.png
page_number: 245
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 57.49
tokens: 11357
characters: 1609
timestamp: 2025-12-24T06:31:41.664128
finish_reason: stop
---

Рисунок 13.2 Поиск в двоичном дереве. Ищем ключ 13, мы идём от корня по пути 15 → 6 → 7 → 13. Чтобы найти минимальный ключ 2, мы всё время идём налево; чтобы найти максимальный ключ 20 — направо. Для вершины с ключом 15 следующей будет вершина с ключом 17 (это минимальный ключ в правом поддереве вершины с ключом 15). У вершины с ключом 13 нет правого поддерева; поэтому, чтобы найти следующую за ней вершину, мы поднимаемся вверх, пока не пройдём по ребру, ведущему вправо-вверх; в данном случае следующая вершина имеет ключ 15.

13.2 Поиск в двоичном дереве

В этом разделе мы покажем, что двоичные деревья поиска позволяют выполнять операции Search, Minimum, Maximum, Successor и Predecessor за время \( O(h) \), где \( h \) — высота дерева.

Поиск

Процедура поиска получает на вход искомый ключ \( k \) и указатель \( x \) на корень поддерева, в котором производится поиск. Она возвращает указатель на вершину с ключом \( k \) (если такая есть) или специальное значение NIL (если такой вершины нет).

Tree-Search\((x, k)\)
1 if \( x = \text{NIL} \) или \( k = key[x] \)
2 then return \( x \)
3 if \( k < key[x] \)
4 then return Tree-Search\((left[x], k)\)
5 else return Tree-Search\((right[x], k)\)

В процессе поиска мы двигаемся от корня, сравнивая ключ \( k \) с ключом, хранящимся в текущей вершине \( x \). Если они равны, поиск завершается. Если \( k < key[x] \), то поиск продолжается в левом поддереве \( x \) (ключ \( k \) может быть только там, согласно свойству упорядоченности). Если \( k > key[x] \), то поиск продолжается в правом поддереве. Длина пути поиска не превосходит высоты дерева,