---
source_image: page_362.png
page_number: 362
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 66.54
tokens: 11531
characters: 2204
timestamp: 2025-12-24T06:37:41.195748
finish_reason: stop
---

Динамические таблицы

ния равен 1)¹. Будем считать, что наша операционная система, как и большинство современных, снабжена подсистемой управления памятью, позволяющей при необходимости выделять новые блоки памяти и освобождать занятые. Имея это в виду, при попытке добавить запись к заполненной таблице мы будем предварительно расширять (expand) таблицу следующим образом: выделим память под таблицу увеличенного размера, скопируем имеющиеся записи из старой таблицы в новую, после чего добавим запись уже к новой таблице.

Как показывает опыт, разумно увеличивать таблицу вдвое в момент переполнения. Если мы только добавляем записи к таблице, то при такой стратегии коэффициент заполнения не может стать меньше 1/2 (если он не был таким в самом начале), т.е. пустые ячейки не будут занимать более половины таблицы.

Вот как выглядит алгоритм Table-Insert, основанный на этих принципах (table[T] — указатель на блок памяти, в котором размещена таблица T, num[T] — количество записей в таблице, size[T] — размер таблицы, т.е. количество ячеек; первоначально size[T] = num[T] = 0):

Table-Insert(T, x)
1 if size[T] = 0
2 then выделить блок table[T] с одной ячейкой
3 size[T] ← 1
4 if num[T] = size[T]
5 then выделить блок памяти new-table с 2 · size[T] ячейками
6 скопировать все записи из table[T] в new-table
7 освободить память, занятую table[T]
8 table[T] ← new-table
9 size[T] ← 2 · size[T]
10 записать x в table[T]
11 num[T] ← num[T] + 1

Проанализируем время работы этого алгоритма. Собственно запись в таблицу происходит в нём только в строках 6 и 10. Стоимость операции "записать элемент в таблицу" примем за единицу. Будем считать, что время работы всей процедуры Table-Insert пропорционально количеству операций "записать в таблицу"; тем самым мы подразумеваем, что затраты на выделение памяти под таблицу с одной ячейкой (строка 2) — величина ограниченная, и что затраты на выделение и освобождение памяти в строках 5 и 7 — величина не большего порядка, чем затраты на

¹ В некоторых приложениях (например, в хеш-таблицах с открытой адресацией) разумно считать таблицу заполненной уже в тот момент, когда коэффициент заполнения превышает некоторую константу, меньшую единицы (см. упр. 18-4.2).