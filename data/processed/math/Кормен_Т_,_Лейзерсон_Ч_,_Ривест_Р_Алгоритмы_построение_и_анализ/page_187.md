---
source_image: page_187.png
page_number: 187
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 69.05
tokens: 11563
characters: 2262
timestamp: 2025-12-24T06:29:08.943908
finish_reason: stop
---

Выбор за линейное в худшем случае время

Отметим, что алгоритмы Select и Randomized-Select, в отличие от описанных в главе 9 алгоритмов сортировки за линейное время, используют только попарные сравнения элементов массива и применимы для произвольного упорядоченного множества. Эти алгоритмы асимптотически эффективнее очевидного подхода "упорядочи множество и выбери нужный элемент", поскольку всякий алгоритм сортировки, использующий только попарные сравнения, требует времени \( \Omega(n \lg n) \) не только в худшем случае (раздел 9.1), но и в среднем (задача 9-1).

Упражнения

10.3-1 Будет ли алгоритм Select работать за линейное время, если разбивать массив на группы не из пяти, а из семи элементов? Покажите, что для групп из трёх элементов рассуждение не проходит.

10.3-2 Пусть \( x — "медиана медиан" \) в алгоритме Select (массив содержит \( n \) элементов). Покажите, что при \( n \geq 38 \) количество элементов, больших \( x \) (так же как и количество элементов, меньших \( x \)) не меньше \( \lceil n/4 \rceil \).

10.3-3 Модифицируйте алгоритм быстрой сортировки так, чтобы он работал за время \( O(n \lg n) \) в худшем случае.

10.3-4* Пусть алгоритм выбора \( i \)-го по счёту элемента использует только попарные сравнения. Покажите, что с помощью тех же сравнений можно в качестве побочного результата получить списки элементов, меньших искомого, а также больших искомого.

10.3-5 Пусть у нас есть какой-то алгоритм, находящий медиану за линейное в худшем случае время. Используя его в качестве подпрограммы, разработайте простой алгоритм, решающий задачу нахождения произвольной порядковой статистики за линейное время.

10.3-6 Под \( k \)-квантилями (\( k \)-th quantiles) множества из \( n \) чисел мы понимаем \( k - 1 \) его элементов, обладающих следующим свойством: если расположить элементы множества в порядке возрастания, то квантили будут разбивать множество на \( k \) равных (точнее, отличающихся не более чем на один элемент) частей. Разработайте алгоритм, который за время \( O(n \lg k) \) находит \( k \)-квантили данного множества.

10.3-7 Разработайте алгоритм, который по заданному \( k \) находит в данном множестве \( S \) его \( k \) элементов, менее всего отстоящих от медианы. Число операций должно быть \( O(|S|) \).