---
source_image: page_778.png
page_number: 778
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 56.47
tokens: 11563
characters: 2081
timestamp: 2025-12-24T06:57:00.120906
finish_reason: stop
---

Упражнения

34.3-1
Постройте автомат для поиска подстроки \( P = aabab \) и продемонстрируйте его работу на тексте \( T = aaababaabaababaab \).

34.3-2
Нарисуйте диаграмму переходов автомата для поиска подстроки \( P = ababbabbabababababbabbb \) (над алфавитом \( \Sigma = \{a, b\} \)).

34.3-3
Будем говорить, что \( P \) — строка с уникальными префиксами (\( P \) is nonoverlappable), если соотношение \( P_k \sqsubset P_q \) возможно лишь при \( k = 0 \) или \( k = q \). Как выглядит диаграмма переходов автомата для поиска подстроки с уникальными префиксами?

34.3-4*
Даны два образца \( P \) и \( P' \). Постройте конечный автомат, находящий все вхождения каждого из этих образцов в данный текст. Постарайтесь, чтоб число состояний вашего автомата было поменьше.

34.3-5
Пусть образец \( P \) содержит, наряду с символами из алфавита \( \Sigma \), еще и символы пропусков (упражнение 34.1-5). Постройте конечный автомат, который отыскивает все вхождения такого образца \( P \) в текст \( T \) за время \( O(|T|) \).

34.4 Алгоритм Кнута — Морриса — Пратта

Теперь мы переходим к алгоритму для поиска подстрок, работающему за линейное время. Этот алгоритм, предложенный Кнутом, Моррисом и Праттом, работает за время \( \Theta(m + n) \). Такое ускорение достигается за счет того, что предварительно вычисляется не функция перехода \( \delta[0..m, 1..|\Sigma|] \), а в \( |\Sigma| \) раз меньший массив — "префикс-функция" \( \pi[1..m] \) (ее вычисление производится за время \( O(m) \)). Зная функцию \( \pi \), можно вычислить \( \delta(q, a) \) для любого состояния \( q \in \{0, 1, ..., m\} \) и символа \( a \) с учётной стоимостью \( O(1) \) (в смысле амортизационного анализа). Сейчас мы увидим, как это делается.

34.4.1 Префикс-функция, ассоциированная с образцом

Префикс-функция, ассоциированная с образцом \( P \), несёт информацию о том, где в строке \( P \) повторно встречаются различные префиксы этой строки. Использование этой информации позволяет избежать проверки заведомо недопустимых сдвигов (говоря в терминах простейшего алгоритма поиска) или обойтись без