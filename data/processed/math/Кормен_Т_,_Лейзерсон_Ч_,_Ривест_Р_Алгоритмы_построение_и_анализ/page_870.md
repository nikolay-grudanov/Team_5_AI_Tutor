---
source_image: page_870.png
page_number: 870
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 57.97
tokens: 11646
characters: 2369
timestamp: 2025-12-24T07:01:07.409418
finish_reason: stop
---

Задача коммивояжёра

В примере на рис. 37.3 этот алгоритм выбирает множества в таком порядке: \( S_1, S_4, S_5 \) и \( S_3 \).

У каждый момент работы алгоритма множество \( U \) содержит ещё не покрытые элементы, а семейство \( C \) — уже включённые в покрытие подмножества. На шаге 4 производится жадный выбор: в качестве \( S \) берётся множество, покрывающее наибольшее число ещё не покрытых элементов (если таких несколько, берём любое). После этого \( S \) добавляется к семейству \( C \), а его элементы удаляются из \( U \). В конце концов множество ещё не покрытых элементов (\( U \)) пусто, а \( C \) является покрытием множества \( X \).

Видно, что алгоритм Greedy-Set-Cover полиномиален (время работы оценивается многочленом от \( |X| \) и \( |\mathcal{F}| \)): количество повторений цикла не превосходит \( \min(|X|, |\mathcal{F}|) \), а каждое повторение легко реализовать за \( O(|X| \cdot |\mathcal{F}|) \) операций, так что всего будет \( O(|X| \cdot |\mathcal{F}| \cdot \min(|X|, |\mathcal{F}|)) \) операций. В упражнении 37.3-3 мы предложим вам реализовать этот алгоритм за линейное время.

Анализ алгоритма

Теперь мы должны сравнить размер покрытия, даваемого этим алгоритмом, с минимально возможным. Нам понадобится обозначение \( H(d) \) для суммы первых \( d \) членов гармонического ряда (см. раздел 3.1): \( H(d) = \sum_{i=1}^d 1/i \).

Теорема 37.4.
Размер покрытия, даваемого алгоритмом Greedy-Set-Cover, превосходит минимально возможный не более чем в
\[
H(\max\{|S| : S \in \mathcal{F}\})
\]
раз.

Доказательство.
Жадный алгоритм отбирает множества одно за другим, на каждом шаге выбирая то из них, которое покрывает больше всего непокрытых элементов. Будем представлять себе, что на каждом шаге имеется доллар, который поровну распределяется между всеми вновь покрытыми элементами. Таким образом, каждый элемент получает деньги только однажды — на том шаге, когда он впервые попадает в покрытие, и получает тем больше денег, чем меньше элементов оказались в том же положении. Формально говоря, если элемент \( x \) входит в множество \( S_i \), выбранное на \( i \)-ом шаге работы алгоритма, и не входит в \( S_k \) при меньших \( k \), то он получит
\[
c_x = \frac{1}{|S_i - (S_1 \cup S_2 \cup \ldots S_{i-1})|}
\]
долларов. [Заметим в скобках, что выгоднее получать деньги как можно позже, так как по мере продвижения алгоритма количе-