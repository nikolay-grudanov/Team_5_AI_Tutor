---
source_image: page_769.png
page_number: 769
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 59.76
tokens: 11720
characters: 2436
timestamp: 2025-12-24T06:56:37.743558
finish_reason: stop
---

столмость вычислений по формуле (34.1) ограничена сверху константой; стало быть, числа \( p \) и \( t_0, t_1, \ldots, t_{n-m} \) могут быть найдены за время \( O(n + m) \), и также за время \( O(n + m) \) могут быть найдены все вхождения образца \( P[1..m] \) в текст \( T[1..n] \).

До сих пор мы не учитывали того, что числа \( p \) и \( t_s \) велики — настолько, что предположение о выполнении арифметических операций за время \( O(1) \) едва ли допустимо. К счастью, эту трудность можно обойти следующим образом: надо проводить вычисления чисел \( p \) и \( t_0 \), а также вычисления по формуле (34.1), по модулю фиксированного числа \( q \) (рис. 34.4; по поводу арифметики по модулю \( q \) см. разд. 33.1). Тогда все числа не превосходят \( q \) и можно считать, что число \( p \) и все \( t_j \) будут действительно вычислены за время \( O(n + m) \). Обычно в качестве \( q \) выбирают простое число, для которого \( 10q \) помещается в машинное слово — это упрощает программирование вычислений. В общем случае (для алфавита \( \{0, 1, 2, \ldots, d\} \)) выбирают такое простое число \( q \), что \( dq \) помещается в машинное слово (благодаря этому все арифметические операции происходят в пределах одного слова); рекуррентное соотношение (34.1) приобретает вид

\[
t_{s+1} = (d(t_s - T[s+1]h) + T[s+m+1]) \bmod q,
\]

где \( h \equiv d^{m-1} \pmod{q} \).

Вычисления по модулю \( q \) хороши всем, кроме одного: из равенства \( t_s \equiv p \pmod{q} \) ещё не следует, что \( t_s = p \). Поэтому, если \( t_s \not\equiv p \pmod{q} \), то сдвиг \( s \) заведомо недопустим и о нем можно забыть, а если \( t_s \equiv p \pmod{q} \), то надо еще проверить, совпадают ли строки \( P[1..m] \) и \( T[s+1..s+m] \) на самом деле. Если совпадают, то мы нашли вхождение образца в строку, а если не совпадают, то произошло холостое срабатывание (spurious hit). Если простое число \( q \) достаточно велико, то можно надеяться, что дополнительные затраты на анализ холостых срабатываний будут невелики.

Запишем текст соответствующей процедуры Rabin-Karp-Matcher. Она получает на вход текст \( T \), образец \( P \), "основание системы счисления" \( d \) (обычно берут \( d = |\Sigma| \)) и простое число \( q \).

Rabin-Karp-Matcher(T,P,d,q)
1 n \gets length[T]
2 m \gets length[P]
3 h \gets d^{m-1} \bmod q
4 p \gets 0
5 t \gets 0
6 for i \gets 1 to m
7 do p \gets (dp+P[i]) \bmod q
8 t \gets (dt+T[i]) \bmod q
9 for s \gets 0 to n-m