---
source_image: page_248.png
page_number: 248
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 57.80
tokens: 11365
characters: 1672
timestamp: 2025-12-24T06:31:42.181617
finish_reason: stop
---

В (элементы на пути) и C (справа от пути). Профессор утверждает, что для любых трёх ключей \( a \in A, b \in B \) и \( c \in C \) верно \( a \leq b \leq c \). Покажите, что он неправ, и приведите контрпример минимально возможного размера.

13.2-3 Докажите формально правильность процедуры Tree-Successor.

13.2-4 В разделе 13.1 был построен алгоритм, печатающий все ключи в неубывающем порядке. Теперь это можно сделать иначе: найти минимальный элемент, а потом \( n - 1 \) раз искать следующий элемент. Докажите, что время работы такого алгоритма есть \( O(n) \).

13.2-5 Докажите, что \( k \) последовательных вызовов Tree-Successor выполняются за \( O(k + h) \) шагов (\( h \) — высота дерева) независимо от того, с какой вершины мы начинаем.

13.2-6 Пусть \( T \) — двоичное дерево поиска, все ключи в котором различны, \( x \) — его лист, а \( y \) — родитель \( x \). Покажите, что \( key[y] \) является соседним с \( key[x] \) ключом (следующим или предыдущим в смысле порядка на ключах).

13.3 Добавление и удаление элемента

Эти операции меняют дерево, сохраняя свойство упорядоченности. Как мы увидим, добавление сравнительно просто; удаление чуть сложнее.

Добавление

Процедура Tree-Insert добавляет заданный элемент в подходящее место дерева \( T \) (сохраняя свойство упорядоченности). Параметром процедуры является указатель \( z \) на новую вершину, в которую помещены значения \( key[z] \) (добавляемое значение ключа), \( left[z] = NIL \) и \( right[z] = NIL \). В ходе работы процедура меняет дерево \( T \) и (возможно) некоторые поля вершины \( z \), после чего новая вершина с данным значением ключа оказывается вставленной в подходящее место дерева.