---
source_image: page_802.png
page_number: 802
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 40.23
tokens: 11504
characters: 2144
timestamp: 2025-12-24T06:57:40.420207
finish_reason: stop
---

35.5 Исполнение алгоритма Any-Segment-Intersect. Положения движущейся прямой в критических точках показаны пунктиром; рядом выписаны пересекаемые отрезки (в порядке сверху — вниз) в момент сразу после прохода критической точки, Пересечение отрезков d и b обнаруживается после удаления отрезка c.

(event point), так что изменение состояния дел у прямой возможно только в критической точке.
Для некоторых алгоритмов (см., например, упражнение 35.2-7) критические точки определяется постепенно по ходу работы алгоритма. Однако мы будем рассматривать алгоритм, в котором расписание легко найти заранее. В частности, абсцисса конца любого отрезка является критической точкой. Упорядочим концы отрезков в порядке возрастания их абсцисс. Отрезок начинает влиять на состояние дел у прямой с момента, когда прямая проходит через его левый конец, и перестаёт с момента, когда прямая проходит через его правый конец.
Состояние дел у прямой можно хранить как упорядоченное множество отрезков, с которым выполняются следующие операции:
INSERT(T, s) : добавить отрезок s в T;
DELETE(T, s) : удалить отрезок s из T;
ABOVE(T, s) : указать отрезок, располагающийся непосредственно выше s в множестве T;
BELOW(T, s) : возвращает отрезок, располагающийся непосредственно ниже s в множестве T.
(Говоря об отношении порядка в T, мы описываем слова "выше" и "ниже" в соответствии с геометрическим смыслом этого отношения.)
Мы можем хранить (линейно) упорядоченное множество из n отрезков и выполнять любую из указанных операций за время O(lg n), используя красно-чёрное дерево. Заметим, что операции сравнения (какой из отрезков выше в данный момент) можно выполнить за время O(1), используя векторные произведения (см. упр. 35.2-2).
Проверка пересечений
Построим алгоритм, который по заданному множеству S, состоящему из n отрезков, проверяет, есть ли среди них хотя бы два пересекающихся. Этот алгоритм использует красно-чёрное дерево для хранения текущего состояния дел у движущейся прямой.

Any-Segment-Intersect(S)
1 Т \gets \emptyset
2 сортируем концы отрезков в порядке возрастания абсцисс (точки
    с равными абсциссами идут в порядке возрастания ординат);