---
source_image: page_874.png
page_number: 874
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 57.04
tokens: 11675
characters: 2376
timestamp: 2025-12-24T07:01:19.713637
finish_reason: stop
---

Задача о сумме подмножества

полностью полиномиальную схему приближения. (Напомним: это означает, что время работы оценивается многочленом от размера задачи и от \(1/\varepsilon\), где \(\varepsilon\) — относительная ошибка.)

Экспоненциальный алгоритм
Если \(L\) — набор чисел, а \(x\) — некоторое число, то через \(L + x\) мы обозначаем набор чисел, который получится, если добавить \(x\) к каждому из элементов \(L\). Например, для \(L = \langle 1, 2, 3, 5, 9 \rangle\) и \(x = 2\) мы имеем \(L + x = \langle 3, 4, 5, 7, 11 \rangle\). Аналогичная запись используется и для множеств:
\[
S + x = \{ s + x : s \in S \}
\]

Нам понадобится процедура Merge-Lists\((L, L')\), результатом которой является соединение двух упорядоченных наборов \(L\) и \(L'\) с сохранением порядка. Вспоминая сортировку слиянием (раздел 1.3.1), мы видим, что это можно сделать за время \(O(|L| + |L'|)\). (Мы не приводим текста этой процедуры.)

Теперь мы можем написать алгоритм Exact-Subset-Sum, решающий сформулированную выше задачу о сумме подмножества. Исходными данными для него является набор положительных целых чисел \(S = \langle x_1, x_2, \ldots, x_n \rangle\) и положительное целое число \(t\). Результатом работы является максимально возможная сумма некоторых элементов из \(S\), не превосходящая \(t\).

Exact-Subset-Sum (S,t)
1 n <- |S|
2 L_0 <- <0>
3 for i<-1 1 to n
4   do L_i <- Merge-Lists(L_{i-1}, L_{i-1}+x_i)
5   удалить из $L_i$ элементы, большие $t$
6 return наибольший элемент в $L_n$

Идея алгоритма проста: если через \(P_i\) обозначить множество всех чисел, которые можно получить, складывая некоторые из \(x_1, x_2, \ldots, x_i\), то
\[
P_i = P_{i-1} \cup (P_{i-1} + x_i)
\]
(элемент \(x_i\) может не входить в сумму, а может и входить) мы видим (индукция по \(i\), упражнение 37.4-1), что \(L_i\) представляет собой список элементов множества \(P_i\) в порядке возрастания (из которого выброшены элементы, большие \(t\)).

Сколько времени требует этот алгоритм? Список \(L_i\) может содержать до \(2^i\) элементов, так что алгоритм экспоненциален. Впрочем, если \(t\) (или все элементы \(S\)) ограничено сверху многочленом от \(|S|\), то время работы алгоритма также ограничено многочленом от \(|S|\).

Полностью полиномиальная схема приближения
Такая схема получается из описанного алгоритма, если хранить списки \(L_i\) в сокращенной форме. Степень сокращения опре-