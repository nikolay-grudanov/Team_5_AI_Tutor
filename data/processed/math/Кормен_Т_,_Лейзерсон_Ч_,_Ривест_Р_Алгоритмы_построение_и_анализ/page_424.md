---
source_image: page_424.png
page_number: 424
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 58.72
tokens: 11398
characters: 1672
timestamp: 2025-12-24T06:40:22.596442
finish_reason: stop
---

21.2-5 Будем считать, что ключи можно только сравнивать (их внутренняя структура нам недоступна). Можно ли тогда реализовать операции над сливаемыми кучами так, чтобы каждая из них имела учётную стоимость \( O(1) \)? (Указание: используйте оценки для времени сортировки.)

21.3 Уменьшение ключа и удаление вершины

В этом разделе мы покажем, как реализовать операцию уменьшения ключа заданной вершины с учётной стоимостью \( O(1) \), а также операцию удаления вершины из фибоначчиевой кучи с учётной стоимостью \( O(D(n)) \) (где \( n \) — число вершин в куче), а \( D(n) \) — оценка для максимальной степени вершины.

После этих операций входящие в кучу деревья перестают быть биномиальными, но не слишком далеко отклоняются от них, так что максимальная степень вершины остаётся равной \( O(\lg n) \). Таким образом, операции FIB-HEAP-EXTRACT-MIN и FIB-HEAP-DELETE имеют учётную стоимость \( O(\lg n) \).

Уменьшение ключа

В следующей процедуре уменьшения ключа (FIB-HEAP-DECREASE-KEY) мы предполагаем, что после изъятия вершины из списка ссылка на вершину-ребёнка не меняется (так что процедура CUT вырезает целое поддерево, см. ниже)

FIB-HEAP-DECREASE-KEY\((H, x, k)\)
1 if \( k > key[x] \)
2 then error "новое значение ключа больше старого"
3 \( key[x] \leftarrow k \)
4 \( y \leftarrow p[x] \)
5 if \( y \neq NIL \) and \( key[x] < key[y] \)
6 then CUT\((H, x, y)\)
7 CASCAING-CUT\((H, y)\)
8 if \( key[x] < key[min[H]] \)
9 then \( min[H] \leftarrow x \)

CUT\((H, x, y)\)
1 удалить \( x \) из списка детей вершины \( y \), уменьшив \( degree[y] \) на 1
2 добавить \( x \) в корневой список кучи \( H \)
3 \( p[x] \leftarrow NIL \)
4 \( mark[x] \leftarrow FALSE \)