---
source_image: page_464.png
page_number: 464
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 61.56
tokens: 11551
characters: 2105
timestamp: 2025-12-24T06:42:20.224640
finish_reason: stop
---

Приведите пример ориентированного графа \( G = (V, E) \), начальной вершины \( s \in V \) и некоторого множества ребер \( E_{\pi} \subseteq E \), для которых для каждой достижимой из \( s \) вершины \( v \in V \) существует единственный путь из \( s \) в \( v \), проходящий по рёбрам из \( E_{\pi} \), и этот путь является кратчайшим в \( G \), но множество ребер \( E_{\pi} \) не совпадает с деревом поиска в ширину, даваемым с помощью процедуры BFS, как ни переставляй элементы в каждом из списков смежных вершин.

23.2-6
Придумайте эффективный алгоритм, выясняющий, является ли данный неориентированный граф двудольным.

23.2-7*
Диаметр (diameter) дерева \( T = (V, E) \) определяется как

\[
\max_{u, v \in V} \delta(u, v)
\]

(то есть как максимальная длина кратчайшего пути между двумя вершинами). Придумайте эффективный алгоритм вычисления диаметра дерева, и оцените время его работы.

23.2-8
Пусть \( G = (V, E) \) — неориентированный граф. Придумайте алгоритм, отыскивающий за время \( O(V + E) \) путь в графе, который проходит каждое ребро ровно по одному разу в каждую сторону. Как найти выход из лабиринта, имея с собой большой запас одинаковых монет?

23.1.3 Поиск в глубину

Стратегия поиска в глубину такова: идти "вглубь", пока это возможно (есть непройденные рёбра), и возвращаться и искать другой путь, когда таких рёбер нет. Так делается, пока не обнаружены все вершины, достижимые из исходной. Если после этого остаются необнаруженные вершины, можно выбрать одну из них и повторять процесс, и делать так до тех пор, пока мы не обнаружим все вершины графа.

Как и при поиске в ширину, обнаружив (впервые) вершину \( v \), смежную с \( u \), мы отмечаем это событие, помещая в поле \( \pi[v] \) значение \( u \). Получается дерево — или несколько деревьев, если поиск повторяется из нескольких вершин. Говоря дальше о поиске в глубину, мы всегда предполагаем, что так и делается (поиск повторяется). Мы получаем подграф предшествования (predecessor subgraph), определённый так: \( G_{\pi} = (V, E_{\pi}) \), где

\[
E_{\pi} = \{ (\pi[v], v) : v \in V \text{ and } \pi[v] \neq NIL \}
\]