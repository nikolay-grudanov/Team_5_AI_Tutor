---
source_image: page_639.png
page_number: 639
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 57.30
tokens: 11695
characters: 2476
timestamp: 2025-12-24T06:50:44.567886
finish_reason: stop
---

Рисунок 30.3 30.3. Работа алгоритма List-PREFIX. (a). Вначале для k-го объекта значение y равно [k, k], а указатель next[k] указывает на (k + 1)-й объект (указатель последнего — на NIL). (b)-(d). Значения y и next после каждого выполнения цикла while (строки 3–6). В конце алгоритма (d) для k-ого объекта значение y равно [1, k].

не префиксы, а суффиксы, то этой разницы бы не было.) Как и алгоритм List-Rank, алгоритм List-Prefix поддерживает следующий инвариант: для любых двух различных объектов i и j либо next[i] ≠ next[j], либо next[i] = next[j] = NIL. Поэтому не происходит одновременного обращения к памяти, так что алгоритм можно реализовать на EREW-машине.

На рис. 30.3 показано состояние списка перед каждым выполнением цикла while. Цикл имеет следующий инвариант: после t-го повторения цикла указатели охватывают 2^t звеньев списка (или равны NIL), а k-й по списку элемент хранит значение [max(1, k - 2^t + 1), k] для k = 1, 2, ..., n. Перед первым выполнением цикла (t = 0) каждый объект (кроме последнего) указывает на следующий. В строке 6 алгоритма k-й элемент (точнее, отвечающий за него процессор) вычисляет значение [k, k+1] = [k, k] ⊗ [k+1, k+1], которое передаётся (k + 1)-му элементу. Указатели меняются так же, как и в алгоритме List-Rank. Состояние списка после первого выполнения цикла показано на рис. 30.3 (b). При втором выполнении цикла k-й элемент (при k = 2, 3, ..., n - 2) вычисляет значение [k - 1, k + 2] = [k - 1, k] ⊗ [k + 1, k + 2], которое передаётся k + 2-му элементу; результат показан на рис. 30.3 (c). Наконец, в ходе третьего (последнего) выполнения цикла оставшиеся два элемента вычисляют нужные значения (рис. 30-3 (d)).

Как и предыдущий алгоритм, алгоритм List-Prefix работает за время O(lg n), а общие затраты составляют O(n lg n).

30.1.5 Метод эйлерова цикла

В этом разделе рассмотрен метод эйлерова цикла и его использование в задаче вычисления глубины вершин двоичного дерева. Если дерево имеет n вершин, то вычисление их глубин займёт время O(lg n); при этом будет использована техника параллельной обработки префиксов.

Дерево хранится в памяти так, как описано в разделе 11.4: каждая вершина i имеет поля parent[i] (родитель), left[i] (левый ребёнок) и right[i] (правый ребёнок).

Имея один процессор, можно вычислить глубину всех вершин дерева с n вершинами за время O(n). Как сократить это время, используя несколько процессоров? Простейший параллельный алгоритм состоит в движении от корня дерева к листьям с увели-