---
source_image: page_247.png
page_number: 247
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 75.69
tokens: 11545
characters: 1772
timestamp: 2025-12-24T06:32:00.088766
finish_reason: stop
---

Поиск в двоичном дереве

по величине ключ) или NIL, если элемент x — последний в дереве.

TREE-SUCCESSOR(x)
1 if right[x] ≠ NIL
2 then return TREE-MINIMUM(right[x])
3 y ← p[x]
4 while y ≠ NIL and x = right[y]
5 do x ← y
6 y ← p[y]
7 return y

Процедура TREE-SUCCESSOR отдельно рассматривает два случая. Если правое поддерево вершины x непусто, то следующий за x элемент — минимальный элемент в этом поддереве и равен TREE-MINIMUM(right[x]). Например, на рис. 13.2 за вершиной с ключом 15 следует вершина с ключом 17.

Пусть теперь правое поддерево вершины x пусто. Тогда мы идём от x вверх, пока не найдём вершину, являющуюся левым сыном своего родителя (строки 3–7). Этот родитель (если он есть) и будет искомым элементом. [Формально говоря, цикл в строках 4–6 сохраняет такое свойство: y = p[x]; искомый элемент непосредственно следует за элементами поддерева с корнем в x.]

Время работы процедуры TREE-SUCCESSOR на дереве высоты h есть O(h), так как мы двигаемся либо только вверх, либо только вниз.

Процедура TREE-PREDECESSOR симметрична.
Таким образом, мы доказали следующую теорему.

Теорема 13.1. Операции Search, Minimum, Maximum, Successor и Predecessor на дереве высоты h выполняются за время O(h).

Упражнения

13.2-1 Предположим, что в двоичном дереве поиска хранятся числа от 1 до 1000 и мы хотим найти число 363. Какие из следующих последовательностей не могут быть последовательностями просматриваемых при этом ключей?
а. 2, 252, 401, 398, 330, 344, 397, 363;
б. 924, 220, 911, 244, 898, 258, 362, 363;
в. 925, 202, 911, 240, 912, 245, 363;
г. 2, 399, 387, 219, 266, 382, 381, 278, 363;
д. 935, 278, 347, 621, 299, 392, 358, 363.

13.2-2 Пусть поиск ключа в двоичном дереве завершается в листе. Рассмотрим три множества: A (элементы слева от пути поиска),