---
source_image: page_363.png
page_number: 363
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 77.68
tokens: 11675
characters: 2717
timestamp: 2025-12-24T06:37:54.236376
finish_reason: stop
---

переписывание из одной таблицы в другую (строка 6).

Пусть теперь мы применили \( n \) операций Table-Insert к таблице, не содержащей первоначально ни одной ячейки. Какова стоимость \( i \)-й операции, после которой в таблице будет \( i \) элементов? Обозначим эту стоимость через \( c_i \). Если в таблице есть место (или если \( i = 1 \)), то \( c_i = 1 \) (мы записываем новый элемент в таблицу один раз в строке 10. Если же места в таблице нет и добавление записи к таблице сопровождается расширением таблицы, то \( c_i = i \): одна единица стоимости идет на запись нового элемента в расширенную таблицу (строка 10), и ещё \( i - 1 \) единица пойдет на копирование старой таблицы в новую (строка 6). Стало быть, \( c_i \leq n \) при всех \( i \), и грубая оценка стоимости \( n \) операций Table-Insert есть \( O(n^2) \). Можно, однако, эту оценку улучшить, если проследить, сколь часто происходит расширение таблицы. В самом деле, расширение происходит только в том случае, когда \( i - 1 \) является степенью двойки, так что

\[
\sum_{i=1}^{n} c_i \leq n + \sum_{j=0}^{\lfloor \lg n \rfloor} 2^j < n + 2n = 3n.
\]

Стало быть, стоимость \( n \) операций Table-Insert не превосходит \( 3n \), и учётную стоимость каждой такой операции можно считать равной 3.

Понять, откуда берется коэффициент 3, можно с помощью метода предоплаты. Именно, при выполнении каждой операции Table-Insert(\( T, x \)) будем вносить по 3 доллара, при этом один доллар немедленно израсходуем на оплату операции "записать \( x \) в table\[T\]" в строке 10, ещё один доллар прикрепим к элементу \( x \), а оставшийся отдадим одному из элементов, уже записанных в таблицу (из тех, что ещё не получили своего доллара) Этими долларами будет оплачиваться перенос записей из старой таблицы в расширенную. При этом всякий раз, когда таблицу необходимо расширять, каждый из её элементов будет иметь по доллару. В самом деле, пусть при предыдущем расширении таблица имела размер \( m \) и была расширена до \( 2m \). С тех пор мы добавили \( m \) элементов, при этом и добавленные элементы, и каждый из \( m \) старых элементов получили по доллару. Таким образом, следующее расширение таблицы уже оплачено.

Можно проанализировать алгоритм Table-Insert и с помощью метода потенциалов. Чтобы это сделать, надо придумать такую потенциальную функцию, которая равна нулю сразу после расширения таблицы и нарастает по мере расширения таблицы (становясь равной размеру таблицы в тот момент, когда свободных ячеек не остаётся). Этим условиям удовлетворяет, например, функция

\[
\Phi(T) = 2 \cdot num[T] - size[T].
\]

Начальное значение потенциала равно нулю, и поскольку в любой момент не менее половины таблицы заполнено, значение \( \Phi(T) \) все-