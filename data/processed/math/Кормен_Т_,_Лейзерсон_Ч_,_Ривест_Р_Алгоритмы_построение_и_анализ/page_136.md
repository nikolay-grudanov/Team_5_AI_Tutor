---
source_image: page_136.png
page_number: 136
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 42.33
tokens: 11372
characters: 1704
timestamp: 2025-12-24T06:26:19.082253
finish_reason: stop
---

7 Сортировка с помощью кучи

В этой главе рассмотрен алгоритм сортировки с помощью кучи (heapsort). Как и алгоритм сортировки слиянием, он требует времени \( O(n \lg n) \) для сортировки \( n \) объектов, но обходится дополнительной памятью размера \( O(1) \) (вместо \( O(n) \) для сортировки слиянием). Таким образом, этот алгоритм сочетает преимущества двух ранее рассмотренных алгоритмов — сортировки слиянием и сортировки вставками.

Структура данных, которую использует алгоритм (она называется "двоичной кучей") оказывается полезной и в других ситуациях. В частности, на её базе можно эффективно организовать очередь с приоритетами (см. разд. 7.5). В следующих главах нам встретятся алгоритмы, использующие сходные структуры данных (биномиальные кучи, фибоначчиевы кучи).

Термин "куча" иногда используют в другом смысле (область памяти, где данные размещаются с применением автоматической "сборки мусора" — например, в языке Lisp), но мы этого делать не будем.

7.1 Кучи

Двоичной кучей (binary heap) называют массив с определёнными свойствами упорядоченности. Чтобы сформулировать эти свойства, будем рассматривать массив как двоичное дерево (рис. 7.1). Каждая вершина дерева соответствует элементу массива. Если вершина имеет индекс \( i \), то её родитель имеет индекс \( \lfloor i/2 \rfloor \) (вершина с индексом 1 является корнем), а её дети — индексы \( 2i \) и \( 2i+1 \). Будем считать, что куча может не занимать всего массива и хранить массив \( A \), его длину \( length[A] \) и специальный параметр \( heap-size[A] \) (размер кучи), причём \( heap-size[A] \leq length[A] \). Куча состоит из элементов \( A[1], \ldots, A[heap-size[A]] \). Движение по дереву осуществляется процедурами