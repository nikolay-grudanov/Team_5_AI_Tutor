---
source_image: page_813.png
page_number: 813
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 64.11
tokens: 11844
characters: 2958
timestamp: 2025-12-24T06:58:40.141471
finish_reason: stop
---

Итак, пусть мы получили \( P, X \) и \( Y \). Если \( |P| \leq 3 \), перебираем все пары точек (максимум три) и сравниваем расстояние. Если же \( |P| > 3 \), мы поступаем так:

Разделяй (divide): Находим вертикальную прямую \( l \), которая делит множество \( P \) на два подмножества \( P_L \) и \( P_R \) половинного размера (\( |P_L| = \lceil |P|/2 \rceil, |P_R| = \lceil |P|/2 \rceil \); точки, лежащие на прямой \( l \), как-то поделены между \( P_L \) и \( P_R \)). Массив \( X \) делим на массивы \( X_L \) и \( X_R \), содержащие точки подмножеств \( P_L \) и \( P_R \) (сохраняя порядок); массив \( Y \) делится на массивы \( Y_L \) и \( Y_R \) аналогичным образом.

Властный (conquer): После деления \( P \) на \( P_L \) и \( P_R \), выполняем два рекурсивных вызова и находим пару ближайших точек в множестве \( P_L \) (входные данные этого вызова — подмножество \( P_L \) и массивы \( X_L \) и \( Y_L \)), а также пару ближайших точек в множестве \( P_R \) (входные данные — \( P_R, X_R \) и \( Y_R \)). Обозначим расстояния между ближайшими точками в подмножествах \( P_L \) и \( P_R \) через \( \delta_L \) и \( \delta_R \). Положим \( \delta = \min(\delta_L, deltaR) \).

Соединяй (combine): Для всего множества \( P \) парой ближайших точек является либо одна из найденных пар точек (расстояние \( \delta \)), либо некоторая "приграничная" пара точек, в которой одна точка принадлежит множеству \( P_L \), а другая — \( P_R \) (если среди таких пар есть пара с расстоянием меньше \( \delta \)). Очевидно, что точки такой приграничной пары отстоят от прямой \( l \) не более, чем на \( \delta \), т.е. находятся в симметричной относительно \( l \) вертикальной приграничной полосе шириной \( 2\delta \) (рис. 35.12 (a)). Чтобы найти такую приграничную пару, если она существует, проделаем следующее.

1. Создадим массив \( Y_1 \), поместив в него все точки из массива \( Y \), которые попадают в приграничную полосу (с той или иной стороны от прямой \( l \)). (Порядок сохраняем: массив \( Y_1 \) отсортирован по ординатам точек.)

2. Для каждой точки \( p \) массива \( Y' \) ищем такие точки массива \( Y' \), которые удалены от \( p \) не более, чем на \( \delta \). Как мы вскоре увидим, достаточно рассмотреть только 7 соседних (в порядке возрастания ординат) точек в массиве \( Y' \). Мы вычисляем расстояние от \( p \) до каждой из этих 7 точек. Выполнив это для всех точек \( p \) из \( Y' \), находим \( \delta' \) — расстояние между точками массива \( Y_1 \), расположенными ближе всего друг к другу.

3. Если \( \delta' < \delta \), то пара ближайших точек находится внутри вертикальной полосы и мы возвращаем эту пару точек и расстояние \( \delta' \). В противном случае мы возвращаем пару, найденную при одном из рекурсивных вызовов, и расстояние \( \delta \).

Сейчас мы докажем правильность этого алгоритма, а затем обсудим детали его реализации (необходимые, чтобы уложиться в \( O(n \lg n) \) действий.

Правильность алгоритма