---
source_image: page_383.png
page_number: 383
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 62.28
tokens: 11426
characters: 1607
timestamp: 2025-12-24T06:38:36.190254
finish_reason: stop
---

В-Tree-Split-Child(x, i, y)

1   z ← Allocate-Node()
2   leaf[z] ← leaf[y]
3   n[z] ← t − 1
4   for j ← 1 to t − 1
5     do key_j[z] ← key_{j+t}[y]
6   if not leaf[y]
7     then for j ← 1 to t
8       do c_j[z] ← c_{j+t}[y]
9   n[y] ← t − 1
10  for j ← n[x] + 1 downto i + 1
11    do c_{j+1}[x] ← c_j[x]
12  c_{i+1}[x] ← z
13  for j ← n[x] downto i
14    do key_{j+1}[x] ← key_j[x]
15  key_i[x] ← key_t[y]
16  n[x] ← n[x] + 1
17  Disk-Write(y)
18  Disk-Write(z)
19  Disk-Write(x)

Вершина y имела 2t детей; после преобразования в ней осталось t наименьших из них, а остальные t стали детьми новой вершины z, которая в свою очередь стала ребёнком вершины x. Ключ-медиана вершины y добавлен к вершине x и стал разделителем между вершиной y и следующей за ней вершиной z.

Строки 1–8 формируют вершину z и передают ей детей. Строка 9 меняет вершину y. Наконец, строки 10–16 вносят соответствующие изменения в вершину x. Строки 17–19 сохраняют изменения на диске. Время работы циклов (строки 4–5 и 7–8) равно Θ(t). (Для остальных циклов требуется не больше t шагов).

Добавление элемента в Б-дерево

Процедура B-Tree-Insert добавляет элемент k в Б-дерево T, пройдя один раз от корня к листу. На это требуется время O(th) = O(t \log_t n) и O(h) обращений к диску, если высота дерева h. По ходу дела мы с помощью процедуры B-Tree-Split разделяем встречающиеся нам полные вершины, используя такое наблюдение: если полная вершина имеет неполного родителя, то её можно разделить, так как в родителе есть место для дополнительного ключа. В конце концов мы оказываемся в неполном листе, куда и добавляем новый элемент.