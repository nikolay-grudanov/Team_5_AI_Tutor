---
source_image: page_638.png
page_number: 638
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 58.42
tokens: 11676
characters: 2398
timestamp: 2025-12-24T06:50:41.415564
finish_reason: stop
---

Переходы по указателям

тельность \( \langle y_1, y_2, \ldots, y_n \rangle \), для которой \( y_1 = x_1 \) и
\[
y_k = y_{k-1} \otimes x_k = x_1 \otimes x_2 \otimes \ldots \otimes x_k
\]
для \( k = 2, 3, \ldots, n \). Другими словами, \( y_k \) есть "⊗-произведение" первых \( k \) элементов последовательности.

Мы будем считать, что элементы \( x_1, \ldots, x_n \), подлежащие обработке, связаны в односторонний список. (Аналогичная задача для массива рассматривается в упражнении 30-1.2). Заметим для начала, что задачу о номере в списке можно рассматривать как частный случай задачи о параллельной обработке префиксов. Действительно, пусть каждый элемент списка равен 1, а операция \( \otimes \) — обычное сложение. Тогда \( y_k = k \), то есть мы вычислили расстояние до начала списка. Поэтому обработку префиксов можно использовать для решения задачи о номере в списке — нужно лишь сначала обратить список (что можно сделать за время \( O(1) \)).

Вернёмся к задаче о параллельной обработке префиксов. Введём следующие обозначения:

\[
[i, j] = x_i \otimes x_{i+1} \otimes \ldots \otimes x_j
\]
при \( 1 \leq i \leq j \leq n \). В частности, \( [k, k] = x_k \) и
\[
[i, k] = [i, j] \otimes [j + 1, k]
\]
при \( 1 \leq i \leq j < k \leq n \). Наша цель — вычислить \( y_k = [1, k] \) для всех \( k = 1, \ldots, n \).

В программе через \( x[i] \) обозначается значение объекта \( i \). (Напоминаем, \( i \) есть адрес в памяти, а также номер ответственного за эту ячейку процессора, и никак не связан с \( k \) — порядковым номером в списке!) Алгоритм вычисляет \( y[i] = y_k = [1, k] \), где \( x[i] = x_k \) есть \( k \)-й с начала элемент списка.

**List-Prefix**(*L*)

1 for (для) каждого процессора \( i \)
2 do \( y[i] \leftarrow x[i] \)
3 while существует объект \( i \), для которого \( next[i] \neq NIL \)
4 do for (для) каждого процессора \( i \)
5 do if \( next[i] \neq NIL \)
6 then \( y[next[i]] \leftarrow y[i] \otimes y[next[i]] \)
7 \( next[i] \leftarrow next[next[i]] \)

Видно, что алгоритм похож на алгоритм определения порядковых номеров элементов. Отличаются лишь инициализация и изменение значений \( y \) (в предыдущем алгоритме \( d \)). В алгоритме **List-Rank** процессор \( i \) изменяет значение \( y[i] \), соответствующее своему объекту, тогда как в алгоритме **List-Prefix** \( i \)-й процессор изменяет "чужое" значение \( y[next[i]] \). (Если бы мы обрабатывали