---
source_image: page_185.png
page_number: 185
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 78.98
tokens: 11660
characters: 2451
timestamp: 2025-12-24T06:29:09.545065
finish_reason: stop
---

на части \( A[p..q] \) и \( A[q+1..r] \) таким образом, что всякий элемент \( A[p..q] \) не превосходит всякого элемента \( A[q+1..r] \))?

10.3 Выбор за линейное в худшем случае время

Теперь рассмотрим (детерминированный) алгоритм SELECT, решающий задачу о порядковых статистиках за время \( O(n) \) в худшем случае. Как и RANDOMIZED-SELECT, этот алгоритм основан на последовательном разбиении массива на меньше части; в данном случае, однако, мы гарантируем, что выбранное разбиение не является неудачным. Алгоритм SELECT использует (детерминированную) процедуру PARTITION (см. описание алгоритма быстрой сортировки в разд. 8.1), модифицированную таким образом, чтобы элемент, с которым сравнивают, задавался как параметр.

Алгоритм SELECT находит \( i \)-й по порядку элемент в массиве размера \( n > 1 \) следующим образом:

1. Разбить \( n \) элементов массива на \( \lceil n/5 \rceil \) групп по 5 элементов и (возможно) одну группу, в которой менее пяти элементов.
2. Найти медиану каждой из \( \lceil n/5 \rceil \) групп (для чего отсортировать группу вставками).
3. Вызвав (рекурсивно) процедуру SELECT, найти число \( x \), являющееся медианой найденных \( \lceil n/5 \rceil \) медиан.
4. Вызвав модифицированную процедуру PARTITION, разбить массив относительно найденной "медианы медиан". Пусть \( k \) — количество элементов в нижней части этого разбиения (в верхней части, стало быть, \( n - k \)).
5. Вызвав (рекурсивно) процедуру SELECT, найти \( i \)-ую порядковую статистику нижней части разбиения, если \( i \leq k \), или \( (i - k) \)-ю порядковую статистику верхней части разбиения, если \( i > k \).

Оценим время работы алгоритма SELECT. Для начала выясним, сколько чисел заведомо будут больше "медианы медиан" \( x \) (см. рис. 10.1). Не менее половины медиан, найденных на втором шаге, будут больше или равны \( x \). Стало быть, по крайней мере половина из \( \lceil n/5 \rceil \) групп даст по три числа, больших \( x \), за двумя возможными исключениями: группа, содержащая \( x \), и последняя неполная группа. Тем самым имеется не менее

\[
3 \left( \left\lceil \frac{1}{2} \left\lceil \frac{n}{5} \right\rceil \right\rceil - 2 \right) \geq \frac{3n}{10} - 6.
\]

элементов, заведомо больших \( x \), и точно так же получаем, что имеется не менее \( 3n/10 - 6 \) элементов, заведомо меньших \( x \). Значит, алгоритм SELECT, рекурсивно вызываемый на пятом шаге, будет обрабатывать массив длиной не более \( 7n/10 + 6 \).