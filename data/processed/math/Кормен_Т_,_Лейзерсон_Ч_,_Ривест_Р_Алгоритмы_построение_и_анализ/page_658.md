---
source_image: page_658.png
page_number: 658
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 77.10
tokens: 11952
characters: 3037
timestamp: 2025-12-24T06:51:54.430895
finish_reason: stop
---

**Рисунок 30.11** 30.11. Построение 6-раскраски и соответствующего максимального независимого множества. Алгоритм использует \( n \) процессоров и работает за время \( O(\lg^* n) \). Вначале список из \( n = 20 \) объектов раскрашен в 20 цветов (что требует пяти битов). За два шага эта раскраска сводится к 6-раскраске. Элементы MIS показаны чёрным цветом.

**30.5.2 Вычисление 6-раскраски**

Укажем алгоритм, находящий 6-раскраску списка. Мы считаем, что за каждым элементом \( x \) списка закреплён процессор процессор, номер которого (известный процессору) есть \( P(x) \in \{0, 1, \ldots, n - 1\} \).

Алгоритм последовательно строит раскраски \( C_0, C_1, \ldots, C_m \), постепенно уменьшая число цветов. Начальная раскраска \( C_0 \) является \( n \)-раскраской, а \( C_m \) — 6-раскраской. На \( k \)-ом шаге по раскраске \( C_k \) вычисляется раскраска \( C_{k+1} \). Число шагов \( m \) есть \( O(\lg^* n) \).

Начальная раскраска \( C_0 \) тривиальна: \( C_0[x] = P(x) \) (цвет вершины есть номер соответствующего ей процессора). Поскольку номера процессоров различны, это отображение действительно является раскраской. (Заметьте, что каждый цвет кодируется \( \lceil \lg n \rceil \) битами и может храниться в памяти, занимая не слишком много места.)

Опишем теперь процесс построения раскраски \( C_{k+1} \) по \( C_k \) (см. рис. 30.11). Мы считаем, что каждый цвет кодируется битовой строкой фиксированной (для данной раскраски) длины. Переход от \( C_k \) к \( C_{k+1} \) уменьшает эту длину.

Итак, пусть цвета раскраски \( C_k \) записываются \( r \) битами и соседние объекты \( x \) и \( \text{next}[x] \) имеют цвета \( C_k[x] = a \) и \( C_k[\text{next}[i]] = b \), где \( a = \langle a_{r-1}, a_{r-2}, \ldots, a_0 \rangle \), \( b = \langle b_{r-1}, b_{r-2}, \ldots, b_0 \rangle \). Цвета эти различны, поэтому \( a_i \neq b_i \) для некоторого \( i \) от 0 до \( r - 1 \). Мы объявим пару \( \langle i, a_i \rangle \) цветом элемента \( x \) в новой раскраске (закодировав её последовательностью битов). Цветом последнего элемента в новой раскраске мы будем считать пару \( \langle 0, a_0 \rangle \), если \( \langle a_{r-1}, a_{r-2}, \ldots, a_0 \rangle \) было его цветом в старой раскраске.

Остаётся понять, почему в новой раскраске цвета соседних вершин будут различны и сколько битов нужно для кодирования её цветов. Начнём с первого; рассмотрим два соседних элемента \( x \) и \( y = \text{next}[x] \) в нашем списке. Раньше они имели цвета \( a = \langle a_{r-1}, a_{r-2}, \ldots, a_0 \rangle \), \( b = \langle b_{r-1}, b_{r-2}, \ldots, b_0 \rangle \), которые различались в бите \( i \), и новый цвет \( x \) есть пара \( \langle i, a_i \rangle \), причём \( a_i \neq b_i \). Пусть новый цвет \( y \) есть пара \( \langle j, b_j \rangle \). Видно, что пары эти различны: если различны их первые члены, то и доказывать нечего, если же первые члены совпадают (\( i = j \)), то различны вторые \( b_j \) равно \( b_i \) и не равно \( a_i \).

Теперь о количестве битов: если на \( k \)-ом шаге цвета запи-