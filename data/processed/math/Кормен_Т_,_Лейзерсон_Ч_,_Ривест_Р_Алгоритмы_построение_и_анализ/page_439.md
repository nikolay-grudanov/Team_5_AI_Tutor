---
source_image: page_439.png
page_number: 439
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 57.13
tokens: 11558
characters: 2360
timestamp: 2025-12-24T06:41:01.185305
finish_reason: stop
---

Рис. 22.4

Рисунок 22.3 Рис. 22.4. Лес непересекающихся множеств. а) Деревья, представляющие множества рис. 22.2. Представителями множеств являются элементы с и f. б) Результат операции Union(e, g).

представим каждое множество корневым деревом, в котором вершинами являются элементы множества, а корень является представителем. Получается лес непересекающихся множеств (disjoint-set forest). Как видно из рисунка (см. рис. 22.4 (а)), каждая вершина указывает на своего родителя, а корень указывает сам на себя. При наивном программировании операций Find-Set и Union такая реализация будет ничуть не лучше списочной; если, однако использовать эвристики "объединения по рангу" и "сжатия путей", то получится самая быстрая (из известных в настоящее время) реализация системы непересекающихся множеств.

Наивные реализации операций выглядят так: Make-Set создает дерево с единственной вершиной, Find-Set(x) состоит в том, что мы идем от x по стрелкам (указывающим на родителя), пока не дойдем до корня (путь, который мы при этом проходим, называется путь поиска, по-английски find path), а Union состоит в том, что мы заставляем корень одного из деревьев указывать не на самого себя, а на корень другого дерева (рис. 22.4б).

Две эвристики

Пока что больших преимуществ (по сравнению со списочной реализацией) не видно: например, в результате n - 1 операции Union может получиться дерево, являющееся цепочкой n вершин. Опишем две эвристики, позволяющих добиться почти линейной оценки времени.

Первая эвристика, называемая объединением по рангу (union by rank), напоминает весовую эвристику в списочной реализации: мы объединяем деревья не как попало, а так, чтобы корень "меньшего" дерева указывал на корень "большего". Выбор "большего" определяется не размером дерева, а специальным параметром — рангом (rank) его корня. Ранг определён для каждой вершины x дерева и в первом приближении может рассматриваться как грубая оценка логарифма числа вершин в поддереве с корнем в x. Точное определение ранга будет дано в следующем разделе.

Вторая эвристика, применяемая в операции Find-Set, называется сжатием путей (path compression). Она заключается в следующем: после того, как путь поиска от вершины к корню пройден, дерево перестраивается: в каждой из вершин пути указатель устанавливается непосредственно на корень (рис. 22.5). При этом ранги остаются прежними.