---
source_image: page_203.png
page_number: 203
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 57.43
tokens: 11382
characters: 1768
timestamp: 2025-12-24T06:29:42.356077
finish_reason: stop
---

**Связанные списки**

**List-Insert** \((L, x)\)
1 \(next[x] \leftarrow head[L]\)
2 **if** \(head[L] \neq NIL\)
3 **then** \(prev[head[L]] \leftarrow x\)
4 \(head[L] \leftarrow x\)
5 \(prev[x] \leftarrow NIL\)

Процедура List-Insert выполняется за время \(O(1)\) (не зависящее от длины списка).

**Удаление элемента из списка**

Процедура List-Delete удаляет элемент \(x\) из списка \(L\), направляя указатели "в обход" этого элемента. При этом в качестве аргумента ей передаётся указатель на \(x\). Если задан ключ элемента \(x\), то перед удалением надо найти его указатель с помощью процедуры List-Search.

**List-Delete** \((L, x)\)
1 **if** \(prev[x] \neq NIL\)
2 **then** \(next[prev[x]] \leftarrow next[x]\)
3 **else** \(head[L] \leftarrow next[x]\)
4 **if** \(next[x] \neq NIL\)
5 **then** \(prev[next[x]] \leftarrow prev[x]\)

Удаление элемента из списка проиллюстрировано на рис. 11.3в. Процедура List-Delete работает за время \(O(1)\); однако для удаления элемента с заданным ключом его надо сначала найти, что потребует времени \(\Theta(n)\).

**Фиктивные элементы**

Если забыть об особых ситуациях на концах списка, процедуру List-Delete можно записать совсем просто:

**List-Delete'** \((L, x)\)
1 \(next[prev[x]] \leftarrow next[x]\)
2 \(prev[next[x]] \leftarrow prev[x]\)

Такие упрощения станут законными, если добавить к списку \(L\) фиктивный элемент \(nil[L]\), который будет иметь поля \(next\) и \(prev\) наравне с прочими элементами списка. Этот элемент (называемый sentinel — часовой) не позволит нам выйти за пределы списка. Указатель на него играет роль значения NIL. Замкнём список в кольцо: в поля \(next[nil[L]]\) и \(prev[nil[L]]\) запишем указатели на голову и хвост списка соответственно, а в поля \(prev\) у головы списка и \(next\) у