---
source_image: page_785.png
page_number: 785
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 46.48
tokens: 11425
characters: 1693
timestamp: 2025-12-24T06:57:07.746794
finish_reason: stop
---

Укажите работающий за линейное время алгоритм, выясняющий, является ли данная строка T циклической перестановкой строки T' (например, строки arc и sag получаются одна из другой циклической перестановкой).

34.4-6
Разработайте эффективный алгоритм, вычисляющий функцию перехода δ для конечного автомата, ищущего подстроку P[1..m] в строке символов алфавита Σ. Ваш алгоритм должен работать за время O(m|Σ|). (Указание. Докажите, что δ(q, a) = δ(π[q], a), если q = m или P[q + 1] ≠ a.)

34.5 Алгоритм Бойера — Мура

Если образец P длинный, а алфавит Σ достаточно велик, то наиболее эффективным алгоритмом поиска подстрок является, видимо, следующий алгоритм, изобретенный Бойером (Robert S. Boyer) и Муром (J. Strother Moore):

Boyer-Moore-Matcher(T, P, \Sigma)
1 n \gets length[T]
2 m \gets length[P]
3 \lambda \gets Compute-Last-Occurrence-Function(P, m, \Sigma)
4 \gamma \gets Compute-Good-Suffix-Function(P, m)
5 s \gets 0
6 while s \leqslant n-m
7   do j \gets m
8     while j>0 and P[j]=T[s+j]
9       do j \gets j-1
10      if j=0
11         then print 'Образец входит со сдвигом 's
12            s \gets s+\gamma[0]
13      else s \gets s+\max(\gamma[j], j-\lambda[T[s+j]])

Если не обращать внимания на загадочные λ и γ, этот алгоритм очень похож на простейший алгоритм поиска подстрок. В самом деле, если мы закомментируем строки 3–4 и заменим строки 12–13 на

12      s \gets s+1
13      else s \gets s+1,

то получится в точности простейший алгоритм разд. 34.1, с той единственной разницей, что сравнение P[1..m] и T[s+1..s+m] идет справа налево, а не слева направо.

Алгоритм Бойера — Мура вносит в простейший алгоритм со сравнением справа налево два усовершенствования, называемые "