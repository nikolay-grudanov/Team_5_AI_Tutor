---
source_image: page_227.png
page_number: 227
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 50.60
tokens: 11596
characters: 2140
timestamp: 2025-12-24T06:30:44.087494
finish_reason: stop
---

Переводы надписей: \( w \) bits — \( w \) битов; extract \( p \) bits — выделить \( p \) битов. ВНИМАНИЕ: на рисунке надо УБРАТЬ знаки целой части, заменив \( \lfloor A \cdot 2^w \rfloor \) на \( A \cdot 2^w \) !!!!!!

Рисунок 12.4 Хеширование методом умножения. Ключ \( k \), представленный в виде \( w \)-битного числа, умножается на \( w \)-битное число \( A \cdot 2^w \), где \( A \) — константа из интервала \((0; 1)\). У произведения берут младшие \( w \) битов, а из этих \( w \) битов выделяют \( p \) старших. Это и есть хеш-значение \( h(k) \).

трёх вариантов при поиске отсутствующего в таблице элемента. Что ж, воспользуемся методом деления с остатком при длине хеш-таблицы \( m = 701 \). Число 701 простое, \( 701 \approx 2000/3 \), и до степеней двойки от числа 701 тоже далеко. Стало быть, можно выбрать хеш-функцию вида

\[
h(k) = k \bmod 701.
\]

На всякий случай можно ещё поэкспериментировать с реальными данными на предмет того, насколько равномерно будут распределены их хеш-значения.

12.3.2 Умножение

Построение хеш-функции методом умножения (multiplication method) состоит в следующем. Пусть количество хеш-значений равно \( m \). Зафиксируем константу \( A \) в интервале \( 0 < A < 1 \), и положим

\[
h(k) = \lfloor m(kA \bmod 1) \rfloor,
\]

где \( kA \bmod 1 \) — дробная часть \( kA \).

Достоинство метода умножения в том, что качество хеш-функции мало зависит от выбора \( m \). Обычно в качестве \( m \) выбирают степень двойки, поскольку в большинстве компьютеров умножение на такое \( m \) реализуется как сдвиг слова. Пусть, например, длина слова в нашем компьютере равна \( w \) битам и ключ \( k \) помещается в одно слово. Тогда, если \( m = 2^p \), то вычисление хеш-функции можно провести так: умножим \( k \) на \( w \)-битное целое число \( A \cdot 2^w \) (мы предполагаем, что это число является целым); получится \( 2w \)-битное число

Метод умножения работает при любом выборе константы \( A \), но некоторые значения \( A \) могут быть лучше других. Оптимальный выбор зависит от того, какого рода данные подвергаются хешированию. В книге [123] Кнут обсуждает выбор константы \( A \) и прихо-