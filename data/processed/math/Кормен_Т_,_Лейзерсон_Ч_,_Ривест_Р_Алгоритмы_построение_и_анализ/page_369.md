---
source_image: page_369.png
page_number: 369
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 79.65
tokens: 11719
characters: 2587
timestamp: 2025-12-24T06:38:08.332206
finish_reason: stop
---

18-2 Динамический двоичный поиск

Чтобы сократить время на добавление элемента к отсортированному массиву, можно поступить так. Распределим элементы отсортированного массива длины \( n \) по \( k = \lceil \log_2 n \rceil \) массивам \( A_0, A_1, \ldots, A_k \) следующим образом: если \( \langle n_{k-1}, n_{k-2}, \ldots, n_0 \rangle \) — двоичное представление числа \( n \) (т.е. \( n = \sum_{i=0}^{k-1} n_i 2^i \)), то массив \( A_i \) пуст, если \( n_i = 0 \), и содержит \( 2^i \) элементов, если \( n_i = 1 \); в этом последнем случае массив \( A_i \) отсортирован. На распределение \( n \) элементов по массивам \( A_0, \ldots, A_n \) никаких условий не накладывается.

а. Реализуйте для этой структуры данных операцию SEARCH (искать). Каково ее время работы в худшем случае?

б. Реализуйте операцию INSERT (добавить элемент). Оцените ее стоимость в худшем случае и учётную стоимость (если возможны только добавления, но не удаления).

в. Как реализовать операцию DELETE (удалить)?

18-3 Сбалансированные по весу деревья

Пусть \( x \) — узел двоичного дерева; через \( size[x] \) обозначим число листьев в поддереве с вершиной в \( x \). Пусть число \( \alpha \) удовлетворяет неравенству \( 1/2 \leq \alpha < 1 \). Будем говорить, что узел \( x \) \( \alpha \)-сбалансирован (\( \alpha \)-balanced), если

\[
size[left[x]] \leq \alpha \cdot size[x]
\]

и

\[
size[right[x]] \leq \alpha \cdot size[x].
\]

Двоичное дерево называется \( \alpha \)-сбалансированным, если все его узлы, кроме листьев, \( \alpha \)-сбалансированы. Подход к сбалансированным деревьям, о котором идет речь ниже, был предложен Г. Варгезе (G. Varghese).

а. Пусть \( x \) — узел двоичного дерева поиска. Объясните, как перестроить поддерево с корнем в \( x \), чтобы оно стало \( 1/2 \)-сбалансированным (самое сильное требование сбалансированности) Ваш алгоритм должен работать за время \( \Theta(size[x]) \) и пользоваться дополнительной памятью объема \( O(size[x]) \).

б. Покажите, что поиск в \( \alpha \)-сбалансированном двоичном дереве с \( n \) узлами требует в худшем случае времени \( O(\log n) \).

Далее будем считать, что \( \alpha > 1/2 \). Будем считать, что после выполнения операций INSERT и DELETE (реализованных стандартным образом), производится балансировка: если какой-то узел дерева перестал быть \( \alpha \)-сбалансированным, выбирается ближайший к корню из таких узлов и соответствующее поддерево перестраивается в \( 1/2 \)-сбалансированное (см. пункт а).

Проанализируем эту схему балансировки с помощью метода потенциалов. Как обычно, потенциал будет тем больше, чем дальше