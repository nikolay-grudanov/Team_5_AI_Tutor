---
source_image: page_288.png
page_number: 288
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 60.16
tokens: 11549
characters: 2193
timestamp: 2025-12-24T06:33:50.796036
finish_reason: stop
---

15.3 Деревья промежутков

В этом разделе мы используем красно-чёрные деревья для хранения меняющегося множества промежутков. Отрезком (closed interval) \([t_1, t_2]\) называется множество вещественных чисел \(t\), для которых \(t_1 \leq t \leq t_2\). (Предполагается, что \(t_1 \leq t_2\).) Полуинтервал (half-open interval) и интервал (open interval) получаются из отрезка выкидыванием одного или двух концов соответственно. В этом разделе мы имеем дело только с отрезками, но все результаты легко распространяются на интервалы и полуинтервалы.

Представим себе базу данных, в которой хранится информация о протяжённых по времени событиях: для каждого события хранится промежуток времени, которое оно занимает. Рассматриваемая в этом разделе структура данных позволяет по любому промежутку найти все события, которые пересекаются с этим промежутком, причём делает это достаточно быстро.

Мы считаем, что отрезок \([t_1, t_2]\) представляет собой запись \(i\), состоящую из двух полей: \(low[i] = t_1\) (левый конец (low endpoint)) и \(high[i] = t_2\) (правый конец (high endpoint)). Будем говорить, что отрезки \(i\) и \(i'\) перекрываются (overlap), если \(low[i] \leq high[i']\) и \(low[i'] \leq high[i]\); иными словами, если \(i \cap i' \neq \emptyset\). (Обратите внимание, что отрезки, имеющие общий конец, считаются перекрывающимися.)

Всего возможно три варианта взаимного расположения отрезков \(i\) и \(i'\) (рис. 15.3):
1. отрезки \(i\) и \(i'\) перекрываются,
2. \(high[i] < low[i']\),
3. \(high[i'] < low[i]\).

Деревом промежутков (interval tree) назовём красно-чёрное дерево, каждая вершина \(x\) которого хранит отрезок \(int[x]\). Дерево промежутков позволяет реализовать следующие операции:
Interval-Insert(\(T, x\)) добавляет к дереву \(T\) элемент \(x\) (содержащий некоторый отрезок \(int[x]\));
Interval-Delete(\(T, x\)) удаляет из дерева \(T\) элемент \(x\);
Interval-Search(\(T, i\)) возвращает указатель на элемент \(x\) дерева \(T\), для которого отрезки \(i\) и \(int[x]\) перекрываются (и возвращает NIL, если такого элемента в дереве нет).
Пример дерева промежутков показан на рис.15.4. Следуя схеме раздела 15.2, мы реализуем такую структуру данных и операции на