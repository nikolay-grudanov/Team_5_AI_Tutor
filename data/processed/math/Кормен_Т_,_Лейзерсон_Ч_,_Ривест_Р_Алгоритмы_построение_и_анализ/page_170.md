---
source_image: page_170.png
page_number: 170
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 58.37
tokens: 11567
characters: 2217
timestamp: 2025-12-24T06:28:11.931428
finish_reason: stop
---

Рисунок 9.2 Работа алгоритма Counting-Sort, применённого к массиву \( A[1..8] \), состоящему из натуральных чисел, не превосходящих \( k = 6 \). (а) Массив \( A \) и вспомогательный массив \( C \) после выполнения цикла в строках 3–4. (б) Массив \( C \) после выполнения цикла в строках 6–7. (в–д) Выходной массив \( B \) и вспомогательный массив \( C \) после одного, двух и трёх повторений цикла в строках 9–11. Зачернённые клетки соответствуют элементам массива, значения которым ещё не присвоены. (е) Массив \( B \) после окончания работы алгоритма.

массива \( A \) помещается на нужное место в массиве \( B \). В самом деле, если все \( n \) элементов различны, то в отсортированном массиве число \( A[j] \) должно стоять на месте номер \( C[A[j]] \), ибо именно столько элементов массива \( A \) не превосходят \( A[j] \); если в массиве \( A \) встречаются повторения, то после каждой записи числа \( A[j] \) в массив \( B \) число \( C[A[j]] \) уменьшается на единицу (строка 11), так что при следующей встрече с числом, равным \( A[j] \), оно будет записано на одну позицию левее.

Оценим время работы алгоритма сортировки подсчётом. Циклы в строках 1–2 и 6–7 работают за время \( O(k) \), циклы в строках 3–4 и 10–11 — за время \( O(n) \), а весь алгоритм, стало быть, работает за время \( O(k + n) \). Если \( k = O(n) \), то время работы есть \( O(n) \).

Для алгоритма сортировки подсчётом нижняя оценка разд. 9.1 — не препятствие, поскольку он не сравнивает сортируемые числа между собой, а использует их в качестве индексов массива.

Алгоритм сортировки подсчётом обладает важным свойством, называемым устойчивостью (it is stable). Именно, если во входном массиве присутствует несколько равных чисел, то в выходном массиве они стоят в том же порядке, что и во входном. Это свойство не имеет смысла, если в массиве записаны только числа сами по себе, но если вместе с числами записаны дополнительные данные, это оказывается важным. Более точно, представим себе, что мы сортируем не просто числа, а пары \( \langle t, x \rangle \), где \( t \) — число от 1 до \( k \), а \( x \) — произвольный объект, и хотим переставить их так, чтобы первые компоненты пар шли в неубывающем порядке. Описанный нами ал-