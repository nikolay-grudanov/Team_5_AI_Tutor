---
source_image: page_272.png
page_number: 272
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 45.12
tokens: 11366
characters: 1679
timestamp: 2025-12-24T06:32:51.123713
finish_reason: stop
---

RB-DELETE(T, z)
1   if left[z] = nil[T] или right[z] = nil[T]
2     then y ← z
3     else y ← TREE-SUCCESSOR(z)
4     if left[y] ≠ nil[T]
5       then x ← left[y]
6       else x ← right[y]
7       p[x] ← p[y]
8     if p[y] = nil[T]
9       then root[T] ← x
10      else if y = left[p[y]]
11         then left[p[y]] ← x
12         else right[p[y]] ← x
13     if y ≠ z
14       then key[z] ← key[y]
15       ▷ Копируем дополнительные данные из вершины y.
16     if color[y] = BLACK
17       then RB-DELETE-FIXUP(T, x)
18     return y

Есть три различия между процедурами RB-DELETE и TREE-DELETE. Во-первых, вместо NIL всюду стоит указатель на фиктивный элемент nil[T]. Во-вторых, проверка \( x \neq \) NIL в строке 7 процедуры TREE-DELETE удалена, и присваивание \( p[x] \leftarrow p[y] \) выполняется в любом случае. Если \( x \) есть фиктивный элемент nil[T], то его указатель на родителя становится равным родителю удаляемого элемента \( y \). В-третьих, в строках 16–17 вызывается процедура RB-DELETE-FIXUP, если удаляемая вершина \( y \) — чёрная. При удалении красной вершины RB-свойства не нарушаются (чёрные высоты не меняются, и красные вершины не могут стать соседними). Передаваемая процедуре RB-DELETE-FIXUP вершина \( x \) являлась единственным ребёнком вершины \( y \), если у \( y \) был ребёнок (не являющийся листом), или фиктивным элементом nil[T], если вершина \( y \) не имела детей. В последнем случае присваивание в строке 7 гарантирует, что \( p[x] \) указывает на бывшего родителя \( y \) — вне зависимости от того, является ли \( x \) настоящей вершиной или фиктивным элементом.

Посмотрим, как процедура RB-DELETE-FIXUP восстанавливает RB-свойства дерева.