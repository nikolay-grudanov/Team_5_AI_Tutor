---
source_image: page_283.png
page_number: 283
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 72.83
tokens: 11662
characters: 2455
timestamp: 2025-12-24T06:33:46.662278
finish_reason: stop
---

порядковый номер в поддеревьях с корнями в \( y \) и \( p[y] \). Если же \( y \) — правый ребёнок, при переходе от \( y \) к \( p[y] \) к порядковому номеру вершины \( x \) прибавится \( size[left[p[y]]] \) элементов левого поддерева и сама вершина \( p[y] \). В строке 5 мы учили эту добавку.

При выходе из цикла \( y = root[T] \), а \( r \) — порядковый номер \( x \) во всём дереве.

Для примера посмотрим, как эта процедура определит порядковый номер вершины с ключом 38 в дереве, изображённом на рис. 15.1. В таблице показан ключ вершины \( y \) и число \( r \) в начале каждого цикла.

<table>
  <tr>
    <th>Шаг</th>
    <th>key[x]</th>
    <th>r</th>
  </tr>
  <tr>
    <td>1</td>
    <td>38</td>
    <td>2</td>
  </tr>
  <tr>
    <td>2</td>
    <td>30</td>
    <td>4</td>
  </tr>
  <tr>
    <td>3</td>
    <td>41</td>
    <td>4</td>
  </tr>
  <tr>
    <td>4</td>
    <td>26</td>
    <td>17</td>
  </tr>
</table>

Возвращается значение 17.

С каждым шагом глубина вершины \( y \) уменьшается на единицу, и каждый шаг требует времени \( O(1) \), поэтому время работы процедуры OS-RANK на \( n \)-элементном множестве есть \( O(\log n) \).

Обновление информации о размерах поддеревьев

С помощью полей \( size \) мы научились быстро вычислять порядковый номер элемента, а также находить \( i \)-й элемент дерева. Теперь надо понять, как обновлять это поле при добавлении и удалении элемента из красно-чёрного дерева. Оказывается, это можно сделать, не ухудшив асимптотическую оценку времени работы процедур добавления и удаления элемента.

Как мы видели в разделе 14.3, добавление элемента в красно-чёрное дерево состоит из двух частей: сначала мы добавляем новую вершину, делая её ребёнком уже существующей, а затем производим некоторые вращения и перекрашивания (если это необходимо)

На первом этапе мы для каждой пройденной вершины \( x \) (на пути от корня до места добавления вершины) увеличим на единицу значение \( size[x] \). В поле \( size \) добавленной вершины запишем число 1. При этом мы проходим путь длиной \( O(\log n) \) и дополнительно тратим время \( O(\log n) \), после чего все поля \( size \) правильны.

При вращении изменяются размеры только двух поддеревьев: их вершинами являются концы ребра, вокруг которого происходило вращение. Поэтому к тексту процедуры LEFT-ROTATE\((T, x)\) (раздел 14.2) достаточно добавить строки

13 \( size[y] \leftarrow size[x] \)
14 \( size[x] \leftarrow size[left[x]] + size[right[x]] + 1 \)