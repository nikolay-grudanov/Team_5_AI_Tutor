---
source_image: page_488.png
page_number: 488
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 65.40
tokens: 11701
characters: 2469
timestamp: 2025-12-24T06:43:35.012338
finish_reason: stop
---

Рисунок 24.5  24.5 Работа алгоритма Прима на графе рис. 24.1 с корневой вершиной \(a\) Рёбра, входящие в дерево \(A\). выделены серым; вершины дерева — чёрным. На каждом шаге к \(A\) добавляется ребро, пересекающее разрез между деревом и его дополнением. Например, на втором шаге можно было бы добавить любое из рёбер \((b, c)\) и \((a, h)\).

\textsc{MST-Prim}$(G, W, r)$
1 $Q \leftarrow V[G]$
2 {\bf for} $u \in Q$
3   {\bf do} $key[u] \gets \infty$
4 $key[r] \gets 0$
5 $\pi[r] \gets \textsc{nil}$
6 {\bf while} $Q \neq \emptyset$
7   {\bf do} $u \leftarrow \textsc{Extract-Min}(Q)$
8     {\bf for} $v \in Adj[u]$
9       {\bf do if} $v \in Q$ и $w(u, v) < key[v]$
10         {\bf then} $\pi(v) \leftarrow u$
11           $key(v) \leftarrow w(u, v)$

На рис. 24.5 показана работа алгоритма Прима. После исполнения строк 1–5 и первого прохода цикла в строках 6 — 11 дерево состоит из единственной вершины \(r\), все остальные вершины находятся в очереди, и значение \(key[v]\) для них равно длине ребра из \(r\) в \(v\) или \(+\infty\), если такого ребра нет (в первом случае \(\pi[v] = r\). Таким образом, выполнен описанный выше инвариант (дерево есть часть некоторого остова, для вершин дерева поле \(\pi\) указывает на родителя, а для остальных вершин на "ближайшую" вершину дерева — вес ребра до неё хранится в \(key[v]\).

Время работы алгоритма Прима зависит от того, как реализована очередь \(Q\). Если использовать двоичную кучу (глава 7), инициализацию в строках 1–4 можно выполнить с помощью процедуры Build-Heap за время \(O(V)\). Далее цикл выполняется \(|V|\) раз, и каждая операция Extract-Min занимает время \(O(\lg V)\), всего \(O(V \lg V)\). Цикл for в строках 8–11 выполняется в общей сложности \(O(E)\) раз, поскольку сумма степеней вершин графа равна \(2|E|\). Проверку принадлежности в строке 9 внутри цикла for можно реализовать за время \(O(1)\), если хранить состояние очереди ещё и как битовый вектор размера \(|V|\). Присваивание в строке 11 подразумевает выполнение операции уменьшения ключа (Decrease-Key), которая для двоичной кучи может быть выполнена за время \(O(\lg V)\). Таким образом, всего получаем \(O(V \lg V + E \lg V) = O(E \lg V)\) — та же самая оценка, что была для алгоритма Крускала.

Однако эта оценка может быть улучшена, если использовать в алгоритме Прима фибоначчиевы кучи. Как мы видели в главе 21, с помощью фибоначчиевой кучи можно выполнять операцию Extract-Min за учётное время \(O(\lg V)\), а операцию Decrease-