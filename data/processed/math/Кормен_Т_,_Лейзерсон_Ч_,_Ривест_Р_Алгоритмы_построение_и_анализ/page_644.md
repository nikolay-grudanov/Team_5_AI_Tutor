---
source_image: page_644.png
page_number: 644
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 64.18
tokens: 11711
characters: 2597
timestamp: 2025-12-24T06:51:01.686492
finish_reason: stop
---

Рисунок 30.6  30.6. Отыскание максимума в массиве за время \( O(1) \) с помощью алгоритма Fast-Max. Для каждой (упорядоченной) пары \( \langle i, j \rangle \) элементов массива \( A = \langle 5, 6, 9, 2, 9 \rangle \) в таблице показан результат сравнения \( A[i] < A[j] \) (Т означает TRUE, F — FALSE). Если в строке есть хотя бы одна буква Т, то соответствующий элемент \( m \) равен FALSE, иначе — TRUE. Элементы массива, для которых в столбце \( m \) стоит значение TRUE, являются максимальными (и запи- сываются в ячейку \( max \)).

\( O(1) \). Напомним, что мы рассматриваем CRCW-модель, в которой все процессоры, производящие запись в данную ячейку, должны записывать туда одно и то же.

Пусть \( A[0...n-1] \) — входной массив. Наш CRCW-алгоритм использует \( n^2 \) процессоров. Каждый процессор сравнивает какие-то два элемента \( A[i] \) и \( A[j] \), где \( 0 \leq i, j \leq n-1 \), и нумеруется парой индексов \( (i, j) \).

Fast-Max(A)
1 \( n \leftarrow length[A] \)
2 for \( i \leftarrow 0 \) to \( n-1 \)
3 do \( m[i] \leftarrow \) TRUE
4 for \( i \leftarrow 0 \) to \( n-1 \) and \( j \leftarrow 0 \) to \( n-1 \) (параллельно)
5 do if \( A[i] < A[j] \)
6 then \( m[i] \leftarrow \) FALSE
7 for \( i \leftarrow 0 \) to \( n-1 \) (параллельно)
8 do if \( m[i] = \) TRUE
9 then \( max \leftarrow A[j] \)
10 return \( max \)

В строке 1 определяется длина массива \( A \) (каким-то из процессоров). В строках 2–3 каждым элементом массива \( m \) занимается какой-то один процессор (их у нас достаточно — \( n^2 \)) и помещает туда значение TRUE. (Будущий смысл массива \( m \) таков: \( m[i] \) истинно, когда \( A[i] \) — максимальный элемент в массиве).

Дальнейшая работа алгоритма показана на рис. 30.6. В строках 4–6 происходит сравнение всех возможных пар \( A[i] \) и \( A[j] \). Если \( A[i] < A[j] \), то \( A[i] \) не может быть максимальным элементом, поэтому мы записываем в \( m[i] \) значение FALSE (строка 6). Несколько различных процессоров могут одновременно производить запись в ячейку \( m[i] \), но все они записывают одно и то же значение — FALSE.

Таким образом, после выполнения строк 4–6 \( m[i] \) истинно для тех и только тех индексов \( i \), для которых \( A[i] \) — максимальный элемент. В строках 7–9 максимальное значение помещается в переменную \( max \), которая является выходным значением (строка 10). К переменной \( max \) могут обращаться сразу несколько процессоров, но все они присваивают ей одно и то же значение, как и требуется в модели одновременной записи общего значения.

Поскольку выполнение каждого из циклов занимает время \( O(1) \)