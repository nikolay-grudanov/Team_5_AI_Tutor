---
source_image: page_583.png
page_number: 583
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 54.37
tokens: 11610
characters: 2277
timestamp: 2025-12-24T06:48:01.939672
finish_reason: stop
---

Возможность проталкивания гарантируется проверками в строках 1 и 6, так что первое утверждение очевидно.

Докажем второе утверждение. Для этого (по лемме 27.28) достаточно доказать, что все выходящие из u рёбра недопустимы. Заметим, что при вызовах процедуры DISCHARGE указатель current[u] перемещается по списку N[u] от его начала head[N[u]] до конца.

В конце вершину u поднимают и начинается новый проход. Каждый раз, прежде чем сдвинуть указатель с произвольной позиции v мы убеждаемся (строка 6), что ребро (u, v) недопустимо. Таким образом, в конце прохода все выходящие из u рёбра были просмотрены и оказались недопустимыми. Могли ли они затем стать допустимыми (до конца прохода)? По лемме 27.27, проталкивания вообще не создают допустимых рёбер. Их могут породить только операции подъёма. Но вершина и не поднималась (в течение прохода по списку), а подъёмы других вершин создают лишь выходящие из них допустимые рёбра. Поэтому в конце прохода все выходящие из вершины и рёбра недопустимы, поэтому её можно поднять.

Алгоритм "поднять-u-в-начало"

Алгоритм "поднять-u-в-начало" хранит множество V \setminus {s, t} вершин (отличных от истока и стока) в виде списка. При этом существенно то, что список этот оказывается "корректно упорядоченным" в следующем смысле: конец любого допустимого рёбра находится дальше в списке, чем начало этого рёбра (напомним, что допустимые рёбра образуют ациклический граф, лемма 27.26). (Задачу о поиске корректного упорядочения для произвольного ациклического графа мы называли задачей топологической сортировки, см. раздел 23.4.)

Следующую в этом списке за u вершину обозначим next[u]; если вершина u — последняя в списке, то next[u] = NIL.

\textsc{Lift-To-Front}($G,s,t$)
1   \textsc{Initialize-Preflow}($G,s$)
2   $L\leftarrow V[G]-\{s,t\}$ (в любом порядке)
3   for (для) каждой вершины $u\in V[G]\setminus\{s,t\}$
4     do $current[u]\leftarrow head[N[u]]$
5     $u\leftarrow head[L]$
6     while $u\neq$\textsc{nil}
7       do $old-height\leftarrow h[u]$
8         \textsc{Discharge}($u$)
9         if $h[u]>old-height$
10           then переместить $u$ в начало списка $L$
11           $u\leftarrow next[u]$

Алгоритм формирует начальный предпоток (строка 1), список L (строка 2) (точно так же, как это делалось раньше). Затем