---
source_image: page_825.png
page_number: 825
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 64.59
tokens: 11775
characters: 2684
timestamp: 2025-12-24T06:59:09.033980
finish_reason: stop
---

ког \( L_1 \) и \( L_2 \) называется язык

\[
L = \{ x_1 x_2 : x_1 \in L_1, x_2 \in L_2 \}.
\]

Замыканием (closure) языка \( L \) называется язык

\[
L^* = \{ \varepsilon \} \cup L \cup L^2 \cup L^3 \cup \ldots,
\]

где \( L^k \) — язык, полученный \( k \)-кратной конкатенацией языка \( L \) с самим собой. Операция замыкания называется также \( * \)-операцией Клини (Kleene star).

Теперь можно сказать, что задача разрешения (точнее, соответствующая ей строковая задача разрешения) является языком над алфавитом \( \Sigma = \{0, 1\} \). Например, задаче PATH соответствует язык \( \text{PATH} = \{ \langle G, u, v, k \rangle : G = (V, E) \) — неориентированный граф, \( , u, v \in V; k \geq 0 \) — целое число, и в графе \( G \) существует путь из \( u \) в \( v \), длина которого не превосходит \( k \} \).

(Мы будем использовать одно и то же название — в данном случае PATH — для обозначения задачи и соответствующего языка.)

Продолжим знакомство с терминологией теории формальных языков. Говорят, что алгоритм \( A \) допускает (accepts) строку \( x \in \{0, 1\}^* \), если на входе \( x \) алгоритм выдает результат 1 (\( A(x) = 1 \)). Алгоритм \( A \) отвергает (rejects) слово \( x \), если \( A(x) = 0 \). (Заметим, что алгоритм может не остановиться на входе \( x \) или дать ответ, отличный от 0 и 1. В этом случае он и не допускает, и не отвергает слово \( x \).) Алгоритм \( A \) допускает (accepts) язык \( L \), если алгоритм допускает те и только те слова, которые принадлежат языку \( L \).

Алгоритм \( A \), допускающий некоторый язык \( L \), не обязан отвергать всякое слово \( x \notin L \). Если алгоритм допускает все слова из \( L \), а все остальные слова отвергает, говорят, что что \( A \) распознаёт (decides) язык \( L \). Язык \( L \) допускается за полиномиальное время (is accepted in polynomial time), если имеется алгоритм \( A \), который допускает данный язык, причем всякое слово \( x \in L \) допускается алгоритмом за время \( O(n^k) \), где \( n \) — длина слова \( x \), а \( k \) — некоторое не зависящее от \( x \) число. Язык \( L \) называется распознаётся за полиномиальное время (is decided in polynomial time), если некоторый алгоритм \( A \) распознаёт данный язык, причем время работы алгоритма на каждом слове длины \( n \) не больше \( O(n^k) \).

Рассмотренный нами язык PATH допускается за полиномиальное время. Нетрудно построить алгоритм, который методом поиска в ширину за полиномиальное время находит кратчайший путь между вершинами \( u \) и \( v \) в графе \( G \), а затем сравнивает длину найденного пути с данным в условии числом \( k \). Если длина пути не превосходит \( k \), алгоритм выдаёт 1 и останавливается.