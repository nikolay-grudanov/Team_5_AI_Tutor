---
source_image: page_308.png
page_number: 308
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 53.08
tokens: 11511
characters: 2124
timestamp: 2025-12-24T06:34:39.743899
finish_reason: stop
---

Как только свойство оптимальности для подзадач установлено, обычно становится ясно, с каким именно множеством подзадач будет иметь дело алгоритм. Например, для задачи о перемножении последовательности матриц подзадачами будут задачи о перемножении кусков этой последовательности.

Перекрывающиеся подзадачи

Второй свойство задач, необходимое для использования динамического программирования, — малость множества подзадач. Благодаря этому при рекурсивном решении задачи мы всё время выходим на одни и те же подзадачи. В таком случае говорят, что у оптимизационной задачи имеются перекрывающиеся подзадачи (overlapping subproblems). В типичных случаях количество подзадач полиномиально зависит от размера исходных данных.

В задачах, решаемых методом "разделяй и властвуй", так не бывает: для них рекурсивный алгоритм, как правило, на каждом шаге порождает совершенно новые подзадачи. Алгоритмы, основанные на динамическом программировании, используют перекрытие подзадач следующим образом: каждая из подзадач решается только один раз, и ответ заносится в специальную таблицу; когда эта же подзадача встречается снова, программа не тратит время на её решение, а берёт готовый ответ из таблицы.

Вернёмся для примера к задаче о перемножении последовательности матриц. Из рисунка 16.1 видно, что решение каждой из подзадач, записанное в данной клеточке таблицы, многократно используется процедурой MATRIX-CHAIN-ORDER при решении подзадач из расположенных выше клеточек. Например, m[3, 4] используется четырежды: при вычислении m[2, 4], m[1, 4], m[3, 5] и m[3, 6]. Было бы крайне неэффективно вычислять m[3, 4] всякий раз заново. В самом деле, рассмотрим следующий (неэффективный) рекурсивный алгоритм, основанный непосредственно на соотношениях (16.2) и вычисляющий m[i, j] — минимальное количество умножений, необходимое для вычисления \( A_{i..j} = A_i A_{i+1} \ldots A_j \):

RECURSIVE-MATRIX-CHAIN(p, i, j)
1 if i = j
2 then return 0
3 m[i, j] ← ∞
4 for k ← i to j − 1
5 do q ← RECURSIVE-MATRIX-CHAIN(p, i, k) +
   + RECURSIVE-MATRIX-CHAIN(p, k + 1, j) + p_{i-1} p_k p_j
6 if q < m[i, j]
7 then m[i, j] ← q
8 return m[i, j]