---
source_image: page_325.png
page_number: 325
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 48.15
tokens: 11395
characters: 1798
timestamp: 2025-12-24T06:35:28.102697
finish_reason: stop
---

17 Жадные алгоритмы

Для многих оптимизационных задач есть более простые и быстрые алгоритмы, чем динамическое программирование. В этой главе мы рассматриваем задачи, которые можно решать с помощью жадных алгоритмов (greedy algorithms). Такой алгоритм делает на каждом шаге локально оптимальный выбор, — в надежде, что итоговое решение также окажется оптимальным. Это не всегда так — но для многих задач такие алгоритмы действительно дают оптимум. Наш первый пример — простая, но не вполне тривиальная задача о выборе заявок (раздел 17.1). Далее (раздел 17.2) мы обсуждаем, для каких задач годятся жадные алгоритмы. В разделе 17.3 рассказывается о сжатии информации с помощью кодов Хаффмена, которые строятся жадным алгоритмом. Раздел 17.4 посвящён так называемым матроидам — комбинаторным объектам, связанным с жадными алгоритмами. Наконец, в разделе 17.5 мы применяем матроиды к задаче о расписании для заказов равной длительности со сроками и штрафами.

В следующих главах мы не раз встретимся с жадными алгоритмами (задача о минимальном покрывающем дереве, алгоритм Дейкстры поиска кратчайших путей из данной вершины, жадная эвристика Хватала для задачи о покрытии множества и другие). Минимальные покрывающие деревья — классический пример использования жадного алгоритма, так что параллельно с этой главой можно читать главу 24.

17.1 Задача о выборе заявок

Пусть даны n заявок на проведение занятий в одной и той же аудитории. Два разных занятия не могут перекрываться по времени. В каждой заявке указаны начало и конец занятия (s_i и f_i для i-й заявки). Разные заявки могут пересекаться, и тогда можно удовлетворить только одну из них. Мы отождествляем каждую заявку с промежутком [s_i, f_i), так что конец одного занятия может совпадать с началом другого, и это не считается пересечением.