---
source_image: page_447.png
page_number: 447
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 63.60
tokens: 11622
characters: 2416
timestamp: 2025-12-24T06:41:34.729839
finish_reason: stop
---

1, 2, 4, 16, 65536, ..., большему \( k \) (каждый член последовательности есть двойка в степени предыдущего члена). Тогда на каждом пути будет не более \( \lg^* n \) шагов, на которых ранг сильно растёт, а ряд \( \sum \beta(k)/2^k \) сходится, но имеет достаточно медленно растущие частичные суммы.]

Из доказанной теоремы и леммы 22.6 немедленно вытекает

Следствие 22.8

Предположим, что над системой непересекающихся множеств (изначально пустой) произвели \( m \) операций Make-Set, Find-Set и Union, \( n \) из которых — Make-Set. Тогда при использовании реализации с помощью леса со сжатием путей и объединением по рангам стоимость этой последовательности операций есть \( O(m \lg^* n) \).

Упражнения
22.4-1
Докажите лемму 22.2.
22.4-2
Сколько битов нужно, чтобы хранить \( size[x] \) для узла \( x \)? Тот же вопрос для \( rank[x] \).
22.4-3
Пользуясь леммой 22.2 и следствием 22.5, докажите, что стоимость \( m \) операций с лесом непересекающихся множеств с использованием объединения по рангам, но без сжатия путей, есть \( O(m \lg n) \), где \( n \), как обычно, обозначает количество операций Make-Set.
22.4-4*
Объясните, почему последние шаги путей требовали в нашем рассуждении особого рассмотрения (а на классифицировались в зависимости от роста ранга, как все остальные): приведите пример ситуации, в которой некоторая вершина \( x \) входит \( \Omega(m) \) раз в путь поиска для операции Find-Set, причём при выходе из неё ранг растёт не сильно. (Как видно из доказательства, это возможно лишь если она по большей части является предпоследней вершиной пути.)

Задачи
22-1 Поиск минимума в режиме off-line.
Задача о поиске минимума в режиме off-line (off-line minimum problem) состоит в следующем. Пусть имеется динамическое множество \( T \), поддерживающее операции Insert\((x)\) (добавить элемент \( x \)) и Extract-Min (удалить минимальный элемент). Первоначально множество \( T \) пусто, затем выполняется некоторая последовательность из \( n \) операций Insert и \( m \) операций Extract-Min, причем операции Insert добавляют в множество по одному разу все натуральные числа от 1 до \( n \) (не обязательно в порядке возрастания). Требуется по данной последовательности операций Insert\((x)\) и Extract-Min создать массив extracted\[1..m\], в котором extracted\[i\] — число, возвращаемое \( i \)-ой по счёту операцией Extract-Min.

Говоря о "режиме off-line", имеют в виду, что от нас требуется