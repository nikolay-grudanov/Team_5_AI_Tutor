---
source_image: page_314.png
page_number: 314
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 66.03
tokens: 11644
characters: 2101
timestamp: 2025-12-24T06:35:08.174210
finish_reason: stop
---

НОП для \( X_{m-1} \) и \( Y \), а затем найти НОП для \( X \) и \( Y_{n-1} \). Более длинная из них и будет служить НОП для \( X \) и \( Y \).

Теперь сразу видно, что возникает перекрытие подзадач. Действительно, чтобы найти НОП \( X \) и \( Y \), нам может понадобиться найти НОП \( X_{m-1} \) и \( Y \), а также НОП \( X \) и \( Y_{n-1} \); каждая из этих задач содержит подзадачу нахождения НОП для \( X_{m-1} \) и \( Y_{n-1} \). Аналогичные перекрытия будут встречаться и далее.

Как и в задаче перемножения последовательности матриц, мы начнём с рекуррентного соотношения для стоимости оптимального решения. Пусть \( c[i, j] \) обозначает длину НОП для последовательностей \( X_i \) и \( Y_j \). Если \( i \) или \( j \) равно нулю, то одна из двух последовательностей пуста, так что \( c[i, j] = 0 \). Сказанное выше можно записать так:

\[
c[i, j] = \begin{cases}
0 & \text{если } i = 0 \text{ или } j = 0, \\
c[i-1, j-1] + 1 & \text{если } i, j > 0 \text{ и } x_i = y_j, \\
\max(c[i, j-1], c[i-1, j]) & \text{если } i, j > 0 \text{ и } x_i \neq y_j.
\end{cases}
\]

Вычисление длины НОП

Исходя из соотношения (16.5), легко написать рекурсивный алгоритм, работающий экспоненциальное время и вычисляющий длину НОП двух данных последовательностей. Но поскольку различных подзадач всего \( \Theta(mn) \), лучше воспользоваться динамическим программированием.

Исходными данными для алгоритма LCS-LENGTH служат последовательности \( X = \langle x_1, x_2, \ldots, x_m \rangle \) и \( Y = \langle y_1, y_2, \ldots, y_n \rangle \). Числа \( c[i, j] \) записываются в таблицу \( c[0..m, 0..n] \) в таком порядке: сначала заполняется слева направо первая строка, затем вторая, и т. д. Кроме того, алгоритм запоминает в таблице \( b[1..m, 1..n] \) "происхождение" \( c[i, j] \): в клетку \( b[i, j] \) заносится стрелка, указывающая на клетку с координатами \( (i-1, j-1) \), \( (i-1, j) \) или \( (i, j-1) \), в зависимости от того, равно ли \( c[i, j] \) числу \( c[i-1, j-1] + 1 \), \( c[i-1, j] \) или \( c[i, j-1] \) (см. (16.5)). Результатами работы алгоритма являются таблицы \( c \) и \( b \).