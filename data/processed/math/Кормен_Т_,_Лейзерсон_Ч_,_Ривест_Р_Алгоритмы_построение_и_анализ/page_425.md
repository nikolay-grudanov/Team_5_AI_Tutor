---
source_image: page_425.png
page_number: 425
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 68.09
tokens: 11616
characters: 2445
timestamp: 2025-12-24T06:40:36.925378
finish_reason: stop
---

**Cascading-Cut(H, y)**

1 \( z \leftarrow p[y] \)
2 **if** \( z \neq \text{NIL} \)
3 **then if** \( mark[y] = \text{FALSE} \)
4 **then** \( mark[y] \leftarrow \text{TRUE} \)
5 **else** \( \text{Cut}(H, y, z) \)
6 \( \text{Cascading-Cut}(H, z) \)

Процедура *Fib-Heap-Decrease-Key* работает так. Сначала (строки 1–3) проверяется, действительно ли новое значение ключа меньше старого. Если да, то старое значение заменяется на новое. Возможно, новое значение по-прежнему больше значения в вершине-родителе, тогда всё в порядке. Если же нет, то в строках 6–7 поддерево с корнем \( x \) вырезается и переносится в корневой список с помощью процедур "каскадного вырезания".

Идея тут проста: мы не хотим позволять вершине всплывать до корня (напомним: нам нужна оценка \( O(1) \) для учётной стоимости). Приходится её вырезать целиком и помещать в корневой список. От этого растёт потенциал, но всего на \( O(1) \), так что это не страшно. Но мы должны следить за структурой дерева, поскольку хотим иметь логарифмическую оценку на максимальную степень вершины (\( D(n) = O(\lg n) \)). Забегая вперёд, отметим, что высота дерева не обязана быть логарифмической (см. упр. 21.4-1).

Мы будем следить, чтобы у одной и той же вершины, не входящей в корневой список, не удалялось несколько детей. Для этого используются пометки (поле \( mark \)): после удаления ребёнка (перенесения его в корневой список с помощью процедуры Cut) вершина делается отмеченной, если она ранее не была отмеченной и не была корнем (строки 3–4 процедуры Cascading-Cut). Если же вершина, у которой удалён ребёнок, уже была отмеченной, то она сама переносится в корневой список, а для её родителя повторяется та же процедура.

После выполнения операций вырезания остаётся только скорректировать атрибут \( min[H] \). Заметим, что минимальной может быть либо вершина с уменьшенным ключом, либо прежняя минимальная вершина.

Таким образом, жизненный цикл вершины выглядит так. Сначала она добавляется в дерево, попадая в его корневой список. При выполнении операции Consolidate деревья в корневом списке объединяются. При этом вершина может либо остаться в корневом списке, приобретя нового ребёнка (если её ключ меньше ключа другой вершины, с которой она объединяется), либо стать ребёнком другой вершины корневого списка. Вершина корневого списка может не только приобретать детей, но и терять их (процедура Cut); отметим, что при этом она не становится помеченной (строка 4 про-