---
source_image: page_624.png
page_number: 624
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 43.22
tokens: 11542
characters: 2243
timestamp: 2025-12-24T06:49:42.397264
finish_reason: stop
---

29.4.2 Характеристики схемы

Как мы говорили, тактовая частота зависит от задержки в схеме из функциональных элементов (в данном случае — задержки в элементе суммирования FA), поскольку все вычисления должны закончиться до начала следующего тактового импульса. В данном случае сумматор имеет глубину \( \Theta(1) \), а для получения всех выходов необходимо \( n+1 \) периодов, так что общее время работы составляет \( (n+1)\Theta(1) = \Theta(n) \). Размер схемы равен \( \Theta(1) \).

29.4.3 Каскадное сложение и побитовое сложение

Каскадный сумматор можно рассматривать как развёрнутую схему устройства побитового сложения: теперь за каждый период между импульсами отвечает свой сумматор.

Такое развёртывание, заменяющее время пространством, можно сделать для любой тактированной схемы, соединяя несколько экземпляров схемы (столько, сколько тактов требуется её работа).

Конечно, при этом увеличивается число элементов — зато не нужны синхронизирующие импульсы от тактового генератора. Такая схема на практике работает несколько быстрее, поскольку в тактированной схеме на каждом такте нужно оставлять некоторый запас времени (чтобы вычисления успели произойти), а после развёртывания выходы каскада сразу же попадают на входы следующего, ничего не ожидая.

29.4.4 Одномерный умножитель

Матричный умножитель, рассмотренный в разделе 29.3, имеет размер \( \Theta(n^2) \). В этом разделе мы рассмотрим два тактированных умножителя, использующих одномерный массив элементов (размера \( \Theta(n) \)) вместо двумерного. Более быстрый из них имеет время работы \( \Theta(n) \) (как и матричный умножитель)

Оба этих умножителя используют алгоритм, который в Америке называют русским народным алгоритмом умножения (Russian peasant’s algorithm). Он показан на рис. 29.18 (a). Сомножители \( a \) и \( b \) записываются рядом, и под каждым из них пишется колонка чисел. В левой колонке число на каждом шаге делится на 2 (остаток отбрасывается); в правой — умножается на 2. Так продолжается до тех пор, пока в левой колонке не будет 1. После этого складываются числа из правой колонки, стоящие напротив нечётных чисел в левой.

На первый взгляд этот алгоритм кажется удивительным, но он становится понятным, если записать все числа в двоичной си-