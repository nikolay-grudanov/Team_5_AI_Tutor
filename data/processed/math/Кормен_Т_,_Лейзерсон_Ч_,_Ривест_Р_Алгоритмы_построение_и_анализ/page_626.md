---
source_image: page_626.png
page_number: 626
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 60.76
tokens: 11773
characters: 2454
timestamp: 2025-12-24T06:50:09.881718
finish_reason: stop
---

Тактированные схемы

После n шагов получаем \( a^{(n)} = 0 \), поэтому инвариант гарантирует, что \( p^{(n)} = a \cdot b \).

Наш алгоритм требует n шагов. Если на каждом шаге использовать для сложения каскадный сумматор, то каждый шаг занимает время \( \Theta(n) \), поэтому общее время работы составляет \( \Theta(n^2) \). Схема состоит из 3n регистров, каскадного сумматора размера \( \Theta(n) \) и \( O(n) \) элементов, формирующих частичные произведения (операция AND над \( a_0^{(j)} \) и b-битами). Общий размер схемы равен \( \Theta(n) \).

Рисунок 29.19 29.19 Два одномерных умножителя. Показано умножение 5-битовых чисел \( a = 19 = \langle 10011 \rangle \) на \( b = 29 = \langle 11101 \rangle \) и содержимое регистров перед каждым шагом; значащие биты выделены серым цветом. (a) Простой умножитель (время работы \( \Theta(n^2) \)). На каждом шаге используется каскадный сумматор, поэтому интервал между тактами должен быть не меньше \( \Theta(n) \). (b) Быстрый умножитель, использующий сложение с запоминанием переносов. Каждый шаг требует времени \( \Theta(1) \). Всего требуется \( 2n - 1 = 9 \) шагов, показаны первые 5. (После этого остаются сложить u и v, для чего достаточно продолжить тот же процесс сложения с запоминанием переносов.)

29.4.6 Быстрая реализация

Уменьшения времени работы можно добиться, используя вместо каскадного сложения сложение с запоминанием переносов (см. рис. 29.19 (b)). Теперь вместо трёх регистров на каждый разряд будут четыре; в двух из них по-прежнему хранятся цифры чисел a и b, а вместо числа p будет храниться два числа u и v, причём поддерживается инвариант

\[
a^{(j)} \cdot b^{(j)} + u^{(j)} + v^{(j)} = a \cdot b \text{ eqno}(29.7)
\]

так что роль p играет сумма \( u + v \) (см. упражнение 29.4-2). Вначале \( u^{(0)} = v^{(0)} = 0 \). (Это соответствует использованию алгоритма сложения с запоминанием переносов для хранения промежуточных результатов: на каждом шаге к сумме \( u + v \) надо добавить очередное частичное произведение, т. е. надо сложить три числа — и получить ответ в виде суммы двух.)

Шаг алгоритма включает сдвиги a и b (как и в медленном алгоритме), а также изменение u и v. Если \( a_0^{(j)} = 1 \), то

\[
u_i^{(j+1)} = parity(b_i^{(j)}, u_i^{(j)}, v_i^{(j)})
\]

при \( i = 0, 1, 2, \ldots, 2n - 1 \) и

\[
v_i^{(j+1)} = \begin{cases}
majority(b_{i-1}^{(j)}, u_{i-1}^{(j)}, v_{i-1}^{(j)}) & \text{если } 1 \leq i \leq 2n - 1 \\
0 & \text{если } i = 0
\end{cases}
\]