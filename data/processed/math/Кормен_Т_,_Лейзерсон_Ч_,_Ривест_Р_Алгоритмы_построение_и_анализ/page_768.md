---
source_image: page_768.png
page_number: 768
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 59.85
tokens: 11749
characters: 2426
timestamp: 2025-12-24T06:56:32.483796
finish_reason: stop
---

Разработайте полиномиальный алгоритм, выясняющий, входит ли данный образец (с символами пропуска) в данный текст.

34.2 Алгоритм Рабина — Карпа

Рабин и Карп изобрели алгоритм поиска подстрок, который эффективен на практике и к тому же обобщается на другие аналогичные задачи (например, поиск образца на двумерной решётке). Хотя в худшем случае время работы алгоритма Рабина-Карпа есть \( \Theta((n - m + 1)m) \), в среднем он работает достаточно быстро.

Предположим для начала, что \( \Sigma = \{0, 1, 2, \ldots, 9\} \) (в общем случае можно считать, что каждый символ в алфавите \( \Sigma \) есть \( d \)-ичная цифра, где \( d = |\Sigma| \)). Тогда строку из \( k \) символов можно рассматривать как десятичную запись числа (\( k \)-значного), а сами символы — как цифры.

Если \( P[1..m] \) — образец, то через \( p \) обозначим число, десятичной записью которого он является; аналогично, если \( T[1..n] \) — текст, то для \( s = 0, 1, \ldots, n - m \) обозначим через \( t_s \) число, десятичной записью которого является строка \( T[s+1..s+m] \). Очевидно, \( s \) является допустимым сдвигом тогда и только тогда, когда \( t_s = p \). Если бы мы могли вычислить \( p \) за время \( O(m) \) и все \( t_i \) за время \( O(n) \) (временно закроем глаза на то обстоятельство, что эти вычисления могут привести к слишком большим числам), то мы смогли бы найти все допустимые сдвиги за время \( O(n) \), сравнивая \( p \) со всеми \( t_s \) по очереди.

Вычислить \( p \) за время \( O(m) \) действительно можно, по схеме Горнера (разд. 32.1):

\[
p = P[m] + 10(P[m-1] + 10(P[m-2] + \cdots + 10(P[2] + 10P[1]) \ldots)).
\]

Точно так же за время \( O(m) \) можно вычислить \( t_0 \).

Чтобы вычислить \( t_1, t_2, \ldots, t_{n-m} \) за время \( O(n - m) \), заметим, что при известном \( t_s \) можно вычислить \( t_{s+1} \) за время \( O(1) \). В самом деле,

\[
t_{s+1} = 10(t_s - 10^{m-1}T[s+1]) + T[s+m+1] : \tag{34.1}
\]

чтобы получить строку \( T[s+2..s+m+1] \) из \( T[s+1..s+m] \), надо удалить \( T[s+1] \) (то есть вычесть \( 10^{m-1}T[s+1] \) из \( t_s \)) и приписать справа \( T[s+m+1] \) (то есть умножить полученную разность на 10 и прибавить к ней \( T[s+m+1] \)). Если вычислить константу \( 10^{m-1} \) заранее (с помощью техники, описанной в разд. 33.6, это можно сделать за время \( O(\lg m) \); впрочем, оценка не ухудшится, если непосредственно перемножить \( m - 1 \) десятку за время \( O(m) \)), то