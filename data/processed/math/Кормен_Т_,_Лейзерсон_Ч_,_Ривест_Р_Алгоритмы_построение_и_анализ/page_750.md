---
source_image: page_750.png
page_number: 750
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 53.43
tokens: 11564
characters: 2090
timestamp: 2025-12-24T06:55:40.795058
finish_reason: stop
---

Проверка чисел на простоту

имеется всего 255. (В упр. 33.8-2 мы укажем одну из причин, по которым таких чисел мало.)

Сейчас мы исправим наш тест так, чтобы даже числа Кармайкла не смогли ввести его в заблуждение.

Вероятностный тест Миллера — Рабина
Этот вероятностный алгоритм проверки простоты числа получается из процедуры PSEUDOPRIME двумя принципиальными усовершенствованиями.

• Тест Миллера — Рабина проверяет соотношение (33.42) для нескольких значений \( a \).

• Вычисляя степень \( a \), фигурирующую в сравнении (33.42), тест по ходу вычисления проверят, не обнаружился ли нетривиальный корень из 1 по модулю \( n \). Если да, тест немедленно прекращает работу и сообщает, что число \( n \) — составное (следствие 33.35).

Процедура Miller-Rabin, приведённая ниже, ниже, получает на вход нечётное число \( n > 2 \) (простоту которого мы хотим проверить) и и целое положительное число \( s \), определяющее, сколько итераций надо провести (чем больше \( s \), тем меньше вероятность ошибки). Тест использует генератор случайных чисел RANDOM (см. раздел 8.3); процедура RANDOM(1, \( n - 1 \)) возвращает случайное целое число \( a \), равномерно распределённое на отрезке \( 1 \leq a \leq n - 1 \).

Тест использует процедуру WITNESS: WITNESS(\( a, n \)) истинно, если \( a \) является "свидетелем" того, что число \( n \) составное.

Witness(a,n)
1 пусть \( \langle b_k, b_{k-1}, \ldots, b_0 \rangle \) --- двоичная запись $n-1$
2 d \gets 1
3 for i \gets k downto 0
4   do x \gets d
5     d \gets (d \cdot d) \bmod n
6     if d=1 и $x \neq 1$ и $x \neq n-1$
7       then return true
8     if b_i=1
9       then d \gets (d \cdot a) \bmod n
10    if d \neq 1
11      then return true
12 return false

Вот как происходит эта проверка. В строке 1 число \( n-1 \) переводится в двоичную систему. Это представление нужно, чтобы вычислять \( a^{n-1} \mod n \) методом повторного возведения в квадрат (строки 3–9). Это делается тем же способом, что и в процедуре MODULAR-EXPONENTATION, но заодно в строках 6–7 проверяется, не наткнулись ли мы на нетривиальный корень из 1. Если наткну-