---
source_image: page_228.png
page_number: 228
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 65.42
tokens: 11667
characters: 2403
timestamp: 2025-12-24T06:31:02.338832
finish_reason: stop
---

Дит к выводу, что значение

\[
A \approx (\sqrt{5} - 1)/2 = 0,6180339887 \ldots
\]

является довольно удачным.

В заключение приведём пример: если \( k = 123456, m = 10000 \) и \( A \) определено формулой (12.2), то

\[
\begin{align*}
h(k) &= \lfloor 10000 \cdot (123456 \cdot 0,61803 \ldots \bmod 1) \rfloor = \\
&= \lfloor 10000 \cdot (76300,0041151 \ldots \bmod 1) \rfloor = \\
&= \lfloor 10000 \cdot 0,0041151 \ldots \rfloor = \\
&= \lfloor 41,151 \ldots \rfloor = 41.
\end{align*}
\]

12.3.3 Универсальное хеширование

Если недоброжелатель будет специально подбирать данные для хеширования, то (знай функцию \( h \)) он может устроить так, что все \( n \) ключей будут соответствовать одной позиции в таблице, в результате чего время поиска будет равно \( \Theta(n) \). Любая фиксированная хеш-функция может быть дискредитирована таким образом. Единственный выход из положения — выбирать хеш-функцию случайным образом, не зависящим от того, какие именно данные вы хешируете. Такой подход называется универсальным хешированием (universal hashing). Что бы ни предпринимал ваш недоброжелатель, если он не имеет информации о выбранной хеш-функции, среднее время поиска останется хорошим.

Основная идея универсального хеширования — выбирать хеш-функцию во время исполнения программы случайным образом из некоторого множества. Стало быть, при повторном вызове с теми же входными данными алгоритм будет работать уже по-другому. Как и в случае с алгоритмом быстрой сортировки, рандомизация гарантирует, что нельзя придумать входных данных, на которых алгоритм всегда бы работал медленно (в примере с компилятором и таблицей символов не сможет получиться, что какой-то определённый стиль выбора идентификаторов приводит к замедлению компиляции: вероятность, что компиляция замедлится из-за неудачного хеширования, во-первых, мала, и во-вторых, зависит только от количества идентификаторов, но не от их выбора).

Пусть \( \mathcal{H} \) — конечное семейство функций, отображающих данное множество \( U \) (множество всевозможных ключей) во множество \( \{0, 1, \ldots, m-1\} \) (множество хеш-значений). Это семейство называется универсальным (universal), если для любых двух ключей \( x, y \in U \) число функций \( h \in \mathcal{H} \), для которых \( h(x) = h(y) \), равно \( |\mathcal{H}|/m \). Иными словами, при случайном выборе хеш-функции вероятность коллизии между двумя данными ключами должна рав-