---
source_image: page_017.png
page_number: 17
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 55.99
tokens: 11298
characters: 1426
timestamp: 2025-12-24T06:20:16.703255
finish_reason: stop
---

sorted sequence — отсортированная последовательность
merge — слияние
initial sequence — начальная последовательность

Рисунок 1.3 Сортировка слиянием для массива \( A = \langle 5, 2, 4, 6, 1, 3, 2, 6 \rangle \).

Merge-Sort\((A, p, r)\)
1 if \( p < r \)
2 then \( q \leftarrow \lfloor (p + r) / 2 \rfloor \)
3 Merge-Sort\((A, p, q)\)
4 Merge-Sort\((A, q + 1, r)\)
5 Merge\((A, p, q, r)\)

Весь массив теперь можно отсортировать с помощью вызова Merge-Sort\((A, 1, length[A])\). Если длина массива \( n = length[A] \) есть степень двойки, то в процессе сортировки произойдёт слияние пар элементов в отсортированные участки длины 2, затем слияние пар таких участков в отсортированные участки длины 4 и так далее до \( n \) (на последнем шаге соединяются два отсортированных участка длины \( n/2 \)). Этот процесс показан на рис. 1.3.

1.3.2 Анализ алгоритмов типа "разделяй и властвуй"

Как оценить время работы рекурсивного алгоритма? При подсчёте мы должны учесть время, затрачиваемое на рекурсивные вызовы, так что получается некоторое рекуррентное соотношение (recurrence equation). Далее следует оценить время работы, исходя из этого соотношения.

Вот примерно как это делается. Предположим, что алгоритм разбивает задачу размера \( n \) на \( a \) подзадач, каждая из которых имеет в \( b \) раз меньший размер. Будем считать, что разбиение требует времени \( D(n) \), а соединение полученных решений — времени \( C(n) \).