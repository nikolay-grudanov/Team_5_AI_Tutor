---
source_image: page_277.png
page_number: 277
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 50.22
tokens: 11498
characters: 2151
timestamp: 2025-12-24T06:33:11.201178
finish_reason: stop
---

Задачи к главе 14

ноты" вершины цвета c, считая count(c) равным 0 для красной вершины и 1 для чёрной.

14.4-6 Предположим, что вершина вставлена в красно-чёрное дерево, а потом сразу же удалена. Будет ли получившееся дерево совпадать с исходным? Почему?

Задачи

14-1 Динамические множества с сохранением предыдущих версий
Иногда полезно сохранять предыдущие версии меняющегося множества. (Такие структуры данных называются по-английски persistent data structures.) Можно, конечно, копировать множество каждый раз, когда оно изменяется. Но такой подход требует много памяти и времени — и есть способы, позволяющие сделать это более эффективно.
Мы хотим предусмотреть возможность хранения предыдущих версий для множества S с операциями INSERT, DELETE и SEARCH. Мы считаем, что множество S реализовано с помощью двоичных деревьев поиска, как показано на рис. 14.8а. Для каждой версии множества мы храним свой отдельный корень. Чтобы добавить ключ 5, мы создаём новую вершину с этим ключом. Эта вершина становится левым ребёнком новой вершины с ключом 7, так как существующую вершину менять нельзя. Подобным образом новая вершина с ключом 7 становится левым ребёнком новой вершины с ключом 8, правый ребёнок которой — существующая вершина с ключом 10. В свою очередь, новая вершина с ключом 8 становится правым ребёнком нового корня r' с ключом 4, левый ребёнок которого — существующая вершина с ключом 3. Таким образом, мы копируем лишь часть дерева, а в остальном используем старое, как это показано на рис. 14.8б.
Мы предполагаем, что вершины дерева содержат поля key, left и right, но не содержат поля p, указывающего на родителя. (См. также упр. 14.3-6.)
а Покажите, какие вершины хранимого таким образом дерева должны быть изменены (созданы) в общем случае при добавлении или удалении элемента.
б Напишите процедуру PERSISTENT-TREE-INSERT, которая добавляет ключ k в дерево T.
в Если высота дерева равна h, сколько времени и памяти требует написанная вами процедура? (Количество памяти можно измерять количеством новых вершин.)
г Пусть мы используем и поля p в вершинах дерева. В этом случае процедура PERSISTENT-TREE-INSERT должна будет выполнить