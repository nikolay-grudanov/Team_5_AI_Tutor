---
source_image: page_012.png
page_number: 12
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 95.24
tokens: 11699
characters: 2465
timestamp: 2025-12-24T06:20:55.947096
finish_reason: stop
---

только размер массива, но и порядок его элементов: если массив почти упорядочен, то времени требуется меньше.)

Как измерять размер входа (input size)? Это зависит от конкретной задачи. В одних случаях разумно считать число элементов на входе (сортировка, преобразование Фурье). В других более естественно считать общее число битов, необходимое для представления всех входных данных. Иногда размер входа измеряется не одним числом, а несколькими (например, число вершин и число рёбер графа).

Временем работы (running time) алгоритма мы называем число элементарных шагов, которые он выполняет — вопрос только в том, что считать элементарным шагом. Мы будем полагать, что одна строка псевдокода требует не более чем фиксированного числа операций (если только это не словесное описание какой-то сложной операции — типа "отсортировать все точки по x-координате"). Мы будем различать также вызов (call) процедуры (на который уходит фиксированное число операций) и её исполнение (execution), которое может быть долгим.

Итак, вернёмся к процедуре INSERTION-SORT и отметим около каждой строки её стоимость (число операций) и число раз, которое эта строка исполняется. Для каждого j от 2 до n (здесь n = length[A] — размер массива) подсчитаем, сколько раз будет исполнена строка 5, и обозначим это число через t_j. (Заметим, что строки внутри цикла выполняются на один раз меньше, чем проверка, поскольку последняя проверка выводит из цикла.)

INSERTION-SORT(A)

<table>
  <tr>
    <th>1</th>
    <td>for j ← 2 to length[A]</td>
    <th>c_1</th>
    <td>n</td>
  </tr>
  <tr>
    <th>2</th>
    <td>do key ← A[j]</td>
    <th>c_2</th>
    <td>n − 1</td>
  </tr>
  <tr>
    <th>3</th>
    <td>▷ добавить A[j] к отсортированной части A[1..j − 1].</td>
    <th>0</th>
    <td>n − 1</td>
  </tr>
  <tr>
    <th>4</th>
    <td>i ← j − 1</td>
    <th>c_4</th>
    <td>n − 1</td>
  </tr>
  <tr>
    <th>5</th>
    <td>while i > 0 and A[i] > key</td>
    <th>c_5</th>
    <td>\( \sum_{j=2}^{n} t_j \)</td>
  </tr>
  <tr>
    <th>6</th>
    <td>do A[i + 1] ← A[i]</td>
    <th>c_6</th>
    <td>\( \sum_{j=2}^{n} (t_j − 1) \)</td>
  </tr>
  <tr>
    <th>7</th>
    <td>i ← i − 1</td>
    <th>c_7</th>
    <td>\( \sum_{j=2}^{n} (t_j − 1) \)</td>
  </tr>
  <tr>
    <th>8</th>
    <td>A[i + 1] ← key</td>
    <th>c_8</th>
    <td>n − 1</td>
  </tr>
</table>

Строка стоимости c, повторённая m раз, даёт вклад cm в общее число операций. (Для количества использованной памяти этого ска-