---
source_image: page_482.png
page_number: 482
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 60.42
tokens: 11644
characters: 2330
timestamp: 2025-12-24T06:43:10.086701
finish_reason: stop
---

Рисунок 24.1  24.1 Минимальное покрывающее дерево. На каждом ребре графа указан вес. Выделены ребра минимального покрывающего дерева (суммарный вес 37). Такое дерево не единственно: заменяя ребро \((b, c)\) ребром \((a, h)\), получаем другое дерево того же веса 37.

двумя пересекающимися диагоналями (суммарная длина \(2\sqrt{2} < 3\)) и даже ещё короче (введя две промежуточные точки, в которых проводники сходятся под углом \(120^\circ\).)

В этой главе мы рассмотрим два способа решения задачи о минимальном покрывающем дереве: алгоритмы Крускала и Прима. Каждый из них легко реализовать с временем работы \(O(E \lg V)\), используя обычные двоичные кучи. Применив фибоначчиевы кучи, можно сократить время работы алгоритма Прима до \(O(E + V \lg V)\) (что меньше \(E + \lg V\), если \(|V|\) много меньше \(|E|\)).

Оба алгоритма (Крускала и Прима) следуют "жадной" стратегии: на каждом шаге выбирается "локально наилучший" вариант. Не для всех задач такой выбор приведёт к оптимальному решению, но для задачи о покрывающем дереве это так. (Мы обсуждали это в главе 17; задача о покрывающем дереве является превосходной иллюстрацией введённых там понятий.)

В разделе 24.1 описана общая схема алгоритма построения минимального остова (добавление рёбер одного за другим). В разделе 24.2 указаны две конкретных реализации общей схемы. Первый алгоритм, восходящий к Крускалу, аналогичен алгоритму поиска связных компонент из раздела 22.1. Другой (алгоритм Прима) аналогичен алгоритму Дейкстры поиска кратчайших путей (раздел 25.2).

24.1 Построение минимального остова

Итак, пусть дан связный неориентированный графа \(G = (V, E)\) и весовая функцией \(w : E \to \mathbb{R}\). Мы хотим найти минимальное покрывающее дерево (остов), следуя жадной стратегии.

Общая схема всех наших алгоритмов будет такова. Искомый остов строится постепенно: к изначально пустому множеству \(A\) на каждом шаге добавляется одно ребро. Множество \(A\) всегда является подмножеством некоторого минимального остова. Ребро \((u, v)\), добавляемое на очередном шаге, выбирается так, чтобы не нарушить этого свойства: \(A \cup \{(u, v)\}\) тоже должно быть подмножеством минимального остова. Мы называем такое ребро *безопасным ребром* (safe edge) для \(A\).

\textsc{Generic-MST} $(G, w)$
1 $A \leftarrow \emptyset$
2 {\bf while} $A$ не является остовом