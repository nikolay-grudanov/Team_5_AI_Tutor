---
source_image: page_217.png
page_number: 217
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 47.81
tokens: 11349
characters: 1814
timestamp: 2025-12-24T06:30:17.307892
finish_reason: stop
---

12 Хеш-таблицы

Часто бывают нужны динамические множества, поддерживающие только "словарные операции" добавления, поиска и удаления элемента. В этом случае часто применяют так называемое хеширование; соответствующая структура данных называется "хеш-таблица" (или "таблица рассстановки"). В худшем случае поиск в хеш-таблице может занимать столько же времени, сколько поиск в списке (\( \Theta(n) \)), но на практике хеширование весьма эффективно. При выполнении некоторых естественных условий математическое ожидание времени поиска элемента в хеш-таблице есть \( O(1) \).

Хеш-таблицу можно рассматривать как обобщение обычного массива. Если у нас достаточно памяти для массива, число элементов которого равно числу всех возможных ключей, для каждого возможного ключа можно отвести ячейку в этом массиве и тем самым иметь возможность добраться до любой записи за время \( O(1) \) ("прямая адресация", см. разд. 12.1). Однако если реальное количество записей значительно меньше, чем количество возможных ключей, то эффективнее применить хеширование: вычислять позицию записи в массиве, исходя из ключа. В разделе 12.2 обсуждаются основные идеи, а в разделе 12.3 — конкретные способы такого вычисления. В этой главе представлено несколько вариантов хеширования.

Мы увидим, что хеширование — эффективный и удобный способ выполнять основные словарные операции (среднее время \( O(1) \) при некоторых предположениях).

12.1 Прямая адресация

Прямая адресация применима, если количество возможных ключей невелико. Пусть возможными ключами являются числа из множества \( U = \{0, 1, \ldots, m - 1\} \) (число \( m \) не очень велико). Предположим также, что ключи всех элементов различны.

Для хранения множества мы пользуемся массивом \( T[0..m-1] \), называемым таблицей с прямой адресацией (direct-address table). Ка-