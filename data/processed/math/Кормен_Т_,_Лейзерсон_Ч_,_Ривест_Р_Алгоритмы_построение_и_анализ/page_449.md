---
source_image: page_449.png
page_number: 449
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 62.98
tokens: 11592
characters: 2371
timestamp: 2025-12-24T06:41:39.976402
finish_reason: stop
---

GRAFT(r, v) ("пришивка"). Вершина r должна быть корнем одного из деревьев, вершина v должна принадлежать к какому-то другому дереву; дерево с корнем r "пришивается" к дереву, содержащему v, при этом v становится родителем r.

(а) Пусть мы реализовали эту структуру данных следующим образом. Деревья представляются как в лесе непересекающихся множеств (p[v] — родитель вершины v, если v — не корень, и p[v] = v, если v — корень), процедура GRAFT(r, v) состоит в присваивании p[r] ← v, процедура MAKE-TREE написана очевидным образом, и, наконец, для нахождения глубины (FIND-DEPTH(v)) мы идем из v в корень и подсчитываем длину пути. Покажите, что при этом стоимость m операций MAKE-TREE, GRAFT и FIND-DEPTH в худшем случае есть \( \Theta(m^2) \).

Алгоритм можно ускорить, если воспользоваться объединением по рангам и сжатием путей. Заметим, что структура дерева, нужного для сжатия путей, не обязана соответствовать структуре исходного дерева — важно лишь, чтобы можно было восстанавливать информацию о глубине (ребро нового дерева должно хранить информацию о разнице глубин концов ребра в старом дереве).

(б) Реализуйте операцию MAKE-TREE.
(в) Реализуйте операцию FIND-DEPTH. Ваш алгоритм должен использовать сжатие путей, а его время работы должно быть пропорционально длине пути поиска.
(г) Реализуйте операцию GRAFT (действуйте по аналогии с алгоритмами UNION и LINK; корень в строимом дереве не обязан быть корнем в старом смысле).
(д) Дайте точную оценку на стоимость последовательности m операций MAKE-TREE, GRAFT и FIND-DEPTH, n из которых — операции MAKE-TREE (для худшего случая).

22-3 Алгоритм Тарьяна для нахождения наименьшего общего предка в режиме off-line.

Наименьший общий предок (least common ancestor, сокращённо LCA) вершин u и v корневого дерева T есть, по определению, вершина наибольшей глубины среди вершин, являющихся предками как u, так и v. Задача о нахождении наименьших общих предка в режиме off-line (off-line least-common-ancestors problem) состоит в следующем. Дано корневое дерево T и некоторое множество P неупорядоченных пар его вершин. Требуется для каждой пары вершин \((u, v) \in P\) найти их наименьшего общего предка.

Ниже приведён алгоритм LCA, решающий эту задачу (наименьшие общие предки всех пар \((u, v) \in P\) будут напечатаны в результате вызова LCA(root[T]); вначале все вершины дерева — белые).

LCA(u)
1 Make-Set(u)