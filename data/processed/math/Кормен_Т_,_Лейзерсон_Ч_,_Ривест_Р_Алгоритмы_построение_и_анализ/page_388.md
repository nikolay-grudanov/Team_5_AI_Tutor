---
source_image: page_388.png
page_number: 388
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 80.97
tokens: 11710
characters: 2684
timestamp: 2025-12-24T06:39:03.534836
finish_reason: stop
---

— минимальная степень Б-дерева. По правилам вершина Б-дерева должна содержать не меньше \( t - 1 \) ключа, так что в нашем случае имеется запасной ключ. Этот прием (следить, чтобы запасной ключ всегда был) позволяет удалить элемент, пройдя Б-дерево один раз от корня к листу и не делая шагов в обратном направлении (с единственным исключением, которое мы его разберем позже).

Договоримся, что если в результате удаления корень дерева стал пустым, то он удаляется, и его единственный ребенок становится новым корнем, при этом высота Б-дерева уменьшается на единицу, и корень уже не пуст (если только всё дерево не пусто).

На рис. 19.8 показаны разные случаи удаления элемента из Б-дерева.

1. Если ключ \( k \) находится в вершине \( x \), являющейся листом, то удаляем \( k \) из \( x \).

2. Если ключ \( k \) находится во внутренней вершине \( x \), то делаем следующее:

Если ребенок \( y \) вершины \( x \), предшествующий \( k \), содержит не менее \( t \) элементов, то находим ключ \( k' \), непосредственно предшествующий ключу \( k \). Этот ключ находится в листе поддерева с корнем в \( y \). Найти его можно за один просмотр поддерева от корня к листу. Рекурсивно вызываем процедуру: удаляем \( k' \). Заменяем в \( x \) ключ \( k \) на \( k' \).

Если ребенок \( z \), следующий за \( k \), содержит не менее \( t \) элементов, поступаем аналогично.

Если и \( y \), и \( z \) содержат по \( t - 1 \) элементу, соединяем вершину \( y \), ключ \( k \), вершину \( z \), помещая всё это в вершину \( y \), которая теперь содержит \( 2t - 1 \) ключ. Стираем \( z \) и выкидываем из \( x \) ключ \( k \) и указатель на \( z \). Рекурсивно удаляем \( k \) из \( y \).

3. Если \( x \) — внутренняя вершина, но ключа \( k \) в ней нет, найдем среди детей вершины \( x \) корень \( c_i[x] \) поддерева, где должен лежать ключ \( k \) (если этот ключ вообще есть). Если \( c_i[x] \) содержит не менее \( t \) ключей, можно рекурсивно удалить \( k \) из поддерева. Если же \( c_i[x] \) содержит всего \( t - 1 \) элемент, то предварительно сделаем шаг 3а или 3б.

Пусть вершина \( c_i[x] \) содержит \( t - 1 \) элемент, но один из её соседей (например, правый) содержит по крайней мере \( t \) элементов. (Здесь соседом мы называем такого ребенка вершины \( x \), который отделен от \( c_i[x] \) ровно одним ключом-разделителем.) Тогда добавим ребёнку \( c_i[x] \) элемент его родителя \( x \), а родителю передадим левый элемент этого соседа. При этом самый левый ребёнок соседа станет самым правым ребенком вершины \( c_i[x] \).

Пусть оба соседа вершины \( c_i[x] \) содержат по \( t - 1 \) элементу. Тогда объединим вершину \( c_i[x] \) с одним из соседей (как в случае 2в).