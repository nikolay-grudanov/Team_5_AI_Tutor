---
source_image: page_210.png
page_number: 210
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 57.78
tokens: 11404
characters: 1947
timestamp: 2025-12-24T06:30:02.464594
finish_reason: stop
---

ном участке памяти. Рассмотрим реализацию списка с помощью нескольких массивов. Перепишите процедуры Allocate-Объект и Free-Объект таким образом, чтобы элементы списка занимали позиции 1..m, где m — число элементов списка. (Указание: воспользуйтесь реализацией стека на базе массива.)

11.3-5 Пусть двусторонне связанный список L длины m представлен с помощью трех массивов key, prev и next длины n, а процедуры выделения и освобождения места поддерживают двусторонне связанный список свободных позиций.

Напишите процедуру Compactify-List (сжатие списка), которая переписывает список L длины m в первые m позиций массивов, сохраняя его структуру (и изменяя список свободных позиций нужным образом). Время работы алгоритма должно быть \( \Theta(m) \), размер используемой памяти (сверх занятой массивами) должен быть \( O(1) \). Не забудьте доказать правильность своего алгоритма.

11.4 Представление корневых деревьев

Описанные в предыдущем разделе способы представления списков применимы и к другим структурам данных, составленным из однотипных элементов. В этом разделе мы научимся использовать указатели для представления деревьев. Начнём мы с двоичных деревьев, а затем объясним, как представлять деревья с произвольным ветвлением.

Каждая вершина дерева будет записью с несколькими полями. Одно из этих полей содержит ключ, как и в случае со списками. Остальные поля предназначены для хранения дополнительных данных и, главное, указателей на другие вершины. Как конкретно устроены эти поля, зависит от типа дерева.

Двоичные деревья

Как показано на рис. 11.9, при представлении двоичного дерева T мы используем поля p, left и right, в которых хранятся указатели на родителя, левого и правого ребёнка вершины x соответственно. Если \( p[x] = NIL \), то x — корень; если у x нет левого или правого ребёнка, то left[x] или right[x] есть NIL. С деревом T связан атрибут root[T] — указатель на его корень. Если root[T] = NIL, то дерево T пусто.