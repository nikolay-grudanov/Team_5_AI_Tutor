---
source_image: page_291.png
page_number: 291
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 66.82
tokens: 11670
characters: 2426
timestamp: 2025-12-24T06:34:02.069933
finish_reason: stop
---

low[i] = 22, то мы переходим к левому ребёнку корня (x ← left[x]). Этот ребёнок хранит отрезок [8, 9], также не перекрывающийся с i. На этот раз max[left[x]] = 10 меньше low[i] = 22, поэтому мы переходим к правому ребёнку вершины x. Там находится отрезок [15, 23], перекрывающийся с i, и поиск завершается.

Рассмотрим пример безрезультатного поиска в том же дереве — будем искать отрезок, перекрывающийся с i = [11, 14]. Снова начинаем с корня. Корень хранит отрезок [16, 21], не перекрывающийся с i. Так как max[left[x]] = 23 больше low[i] = 11, переходим к левому ребёнку. Теперь в x хранится отрезок [8, 9]. Он не перекрывается с i, и max[left[x]] = 10 меньше low[i] = 11, поэтому идём направо. (Слева искомого отрезка быть не может). В x теперь хранится [15, 23], с i этот отрезок не перекрывается, left[x] = NIL, поэтому идём направо и возвращаем значение NIL.

Корректность процедуры Interval-Search устанавливает теорема 15.2, которая утверждает, что если отрезки int[x] и i не перекрываются, то дальнейший поиск идёт в правильном направлении (если нужные отрезки вообще есть в дереве, то они есть и в выби-раемой части дерева). Поэтому нам достаточно просмотреть всего один путь. (Обратите внимание, что слова "правильное направление" не означают, что в другом направлении искомых отрезков нет: мы утверждаем лишь, что если они есть вообще, то есть и в "правильном" направлении!)

Теорема 15.2. Пусть x — произвольная вершина дерева, i — отрезок, не перекрывающийся с int[x], и мы выполняем строки 3–5 процедуры Interval-Search(T, i). Тогда:

1. Если выполняется строка 4, то либо поддерево с корнем left[x] (левое поддерево) содержит отрезок, перекрывающийся с i, либо поддерево с корнем right[x] (правое поддерево) не содержит отрезка, перекрывающегося с i.
2. Если выполняется строка 5, то левое поддерево не содержит отрезка, перекрывающегося с i.

Доказательство. Начнём с более простого случая 2. Строка 5 выполняется, если не выполнено условие в строке 3, то есть если left[x] = NIL или max[left[x]] < low[i]. В первом случае левое поддерево пусто, поэтому не содержит отрезка, перекрывающегося с i. Предположим, что left[x] ≠ NIL и max[left[x]] < low[i]. Рассмотрим произвольный отрезок i' из левого поддерева (см. рис. 15.5a). Так как max[left[x]] — наибольший правый конец таких отрезков, то

\[
high[i'] \leq max[left[i]] < low[i],
\]

поэтому отрезок i' целиком лежит левее отрезка i. Случай 2 рассмотрен.