---
source_image: page_837.png
page_number: 837
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 63.27
tokens: 11727
characters: 2694
timestamp: 2025-12-24T06:59:44.039783
finish_reason: stop
---

переводы надписей:
input bits — сертификат их machine state — регистры процессора
working storage — рабочая память
0/1 output — выходной бит
36.7 Последовательность конфигураций, соответствующая работе алгоритма \( A \) для входа \( x \) и сертификата \( y \). Каждая конфигурация соответствует состоянию вычисления в какой-то момент времени и включает в себя (помимо \( A, x \) и \( y \)) также значение счётчика команд (PC), а также содержимое регистров процессора и рабочей памяти. Каждая конфигурация переводится в следующую с помощью схемы \( M \) из функциональных элементов. Выходной бит записан в выделенном месте рабочей памяти.

\( C \in \text{CIRCUIT-SAT} \). (Функция \( f \) будет вычисляться полиномиальным алгоритмом.)
Поскольку \( L \in \text{NP} \), существует алгоритм \( A \), проверяющий данный язык за полиномиальное время. Мы используем этот алгоритм для построения сводящего алгоритма \( F \). Пусть \( T(n) \) — наибольшее время работы алгоритма \( A \) на входах длины \( n \) (напомним, что мы называем входом первый аргумент алгоритма \( A \); второй называется сертификатом). Выберем такое число \( k \), что \( T(n) = O(n^k) \) и длина сертификатов для входов длины \( n \) тоже есть \( O(n^k) \). (Время работы алгоритма полиномиально зависит от общей длины условия и сертификата. Но поскольку длина сертификата ограничена полиномом от длины условия, время работы алгоритма также ограничено полиномом от \( n \).)
Идея доказательства состоит в представлении работы алгоритма \( A \) в виде последовательности конфигураций. Как показано на рис. 36.7, каждая конфигурация состоит из части, содержащей программу, счётчика команд, состояния регистров процессора, входа \( x \), сертификата \( y \) и рабочей памяти.
Начальное состояние памяти компьютера образует конфигурацию \( c_0 \). Затем каждая конфигурация \( c_i \) преобразуется в следующую конфигурацию \( c_{i+1} \), причём это преобразование выполняется с помощью схемы из функциональных элементов \( M \), реализованной в электронике компьютера. В конце работы алгоритм получает ответ (ноль или единицу). Будем считать, что этот ответ записывается в определённое место памяти. После получения ответа программа останавливается, и состояние памяти в дальнейшем не изменяется. Следовательно, если алгоритм делает не более \( T(n) \) шагов, результат работы алгоритма находится в фиксированном бите конфигурации \( c_{T(n)} \).
Таким образом, можно построить схему, которая последовательно вычисляет конфигурации \( c_1, c_2, \ldots, c_{T(N)} \). Эта схема состоит из последовательно соединённых \( T(n) \) копий схемы \( M \). Выход \( i \)-ой копии схемы \( M \) будет конфигурацией \( c_i \). Выходными зна-