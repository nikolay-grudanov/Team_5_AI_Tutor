---
source_image: page_015.png
page_number: 15
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 74.11
tokens: 11455
characters: 1898
timestamp: 2025-12-24T06:20:34.998961
finish_reason: stop
---

Упражнения

1.2-1 Будем сортировать массив из n элементов так: просмотрим его и найдём минимальный элемент, который скопируем в первую ячейку другого массива. Затем просмотрим его снова и найдём следующий элемент, и так далее. Такой способ сортировки можно назвать сортировкой выбором (selection sort). Запишите этот алгоритм с помощью псевдокода. Укажите время его работы в лучшем и худшем случаях, используя Θ-обозначения.

1.2-2 Вернёмся к алгоритму линейного поиска (упр. 1.1-3). Сколько сравнений потребуется в среднем этому алгоритму, если искомым элементом может быть любой элемент массива (с одинаковой вероятностью)? Каково время работы в худшем случае и в среднем? Как записать эти времена с помощью Θ-обозначений?

1.2-3 Дана последовательность чисел x₁, x₂, ..., xₙ. Покажите, что за время Θ(n log n) можно определить, есть ли в этой последовательности два одинаковых числа.

1.2-4 Даны коэффициенты a₀, a₁, ..., aₙ₋₁ многочлена; требуется найти его значение в заданной точке x. Опишите естественный алгоритм, требующий времени Θ(n²). Как выполнить вычисления за время Θ(n), не используя дополнительного массива? Используйте "схему Горнера":

\[
\sum_{i=0}^{n-1} a_i x^i = (\ldots (a_{n-1} x + a_{n-2}) x + \ldots + a_1) x + a_0.
\]

1.2-5 Как записать выражение n³/1000 - 100n² - 100n + 3 с помощью Θ-обозначений?

1.2-6 Почти любой алгоритм можно немного изменить, радикально уменьшив время его работы в лучшем случае. Как?

1.3 Построение алгоритмов

Есть много стандартных приёмов, используемых при построении алгоритмов. Сортировка вставками является примером алгоритма, действующего по шагам (incremental approach): мы добавляем элементы один за другим к отсортированной части массива.

В этом разделе мы покажем в действии другой подход, который называют "разделяй и властвуй" (divide-and-conquer approach), и построим с его помощью значительно более быстрый алгоритм сортировки.