---
source_image: page_289.png
page_number: 289
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 39.86
tokens: 11314
characters: 1439
timestamp: 2025-12-24T06:33:30.734326
finish_reason: stop
---

Деревья промежутков

Рисунок 15.3 Три варианта взаимного расположения отрезков \( i \) и \( i' \). (а) Отрезки \( i \) и \( i' \) перекрываются. Возможно четыре варианта; во всех четырёх \( low[i] \leq high[i'] \) и \( low[i'] \leq high[i] \). (б) \( high[i] < low[i'] \). (в) \( high[i'] < low[i] \).

ней.

Шаг 1: Базовая структура данных

Мы уже выбрали базовую структуру: красно-чёрное дерево, каждая вершина \( x \) которого содержит отрезок \( int[x] \). Ключом вершины является левый конец отрезка \( low[int[x]] \); обход дерева в порядке "левое поддерево — корень — правое поддерево" перечисляет вершины в порядке возрастания ключей.

Шаг 2: Дополнительная информация

Каждая вершина, помимо отрезка, содержит поле \( max[x] \), в котором хранится максимальный из правых концов отрезков, содержащихся в поддереве с корнем \( x \).

Шаг 3: Обновление дополнительной информации

Проверим, что дополнительную информацию можно обновлять при добавлении и удалении элемента без (асимптотического) ухудшения времени работы этих операций. В самом деле,

\[
max[x] = \max(high[int[x]], max[left[x]], max[right[x]])
\]

и остаётся лишь сослаться на теорему 15.1. Можно отметить также, что при вращениях поле \( max \) можно обновлять за время \( O(1) \) (упр. 15.2-4 и 15.3-1).

Шаг 4: Новые операции

Процедура INTERVAL-SEARCH(\( T, i \)) находит в дереве \( T \) отрезок, перекрывающийся с \( i \). Если такого отрезка нет, она возвращает