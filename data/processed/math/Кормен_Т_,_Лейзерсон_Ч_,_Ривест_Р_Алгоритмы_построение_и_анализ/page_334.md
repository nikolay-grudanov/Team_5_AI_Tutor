---
source_image: page_334.png
page_number: 334
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 44.23
tokens: 11393
characters: 1708
timestamp: 2025-12-24T06:35:47.293822
finish_reason: stop
---

Коды Хаффмена

Рисунок 17.4 Деревья, соответствующие двум кодам рис. 17.3. В каждом листе указан соответствующий символ и частота его использования в тексте. Во внутренних узлах указана сумма частот для листьев соответствующего поддерева. (а) Дерево, соответствующее равномерному коду \( a = 000, \ldots, f = 100 \). (б) Дерево, соответствующее оптимальному префиксному коду \( a = 0, b = 101, \ldots, f = 1100 \).

На рис. 17.4 изображены деревья, соответствующие двум кодам рис. 17.3.

Оптимальному (для данного файла) коду всегда соответствует двоичное дерево, в котором всякая вершина, не являющаяся листом, имеет двоих детей (см. упражнение 17.3-1). В частности, равномерный код из нашего примера оптимальным быть не может, так как в соответствующем дереве (рис. 17.4а) есть вершина с одним ребёнком (коды некоторых символов начинаются с 10..., но ни один код символа не начинается с 11...). Такое свойство оптимального кода позволяет легко доказать, что дерево оптимального префиксного кода для файла, в котором используются все символы из некоторого множества \( C \) и только они, содержит ровно \( |C| \) листьев, по одному на каждый символ, и ровно \( |C| - 1 \) узлов, не являющихся листьями.

Зная дерево \( T \), соответствующее префиксному коду, легко найти количество битов, необходимое для кодирования файла. Именно, для каждого символа \( c \) из алфавита \( C \) пусть \( f[c] \) обозначает число его вхождений в файл, а \( d_T(c) \) — глубину соответствующего листа в дереве или, что то же самое, длину последовательности битов, кодирующей \( c \). Тогда для кодирования файла потребуется

\[
B(T) = \sum_{c \in C} f[c] d_T(c)
\]

битов. Назовем это число стоимостью (cost) дерева \( T \).