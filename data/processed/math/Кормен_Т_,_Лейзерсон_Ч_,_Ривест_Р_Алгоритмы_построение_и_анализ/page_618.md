---
source_image: page_618.png
page_number: 618
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 66.51
tokens: 11820
characters: 2567
timestamp: 2025-12-24T06:49:52.828739
finish_reason: stop
---

мер \( \Theta(n^2) \). Дерево Уоллеса (Wallace-tree multiplier) также имеет размер \( \Theta(n^2) \), но работает быстрее, за время \( \Theta(\lg n) \). Обе схемы используют умножение столбиком.

29.3.1 Матричный умножитель

Матричный умножитель работает в три этапа: (1) вычисляет частичные произведения; (2) складывает их, используя сложение с запоминанием переносов, пока не остается два числа; (3) складывает эти два числа (с помощью каскадного сумматора или с предвычислением переносов).

Матричный умножитель (array multiplier) показан на рис. 29.14; входные биты \( a_i \) соответствуют вертикальным проводам, биты \( b_i \) — горизонтальным. Каждый входной бит поступает на входы \( n \) элементов AND, которые вычисляют разряды частичных произведений:

\[
m_{j+i}^{(i)} = a_j \cdot b_i = a_j AND b_i
\]

Число элементов AND равно \( n^2 \); все они работают одновременно, вычисляя биты частичных произведений (кроме тех, что заведомо равны 0). Затем сумматоры с запоминанием переносов (составленные из суммирующих элементов \( FA_j^{(i)} \)) складывают частичные произведения. Младшие разряды появляются на выходах в парном столбце рисунка, старшие получаются на выходе сумматора в низу рисунка.

Рисунок 29.14 29.14 Матричный умножитель для \( n = 4 \). Элемент AND, обозначенный \( G_j^{(i)} \), вычисляет \( j \)-й бит частичного произведения \( m^{(i)} \). Каждый горизонтальный ряд суммирующих элементов \( FA_j^{(i)} \) представляет собой сумматор с запоминанием переносов. Младшие \( n \) битов произведения — это бит \( m_0^{(0)} \) и \( u \)-биты, получаемые в правом столбце в ходе сложения с запоминанием переносов. Старшие \( n \) битов получаются на выходе сумматора, складывающего \( u \)-биты \( v \)-биты, выходящие из суммирующие элементов нижней строки. Показаны значения для множителей рис. 29.13.

Последовательно выполняемые сложения с запоминанием переносов показаны на рис. 29.15. Вначале из чисел 0, \( m^{(0)} \) и \( m^{(1)} \) получаются числа \( u^{(1)} \) и \( v^{(1)} \) (не более \( n + 1 \) битов в каждом; для \( v^{(1)} \) это так, поскольку \( n + 1 \)-ые разряды двух слагаемых из трёх равны 0), при этом \( m^{(0)} + m^{(1)} = u^{(1)} + v^{(1)} \). Затем из чисел \( u^{(1)} \), \( v^{(1)} \) и \( m^{(2)} \) получаются числа \( u^{(2)} \) и \( v^{(2)} \), имеющие по \( n + 2 \) битов каждое (снова в двух слагаемых из трёх старший бит равен 0). Мы продолжаем процесс, складывая \( u^{(i-1)} \), \( v^{(i-1)} \) и \( m^{(i)} \) для всех \( i = 2, 3, \ldots, n - 1 \). В конце концов мы получаем 2 числа \( u^{(n-1)} \) и