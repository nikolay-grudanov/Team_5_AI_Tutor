---
source_image: page_174.png
page_number: 174
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 66.79
tokens: 11582
characters: 2257
timestamp: 2025-12-24T06:28:33.945187
finish_reason: stop
---

9.3-2 Какие из следующих алгоритмов сортировки являются устойчивыми: сортировка вставками, сортировка слиянием, сортировка с помощью кучи, быстрая сортировка? Объясните, каким способом можно любой алгоритм сортировки превратить в устойчивый. Сколько при этом потребуется дополнительного времени и памяти?

9.3-3 Докажите по индукции, что алгоритм цифровой сортировки правилен. Где в вашем доказательстве используется устойчивость алгоритма сортировки цифр?

9.3-4 Объясните, как рассортировать \( n \) целых положительных чисел, не превосходящих \( n^2 \), за время \( O(n) \).

9.3-5* Пусть мы сортируем перфокарты с помощью сортировочной машины, начиная со старшего разряда. Сколько раз придётся запустить машину (в худшем случае) для сортировки \( d \)-значных чисел? Какое максимальное количество стопок карт придётся одновременно хранить по ходу дела?

9.4 Сортировка вычёрпыванием

Алгоритм сортировки вычёрпыванием (bucket sort) работает за линейное (среднее) время. Как и сортировка подсчётом, сортировка вычёрпыванием годится не для любых исходных данных: говоря о линейном среднем времени, мы предполагаем, что на вход подаётся последовательность независимых случайных чисел, равномерно распределённых на промежутке \([0; 1)\) (определение равномерного распределения дано в разд. 6.2).

[Заметим, что этот алгоритм — детерминированный (не использует генератора случайных чисел); понятие случайности возникает лишь при анализе времени его работы.]

Идея алгоритма состоит в том, что промежуток \([0; 1)\) делится на \( n \) равных частей, после чего для чисел из каждой части выделяется свой ящик-черпак (bucket), и \( n \) подлежащих сортировке чисел раскладываются по этим ящикам. Поскольку числа равномерно распределены на отрезке \([0; 1)\), следует ожидать, что в каждом ящике их будет немного. Теперь отсортируем числа в каждом ящике по отдельности и пройдёмся по ящикам в порядке возрастания, выписывая попавшие в каждый из них числа также в порядке возрастания.

Будем считать, что на вход подается \( n \)-элементный массив \( A \), причем \( 0 \leq A[i] < 1 \) для всех \( i \). Используется также вспомогательный массив \( B[0..n-1] \), состоящий из списков, соответствующих ящикам. Алгоритм использует операции со списками, которые опи-