---
source_image: page_642.png
page_number: 642
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 44.37
tokens: 11428
characters: 1964
timestamp: 2025-12-24T06:50:37.263713
finish_reason: stop
---

30.1-7. Распространите метод эйлерова цикла на деревья с произвольной степенью вершин (выбрав подходящее представление дерева). Постройте алгоритм, вычисляющий глубину всех n вершин дерева (в этом представлении) за время O(\lg n).

30.1-8. Измените алгоритм List-Rank так, чтобы проверка условия окончания цикла производилась явно (без использования управляющей сети), сохраняя оценку на работы. (Указание: следите за первым элементом списка).

30.2 CRCW- и EREW-алгоритмы

Одновременный доступ к памяти в параллельных компьютерах имеет свои плюсы и минусы. Недостатком является сложность аппаратной поддержки такого доступа. Кроме того, возможности одновременного доступа используются не так часто. С другой стороны, в некоторых случаях без этих возможностей трудно обойтись. На практике часто выбирается один из промежуточных вариантов.

В этом разделе рассматриваются преимущества одновременного доступа. Существуют задачи, для которых наилучший CRCW-алгоритм работает быстрее наилучшего EREW-алгоритма. Такова, например, задача отыскания корней деревьев в графе, являющемся лесом, а также задача поиска максимального элемента в массиве. Эти задачи рассмотрены ниже.

30.2.1 Польза параллельного чтения

Пусть дано несколько двоичных деревьев, заданных следующим образом: каждая вершина i имеет указатель parent[i] на родителя (если вершина является корнем, то parent[i] = NIL). Требуется для каждой вершины i найти корень root[i] дерева, которому она принадлежит. С каждой вершиной мы связываем один процессор.

FIND-ROOTS(F)
1 for (для каждого процессора i
2 do if parent[i] = NIL
3 then root[i] ← i
4 while существует узел i, для которого parent[i] ≠ NIL
5 do for (для каждого процессора i
6 do if parent[i] ≠ NIL
7 then root[i] ← root[parent[i]]
8 parent[i] ← parent[parent[i]]

Работа алгоритма показана на рис. 30.5. После инициализации (строки 1–3) корни известны только для корневых вершин (рис. 30.5 (a)). В цикле while (строки 4–8) происходят переходы