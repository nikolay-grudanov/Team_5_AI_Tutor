---
source_image: page_019.png
page_number: 19
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 96.79
tokens: 11666
characters: 2455
timestamp: 2025-12-24T06:20:57.703223
finish_reason: stop
---

1.3-5 Возвращаясь к задаче поиска (упр. 1.1-3), заметим, что при поиске в отсортированном массиве мы можем сначала сравнить искомый элемент со средним элементом массива, узнать, в какой половине его следует искать, а затем применить ту же идею рекурсивно. Такой способ называется двоичным поиском (binary search). Напишите соответствующую программу, используя цикл или рекурсию. Объясните, почему время её работы есть \( \Theta(\log n) \).

1.3-6 Заметим, что цикл while в строках 5–7 процедуры INSERTION-SORT (разд. 1.1) просматривает элементы отсортированного участка \( A[1..j-1] \) подряд. Вместо этого можно было бы использовать двоичный поиск (упр. 1.3-5), чтобы найти место вставки за время \( \Theta(\log n) \). Удастся ли таким образом сделать общее время работы равным \( \Theta(n \log n) \)?

1.3-7* Дан массив \( S \) из \( n \) действительных чисел, а также число \( x \). Как за время \( \Theta(n \log n) \) определить, можно ли представить \( x \) в виде суммы двух элементов массива \( S \)?

Замечания

Как мог бы сказать Козьма Прутков, хороший алгоритм подобен острому ножу — тот и другой достигают цели легко и просто. Другое сравнение: человек, пользующийся плохим алгоритмом, подобен повару, отбивающему мясо отвёрткой: едва съедобный и малоприятный результат достигается ценой больших усилий.

Часто разница между плохим и хорошим алгоритмом более существенна, чем между быстрым и медленным компьютером. Пусть мы хотим отсортировать массив из миллиона чисел. Что быстрее — сортировать его вставками на суперкомпьютере (100 миллионов операций в секунду) или слиянием на домашнем компьютере (1 миллион операций)? Пусть к тому же сортировка вставками написана на ассемблере чрезвычайно экономно, и для сортировки \( n \) чисел нужно, скажем, лишь \( 2n^2 \) операций. В то же время алгоритм слиянием написан без особой заботы об эффективности и число операций есть \( 50n \log n \). Для сортировки миллиона чисел получаем

\[
\frac{2 \cdot (10^6)^2 \text{ операций}}{10^8 \text{ операций в секунду}} = 20\ 000 \text{ секунд} \approx 5,56 \text{ часов}
\]

для суперкомпьютера и всего

\[
\frac{50 \cdot (10^6) \log(10^6) \text{ операций}}{10^6 \text{ операций в секунду}} \approx 1\ 000 \text{ секунд} \approx 17 \text{ минут}
\]

для домашнего компьютера.

Мы видим, что разработка эффективных алгоритмов — не менее важная компьютерная технология, чем разработка быстрой электроники. В этой области также происходит заметный прогресс.