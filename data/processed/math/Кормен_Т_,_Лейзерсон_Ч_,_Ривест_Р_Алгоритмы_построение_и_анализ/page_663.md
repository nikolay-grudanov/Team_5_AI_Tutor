---
source_image: page_663.png
page_number: 663
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 58.97
tokens: 11677
characters: 2404
timestamp: 2025-12-24T06:51:43.837252
finish_reason: stop
---

v лежат в одной связной компоненте.

c. Докажите, что алгоритм работает правильно, то есть останавливается и в момент остановки \( p[u] = p[v] \) тогда и только тогда, когда u и v принадлежат одной связной компоненте.

Оценим время работы алгоритма. Рассмотрим какую-нибудь связную компоненту C, содержащую не меньше двух вершин. Пусть в некоторый момент работы алгоритма компонента C состоит из нескольких деревьев \( \{T_i\} \). Определим потенциал компоненты C как

\[
\Phi(C) = \sum_{T_i} \text{height}(T_i)
\]

где \( \text{height}(T_i) \) — высота дерева \( T_i \). Наша цель — показать, что каждая пара операций НООК—JUMP уменьшает \( \Phi(C) \) в некоторое фиксированное число раз (или ещё сильнее).

d. Докажите, что после первого вызова процедуры НООК нет деревьев высоты 0 и что \( \Phi(C) \leq |V| \).

e. Докажите, что последующие вызовы процедуры НООК не увеличивают \( \Phi(C) \).

f. Докажите, что после любого вызова процедуры НООК, кроме первого, среди деревьев ссылок нет звёзд (за исключением связных компонент, все вершины которых уже объединены в одну звезду).

g. Докажите, что если деревья ссылок для данной связной компоненты C ещё не превратились в одну звезду, то после вызова процедуры JUMP потенциал \( \Phi(C) \) уменьшается по крайней мере в полтора раза. Каков наихудший случай (когда потенциал уменьшается меньше всего)?

h. Выведите из предыдущего, что время работы алгоритма составляет \( O(\lg |V|) \).

30-4 Транспонирование изображения

Видеопамять можно рассматривать как матрицу битов M размера \( p \times p \) (считаем, что точки бывают чёрными и белыми). При этом на дисплее видна её часть — верхняя левая подматрица размера \( n \times n \). Определим операцию переноса блока битов (Block Transfer of bits, BitBLT). Процедура BitBLT\((r_1, c_1, r_2, c_2, nr, nc, *)\) выполняет присваивания

\[
M[r_2 + i, c_2 + j] \leftarrow M[r_2 + i, c_2 + j] * M[r_1 + i, c_1 + j]
\]

для всех \( i = 0, 1, \ldots, nr - 1, j = 0, 1, \ldots, nc - 1 \). Здесь * обозначает любую из 16 бинарных логических операций.

Пусть требуется транспонировать видимую часть изображения: \( M[i, j] \leftarrow M[j, i] \). Будем предполагать, что время копирования битов меньше, чем время переноса блока битов, так что мы оцениванием именно число операций BitBLT.

Докажите, что можно транспонировать изображение, вызывая процедуру BitBLT всего лишь \( O(\lg n) \) раз. Предполагается, что