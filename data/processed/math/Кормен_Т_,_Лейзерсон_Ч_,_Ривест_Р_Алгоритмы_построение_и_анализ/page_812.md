---
source_image: page_812.png
page_number: 812
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 46.43
tokens: 11576
characters: 2096
timestamp: 2025-12-24T06:58:17.880643
finish_reason: stop
---

35.11
(К упр. 35.3-4)
(a) Звёздный многоугольник: из точки p видна любая точка его границы.
(b) Многоугольник, не являющийся звёздным. Слева закрашена тень точки q, справа — тень точки ql. Ядро пусто, так как эти области не пересекаются.

мы должны указать выпуклую оболочку всех точек, полученных к этому моменту. Можно применить проход Грэхема на каждом шаге заново, и тогда общее время работы алгоритма будет равно \( O(n^2 \lg n) \). Придумайте алгоритм, требующий времени \( O(n^2) \).
35.3-6*
Используя просмотр точек слева направо, найдите выпуклую оболочку n точек за время \( O(n \lg n) \).

35.4 Отыскание пары ближайших точек

Пусть теперь нам надо найти среди \( n \leq 2 \) точек множества Q пару ближайших друг к другу точек. Расстояние между точками понимается в обычном смысле: точки \( p_1 = (x_1, y_1) \) и \( p_2 = (x_2, y_2) \) находятся на расстоянии \( \sqrt{(x_1 - x_2)^2 + (y_1 - y_2)^2} \).

Вообще говоря, две точки могут совпадать (тогда расстояние между ними равно 0). Такая задача может возникнуть, например, в системах контроля за транспортом: полезно знать, какие два транспортных средства ближе всего друг к другу (риск столкновения)

Если искать пару ближайших точек "в лоб", надо перебрать все \( C_n^2 = \Theta(n^2) \) пары точек. В этом разделе мы с помощью метода "разделяй и властвуй" построим алгоритм, время работы которого описывается рекуррентным соотношением \( T(n) = 2T(n/2) + O(n) \), т.е. равно \( O(n \lg n) \).

Метод "разделяй и властвуй" для отыскания ближайших точек.

Входные данные каждого рекурсивного вызова алгоритма состоят из подмножества \( P \subseteq Q \) и двух массивов X и Y. Каждый из массивов содержит точки подмножества p, но порядок в них разный: в массиве X точки расположены в порядке возрастания абсцисс, а в массиве Y — в порядке возрастания ординат. Заметим, что мы не можем позволить себе сортировать точки при каждом вызове, так как в этом случае получится соотношение (как минимум) \( T(n) = 2T(n/2) + O(n \lg n) \), т.е. \( T(n) = O(n \ln^2 n) \).
(Мы увидим, как эту трудность можно обойти с помощью "предсортировки".