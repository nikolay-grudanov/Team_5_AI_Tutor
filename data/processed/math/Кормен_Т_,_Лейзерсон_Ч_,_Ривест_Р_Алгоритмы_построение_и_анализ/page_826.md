---
source_image: page_826.png
page_number: 826
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 50.31
tokens: 11621
characters: 2470
timestamp: 2025-12-24T06:59:01.205507
finish_reason: stop
---

В противном случае алгоритм зациклывается, не выдавая никакого ответа. Ясно, что такой алгоритм допускает, но не распознаёт язык PATH. Однако легко исправить описанный алгоритм таким образом, чтобы слова, не принадлежащие языку, отвергались (если длина кратчайшего пути превосходит k, надо отвергать входное слово). Такой алгоритм допускает и распознаёт язык PATH.

Отметим, что для некоторых языков (например, для множества всех программ, заканчивающих свою работу) есть допускающий, но нет распознающего алгоритма.

Мы уже дали определение класса задач P. Ниже мы определим также класс NP. В теории сложности вычислений рассматриваются многие другие сложностные классы (complexity classes). Например, имеется важный класс PSPACE, состоящий из задач, решаемых алгоритмами с использованием памяти полиномиального размера, или класс EXP, состоящий из задач, которые можно решить за время O(2^{n^k}). Неформально сложностной класс можно определить как семейство языков, для которых распознающие алгоритмы имеют заданную меру сложности (например заданное время работы). Мы не даём точного определения, отсылая заинтересованного читателя работе Хартманиса и Стирнса [95].

Теперь можно переформулировать определение класса P так:
P = {L \subset \{0,1\}^* : \text{существует алгоритм } A, \text{ распознающий язык } L \text{ за полиномиальное время}}

На самом деле в данной ситуации нет разницы между языками, допускаемыми и распознаваемыми за полиномиальное время.

Теорема 36.2

\[
P = \{L : L \text{ допускается за полиномиальное время}\}

Доказательство
Если язык распознаётся некоторым алгоритмом, то он и допускается тем же алгоритмом. Остаётся доказать, что если язык L допускается полиномиальным алгоритмом A, то он распознаётся некоторым (возможно, другим) полиномиальным алгоритмом A'. Пусть алгоритм A допускает язык L за время O(n^k). Это значит, что существует константа c, для которой A допускает любое слово длины n из L, сделав не более T = cn^k шагов. (Формально говоря, это верно для достаточно длинных слов x; мы опускаем очевидные детали.)

Новый алгоритм A' моделирует работу алгоритма A и считает число шагов этого алгоритма, сравнивая его с известной границей T. Если за время T алгоритм A допускает слово x, алгоритм A' также допускает это слово и выдаёт 1. Если же A не допускает x за указанное время, то алгоритм A' прекращает моделирование и отвергает слово (выдаёт 0). Замедление работы за счёт моделирования и подсчёта шагов не так уж и велико и