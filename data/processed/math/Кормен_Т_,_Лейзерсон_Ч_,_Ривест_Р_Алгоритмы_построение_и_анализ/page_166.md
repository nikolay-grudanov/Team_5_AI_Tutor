---
source_image: page_166.png
page_number: 166
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 39.36
tokens: 11340
characters: 1657
timestamp: 2025-12-24T06:27:42.401689
finish_reason: stop
---

9 Сортировка за линейное время

Мы познакомились с различными алгоритмами, которые могут отсортировать n чисел за время O(n lg n). Алгоритмы сортировки слиянием (merge sort) и сортировки с помощью кучи (heap sort) работают за такое время в худшем случае, а у алгоритма быстрой сортировки таковым является среднее время работы. Оценка O(n lg n) точна: для каждого из этих алгоритмов можно предъявить последовательность из n чисел, время обработки которой будет Ω(n lg n).

Все упомянутые алгоритмы проводят сортировку, основываясь исключительно на попарных сравнениях элементов, поэтому их иногда называют сортировками сравнением (comparison sort). В разделе 9.1 мы покажем, что всякий алгоритм такого типа сортирует n элементов за время не меньше Ω(n lg n) в худшем случае. Тем самым алгоритмы сортировки слиянием и с помощью кучи асимптотически оптимальны: не существует алгоритма сортировки сравнением, который превосходил бы указанные алгоритмы более, чем в конечное число раз.

В разделах 9.2, 9.3 и 9.4 мы рассматриваем три алгоритма сортировки (сортировка подсчётом, цифровая сортировка и сортировка вычёркиванием), работающих за линейное время. Разумеется, они улучшают оценку Ω(n lg n) за счёт того, что используют не только попарные сравнения, но и внутреннюю структуру сортируемых объектов.

9.1 Нижние оценки для сортировки

Говорят, что алгоритм сортировки основан на сравнениях, если он никак не использует внутреннюю структуру сортируемых элементов, а лишь сравнивает их и после некоторого числа сравнений выдаёт ответ (указывающий истинный порядок элементов). Так мы приходим к модели алгоритмов сортировки, называемой разрешающими деревьями.