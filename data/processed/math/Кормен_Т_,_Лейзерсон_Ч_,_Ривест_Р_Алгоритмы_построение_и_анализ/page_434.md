---
source_image: page_434.png
page_number: 434
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 59.82
tokens: 11531
characters: 2329
timestamp: 2025-12-24T06:40:45.461450
finish_reason: stop
---

FIND-SET(x) ("найти множество"). Возвращает указатель на представитель (единственного) множества, содержащего элемент x.

UNION(x, y) ("объединение"). Применяма, если элементы x и y содержатся в различных множествах S_x и S_y, и заменяет эти множества на объединение S_x \cup S_y; при этом выбирается некоторый представитель для S_x \cup S_y. Сами множества S_x и S_y при этом удаляются.

В некоторых приложениях выбор представителя в множестве должен подчиняться каким-то правилам (например, элементы могут быть упорядочены и представителем является наименьший элемент множества). В любом случае существенно, что представитель множества не меняется, пока само множество остается неизменным.

В этой главе мы оценим время работы операций над системами непересекающихся множеств. Параметрами будут число операций MAKE-SET (то есть общее число элементов во всех множествах), которое мы обозначим через n, а также суммарное число операций UNION, MAKE-SET и FIND-SET, которое мы обозначим через m. Прежде всего заметим, что (по определению) m \geq n, а также что число операций UNION не превосходит n - 1 (после каждой из них количество множеств уменьшается на единицу).

Пример использования систем непересекающихся множеств

Применим системы непересекающихся множеств к задаче о связных компонентах неориентированного графа (см. раздел 5.4; пример графа с четырьмя связными компонентами дан на рис. 22.1a).

Алгоритм CONNECTED-COMPONENTS (связные компоненты), приведённый ниже, разбивает множество вершин графа на непересекающиеся множества, соответствующие связным компонентам; после этого можно с помощью процедуры SAME-COMPONENT выяснить, лежат ли две данные вершины в одной компоненте. Если граф задан заранее ("режим off-line"), быстрее найти его связные компоненты с помощью поиска в глубину (упражнение 23.3-9); однако если граф строится постепенно и в любой момент надо уметь отвечать на вопрос, каковы его связные компоненты ("режим on-line"), то может оказаться выгоднее применить наш алгоритм, а не проводить заново поиск в глубину после добавления каждого из рёбер.

Ниже E[G] и V[G] обозначают множества соответственно рёбер и вершин графа G.

Connected-Components(G)
1 for (для) каждой вершины v \in V[G]
2 do Make-Set(v)
3 for (для) каждого ребра (u,v) \in E[G]
4 do if Find-Set(u) \neq Find-Set(v)
5 then Union(u,v)