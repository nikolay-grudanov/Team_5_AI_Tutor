---
source_image: page_202.png
page_number: 202
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 51.01
tokens: 11351
characters: 1574
timestamp: 2025-12-24T06:29:35.621895
finish_reason: stop
---

Рисунок 11.3 (а) Двусторонне связанный список \( L \) содержит числа 1, 4, 9, 16. Каждый элемент списка — это запись с полями для ключа и указателей на предыдущий и последующий элементы (эти указатели изображены стрелками). В поле \( next \) у хвоста списка и в поле \( prev \) у головы списка находится указатель NIL (косая черта на рисунке); \( head[L] \) указывает на голову списка. (б) В результате выполнения операции List-Insert\((L, x)\), где \( key[x] = 25 \), в списке появился новый элемент с ключом 25; он стал новой головой списка, а его поле \( next \) указывает на бывшую голову — элемент с ключом 9. (в) Вслед за этим была выполнена операция List-Delete\((L, x)\), где \( x \) — указатель на элемент с ключом 4.

Поиск в списке

Процедура List-Search\((L, k)\) находит в списке \( L \) (с помощью простого линейного поиска) первый элемент, имеющий ключ \( k \). Точнее говоря, она возвращает указатель на этот элемент, или NIL, если элемента с таким ключом в списке нет. Если, например, \( L \) — список рис. 11.3а, то вызов List-Search\((L, 4)\) вернёт указатель на третий элемент списка, а вызов List-Search\((L, 7)\) вернёт NIL.

List-Search\((L, k)\)
1 \( x \leftarrow head[L] \)
2 while \( x \neq \text{NIL} \) and \( key[x] \neq k \)
3 do \( x \leftarrow next[x] \)
4 return \( x \)

Поиск в списке из \( n \) элементов требует в худшем случае (когда приходится просматривать весь список) \( \Theta(n) \) операций.

Добавление элемента в список

Процедура List-Insert добавляет элемент \( x \) к списку \( L \), помещая его в голову списка (рис. 11.3б).