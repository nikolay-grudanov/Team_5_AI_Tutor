---
source_image: page_339.png
page_number: 339
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 58.02
tokens: 11546
characters: 2065
timestamp: 2025-12-24T06:36:23.078533
finish_reason: stop
---

y, можно применить лемму 17.3 и увидеть, что нам остаётся найти оптимальное кодовое дерево для алфавита \( C' \) и затем добавить к вершине \( z \) двух детей, помеченных символами \( x \) и \( y \). Это и делает алгоритм Huffman.

Упражнения

17.3-1 Докажите, что в бинарном дереве, соответствующем оптимальному префиксному коду, всякая вершина либо является листом, либо имеет двух детей.

17.3-2 Найдите код Хаффмена для алфавита, в котором частоты символов совпадают с первыми восемью числами Фибоначчи:

\[
a : 1 \quad b : 1 \quad c : 2 \quad d : 3 \quad e : 5 \quad f : 8 \quad g : 13 \quad h : 21.
\]

Что будет, если в алфавите \( n \) символов, частоты которых совпадают с первыми \( n \) числами Фибоначчи?

17.3-3 Докажите, что стоимость двоичного дерева, соответствующего префиксному коду, можно вычислить следующим образом: для каждой вершины, не являющейся листом, найти сумму частот ее детей, и сложить все полученные числа.

17.3-4 Расположим символы алфавита в порядке убывания (невозрастания) частот. Докажите, что в оптимальном префиксном коде длины кодирующих эти символы последовательностей битов будут идти в неубывающем порядке.

17.3-5 Докажите, что оптимальный префиксный код для алфавита из \( n \) символов может быть представлен последовательностью из \( 2n - 1 + n \lceil \log_2 n \rceil \) битов. (Указание: для задания структуры дерева достаточно \( 2n - 1 \) битов.)

17.3-6 Обобщите алгоритм Хаффмена на тернарные коды (каждый символ кодируется последовательностью из цифр 0, 1 и 2). Коды, порождаемые вашим алгоритмом, должны быть оптимальны.

17.3-7 Пусть алфавит содержит \( 2^8 = 256 \) символов, причём максимальная частота превосходит минимальную не более чем вдвое. Покажите, что для алфавита с такими частотами код Хаффмена не более эффективен, чем равномерный восьмибитовый код.

17.3-8 Профессор утверждает, что написанная им программа сжатия информации позволяет сжать любой файл длины 1000 (последовательность из тысячи 8-битовых байтов) хотя бы на один бит, после чего написанная им программа восстановления сможет вос-