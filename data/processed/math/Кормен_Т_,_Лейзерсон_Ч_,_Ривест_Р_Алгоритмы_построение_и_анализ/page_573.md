---
source_image: page_573.png
page_number: 573
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 53.09
tokens: 11570
characters: 2084
timestamp: 2025-12-24T06:47:30.739712
finish_reason: stop
---

разницей высот. Впрочем, более крутые рёбра уже насыщены и так (лемма 27.13)

Операция Push называется проталкиванием из вершины u в вершину v (применённым к вершине u). Проталкивание называется насыщающим (saturating), если в результате ребро (u, v) становится насыщенным (saturated), то есть если \( c_f(u, v) \) обращается в нуль (ребро исчезает из остаточной сети); в противном случае проталкивание считают ненасыщающим (nonsaturating).

Процедура Lift(u) поднимает переполненную вершину u на максимальную высоту, которая допустима по определению высотной функции. Посмотрим на соотношение высот вершины и её соседей в остаточной сети. По определению высотной функции высота вершины превосходит высоту соседа в остаточной сети не более чем на 1. Если есть сосед, который на единицу ниже, то можно выполнить проталкивание (но нельзя выполнить подъём). Если все соседи не ниже, то проталкивание выполнить нельзя, а подъём — можно, после чего возможно проталкивание. Вот как выглядит процедура подъёма (lifting):

\textsc{Lift}($u$)
1 $\triangleright$ дано: вершина $u$ переполнена; для любого ребра $(u, v) \in E_f$ выполнено неравенство $h(u) \leq h(v)$.
2 $\triangleright$ надо: увеличить $h[u]$, подготовляя проталкивание
    из вершины $u$
3 $h[u] \leftarrow 1 + \min\{h[v] | (u, v) \in E_f\}$

Заметим, что если вершина u переполнена, то в \( E_f \) найдётся по крайней мере одно ребро, выходящее из u (минимум в строке 3 берётся по непустому множеству). Чтобы доказать это, вспомним, что \( f[V, u] = e[u] > 0 \), поэтому существует по крайней мере одна такая вершина v, для которой \( f(v, u) > 0 \). Получаем

\[
c_f(u, v) = c(u, v) - f[u, v] = c(u, v) + f[v, u] > 0,
\]

а это означает, что \((u, v) \in E_f\). (Если в вершине жидкость выливается, то она откуда-то приходит, и есть резерв, состоящий в уменьшении этого прихода.)

Общая схема алгоритма
Алгоритм начинается с вызова Initialize-Preflow, задающего начальный предпоток:

\[
f[u, v] = \begin{cases}
c(u, v) & \text{если } u = s, \\
-c(v, u) & \text{если } v = s, \\
0 & \text{в остальных случаях}.
\end{cases}
\]