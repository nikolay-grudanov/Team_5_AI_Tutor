---
source_image: page_838.png
page_number: 838
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 68.62
tokens: 11804
characters: 2883
timestamp: 2025-12-24T06:59:49.373764
finish_reason: stop
---

cheniами схемы будут биты конфигурации \( c_{T(n)} \). Описанную схему назовем \( C' \).

Вспомним, что должен делать сводящий алгоритм \( F \). Получив входное слово \( x \), он должен построить схему \( C = f(x) \), которая выполнима, если и только если существует такой сертификат \( y \), что \( A(x, y) = 1 \). Для этого найдём длину \( n \) слова \( x \) и построим схему \( C' \) описанным способом. Входом схемы \( C' \) будет начальная конфигурация вычисления \( A(x, y) \), а выходом — конфигурация \( c_{T(n)} \).

Затем полученную схему \( C' \) следует немного преобразовать. Во-первых, нужно установить значения входных переменных, соответствующих программе \( A \), начальному положению счетчика команд, входу \( x \), исходному состоянию служебной информации и рабочей части памяти. (Для этого мы соединяем соответствующие входы схемы с постоянными сигналами 0 или 1.) Неопределенными остаются только те входные переменные, которые отвечают за значение сертификата \( y \). Во-вторых, игнорируются все выходы схемы \( C' \), кроме одного — того бита конфигурации \( c_{T(n)} \), в котором хранится результат работы алгоритма \( A \). Новая, преобразованная схема и есть нужная нам схема \( C \). Сводящий алгоритм, получив вход \( x \), строит схему \( C \) и выдаёт её (точнее, её представление в виде строки битов).

Остается доказать, что сводящий алгоритм обладает двумя необходимыми свойствами. Во-первых, нужно показать, что \( F \) корректно вычисляет сводящую функцию \( f \). Это значит, что схема \( C \) выполнима тогда и только тогда, когда существует сертификат \( y \), для которого \( A(x, y) = 1 \). Во-вторых, нужно показать, что алгоритм \( F \) работает полиномиальное время.

Докажем корректность алгоритма \( F \). Пусть существует сертификат \( y \) длины \( O(n^k) \), для которого \( A(x, y) = 1 \). Подставим биты сертификата \( y \) во входные переменные схемы \( C \). Тогда выход схемы \( C(y) \) будет равен \( A(x, y) = 1 \). Таким образом, если существует сертификат, то схема \( C = f(x) \) выполнима. Наоборот, если схема \( C \) выполнима, то для некоторого набора \( y \) значений входных переменных имеем \( C(y) = 1 \), и потому \( A(x, y) = 1 \). Корректность алгоритма \( F \) доказана.

Осталось заметить, что размер схемы \( C \) и время работы сводящего алгоритма полиномиально зависят от размера входа \( n = |x| \). Прежде всего заметим, что каждая конфигурация содержит полиномиальное число битов. Действительно, длина программы \( A \) фиксирована и не зависит от входа, длина входа \( x \) равна \( n \), а длина сертификата \( y \) полиномиально зависит от \( n \). Поскольку алгоритм \( A \) делает только полиномиальное число шагов, размер используемой им памяти тоже полиномиален. (Мы считаем, что не только число фактически использованных ячеек памяти, но и общее число ячеек памяти полиномиально. На самом деле это