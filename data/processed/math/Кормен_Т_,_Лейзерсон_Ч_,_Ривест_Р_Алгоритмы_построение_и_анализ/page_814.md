---
source_image: page_814.png
page_number: 814
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 65.35
tokens: 11749
characters: 2854
timestamp: 2025-12-24T06:58:45.833442
finish_reason: stop
---

Нужно понять лишь, почему достаточно сравнивать каждую точку полосы лишь с семью следующими за ней (в порядке возрастания ординаты). Сейчас мы в этом убедимся.

Пусть (при некотором вызове) ближайшей парой точек является пара из точек \( p_L \in P_L \) и \( p_R \in P_R \) (рис. 35.12 (а)), и расстояние \( \delta' \) между этими точками строго меньше \( \delta \). Точка \( p_L \) должна находиться слева от \( l \) на расстоянии не более \( \delta \) (или на самой прямой); \( p_R \) — справа на расстоянии не большем \( \delta \) (или на прямой). Кроме того, расстояние по вертикали между \( p_L \) и \( p_R \) также не превосходит \( \delta \). Следовательно (рис. 35.12 (а)), точки \( p_L \) и \( p_R \) можно поместить в прямоугольник размера \( \delta \times 2\delta \), симметричной относительно прямой \( l \). (Конечно, в него могут попасть и другие точки.)

Покажем теперь, что внутри этого прямоугольника может быть не более 8 точек из множества \( P \). Рассмотрим его левую половину — квадрат \( \delta \times \delta \). Все точки из \( P_L \) находятся на расстоянии не менее \( \delta \) друг от друга, поэтому в этом квадрате может быть максимум 4 таких точки (в каждой его четвертинке может быть не более одной точки), см. рис. 35.12 (б). В правой половине прямоугольника (не считая границы) точек из \( P_L \) быть не может, так что всего в прямоугольнике не более 4 точек из \( P_L \). По аналогичным причинам там не более 4 точек из \( P_R \). Заметим, что случай 8 точек действительно возможен: четыре точки из \( P_L \) могут быть в углах левого квадрата, а четыре точки из \( P_R \) — в углах правого (две точки будут общими для \( P_L \) и \( P_R \)). А Теперь ясно, что что для каждой точки достаточно проверить 7 точек, непосредственно следующих за ней в массиве \( Y' \): если между двумя ближайшими точками есть ещё 7 промежуточных (в порядке возрастания ординат), то все 9 точек попадут внутрь прямоугольника, а этого быть не может, как мы видели.

Детали реализации и время работы алгоритма.

Наша цель — получить для времени работы алгоритма рекуррентное соотношение \( T(n) = 2T(n/2) + O(n) \) (здесь \( T(n) \) — время обработки \( n \) точек). Чтобы этого достичь, мы должны предполагать, что входные массивы \( X \) и \( Y \) отсортированы по абсциссе и ординате соответственно (тогда разделить множество на левую и правую половины можно за линейное время). Соответственно мы обязаны при рекурсивном вызове передавать множества \( P_L \) и \( P_R \) в отсортированном виде. Ясно, что это не трудно сделать, проходя массив от начала к концу и раскладывая его элементы на две группы. В некотором смысле это действие обратно в процедуре MERGE, использованной при сортировке слиянием (раздел 1.3.1).

Осталось заметить, что начальная сортировка (presorting) выполняется всего один раз и потому не входит в рекуррентное со-