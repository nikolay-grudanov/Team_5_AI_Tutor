---
source_image: page_246.png
page_number: 246
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 59.10
tokens: 11379
characters: 1674
timestamp: 2025-12-24T06:31:43.252498
finish_reason: stop
---

Поэтому время поиска есть \( O(h) \) (где \( h \) — высота дерева).

Вот итеративная версия той же процедуры (которая, как правило, более эффективна):

Iterative-Tree-Search\((x, k)\)
1 while \( x \neq \text{NIL} \) и \( k \neq key[x] \)
2 do if \( k < key[x] \)
3 then \( x \leftarrow left[x] \)
4 else \( x \leftarrow right[x] \)
5 return \( x \)

Минимум и максимум

Минимальный ключ в дереве поиска можно найти, пройдя по указателям \( left \) от корня (пока не упрёмся в NIL), см. рис. 13.2. Процедура возвращает указатель на минимальный элемент поддерева с корнем \( x \).

Tree-Minimum\((x)\)
1 while \( left[x] \neq \text{NIL} \)
2 do \( x \leftarrow left[x] \)
3 return \( x \)

Свойство упорядоченности гарантирует правильность процедуры Tree-Minimum. Если у вершины \( x \) нет левого ребёнка, то минимальный элемент поддерева с корнем \( x \) есть \( x \), так как любой ключ в правом поддереве не меньше \( key[x] \). Если же левое поддерево вершины \( x \) не пусто, то минимальный элемент поддерева с корнем \( x \) находится в этом левом поддереве (поскольку сам \( x \) и все элементы правого поддерева больше).

Алгоритм Tree-Maximum симметричен:

Tree-Maximum\((x)\)
1 while \( right[x] \neq \text{NIL} \)
2 do \( x \leftarrow right[x] \)
3 return \( x \)

Оба алгоритма требуют времени \( O(h) \), где \( h \) — высота дерева (поскольку двигаются по дереву только вниз).

Следующий и предыдущий элементы

Как найти в двоичном дереве элемент, следующий за данным? Свойство упорядоченности позволяет сделать это, двигаясь по дереву. Вот процедура, которая возвращает указатель на следующий за \( x \) элемент (если все ключи различны, он содержит следующий