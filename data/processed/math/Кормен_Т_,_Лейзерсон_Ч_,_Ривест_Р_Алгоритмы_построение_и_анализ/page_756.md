---
source_image: page_756.png
page_number: 756
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 48.45
tokens: 11439
characters: 1816
timestamp: 2025-12-24T06:55:40.635957
finish_reason: stop
---

**ρ-эвристика Полларда.**

Перебирая все числа от 1 до В в качестве возможных делителей заданного числа n, мы сможем разложить на множители любое число вплоть до \( B^2 \). Сейчас мы опишем алгоритм, который делает примерно столько же действий и позволяет раскладывать на множители числа порядка \( B^4 \) (в большинстве случаев). К сожалению, нельзя гарантировать, что он выдаст ответ достаточно быстро; нельзя гарантировать даже того, что вообще разложение будет найдено. Однако на практике этот алгоритм зарекомендовал себя неплохо.

Pollard-Rho(n)
1 i \gets 1
2 x_i \gets Random (0,n-1)
3 y \gets x_i
4 k \gets 2
5 while true
6   do i \gets i+1
7     x_i \gets (x_{i-1}^2 - 1) \bmod n
8     d \gets \gcd(y-x_i,n)
9     if d \neq 1 и d \neq n
10        then print d
11     if i=k
12        then y \gets x_i
13        k \gets 2k

Эта процедура основана на рекуррентном соотношении

\[
x_i = (x_{i-1}^2 - 1) \bmod n
\]

и вычисляет один за другим члены соответствующей последовательности

\[
x_1, x_2, x_3, x_4, \ldots
\]

(строка 7); переменная i указывает номер члена, начиная с 1 ж первый член \( x_1 \) выбирается случайно (строки 1–2). (На самом деле в каждый момент хранится только один член последовательности, так что можно опустить индекс i и использовать одну переменную x для хранения текущего члена последовательности).

Переменная k последовательно принимает значения 2, 4, 8, ... (строки 4 и 13), когда значение i доходит до текущего значения k, значение \( x_i \) запоминается в переменной y, а переменная k увеличивается вдвое. Таким образом, у последовательно принимает значения \( x_1, x_2, x_4, x_8, \ldots \)

В строках 8–10 мы пытаемся найти делитель числа n, используя два члена последовательности — текущее значение \( x_i \) и сохранённое значение y. Эта попытка удачна, если число \( d = \)