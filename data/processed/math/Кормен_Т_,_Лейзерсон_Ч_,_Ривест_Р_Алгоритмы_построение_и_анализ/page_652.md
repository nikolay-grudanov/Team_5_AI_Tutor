---
source_image: page_652.png
page_number: 652
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 51.98
tokens: 11526
characters: 2260
timestamp: 2025-12-24T06:51:06.895466
finish_reason: stop
---

30.4 Эффективная параллельная обработка префиксов

В разделе 30.1.2 был рассмотрен EREW-алгоритм параллельной обработки префиксов для списка из n элементов за время O(lg n). Он использует n процессоров, поэтому затраты составляют \( \Theta(n \lg n) \), что больше, чем затраты \( \Theta(n) \) однопроцессорного алгоритма. Следовательно, алгоритм List-Prefix не является эффективным по затратам.

В этом разделе описывается вероятностный EREW-алгоритм параллельной обработки префиксов, который использует \( \Theta(n / \lg n) \) процессоров и в большинстве случаев (с большой вероятностью) работает за время \( O(\lg n) \). Таким образом, этот (вероятностный) алгоритм можно считать эффективным по затратам. Конструкция теоремы 30.4 позволяет указать такой алгоритм для любого числа процессоров \( p = O(n / \lg n) \).

30.4.1 Рекурсивная параллельная обработка префиксов

Алгоритм Randomized-List-Prefix использует для n-элементного списка \( p = \Theta(n / \lg n) \) процессоров, так что каждый процессор отвечает за \( n/p = \Theta(\lg n) \) элементов. Распределение объектов по процессорам происходит произвольным образом (не обязательно подряд) в начале работы алгоритма и более не меняется. Для удобства будем считать, что список является двунаправленным, поскольку такой список можно изготовить из однонаправленного за время \( O(1) \).

Идея алгоритма состоит в том, чтобы исключить из списка некоторые объекты (присоединив их к следующим за ними), произвести обработку префиксов для получившегося списка, а затем обработать пропущенные префиксы, учитя исключённые элементы. Один уровень рекурсии показан на рис. 30.9, а весь процесс — на рис. 30.10.

При выборе исключаемых элементов мы будем соблюдать такие правила:

1. Нельзя одновременно исключать два элемента, за которые отвечает один и тот же процессор.
2. Нельзя исключать два соседних в списке объекта.

Перед тем как описывать механизм выбора исключаемых элементов, рассмотрим подробнее сам процесс исключения. Пусть решено исключить k-й объект. Тогда (k + 1)-й объект запоминает значение \([k, k+1] = [k, k] \otimes [k+1, k+1]\) (после чего k-й объект удаляется). Если k-й объект является последним, то он просто удаляется из списка.

После удаления процедура Randomized-List-Prefix вызывает