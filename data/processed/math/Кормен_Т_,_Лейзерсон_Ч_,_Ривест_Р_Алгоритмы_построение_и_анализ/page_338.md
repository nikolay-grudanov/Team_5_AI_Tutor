---
source_image: page_338.png
page_number: 338
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 65.40
tokens: 11671
characters: 2397
timestamp: 2025-12-24T06:36:23.664186
finish_reason: stop
---

Коды Хаффмена

сливаемых узлов. В упражнении 17.3-3 мы предложим вам доказать, что стоимость дерева равна сумме стоимостей всех слияний, необходимых для его построения. Стало быть, алгоритм Huffman на каждом шаге выбирает слияние, наименее увеличивающее стоимость.

Теперь установим свойство оптимальности для подзадач.
Пусть фиксирован алфавит \( C \) и два символа \( x, y \) этого алфавита, а \( C' \) — алфавит, который получится из \( C \), если выкинуть \( x \) и \( y \) и добавить новый символ \( z \).

Рассмотрим кодовые деревья для \( C \), в которых \( x \) и \( y \) (точнее, соответствующие им листья) являются братьями. Каждому такому дереву соответствует кодовое дерево для \( C' \), которое получится, если выбросить вершины \( x \) и \( y \), а их общего родителя считать кодом символа \( z \).

При этом соответственно каждому кодовому дереву для \( C' \) соответствует ровно два кодовых дерева для \( C \) (в одном из них \( x \) будет левым ребёнком, в другом — правым).

Пусть для каждого символа \( c \) из \( C \) фиксирована его частота \( f[c] \). Определим частоты для символов из \( C' \), считая частотой символа \( z \) сумму \( f[x] + f[y] \); для остальных символов частоты остаются теми же, что и в \( C \). Тогда для кодовых деревьев (для обоих алфавитов) определены стоимости.

Лемма 17.3. Стоимости соответствующих друг другу деревьев \( T \) и \( T' \) (при описанном соответствии) отличаются на величину \( f[x] + f[y] \).

Доказательство. Легко видеть, что \( d_T(c) = d_{T'}(c) \) для всех \( c \in C \setminus \{x, y\} \), а также что \( d_T(x) = d_T(y) = d_{T'}(z) + 1 \). Следовательно,
\[
f[x]d_T(x) + f[y]d_T(y) = (f[x] + f[y])(d_{T'}(z) + 1) =
= f[z]d_{T'}(z) + (f[x] + f[y]),
\]
откуда \( B(T) = B(T') + f[x] + f[y] \).

Эта лемма показывает, что выполнено свойство оптимальности для подзадач (оптимальное дерево \( T \) соответствует оптимальному дереву \( T' \) для меньшей задачи).

Из двух доказанных лемм легко следует

Теорема 17.4. Алгоритм Huffman строит оптимальный префиксный код.

Доказательство. Лемма 17.2 показывает, что оптимальные кодовые деревья можно искать среди таких, у которых два наиболее редких символа (назовём из \( x \) и \( y \)) являются братьями. Им соответствуют деревья для алфавита \( C' \), в котором символы \( x \) и \( y \) слиты в один символ \( z \). Считая частоту символа \( z \) равной сумме частот \( x \) и