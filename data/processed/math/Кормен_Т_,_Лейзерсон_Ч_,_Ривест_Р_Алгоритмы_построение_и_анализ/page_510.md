---
source_image: page_510.png
page_number: 510
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 58.46
tokens: 11686
characters: 2404
timestamp: 2025-12-24T06:44:30.356188
finish_reason: stop
---

Рис. 25.8 (в оригинале в подписи была опечатка: \( v \), тогда как надо \( u \)).

**Рисунок 25.8** 25.8. Алгоритм для поиска кратчайших путей в ациклическом ориентированном графе. Вершины топологически отсортированы (на рисунке слева направо). Исходная вершина — \( s \). В вершинах записаны значения функции \( d \); для серых рёбер \( (u, v) \) имеем \( \pi[v] = u \). (а) Перед первой итерацией цикла в строках 3–5. (б–ж) Последовательные состояния после каждой итерации цикла в строках 3–5. На каждом из этих рисунков прибавляется по одной чёрной вершине (которая была вершиной \( u \) во время соответствующей итерации цикла). Значения \( d \) на рисунке (ж) — окончательные.

**25.3 Кратчайшие пути в ациклическом ориентированном графе**

В ациклическом ориентированном графе \( G = (V, E) \) кратчайшие пути из одной вершины можно найти за время \( O(V + E) \), если проводить релаксацию ребер в порядке, заданном топологическим упорядочением вершин. Заметим, что в ациклическом ориентированном графе кратчайшие пути всегда определены, поскольку циклов отрицательного веса (и вообще циклов) нет.

В разделе 23.4 мы рассматривали алгоритм топологической сортировки вершин ациклического графа. Он располагает их в таком порядке, чтобы все рёбра графа вели от "меньших" вершин к "большим" (в смысле этого порядка). После этого мы просматриваем вершины в этом порядке и для каждой вершины подвергаем релаксации все выходящие из неё рёбра.

**Dag-Shortest-Paths(G, w, s)**

1 топологически отсортировать вершины G
2 Initialize-Single-Source(G, s)
3 for (для) всех вершин u (в найденном порядке)
4 do for (для) всех вершин v \in Adj[u]
5 do Relax(u, v, w)

Пример работы этого алгоритма приведён на рис. 25.8.

Оценим время работы алгоритма **Dag-Shortest-Paths**. Как мы видели в разд. 23.4, стоимость топологической сортировки (строка 1) есть \( \Theta(V + E) \), а стоимость инициализации в строке 2 есть \( O(V) \). В цикле в строках 3–5 каждое ребро обрабатывается, как и в алгоритме Дейкстры, ровно один раз, но, в отличие от алгоритма Дейкстры, стоимость такой обработки есть \( O(1) \). Стало быть, наш алгоритм выполняется за время \( \Theta(V + E) \), пропорциональное объему памяти, необходимому на представление графа с помощью списков смежных вершин.

Покажем, что алгоритм **Dag-Shortest-Paths** правилен.

**Теорема 25.15**
Пусть взвешенный ориентированный граф \( G = (V, E) \) с исход-