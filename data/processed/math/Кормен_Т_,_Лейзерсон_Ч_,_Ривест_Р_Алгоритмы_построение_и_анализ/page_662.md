---
source_image: page_662.png
page_number: 662
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 58.42
tokens: 11680
characters: 2377
timestamp: 2025-12-24T06:51:43.135163
finish_reason: stop
---

Задачи

а. Докажите, что если \( m \leq p/2 \), то нахождение максимума из \( m \) чисел можно за время \( O(1) \) свести к нахождению максимума из не более чем \( m^2/p \) чисел, используя CRCW-машину с \( p \) процессорами.

б. Пусть вначале имеется \( m = \lfloor p/2 \rfloor \) чисел. Сколько их останется после \( k \) применений конструкции пункта (а)?

с. Постройте CRCW-алгоритм поиска максимума из \( n \) чисел со временем работы \( O(\lg \lg n) \), использующий \( p = n \) процессоров.

30-3 Связные компоненты

В этой задаче строится алгоритм для поиска связных компонент неориентированного графа \( G = (V, E) \). Алгоритм предназначен для CRCW-машины (в которой может записаться любое из одновременно записываемых значений) с \( |V + E| \) процессорами. Для каждой вершины \( v \) мы храним указатель \( p[v] \). Вначале \( p[v] = v \) для всех вершин \( v \). В конце \( p[v] = p[u] \) в том и только в том случае, когда \( u \) и \( v \) лежат в одной связной компоненте. Во время работы алгоритма указатели образуют несколько деревьев ссылок (pointer trees). Дерево ссылок называется звездой (star), если \( p[u] = p[v] \) для любых двух его вершин \( u \) и \( v \).

Предполагается, что каждое ребро в графе продублировано, то есть вместе с парой \( (u, v) \) множество \( E \) содержит пару \( (v, u) \). Алгоритм использует две основных операции: НООК и Jump, а также процедуру STAR, которая делает \( star[v] \) равным TRUE, если вершина \( v \) принадлежит звезде.

НООК\((G)\)
1 STAR\((G)\)
2 for (для каждого ребра \( (u, v) \in E[G] \))
3 do if \( star[u] \) и \( p[u] > p[v] \)
4 then \( p[p[u]] \leftarrow p[v] \)

STAR\((G)\)
6 for (для каждого ребра \( (u, v) \in E[G] \))
7 do if \( star[u] \) и \( p[u] \neq p[v] \)
8 then \( p[p[u]] \leftarrow p[v] \)

Jump\((G)\)
1 for (для каждой вершины \( v \in V[G] \))
2 do \( p[v] \leftarrow p[p[v]] \)

Алгоритм работает следующим образом: вначале выполняется НООК, а затем чередуются НООК, Jump, НООК, Jump и так далее, пока при выполнении процедуры Jump не окажется, что ни один указатель не меняется. Заметьте, что вначале дважды выполняется процедура НООК.

а. Напишите процедуру STAR\((G)\).

б. Докажите, что указатели \( p \) образуют в любой момент несколько деревьев, причём корни находятся в тех вершинах, которые указывают на себя. Докажите, что если \( p[u] = p[v] \), то \( u \) и \( v \)