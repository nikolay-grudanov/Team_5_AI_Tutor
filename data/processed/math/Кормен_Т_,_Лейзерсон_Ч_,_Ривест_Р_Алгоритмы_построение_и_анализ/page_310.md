---
source_image: page_310.png
page_number: 310
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 54.65
tokens: 11536
characters: 2100
timestamp: 2025-12-24T06:34:41.375130
finish_reason: stop
---

Динамическое программирование "сверху вниз"

Алгоритм раздела 16.1 действовал "снизу вверх". Но тот же приём (исключение повторного решения подзадач) можно реализовать и для алгоритмов, работающих "сверху вниз". Для этого нужно запоминать ответы к уже решённым подзадачам в специальной таблице. Сначала вся таблица пуста (т.е. заполнена специальными записями, указывающими на то, что соответствующее значение еще не вычислено). Когда в процессе выполнения алгоритма подзадача встречается в первый раз, её решение заносится в таблицу. В дальнейшем решение этой подзадачи берётся прямо из таблицы. (В нашем примере таблицу ответов завести легко, так как подзадачи нумеруются парами \((i, j)\). В более сложных случаях можно использовать хеширование.) По-английски этот прием улучшения рекурсивных алгоритмов называется memoization.

Применим это усовершенствование к алгоритму Recursive-Matrix-Chain:

Memoized-Matrix-Chain(\(p\))

1 \( n \leftarrow length[p] - 1 \)
2 for \( i \leftarrow 1 \) to \( n \)
3 do for \( j \leftarrow i \) to \( n \)
4 do \( m[i, j] \leftarrow \infty \)
5 return Lookup-Chain(\(p, 1, n\))

Lookup-Chain(\(p, i, j\))

1 if \( m[i, j] < \infty \)
2 then return \( m[i, j] \)
3 if \( i = j \)
4 then \( m[i, j] \leftarrow 0 \)
5 else for \( k \leftarrow i \) to \( j - 1 \)
6 do \( q \leftarrow \) Lookup-Chain(\(p, i, k\)) +
   + Lookup-Chain(\(p, k + 1, j\)) + \( p_{i-1} p_k p_j \)
7 if \( q < m[i, j] \)
8 then \( m[i, j] \leftarrow q \)
9 return \( m[i, j] \)

Процедура Memoized-Matrix-Chain, подобно Matrix-Chain-Order, заполняет таблицу \(m[1..n, 1..n]\), где \(m[i, j]\) — минимальное количество умножений, необходимое для вычисления \(A_{i..j}\). Первоначально \(m[i, j] = \infty\) в знак того, что соответствующее место в таблице не заполнено. Если при исполнении Lookup-Chain(\(p, i, j\)) оказывается, что \(m[i, j] < \infty\), то процедура сразу выдает это значение \(m[i, j]\). В противном случае \(m[i, j]\) вычисляется как в процедуре Recursive-Matrix-Chain, записывается в таблицу и выдаётся в качестве ответа. Тем самым вызов Lookup-Chain(\(p, i, j\)) всегда