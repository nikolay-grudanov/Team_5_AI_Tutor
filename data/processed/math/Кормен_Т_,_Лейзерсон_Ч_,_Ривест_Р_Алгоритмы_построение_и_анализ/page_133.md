---
source_image: page_133.png
page_number: 133
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 34.58
tokens: 11297
characters: 1662
timestamp: 2025-12-24T06:26:00.587075
finish_reason: stop
---

Введение

В этой части мы рассмотрим несколько алгоритмов, решающих задачу сортировки (sorting problem). Исходным данным для этой задачи является последовательность чисел \( \langle a_1, a_2, \ldots, a_n \rangle \). Результатом должна быть последовательность \( \langle a'_1, a'_2, \ldots, a'_n \rangle \), состоящая из тех же чисел, идущих в неубывающем порядке: \( a'_1 \leq a'_2 \leq \cdots \leq a'_n \). Обычно исходная последовательность задана как массив, хотя возможны и другие варианты (например, связанный список).

Структура сортируемых объектов

На практике редко требуется упорядочивать числа как таковые. Обычно надо сортировать записи (records), содержащие несколько полей, и располагать их в порядке, определяемым одним из полей. [Например, в архиве отдела кадров для каждого сотрудника фирмы может храниться запись, содержащая различные поля (фамилия, имя, отчество, год рождения, адрес и т.п.), и в какой-то момент может понадобиться упорядочить все записи по годам рождения.] Поле, по которому проводится сортировка (год рождения в нашем примере), называется ключом (key), а остальные поля — дополнительными данными (satellite data). Можно представлять себе дело так: алгоритм сортирует ключи, но вместе с каждым ключом перемещаются (без изменения) дополнительные данные, с ними связанные. (Если этих данных много, разумно перемещать не сами данные, а лишь указатель на них.)

Все эти подробности мы не рассматриваем, ограничиваясь задачей сортировки ключей. Приводимые нами алгоритмы являются, таким образом, лишь "скелетом" реальной программы, к которому нужно добавить обработку дополнительных данных (что обычно не сложно, хотя и хлопотно).