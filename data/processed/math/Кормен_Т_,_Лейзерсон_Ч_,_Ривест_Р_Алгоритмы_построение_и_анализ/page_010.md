---
source_image: page_010.png
page_number: 10
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 89.51
tokens: 11562
characters: 2343
timestamp: 2025-12-24T06:20:50.332467
finish_reason: stop
---

A[j] (строка 2 алгоритма) и сдвигаем идущие перед ним и большие его по величине элементы (начиная с j - 1-го) вправо, освобождая место для взятого элемента. (строки 4–7). В строке 8 элемент A[j] помещается в освобождённое место.

Псевдокод

Вот основные соглашения, которые мы будем использовать:
1. Отступ от левого поля указывает на уровень вложенности. Например, тело цикла for (строка 1) состоит из строк 2–8, а тело цикла while (строка 5) содержит строки 6–7, но не 8. Это же правило применяется и для if-then-else. Это делает излишним специальные команды типа begin и end для начала и конца блока. (В реальных языках программирования такое соглашение применяется редко, поскольку затрудняет чтение программ, переходящих со страницы на страницу.)
2. Циклы while, for, repeat и условные конструкции if, then, else имеют тот же смысл, что в Паскале.
3. Символ ▷ начинает комментарий (идущий до конца строки).
4. Одновременное присваивание i ← j ← e (переменные i и j получают значение e) заменяет два присваивания j ← e и i ← j (в этом порядке).
5. Переменные (в данном случае i, j, key) локальны внутри процедуры (если не оговорено противное).
6. Индекс массива пишется в квадратных скобках: A[i] есть i-й элемент в массиве A. Знак ".." выделяет часть массива: A[1..j] обозначает участок массива A, включающий A[1], A[2], ..., A[j].
7. Часто используются объекты (objects), состоящие из нескольких полей (fields), или, как говорят, имеющие несколько атрибутов (attributes). Значение поля записывается как имя_поля[имя_объекта]. Например, длина массива считается его атрибутом и обозначается length, так что длина массива A запишется как length[A]. Что обозначают квадратные скобки (элемент массива или поле объекта), будет ясно из контекста.

Переменная, обозначающая массив или объект, считается указателем на составляющие его данные. После присваивания y ← x для любого поля f выполнено f[y] = f[x]. Более того, если мы теперь выполним оператор f[x] ← 3, то будет не только f[x] = 3, но и f[y] = 3, поскольку после y ← x переменные x и y указывают на один и тот же объект.

Указатель может иметь специальное значение NIL, не указывающее ни на один объект.
8. Параметры передаются по значению (by value): вызванная процедура получает собственную копию параметров; изменение параметра внутри процедуры снаружи невидимо. При передаче объек-