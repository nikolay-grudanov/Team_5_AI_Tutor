---
source_image: page_316.png
page_number: 316
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 50.47
tokens: 11483
characters: 1801
timestamp: 2025-12-24T06:34:59.896926
finish_reason: stop
---

Построение НОП

Таблица b, созданная процедурой LCS-LENGTH, позволяет быстро найти НОП последовательностей X = ⟨x₁, x₂, ..., xₘ⟩ и Y = ⟨y₁, y₂, ..., yₙ⟩. Для этого надо пройти по пути, указанному стрелками, начиная с b[m, n]. Пройденная стрелка ↵ в клетке (i, j) означает, что xᵢ = yⱼ входит в наибольшую общую подпоследовательность. Вот как это реализовано в рекурсивной процедуре PRINT-LCS (НОП для X и Y печатается при вызове PRINT-LCS(b, X, length[X], length[Y])):

PRINT-LCS(b, X, i, j)
1 if i = 0 или j = 0
2 then return
3 if b[i, j] = "↖"
4 then PRINT-LCS(b, X, i - 1, j - 1)
5 напечатать xᵢ
6 elseif b[i, j] = "↑"
7 then PRINT-LCS(b, X, i - 1, j)
8 else PRINT-LCS(b, X, i, j - 1)

Будучи применённой к таблице рис. 16.3, эта процедура напечатает BCBA. Время работы процедуры есть O(m + n), поскольку на каждом шаге хотя бы одно из чисел m и n уменьшается.

Улучшение алгоритма

После того, как алгоритм разработан, нередко удается сделать его более экономным. В нашем примере можно обойтись без таблицы b. В самом деле, каждое из чисел c[i, j] зависит от c[i - 1, j], c[i, j - 1] и c[i - 1, j - 1]. Зная c[i, j], мы можем за время O(1) выяснить, какая из этих трёх записей использовалась. Тем самым можно найти НОП за время O(m + n) с помощью одной только таблицы c (в упражнении 16.3-2 мы попросим вас это сделать). При этом мы экономим Θ(mn) памяти. (Впрочем, асимптотика не меняется: объём таблицы с есть также Θ(mn).)

Если нас интересует только длина наибольшей общей подпоследовательности, то столько памяти не нужно: вычисление c[i, j] затрагивает только две строки с номерами i и i - 1 (это не предел экономии: можно обойтись памятью на одну строку таблицы с плюс ещё чуть-чуть, см. упражнение 16.3-4). При этом, однако, саму подпоследовательность найти (за время O(m + n)) не удается.