---
source_image: page_140.png
page_number: 140
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 65.22
tokens: 11559
characters: 2087
timestamp: 2025-12-24T06:26:56.210358
finish_reason: stop
---

свойство в вершине largest) и рекурсивно вызывает себя для вершины largest, чтобы исправить возможные нарушения.

Оценим время работы процедуры HEAPIFY. На каждом шаге требуется произвести \( \Theta(1) \) действий, не считая рекурсивного вызова. Пусть \( T(n) \) — время работы для поддерева, содержащего \( n \) элементов. Если поддерево с корнем \( i \) состоит из \( n \) элементов, то поддеревья с корнями LEFT\((i)\) и RIGHT\((i)\) содержат не более чем по \( 2n/3 \) элементов каждое (наихудший случай — когда последний уровень в поддереве заполнен наполовину). Таким образом,

\[
T(n) \leq T(2n/3) + \Theta(1)
\]

Из теоремы 4.1 (случай 2) получаем, что \( T(n) = O(\lg n) \). Эту же оценку можно получить так: на каждом шаге мы спускаемся по дереву на один уровень, а высота дерева есть \( O(\lg n) \).

Упражнения

7.2-1 Покажите, следуя образцу рис. 7.2, как работает процедура HEAPIFY\((A, 3)\) для массива \( \langle 27, 17, 3, 16, 13, 10, 1, 5, 7, 12, 4, 8, 9, 0 \rangle \).

7.2-2 Пусть элемент \( A[i] \) больше, чем его дети. Каков будет результат вызова процедуры HEAPIFY\((A, i)\)?

7.2-3 Пусть \( i > heap-size[A]/2 \). Каков будет результат вызова процедуры HEAPIFY\((A, i)\)?

7.2-4 Измените процедуру HEAPIFY, заменив рекурсию циклом. (Некоторые компиляторы при этом порождают более эффективный код.)

7.2-5 Докажите, что наибольшее время работы процедуры HEAPIFY для кучи из \( n \) элементов равно \( \Omega(\lg n) \). (Указание: приведите пример, когда процедура вызывается для каждой вершины на пути от корня к листу).

7.3 Построение кучи

Пусть дан массив \( A[1..n] \), который мы хотим превратить в кучу, переставив его элементы. Для этого можно использовать процедуру HEAPIFY, применяя её по очереди ко всем вершинам, начиная с нижних. Поскольку вершины с номерами \( \lfloor n/2 \rfloor + 1, ..., n \) являются листвами, поддеревья с этими вершинами удовлетворяют основному свойству. Для каждой из оставшихся вершин, в порядке убывания индексов, мы применяем процедуру HEAPIFY. Порядок обработки вершин гарантирует, что каждый раз условия вызова процедуры