---
source_image: page_635.png
page_number: 635
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 56.71
tokens: 11660
characters: 2547
timestamp: 2025-12-24T06:50:32.938317
finish_reason: stop
---

Рисунок 30.2  30.2. Использование метода переходов по указателям для вычисления расстояний до конца списка за время \( O(\lg n) \). (a). Начальное состояние: все значения \( d \) равны 1. (b)-(d). Состояния списка после каждого выполнения цикла while в алгоритме List-Rank. В конце значение \( d \) совпадает с расстоянием до конца списка.

этого элемента в списке может быть любым.) На рис. 30.2(a) показан пример списка из объектов \( \langle 3, 4, 6, 0, 1, 5 \rangle \). Поскольку для каждого элемента имеется собственный процессор, все элементы списка можно обрабатывать параллельно.

Пусть дан односторонне связанный список \( L \) из \( n \) элементов, и для каждого его элемента требуется найти расстояние до конца списка. Более формально, если \( \text{next}[i] \) — указатель объекта \( i \) на следующий объект, то расстояние до конца списка задаётся индуктивно следующим образом:

\[
d[i] = \begin{cases}
0 & \text{если } \text{next}[i] = \text{NIL} \\
d[\text{next}[i]] + 1 & \text{если } \text{next}[i] \neq \text{NIL}
\end{cases}
\]

Эта задача называется задачей о номере в списке (list-ranking problem).

Тривиальное решение состоит в вычислении расстояний последовательно, начиная с конца списка. При этом время работы составляет \( \Theta(n) \), поскольку \( k \)-й с конца объект может быть обработан лишь после \( k-1 \) следующих за ним объектов. Такое решение по сути является последовательным, а не параллельным — в каждый момент активен только один процессор. Рассмотрим теперь алгоритм с временем работы \( \Theta(\lg n) \).

List-Rank(\( L \))
1 for (для) каждого процессора
2 do if \( \text{next}[i] = \text{NIL} \)
3 then \( d[i] \leftarrow 0 \)
4 else \( d[i] \leftarrow 1 \)
5 while существует объект \( i \), для которого \( \text{next}[i] \neq \text{NIL} \)
6 do for (для) каждого процессора \( i \)
7 do if \( \text{next}[i] \neq \text{NIL} \)
8 then \( d[i] \leftarrow d[i] + d[\text{next}[i]] \)
9 \( \text{next}[i] \leftarrow \text{next}[\text{next}[i]] \)

На рис. 30.2 показаны состояния списка перед каждым повторением цикла while в строках 5–9. Состояние списка после заполнения полей \( d[i] \) (строки 1–4) показано на рис. 30.2(a). На первом шаге у всех объектов, кроме последнего, указатели не равны NIL, поэтому строки 8–9 выполняются для первых пяти процессоров. Получается состояние списка, показанное на рис. 30-2(b). На следующем шаге строки 8–9 выполняются только для первых четырёх процессоров (у двух последних объектов указатели уже равны NIL). Результат показан на рис. 30-2(c). При третьем (и