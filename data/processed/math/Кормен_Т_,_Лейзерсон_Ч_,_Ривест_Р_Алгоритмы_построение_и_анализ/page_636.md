---
source_image: page_636.png
page_number: 636
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 51.42
tokens: 11459
characters: 2184
timestamp: 2025-12-24T06:50:27.716781
finish_reason: stop
---

После днем) выполнении цикла работают только два первых процессора. Конечный результат показан на рис. 30-2(d).

Идея композиции переходов по указателям (pointer jumping) реализована в строке 9, где производится операция next[i] ← next[next[i]]. Заметьте, что эти действия нарушают структуру списка, поскольку меняются поля указателей. Если необходимо сохранить список, необходимо сделать копии полей указателей и производить действия с копиями.

30.1.2 Корректность

Цикл в строках 5–9 имеет следующий инвариант: для любого объекта i либо next[i] указывает на объект, находящийся в списке на расстоянии d[i], либо next[i] = NIL и d[i] есть расстояние до конца списка.

Заметьте, что для правильной работы алгоритма необходима синхронизация: чтение всех указателей next[next[i]] (в строке 9) должно произойти до записи их новых значений.

Теперь покажем, что программа List-Rank не использует одновременного обращения к памяти (и поэтому может выполняться на EREW-машине). Ясно, что в строках 2–7, а также при записи в строках 8 и 9 не происходит одновременного обращения к одной ячейке, так как за каждый элемент списка отвечает свой процессор. Кроме того, переход по указателям сохраняет следующий инвариант: для любых двух различных объектов i и j либо next[i] ≠ next[j], либо next[i] = next[j] = NIL. Действительно, вначале это условие выполнено; оно сохраняется при выполнении строки 9. Поэтому при чтении в строке 9 не происходит одновременного обращения к одной ячейке.

В строке 8 не происходит одновременного чтения благодаря синхронизации: мы считаем, что сначала все процессоры читают d[i], и лишь затем d[next[i]]. В результате при i = next[j] содержимое d[i] сначала прочитывается i-м процессором, а затем j-м. При такой синхронизации алгоритм может работать на EREW-машине.

В дальнейшем предполагается, что при выполнении программ предусмотрена надлежащая синхронизация, и подобного рода требования всегда выполнены.

30.1.3 Анализ

Пусть список L содержит n элементов. Покажем, что время работы алгоритма составляет O(lg n). Поскольку инициализация и каждое выполнение цикла while занимают время O(1), достаточно показать, что цикл выполняется lg n раз. Это следует из