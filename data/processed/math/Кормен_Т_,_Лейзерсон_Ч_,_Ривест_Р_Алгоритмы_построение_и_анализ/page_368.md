---
source_image: page_368.png
page_number: 368
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 76.06
tokens: 11690
characters: 2365
timestamp: 2025-12-24T06:38:04.502521
finish_reason: stop
---

Задачи к главе 18

дает ниже 1/3, то мы сокращаем таблицу на треть её размера. Пользуясь потенциалом

\[
\Phi(T) = |2 \cdot num[T] - size[T]|,
\]

покажите, что при этом учётная стоимость операции Table-Delete ограничена.

Задачи

18-1 Двоичный счетчик с обратным порядком битов

В главе 32 мы расскажем о важном алгоритме, называемом быстрым преобразованием Фурье. Этот алгоритм начинается с обращения битов индекса (bit-reversal permutation) у массива \( A[0..n-1] \), где \( n = 2^k \) (\( k \) — натуральное число). Именно, каждое \( A[a] \) заменяется на \( A[\operatorname{rev}_k(a)] \), где \( \operatorname{rev}_k(a) \) получается, если представить число \( a \) в виде последовательности \( k \) битов, а затем написать эти биты в обратном порядке. Иными словами, если \( a = \sum_{i=0}^{k-1} a_i 2^i \), то

\[
\operatorname{rev}_k(a) = \sum_{i=0}^{k-1} a_{k-i-1} 2^i.
\]

Пример: \( \operatorname{rev}_4(3) = 12 \), поскольку 3 в двоичной записи есть 0011, а 1100 — двоичная запись числа 12.

а. Легко вычислить \( \operatorname{rev}_k(a) \) за время \( \Theta(k) \). Как произвести операцию обращения битов индекса в массиве длиной \( n = 2^k \) за время \( O(nk) \)? Чтобы выполнять обращение битов индекса быстрее, можно применить амортизационный анализ к процедуре прибавления единицы наоборот, которая даёт \( \operatorname{rev}_k(a+1) \) по данному \( \operatorname{rev}_k(a) \). Выделим массив битов длиной \( k \) для хранения счетчика с обращённым порядком битов. Нам нужно разработать процедуру Bit-Reversed-Increment, переводящую \( \operatorname{rev}_k(a) \) в \( \operatorname{rev}_k(a) + 1 \). Если, например, \( k = 4 \) и первоначально в счетчике с обращённым порядком битов было записано 0000, то в результате последовательных вызовов процедуры Bit-Reversed-Increment значения счётчика будут равны

0000, 1000, 0100, 1100, 0010, 1010, ... = 0, 8, 4, 12, 2, 10, ...

б. Пусть компьютер умеет за единичное время проводить с \( k \)-битными словами такие операции, как сдвиг на произвольное количество битов, логические И и ИЛИ и т.д. Как нужно реализовать процедуру Bit-Reversed-Increment, чтобы обращение битов индекса у массива длиной \( n = 2^k \) занимало \( O(n) \) времени?

в. Пусть за единичное время \( k \)-битное слово можно сдвинуть лишь на один бит. Можно ли в этом случае провести обращение битов индекса за время \( O(n) \)?