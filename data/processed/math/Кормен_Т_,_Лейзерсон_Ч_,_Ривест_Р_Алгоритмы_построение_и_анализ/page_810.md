---
source_image: page_810.png
page_number: 810
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 60.82
tokens: 11773
characters: 2659
timestamp: 2025-12-24T06:58:28.741323
finish_reason: stop
---

[рисунок совпадает с 35.8 (а), только добавлено обозначение \( p_1 \) для точки рядом с \( p_0 \)]

35.9 Если точки \( p_1, \ldots, p_k, p_j, p_i \) идут в порядке возрастания полярных углов (относительно точки \( p_0 \)), которые меняются в промежутке от \([0, \pi)\), и при движении по двум соседним участкам \( p_k p_j p_i \) ломаной \( p_0 p_1 \ldots p_k p_j p_i \) мы поворачиваем вправо или идём прямо, то выпуклая оболочка точек \( p_1, \ldots, p_k, p_j, p_i \) не изменится после удаления точки \( p_j \) (поскольку она лежит внутри треугольника \( p_0 p_k p_i \)).

ния нескольких (и, возможно, многих) старых.

Тем не менее, методы амортизационного анализа позволяют легко доказать, что общее число действий есть \( O(n) \). В самом деле, любая точка \( p_i \) добавляется в стек \( S \) только один раз, а потому и удаляется не более одного раза. Тем самым общее время и на добавление, и на удаление есть \( O(n) \). (Аналогичное рассуждение мы использовали в разделе 18.1 при анализе процедуры MULTIPOR.)

Проход Джарвиса

Проход Джарвиса вычисляет выпуклую оболочку множества точек \( Q \) при помощи "заворачивания" (package wrapping, gift wrapping). Алгоритм требует времени \( O(nh) \), где \( h \) — число вершин выпуклой оболочки. Поэтому, для класса задач, где \( h \) есть \( o(\lg n) \), проход Джарвиса асимптотически быстрее просмотра Грэхема.

Идея алгоритма такова: мы хотим обвязать наши гвозди верёвкой. Конец верёвки прикрепим к нижнему гвоздю \( p_0 \) (которая выбирается как и в предыдущем алгоритме), и пустили верёвку вправо. Затем будем поднимать правый конец верёвки, пока она не коснётся некоторого гвоздя \( p_1 \). Дальше мы вращаем верёвку уже относительно \( p_1 \), пока она не коснётся следующего гвоздя \( p_2 \). Так продолжается, пока верёвка не дойдёт до исходной точки \( p_0 \).

Более формально, последовательность точек \( H = \langle p_0, p_1, \ldots, p_h - 1 \rangle \), являющихся вершинами \( CH(Q) \), строится так. Мы начинаем с точки \( p_0 \). Следующая точка \( p_1 \) имеет наименьший (среди всех точек множества \( Q \)) полярный угол относительно \( p_0 \) (см. рис. 35.10) (Если таковых несколько, выбираем самую далёкую.) Затем мы, стоя в точке \( p_1 \), сравниваем полярные углы всех точек и выбираем точку \( p_2 \) с наименьшим полярным углом (относительно \( p_1 \)), и так далее. В какой-то момент мы дойдём до верхней точки (точки с наибольшей ординатой), после чего процесс продолжится, только теперь надо отсчитывать полярные углы от луча, направленного влево, а не вправо. Тем самым мы построим сначала (до верхней точки) правую цепь (right chain) выпуклой оболочки, а затем левую цепь