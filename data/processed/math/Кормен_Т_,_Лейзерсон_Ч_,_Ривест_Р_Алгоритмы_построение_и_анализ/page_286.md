---
source_image: page_286.png
page_number: 286
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 62.79
tokens: 11575
characters: 2481
timestamp: 2025-12-24T06:33:46.633613
finish_reason: stop
---

Глава 15 Пополнение структур данных

информации дан в упр. 15.2-1.)

На шаге 3 мы убедились, что обновление полей size при добавлении и удалении элементов можно выполнить без ухудшения асимптотики для времени добавления и удаления. В этом смысле наш выбор удачен: если бы, скажем, мы решили хранить для каждой вершины её порядковый номер, то процедуры OS-SELECT и OS-RANK работали бы быстро, но добавление нового элемента повлекло бы за собой изменение дополнительной информации во многих вершинах дерева (во всех, если добавленный элемент минимальен). Наш выбор (поле size) даёт удачный компромисс между лёгкостью использования и обновления.

На шаге 4 мы реализовали процедуры OS-SELECT и OS-RANK, из-за которых мы, собственно, и затевали всё это дело.

Впрочем, в других ситуациях (упр. 15.2-1) дополнительная информация используется не для реализации новых операций, а для ускорения уже имеющихся.

Дополнительная информация для красно-чёрных деревьев

Следующая теорема показывает, что для красно-чёрных деревьев информацию определённого вида можно обновлять, не замедляя (асимптотически) операции добавления и удаления. Её доказательство во многом повторяет рассуждения из раздела 15.1.

Теорема 15.1 (Пополнение красно-чёрного дерева). Рассмотрим дополнительный атрибут f, определённый для вершин красно-чёрных деревьев. Предположим, что для всякой вершины x значение f[x] полностью задаётся остальной информацией, хранящейся в вершинах x, left[x] и right[x] (в том числе значениями f[left[x]] и f[right[x]]), и его вычисление по этим данным требует времени O(1). Тогда поля f можно обновлять при добавлении и удалении элемента из дерева, не ухудшая (асимптотически) время выполнения добавления и удаления.

Доказательство. Идея доказательства состоит в том, что изменение поля f в некоторой вершине x повлечёт за собой изменения поля f только в вершинах, расположенных на пути из корня в x. В самом деле, изменение f[x] повлечёт за собой изменение f[p[x]], что в свою очередь изменит f[p[p[x]]] и т.д., но другие вершины останутся нетронутыми. От f[root[T]] не зависит значение поля f в других вершинах, и процесс изменений остановится. Так как высота дерева равна O(log n), то после изменения поля f[x] для какой-то одной вершины x мы сможем обновить все необходимые поля за время O(log n).

Добавление элемента x в дерево T делается в два этапа (см. разд. 14.3). На первом этапе вершину x добавляют в качестве ребёнка уже существующей вершины p[x]. Значение f[x] вычисля-