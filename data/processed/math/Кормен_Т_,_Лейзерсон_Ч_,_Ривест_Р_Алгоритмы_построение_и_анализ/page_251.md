---
source_image: page_251.png
page_number: 251
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 57.17
tokens: 11423
characters: 1821
timestamp: 2025-12-24T06:31:59.576730
finish_reason: stop
---

Добывление и удаление элемента

TREE-DELETE(T, z)
1   if left[z] = NIL или right[z] = NIL
2     then y ← z
3     else y ← TREE-SUCCESSOR(z)
4     if left[y] ≠ NIL
5       then x ← left[y]
6       else x ← right[y]
7     if x ≠ NIL
8       then p[x] ← p[y]
9     if p[y] = NIL
10       then root[T] ← x
11       else if y = left[p[y]]
12         then left[p[y]] ← x
13         else right[p[y]] ← x
14     if y ≠ z
15       then key[z] ← key[y]
16         ▷ копируем дополнительные данные, связанные с y
17     return y

В строках 1–3 определяется вершина y, которую мы потом вырежем из дерева. Это либо сама вершина z (если у z не более одного ребёнка), либо следующий за z элемент (если у z двое детей). Затем в строках 4–6 переменная x становится указателем на существующего ребёнка вершины y, или равной NIL, если у y нет детей. Вершина y вырезается из дерева в строках 7–13 (меняются указатели в вершинах p[y] и x). При этом отдельно рассматриваются граничные случаи, когда x = NIL и когда y является корнем дерева. Наконец, в строках 14–16, если вырезанная вершина y отлична от z, ключ (и дополнительные данные) вершины y перемещаются в z (ведь нам надо было удалить z, а не y). Наконец, процедура возвращает указатель y (это позволит вызывающей процедуре впоследствии освободить память, занятую вершиной y). Время выполнения есть O(h) на дереве высоты h.

Итак, мы доказали следующую теорему.

Теорема 13.2. Операции INSERT и DELETE могут быть выполнены за время O(h), где h — высота дерева.

Упражнения

13.3-1 Напишите рекурсивный вариант процедуры TREE-INSERT.

13.3-2 Начиная с пустого дерева, будем добавлять элементы с различными ключами один за другим. Если после этого мы проводим поиск элемента с ключом x, то число сравнений на единицу больше числа сравнений, выполненных при добавлении этого элемента. По-