---
source_image: page_056.png
page_number: 56
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 66.34
tokens: 11598
characters: 2029
timestamp: 2025-12-24T06:22:51.806098
finish_reason: stop
---

(для простоты мы вновь игнорируем округления). Здесь сумма значений на каждом уровне равна \( n \). Дерево обрывается, когда значения аргумента становятся сравнимыми с 1. Для разных ветвей это происходит на разной глубине, и самый длинный путь \( n \to (2/3)n \to (2/3)^2n \to \cdots \to 1 \) требует около \( k = \log_{3/2} n \) шагов (при таком \( k \) мы имеем \( (2/3)^k n = 1 \)). Поэтому \( T(n) \) можно оценить как \( O(n \lg n) \).

Упражнения

4.2-1 Итерируя (подставляя в себя) соотношение \( T(n) = 3T(\lfloor n/2 \rfloor) + n \), найдите хорошую верхнюю асимптотическую оценку для \( T(n) \).

4.2-2 Анализируя дерево рекурсии, покажите, что \( T(n) = T(n/3) + T(2n/3) + n \) влечёт \( T(n) = \Omega(n \lg n) \).

4.2-3 Нарисуйте дерево рекурсии для \( T(n) = 4T(\lfloor n/2 \rfloor) + n \) и получите асимптотически точные оценки для \( T(n) \).

4.2-4 С помощью итераций решите соотношение \( T(n) = T(n - a) + T(a) + n \), где \( a \geq 1 \) — некоторая константа.

4.2-5 С помощью дерева рекурсии решите соотношение \( T(n) = T(\alpha n) + T((1 - \alpha)n) + n \), где \( \alpha \) — константа в интервале \( 0 < \alpha < 1 \).

4.3 Общий рецепт

Этот метод годится для рекуррентных соотношений вида

\[
T(n) = aT(n/b) + f(n),
\]

где \( a \geq 1 \) и \( b > 1 \) — некоторые константы, а \( f \) — положительная (по крайней мере для больших значений аргумента) функция. Он даёт общую формулу; запомнив её, можно решать в уме различные рекуррентные соотношения.

Соотношение (4.5) возникает, если алгоритм разбивает задачу размера \( n \) на \( a \) подзадач размера \( n/b \), эти подзадачи решаются рекурсивно (каждая за время \( T(n/b) \)) и результаты объединяются. При этом затраты на разбиение и объединение описываются функцией \( f(n) \) (в обозначениях раздела 1.3.2 \( f(n) = C(n) + D(n) \)). Например, для процедуры Merge-Sort мы имеем \( a = 2,\ b = 2,\ f(n) = \Theta(n) \).

Как всегда, в формуле (4.5) возникает проблема с округлением: \( n/b \) может не быть целым. Формально следовало бы заменить