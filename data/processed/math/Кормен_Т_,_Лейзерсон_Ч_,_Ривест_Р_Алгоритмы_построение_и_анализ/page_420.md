---
source_image: page_420.png
page_number: 420
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 59.27
tokens: 11419
characters: 1767
timestamp: 2025-12-24T06:40:12.601844
finish_reason: stop
---

A[0..D(n[H])]. Позиция с номером i в этом массиве предназначена для хранения указателя на корень фибоначчиева дерева степени i. Вначале массив пуст (все его ячейки содержат NIL). Постепенно в него переписываются вершины из корневого списка. Если при этом оказывается, что ячейка для вершины нужной степени уже занята, то у нас есть два дерева этой степени, они объединяются, и мы пытаемся записать объединённое дерево в следующую ячейку массива A. Если и она занята, то мы снова производим операцию объединения, получаем дерево ещё на единицу большей степени и т. д.

CONSOLIDATE(H)
1 for i ← 0 to D(n[H])
2 do A[i] ← NIL
3 for (для) каждой вершины w корневого списка кучи H
4 do x ← w
5 d ← degree[x]
6 while A[d] ≠ NIL
7 do y ← A[d]
8 if key[x] > key[y]
9 then обмен x ↔ y
10 FiB-HEAP-LINK(H, y, x)
11 A[d] ← NIL
12 d ← d + 1
13 A[d] ← x
14 min[H] ← NIL
15 for i ← 0 to D(n[H])
16 do if A[i] ≠ NIL
17 then добавить A[i] в корневой список H
18 if min[H] = NIL or key[A[i]] < key[min[H]]
19 then min[H] ← A[i]

FiB-HEAP-LINK(H, y, x)
1 удалить y из корневого списка кучи H
2 включить y в список детей вершины x, увеличив degree[x]
3 mark[y] ← FALSE

Опишем работу процедуры CONSOLIDATE более подробно. В строках 1–2 массив A заполняется значениями NIL. В цикле for (строки 3–13) мы перебираем все корневые вершины w. Каждую из них мы добавляем к массиву A (соединяя её с имеющимися там вершинами, если нужно). Обработка каждой из корневых вершин w может потребовать нескольких операций FiB-HEAP-LINK и заканчивается созданием дерева, корневая вершина x которого может совпадать, а может и не совпадать с w, но в любом случае это дерево содержит вершину w. После этого элемент массива A[degree[x]] устанавливается таким образом, чтобы он указывал на x. В процессе этих