---
source_image: page_309.png
page_number: 309
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 45.28
tokens: 11435
characters: 1527
timestamp: 2025-12-24T06:34:31.980730
finish_reason: stop
---

Рисунок 16.2 Дерево рекурсии для Recursive-Matrix-Chain(p, 1, 4). В каждой вершине записаны значения i и j. Заштрихованы "лишние" вершины (вычисления в которых повторяют уже проделанные).

На рис. 16.2 изображено дерево рекурсии для Recursive-Matrix-Chain(p, 1, 4). В каждой вершине записаны значения i и j. Обратите внимание, что некоторые пары (i, j) встречаются многократно.

Легко видеть, что время работы Recursive-Matrix-Chain(p, 1, n) зависит от n по меньшей мере экспоненциально. В самом деле, обозначим его T(n) и примем, что время исполнения строк 1–2, а также 6–7, равно единице. Тогда:

\[
T(1) \geq 1,
\]
\[
T(n) \geq 1 + \sum_{k=1}^{n-1} (T(k) + T(n-k) + 1), \quad \text{если } n > 1.
\]

В сумме по k каждое T(i) (при \( i = 1, 2, \ldots, n-1 \)) встречается дважды, и ещё есть n – 1 единиц. Стало быть,

\[
T(n) \geq 2 \sum_{i=1}^{n-1} T(i) + n. \tag{16.4}
\]

Докажем по индукции, что \( T(n) \geq 2^{n-1} \) для всех \( n \geq 1 \). При \( n = 1 \) неравенство выполнено, так как \( T(1) \geq 1 = 2^0 \). Шаг индукции:

\[
T(n) \geq 2 \sum_{i=1}^{n-1} 2^{i-1} + n = 2 \sum_{i=0}^{n-2} 2^i + n =
\]
\[
= 2(2^{n-1} - 1) + n = 2^n - 2 + n \geq 2^{n-1}.
\]

Мы видим, что алгоритм Recursive-Matrix-Chain требует экспоненциального времени. Причина в том, что этот алгоритм многократно встречает одинаковые подзадачи и каждый раз решает их заново. Различных подзадач всего лишь \( \Theta(n^2) \), и масса времени теряется на лишнюю работу. Метод динамического программирования позволяет этой лишней работы избежать.