---
source_image: page_877.png
page_number: 877
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 57.47
tokens: 11706
characters: 2632
timestamp: 2025-12-24T07:01:28.272236
finish_reason: stop
---

Теорема. Алгоритм Approx-Subset-Sum представляет собой полностью полиномиальную схему приближения для задачи о сумме подмножества.

Доказательство. Обе операции (сокращение списка в строке 5 и удаление слишком больших элементов в строке 6) могут лишь уменьшить список, так что список \( L_i \) остаётся подмножеством множества \( P_i \). (Напомним, что через \( P_i \) обозначается множество всех чисел, которые можно получить, складывая некоторые из \( x_1, x_2, \ldots, x_i \).) Таким образом, число \( z \) действительно будет суммой некоторого подмножества, причём \( z \leq t \). Осталось проверить лишь, что оно не меньше \( (1 - \varepsilon) \), умноженного на максимальную возможную сумму, не превосходящую \( t \). (Именно этого требует неравенство (37.2) для нашего случая.)

Посмотрим, к какой ошибке приводит сокращение списка на каждом шаге. При сокращении остающееся число будет меньше вычеркнутого, но не намного: не более чем на \( (\varepsilon / n) \)-ую долю. Другими словами, остающийся элемент не меньше вычеркнутого, умноженного на \( (1 - \varepsilon / n) \). Рассуждая по индукции, легко видеть, что для всякого элемента у множества \( P_i \), не превосходящего \( t \), можно указать элемент \( z \) в списке \( L_i \), для которого

\[
(1 - \varepsilon / n)^i y \leq z \leq y.
\]

В частности, при \( i = n \) можно взять в качестве у оптимальное решение задачи о сумме подмножества и убедиться, что существует \( z \in L_n \), для которого

\[
(1 - \varepsilon / n)^n y \leq z \leq y
\]

тем самым ответ алгоритма (который заведомо не меньше этого \( z \)) будет не меньше \( (1 - \varepsilon / n)^n y \). Нам остается только убедиться, что \( (1 - \varepsilon / n)^n \geq (1 - \varepsilon ) \).

В самом деле, продифференцировав \( (1 - \varepsilon / u)^u \) по \( u \), убеждаемся, что это выражение возрастает как функция от \( u \); остаётся сравнить его значения при \( u = 1 \) и \( u = n \).

[Это легко понять и без производных: в убывающей последовательности

\[
1, (1 - \delta), (1 - \delta)^2, \ldots, (1 - \delta)^n
\]

второй член меньше первого (на \( \delta \)), третий член меньше второго и т.п. Разности между соседними членами убывают, так как составляют фиксированную долю от уменьшаемого. Поэтому общее изменение при переходе от первого члена к последнему не превосходит \( n \delta \) и \( (1 - \delta)^n \geq 1 - n \delta \). Остаётся положить \( \delta = \varepsilon / n \).]

Теперь оценим время работы нашего алгоритма, для чего надо оценить длину списков \( L_i \). После сокращения списка соседние его элементы отличаются как минимум в \( 1/(1 - \varepsilon / n) \) раз. При этом