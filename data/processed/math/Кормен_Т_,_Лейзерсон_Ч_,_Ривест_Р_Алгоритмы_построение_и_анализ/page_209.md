---
source_image: page_209.png
page_number: 209
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 43.98
tokens: 11296
characters: 1424
timestamp: 2025-12-24T06:29:48.035905
finish_reason: stop
---

Рисунок 11.8 Списки \( L_1 \) (светло-серый) и \( L_2 \) (тёмно-серый), а также список свободных мест (черный) хранятся в одной тройке массивов.

ALLOCATE-OBJECT()

1 if free = NIL
2 then error "Свободного места нет"
3 else x ← free
4 free ← next[x]
5 return x

FREE-OBJECT(x)
1 next[x] ← free
2 free ← x

Первоначально список свободных позиций содержит \( n \) элементов. Если свободного места не осталось, процедура ALLOCATE-OBJECT сообщает об ошибке.

Часто один список свободных позиций обслуживает сразу несколько динамических множеств (рис. 11.8).

Описанные процедуры выделения и освобождения памяти просты и удобны (работают за время \( O(1) \)). Их можно приспособить для хранения однотипных записей любого вида, отведя одно из полей записи под хранение индекса next (в свободных позициях).

Упражнения

11.3-1 Следуя образцу рис. 11.5, изобразите представление последовательности \( \langle 13, 4, 8, 19, 5, 11 \rangle \) в виде двусторонне связанного списка, реализованного с помощью трех массивов; по образцу рис. 11.6 изобразите тот же список, реализованный с помощью одного массива.

11.3-2 Напишите процедуры ALLOCATE-OBJECT и FREE-OBJECT для случая однотипных записей, хранящихся в одном массиве.

11.3-3 Почему в процедурах ALLOCATE-OBJECT и FREE-OBJECT никак не фигурирует поле prev?

11.3-4 Часто (например, при страничной организации виртуальной памяти) бывает полезно хранить элементы списка в непрерыв-