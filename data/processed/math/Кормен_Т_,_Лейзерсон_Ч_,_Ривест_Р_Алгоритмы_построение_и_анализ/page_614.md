---
source_image: page_614.png
page_number: 614
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 62.37
tokens: 11786
characters: 2448
timestamp: 2025-12-24T06:49:36.227036
finish_reason: stop
---

29.2.3 Вычисление типов переноса с помощью параллельной префиксной схемы

Здесь мы рассмотрим схему, использующую возможность параллельных вычислений и позволяющую за время \( O(\lg n) \) вычислить все типы переноса \( y_i \). Она имеет размер \( \Theta(n) \).

Введём некоторые обозначения. При \( 0 \leq i \leq j \leq n \) положим

\[
[i, j] = x_i \otimes x_{i+1} \otimes \ldots \otimes x_j
\]

В частности, \( [i, i] = x_i \). Если \( 0 \leq i < j \leq k \leq n \), то

\[
[i, k] = [i, j-1] \otimes [j, k]
\]

поскольку операция композиции \( \otimes \) ассоциативна. Наша цель — вычислить все \( y_i = [0, i] \).

Схема состоит из одинаковых элементов, каждый из которых вычисляет композицию \( \otimes \). Идея её проста: на первом уровне параллельно вычисляются композиции пар ([1, 2], [3, 4], ...), затем четвёрок и так далее, пока мы не дойдем до композиции всех элементов. Затем мы движемся в обратном направлении, пока не доходим до искомых \( y_i \). Фрагмент дерева (внутренняя вершина и её потомки) показан на рис. 29.8. На рис. 29.9 показана полная схема для \( n = 8 \). Входы \( x_1, \ldots x_n \) и выходы \( y_0, \ldots, y_{n-1} \) расположены в листьях дерева, а вход \( x_0 \) и выход \( y_n \) — в корне, так что данные движутся по дереву сначала от листьев к корню, а потом обратно.

Рисунок 29.8 Схема для параллельного вычисления префиксов. Показана внутренняя вершина, отвечающая за \( x_i \ldots x_k \). Левое поддерево объединяет входы \( x_i, \ldots, x_{j-1} \), правое — входы \( x_j, \ldots, x_k \). Два элемента \( \otimes \) (один используется при прямом ходе, другой — при обратном) вычисляют \( [i, k] = [i, j-1] \otimes [j, k] \) и \( [0, j-1] = [0, i-1] \otimes [i, j-1] \).

Рисунок 29.9 29.9 Случай \( n = 8 \). (а) Общая структура и вычисляемые значения (б) Значения, соответствующие примеру на рис. 29.3

Два элемента \( \otimes \) в каждом узле работают в разное время (имеют разную глубину): левый (на рис. 29.8) работает "на пути вверх", а правый — на пути вниз. Убедитесь в том, что схема работает правильно, можно по индукции. Предполагая, что поддеревья на рис. 28.8 вычисляют \( [i, j-1] \) и \( [j, k] \), мы получаем, что левый элемент \( \otimes \) вычисляет \( [i, k] \) так что вычисления снизу вверх правильны. Проследим за движением информации вниз. Предполагая, что в вершину на рис. 29.8 сверху приходит правильное значение \( [0, i-1] \), мы видим, что правый элемент \( \otimes \) правильно