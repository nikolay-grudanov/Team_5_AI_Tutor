---
source_image: page_873.png
page_number: 873
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 48.26
tokens: 11506
characters: 1988
timestamp: 2025-12-24T07:01:07.912342
finish_reason: stop
---

Глава 37  Приближённые алгоритмы

оценка немного лучше, чем для приведённого в разделе 37.1 алгоритма Approx-Vertex-Cover.)

Упражнения.
37.3-1
Рассмотрим каждое из слов arid, dash, drain, heard, lost, nose, shun, slate, snare, thread как множество букв. Что даёт алгоритм Greedy-Set-Cover в применении к этим множествам? (Если возникает выбор между несколькими словами, берётся первое в алфавитном порядке.)
37.3-2
Покажите, что задача о покрытии множествами, рассматриваемая как задача разрешения, является NP-полной, сведя к ней задачу о вершинном покрытии.
37.3-3
Покажать, что можно реализовать алгоритм Greedy-Set-Cover с временем работы \( O(\sum_{S \in \mathcal{F}} |S|) \).
37.3-4
Объясните, почему следующее ослабление утверждения теоремы 37.4 очевидно:

\[
|\mathcal{C}| \leq |\mathcal{C}^*| \cdot \max\{|S| : S \in \mathcal{F}\}.
\]

37.5
Приведите примеры, показывающие, что количество различных ответов, даваемых алгоритмом Greedy-Set-Cover при разных способах выбора множества в строке 4 (из множеств, покрывающих одинаковое число ещё не покрытых элементов), может экспоненциально расти с ростом размера задачи.

37.3 Задача о сумме подмножества

Исходным данным для этой задачи является пара \((S, t)\), где \(S = \{x_1, x_2, \ldots, x_n\}\) представляет собой некоторое множество положительных целых чисел, а \(t\) — положительное целое число. Зная \(S\) и \(t\), надо выяснить, можно ли найти подмножество множества \(S\), сумма элементов которого в точности равна \(t\). Эта задача является NP-полной (см. раздел 36.5.3).

Задачу можно ставить и в оптимизационном варианте, требуя отыскать среди подмножеств, сумма которых не превосходит \(t\), такое, у которого сумма ближе всего к \(t\). Можно представить себе, что мы должны как можно больше загрузить машину грузоподъёмности \(t\), имея ящики весов \(x_1, \ldots, x_n\) (но не переходя границы).

В этом разделе мы приводим алгоритм, решающий эту задачу за экспоненциальное время, и показываем, как из него получить