---
source_image: page_473.png
page_number: 473
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 69.48
tokens: 11708
characters: 2503
timestamp: 2025-12-24T06:42:50.047563
finish_reason: stop
---

Рисунок 23.7 23.9 (а) Ориентированный граф G и его сильно связные компоненты (показаны серым). (б) Транспонированный граф \( G^T \). Показано дерево поиска в глубину, вычисляемое в строке 3 процедуры Strongly-Connected-Components Ребра дерева обведены серым. Вершины b, c, g, h, являющиеся корнями деревьев поиска в глубину (для графа \( G^T \)), выделены чёрным. (с) Ациклический граф, который получится, если стянуть каждую сильно связанную компоненту графа G в точку.

23.4-5
Другой способ топологической сортировки состоит в том, чтобы последовательно находить вершины с входящей степенью 0, печатать их и удалять из графа вместе со всеми выходящими из них рёбрами. Как реализовать эту идею, чтобы время выполнения составило \( O(V + E) \)? Что произойдёт, если в исходном графе есть циклы?

23.5 Сильно связные компоненты.

23.1.5 Сильно связные компоненты

Классическое применение поиска в глубину — задача о разложении графа на сильно связные компоненты. Мы покажем, как это можно сделать, дважды выполнив поиск в глубину.

Многие алгоритмы, работающие на ориентированных графах, начинают с отыскания сильно связных компонент: после этого задача решается отдельно для каждой компоненты, а потом решения комбинируются в соответствии со связями между компонентами. Эти связи можно представлять в виде так называемого "графа компонент" (упр. 23.5-4).

Вспомним (глава 5), что сильно связной компонентой ориентированного графа \( G = (V, E) \) называется максимальное множество вершин \( U \subset V \) с таким свойством: любые две вершины \( u \) и \( v \) из \( U \) достижимы друг из друга (\( u \leadsto v \) и \( v \leadsto u \)).

Пример графа с выделенными сильно связными компонентами показан на рис. 23.9.

Алгоритм поиска сильно связных компонент графа \( G = (V, E) \) будет использовать "транспонированный" граф \( G^T = (V, E^T) \) (упр. 23.1-3), получаемый из исходного обращением стрелок на рёбрах: \( E^T = \{ (u, v) : (v, u) \in E \} \). Такой граф можно построить за время \( O(V + E) \) (мы считаем, что исходный и транспонированный графы заданы с помощью списков смежных вершин). Легко понять, что \( G \) и \( G^T \) имеют одни и те же сильно связные компоненты (поскольку \( v \) достижимо из \( u \) в \( G^T \), если и только если \( u \) достижимо из \( v \) в \( G^T \)). На рисунке 23.9 (б) показан трезультат транспонирования графа рис. 23.9 (а).

Следующий алгоритм находит сильно связные компоненты ориентированного графа \( G = (V, E) \), используя два поиска в глубину