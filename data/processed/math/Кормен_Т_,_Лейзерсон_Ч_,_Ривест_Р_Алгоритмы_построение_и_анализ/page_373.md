---
source_image: page_373.png
page_number: 373
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 61.49
tokens: 11572
characters: 2526
timestamp: 2025-12-24T06:38:04.703386
finish_reason: stop
---

"рекордно" быстрые алгоритмы обработки графов используют фибоначчиевы кучи.

Наконец, в главе 22 мы рассматриваем структуры данных для хранения непересекающихся множеств (отношений эквивалентности). Мы имеем в виду следующее: имеется некоторое конечное множество, разбитое на классы. В начальный момент каждый класс содержит по одному элементу; затем их можно попарно объединять. В любой момент один из элементов класса считается его представителем; операция Find-Set(x) даёт представитель класса, содержащего x, операция Union(x, y) объединяет два класса. Оказывается, что весьма простое представление этой информации в виде корневого дерева весьма эффективно: последовательность из m операций требует времени O(mα(m, n)), где α(m, n) — исключительно медленно растущая функция. Правда, доказать эту оценку весьма непросто (несмотря на простоту самой структуры данных), и мы ограничимся доказательство чуть менее сильной оценки.

Разумеется, этот раздел книги никак не претендует на полноту — множество интересных структур данных в него не вошли. Укажем некоторые из них:

• Структура данных, поддерживающая операции отыскания минимума, максимума, добавления и удаления элемента, поиска, удаления минимального и максимального элементов, поиск предыдущего и следующего элементов за время O(lg lg n) в худшем случае — в предположении, что все ключи являются целыми числами от 1 до n (ван Эмде Боас [194]).

• Динамические деревья (dynamic trees), которые предложили Слеатор и Тарьян [177] (см. также Тарьян [188]). Эта структура данных хранит лес из непересекающихся корневых деревьев. Каждое ребро каждого дерева имеет некоторый вещественную стоимость. Можно искать родителей, корни, стоимости рёбер, а также минимальную стоимость ребра на пути от данной вершины к корню. Можно удалять рёбра, менять стоимости рёбер на пути к корню, прививать корень дерева к другому дереву, а также делать заданную вершину корнем дерева, в котором она находится. Все эти операции можно реализовать с учётной стоимостью O(lg n); более сложная реализация гарантирует время работы O(lg n) и в худшем случае.

• Расширяющиеся деревья (splay trees) также предложили Слеатор и Тарьян [178] (см. также Тарьян [188]). Они представляют собой двоичные деревья с обычными для деревьев поиска операциями; их учётная стоимость составляет O(lg n) (за счёт того, что время от времени дерево подвергается балансировке). Расширяющиеся деревья можно применить при реализации динамических деревьев.

• Структуры данных с сохранением предыдущих версий (persistent