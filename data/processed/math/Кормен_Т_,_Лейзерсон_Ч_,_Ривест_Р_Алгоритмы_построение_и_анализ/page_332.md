---
source_image: page_332.png
page_number: 332
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 60.80
tokens: 11600
characters: 2263
timestamp: 2025-12-24T06:36:00.762783
finish_reason: stop
---

Коды Хаффмена

17.2-2 Разработайте основанный на динамическом программировании алгоритм для решения дискретной задачи о рюкзаке. Алгоритм должен работать за время \( O(nW) \) (\( n \) — количество вещей, \( W \) — максимальный вес рюкзака).

17.2-3 Пусть в дискретной задаче о рюкзаке вещи можно упорядочить таким образом, чтобы одновременно выполнялись неравенства \( w_1 \leq w_2 \leq \cdots \leq w_n \) и \( v_1 \geq v_2 \geq \cdots \geq v_n \). Разработайте эффективный алгоритм для нахождения оптимального набора и докажите, что он правилен.

17.2-4 Профессор едет по шоссе из Петербурга в Москву, имея при себе карту с указанием всех стоящих на шоссе бензоколонок и расстояний между ними. Известно расстояние, которое может проехать машина с полностью заправленным баком. Разработайте эффективный алгоритм, позволяющий выяснить, на каких бензоколонках надо заправляться, чтобы количество заправок было минимально. (В начале пути бак полон.)

17.2-5 Дано \( n \) точек \( x_1, x_2, \ldots, x_n \) на координатной прямой; требуется покрыть все эти точки наименьшим числом отрезков длины 1. Разработайте эффективный алгоритм, решающий эту оптимизационную задачу.

17.2-6* Предполагая известным решение задачи 10-2, найдите решение непрерывной задачи о рюкзаке за время \( O(n) \).

17.3 Коды Хаффмена

Коды Хаффмена широко используются при сжатия информации (в типичной ситуации выигрыш может составить от 20% до 90% в зависимости от типа файла). Алгоритм Хаффмена находит оптимальные коды символов (исходя из частоты использования этих символов в сжимаемом тексте) с помощью жадного выбора.

Пусть в файле длины 100 000 известны частоты символов (рис. 17.3). Мы хотим построить двоичный код (binary character code), в котором каждый символ представляется в виде конечной последовательности битов, называемой кодовым словом (codeword). При использовании равномерного кода (fixed-length code), в котором все кодовые слова имеют одинаковую длину, на каждый символ (из шести имеющихся) надо потратить как минимум три бита, например, \( a = 000, b = 001, \ldots, f = 101 \). На весь файл уйдет 300 000 битов — нельзя ли уменьшить это число?

Неравномерный код (variable-length code) будет экономнее, если часто встречающиеся символы закодировать короткими последо-