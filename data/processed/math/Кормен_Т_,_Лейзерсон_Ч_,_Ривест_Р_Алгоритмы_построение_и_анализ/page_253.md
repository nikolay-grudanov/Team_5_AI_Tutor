---
source_image: page_253.png
page_number: 253
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 78.27
tokens: 11774
characters: 2530
timestamp: 2025-12-24T06:32:24.784608
finish_reason: stop
---

13.4 Случайные двоичные деревья поиска

одному и тому же дереву.) В этом разделе мы докажем, что математическое ожидание высоты случайного дерева из \( n \) ключей есть \( O(\lg n) \).

Посмотрим, как связана структура дерева с порядком добавления ключей.

Лемма 13.3. Пусть \( T \) — дерево, получающееся после добавления \( n \) различных ключей \( k_1, k_2, \ldots, k_n \) (в указанном порядке) к изначально пустому дереву. Тогда \( k_i \) является предком \( k_j \) в \( T \) тогда и только тогда, когда \( i < j \), и при этом

\[
k_i = \min\{k_l : 1 \leq l \leq i \text{ и } k_l > k_j\}
\]

(ключ \( k_i \) больше \( k_j \) и их не разделяет ни один ключ среди \( k_1, \ldots, k_i \))

или

\[
k_i = \max\{k_l : 1 \leq l \leq i \text{ и } k_l < k_j\}
\]

(ключ \( k_i \) меньше \( k_j \) и их не разделяет ни один ключ среди \( k_1, \ldots, k_i \))

Доказательство. \( \Rightarrow \): Предположим, что \( k_i \) является предком \( k_j \). Очевидно, \( i < j \) (потомок появляется в дереве позже предка). Рассмотрим дерево \( T_i \), которое получается после добавления ключей \( k_1, k_2, \ldots, k_i \). Путь в \( T_i \) от корня до \( k_i \) тот же, что и путь в \( T \) от корня до \( k_i \). Таким образом, если бы ключ \( k_j \) был добавлен в \( T_i \), он стал бы правым или левым ребёнком \( k_i \). Следовательно (см. упр. 13.2-6), \( k_i \) является либо наименьшим среди тех ключей из \( k_1, k_2, \ldots, k_i \), которые больше \( k_j \), либо наибольшим среди ключей из того же набора, меньших \( k_j \).

\( \Leftarrow \): Предположим, что \( k_i \) является наименьшим среди тех ключей \( k_1, k_2, \ldots, k_i \), которые больше \( k_j \). (Другой случай симметричен.) Что будет происходить при помещении ключа \( k_j \) в дерево? Сравнение \( k_j \) с ключами на пути от корня к \( k_i \) даст те же результаты, что и для \( k_i \). Следовательно, мы пройдём путь от корня до \( k_i \), так что \( k_j \) станет потомком \( k_i \).

Лемма доказана.

Теперь можно понять, как зависит глубина каждого ключа от перестановки на входе.

Следствие 13.4. Пусть \( T \) — дерево, полученное из пустого добавлением \( n \) различных ключей \( k_1, k_2, \ldots, k_n \) (в указанном порядке). Для каждого ключа \( k_j \) (при всех \( 1 \leq j \leq n \)) рассмотрим множества

\[
G_j = \{k_i : 1 \leq i < j \text{ и } k_l > k_i > k_j \text{ при всех } l < i, \text{ для которых } k_l > k_j\}
\]

и

\[
L_j = \{k_i : 1 \leq i < j \text{ и } k_l < k_i < k_j \text{ при всех } l < i, \text{ для которых } k_l < k_j\}.
\]