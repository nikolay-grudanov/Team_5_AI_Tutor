---
source_image: page_195.png
page_number: 195
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 66.39
tokens: 11533
characters: 2454
timestamp: 2025-12-24T06:29:31.786285
finish_reason: stop
---

Часть III Структуры данных

и применяя функцию SUCCESSOR, мы перечислим все элементы множества в неубывающем порядке и т. п.

Стоимость операций над множествами обычно оценивается через размер множеств, к которым они применяются. Например, в главе 14 мы описываем структуру данных, которая позволяет выполнить каждую из перечисленных операций за время \( O(\lg n) \), где \( n \) — число элементов множества.

Обзор части III

В главах 11–15 мы описываем различные структуры данных, предназначенные для работы с динамическими множествами. С помощью этих структур данных можно разработать эффективные алгоритмы для решения многих различных задач. Кстати, с одной важной структурой данных (кучей) мы уже познакомились в главе 7.

В главе 11 мы разбираем принципы работы с простейшими структурами данных: стеками, очередями, связанными списками и корневыми деревьями. В этой же главе рассказывается, как реализовать записи и указатели с помощью языков программирования, в которых нет соответствующих типов данных. Большая часть материала этой главы составляет стандартный материал начального курса программирования.

В главе 12 мы познакомимся с хеш-таблицами, поддерживающими операции INSERT, DELETE и SEARCH. В худшем случае поиск в хеш-таблице требует времени \( \Theta(n) \), но среднее время, необходимое для выполнения любой из словарных операций с хеш-таблицей, составляет (при некоторых предположениях) лишь \( O(1) \). Анализ хеширования использует теорию вероятностей, но для понимания большей части главы знакомство с этой теорией не обязательно.

В главе 13 мы занимаемся деревьями двоичного поиска. Эти деревья поддерживают все перечисленные операции с множествами. В худшем случае стоимость каждой из операций есть \( \Theta(n) \), но для случайно построенного дерева математическое ожидание этой стоимости есть \( O(\lg n) \). На базе деревьев двоичного поиска строятся многие другие структуры данных.

Глава 14 посвящена красно-чёрным деревьям. Эта разновидность деревьев двоичного поиска гарантированно работает быстро: время выполнения каждой операции в худшем случае есть \( O(\lg n) \). Красно-чёрные деревья представляют собой один из вариантов "сбалансированных" деревьев поиска; другой вариант (Б-деревья) обсуждается в главе 19. Алгоритмы для работы с красно-чёрными деревьями устроены довольно хитро. Хотя детали можно опустить при первом чтении, интересно в них разобраться.

В главе 15 мы рассматриваем дополнительные структуры на