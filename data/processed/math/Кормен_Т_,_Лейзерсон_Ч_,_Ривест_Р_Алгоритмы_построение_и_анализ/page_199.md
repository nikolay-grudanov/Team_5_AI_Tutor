---
source_image: page_199.png
page_number: 199
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 75.90
tokens: 11555
characters: 2192
timestamp: 2025-12-24T06:29:53.417945
finish_reason: stop
---

Стеки и очереди

Очереди

Операцию добавления элемента к очереди мы будем обозначать Enqueue, а операцию удаления элемента из очереди будем обозначать Dequeue. (Как и для стеков, удаляемый из очереди элемент определен однозначно и поэтому является не передаётся процедуре процедуре Dequeue, а возвращается этой процедурой.) Правило здесь такое же, как в живой очереди: первым пришёл — первым обслужен. (И если наши программы правильны, можно не опасаться, что кто-то пройдёт без очереди.)

Другими словами, у очереди есть голова (head) и хвост (tail). Элемент, добавляемый в очередь, оказывается в её хвосте, как только что подошедший покупатель; элемент, удаляемый из очереди, находится в её голове, как тот покупатель, что отстоял дольше всех.

На рис. 11.2 показано, как можно реализовать очередь, вмещающую не более чем \( n - 1 \) элемент, на базе массива \( Q[1..n] \). Мы храним числа \( head[Q] \) — индекс головы очереди, и \( tail[Q] \) — индекс свободной ячейки, в которую будет помещён следующий добавляемый к очереди элемент. Очередь состоит из элементов массива, стоящих на местах с номерами \( head[Q], head[Q] + 1, \ldots, tail[Q] - 1 \) (подразумевается, что массив свёрнут в кольцо: за \( n \) следует 1). Если \( head[Q] = tail[Q] \), то очередь пуста. Первоначально имеем \( head[Q] = tail[Q] = 1 \). Если очередь пуста, попытка удалить элемент из неё ведёт к ошибке (underflow); если \( head[Q] = tail[Q] + 1 \), то очередь полностью заполнена, и попытка добавить к ней элемент вызовет переполнение (overflow).

В наших реализациях процедур Enqueue и Dequeue мы игнорируем возможность переполнения или попытки изъятия элемента из пустой очереди (в упражнении 11.1-4 мы попросим вас внести в код соответствующие проверки).

Enqueue(\( Q, x \))
1 \( Q[tail[Q]] \leftarrow x \)
2 if \( tail[Q] = length[Q] \)
3 then \( tail[Q] \leftarrow 1 \)
4 else \( tail[Q] \leftarrow tail[Q] + 1 \)

Dequeue(\( Q \))
1 \( x \leftarrow Q[head[Q]] \)
2 if \( head[Q] = length[Q] \)
3 then \( head[Q] \leftarrow 1 \)
4 else \( head[Q] \leftarrow head[Q] + 1 \)
5 return \( x \)

Работа процедур Enqueue и Dequeue показана на рис. 11.2. Каждая из этих процедур работает за время \( O(1) \).