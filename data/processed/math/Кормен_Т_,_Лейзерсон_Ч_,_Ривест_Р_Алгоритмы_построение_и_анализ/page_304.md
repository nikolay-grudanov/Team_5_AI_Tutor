---
source_image: page_304.png
page_number: 304
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 69.19
tokens: 11738
characters: 2412
timestamp: 2025-12-24T06:34:40.317179
finish_reason: stop
---

работы такого алгоритма экспоненциально зависит от \( n \), так что этот алгоритм не лучше полного перебора. Настоящий выигрыш во времени мы получим, если воспользуемся тем, что подзадач относительно немного: по одной задаче для каждой пары \((i, j)\), для которой \(1 \leq i \leq j \leq n\), а всего \(C_n^2 + n = \Theta(n^2)\). Экспоненциальное время работы возникает потому, что рекурсивный алгоритм решает каждую из подзадач по многу раз, на разных ветвях дерева рекурсии. Такое "перекрытие подзадач" — характерный признак задач, решаемых методом динамического программирования.

Вместо рекурсии мы вычислим оптимальную стоимость "снизу вверх". В нижеследующей программе предполагается, что матрица \(A_i\) имеет размер \(p_{i-1} \times p_i\) при \(i = 1, 2, \ldots, n\). На вход подаётся последовательность \(p = \langle p_0, p_1, \ldots, p_n \rangle\), где \(length[p] = n + 1\). Программа использует вспомогательные таблицы \(m[1..n, 1..n]\) (для хранения стоимостей \(m[i, j]\)) и \(s[1..n, 1..n]\) (в ней отмечается, при каком \(k\) достигается оптимальная стоимость при вычислении \(m[i, j]\)).

**MATRIX-CHAIN-ORDER**(*p*)

```
1   n ← length[p] − 1
2   for i ← 1 to n
3     do m[i, i] ← 0
4   for l ← 2 to n
5     do for i ← 1 to n − l + 1
6       do j ← i + l − 1
7         m[i, j] ← ∞
8         for k ← i to j − 1
9           do q ← m[i, k] + m[k + 1, j] + p_{i−1} p_k p_j
10           if q < m[i, j]
11             then m[i, j] ← q
12             s[i, j] ← k
13   return m, s
```

Заполняя таблицу \(m\), этот алгоритм последовательно решает задачи об оптимальной расстановке скобок для одного, двух, ..., \(n\) сомножителей. В самом деле, соотношение (16.2) показывает, что число \(m[i, j]\) — стоимость перемножения \(j - i + 1\) матриц — зависит только от стоимостей меньшего (чем \(j - i + 1\)) числа матриц. Именно, для \(k = i, i + 1, \ldots, j - 1\) получается, что \(A_{i..k}\) — произведение \(k - i + 1 < j - i + 1\) матриц, а \(A_{k+1..j}\) — произведение \(j - k < j - i + 1\) матриц.

Сначала (в строках 2–3) алгоритм выполняет присваивания \(m[i, i] ← 0\) для \(i = 1, 2, \ldots, n\): стоимость перемножения последовательности из одной матрицы равна нулю. При первом исполнении цикла (строки 4–12) вычисляются (с помощью соотношений (16.2)) значения \(m[i, i + 1]\) для \(i = 1, 2, \ldots, n - 1\) — это минимальные стоимости для последовательностей длины 2. При втором проходе вычи-