---
source_image: page_581.png
page_number: 581
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 58.30
tokens: 11620
characters: 2295
timestamp: 2025-12-24T06:47:58.588025
finish_reason: stop
---

так, что проталкивание становится возможным, то есть появляется допустимое ребро.

Проверим второе утверждение леммы. Предположим, что после подъёма имеется допустимое ребро \((v, u)\). Тогда \(h(v) = h(u) + 1\) — а до подъёма было выполнено \(h(v) > h(u) + 1\). По определению высотной функции ребро \((u, v)\) должно быть насыщенным (до и после подъёма — подъём не меняет потоков), и потому не входит в остаточную сеть и не является допустимым.

Списки соседей

Алгоритм "поднять-u-в-начало" использует специальный способ хранения рёбер сети \(G = (V, E)\). Именно, для каждой вершины \(u \in V\) имеется односторонне связанный список соседей (neighbor list) \(N[u]\). Вершина \(v\) фигурирует в этом списке, если \((u, v) \in E\) или если \((v, u) \in E\). Таким образом, список \(N[u]\) содержит все вершины \(v\), для которых \((u, v)\) имеет шанс появиться в остаточной сети. Первый элемент этого списка обозначается \(\text{head}[N[u]]\); следующий за вершиной \(v\) сосед — \(\text{next-neighbor}[v]\). Если вершина \(v\) — последняя в списке, то \(\text{next-neighbor}[v] = \text{NIL}\).

Порядок в списке соседей может быть произвольным; он не меняется в ходе работы (всякий раз алгоритм просматривает список соседей в одном и том же порядке). Для каждой вершины и хранится указатель \(\text{current}[u]\) на очередной элемент списка \(N[u]\). Изначально \(\text{current}[u]\) установлен на \(\text{head}[N[u]]\).

Обработка переполненной вершины

Обработка переполненной вершину и состоит в том, что её разряжают (discharge), проталкивая весь избыток потока в соседние по допустимым рёбрам. Иногда для этого необходимо создать новые допустимые рёбра, подняв вершину \(u\).

\textsc{Discharge}($u$)
1 while $e[u]>0$
2 do $v\leftarrow \text{current}[u]$
3 if $v=\text{nil}$
4 then \textsc{Lift($u$)}
5 $current[u]\leftarrow \text{head}[N[u]]$
6 elseif $c_f(u,v)>0$ and $h[u]=h[v]+1$
7 then \textsc{Push($u,v$)}
8 else $current[u]\leftarrow \text{next-neighbor}[v]$

На рис. 27.10 показаны несколько итераций цикла while (строки 1–8).

Каждая итерация цикла while производит одно из трёх действий:
1. Если мы дошли до конца списка (\(v = \text{NIL}\)), то мы поднимаем вершину \(u\) (строка 4) и переходим к началу списка \(N[u]\) (строка 5). Мы видим (лемма 27.29), что подъём возможен.