---
source_image: page_387.png
page_number: 387
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 61.41
tokens: 11493
characters: 2001
timestamp: 2025-12-24T06:38:42.677647
finish_reason: stop
---

Упражнения

19.2-1 Проследить, за добавлением в пустое Б-дерево элементов \( F, S, Q, K, C, L, H, T, V, W, M, R, N, P, A, B, X, Y, D, Z, E \) в указанном порядке (нарисовать только состояния дерева перед разделением какой-то из вершин, а также последнее состояние)

19.2-2 Выяснить, исполняются ли лишние операции Disk-Read или Disk-Write при вызове процедуры B-Tree-Insert. (Лишняя операция Disk-Read читает сектор, уже загруженный в оперативную память. Лишняя операция Disk-Write сохраняет на диске не изменяющийся сектор.)

19.2-3 Как найти минимальный элемент в Б-дереве? Как найти элемент Б-дерева, предшествующий данному элементу?

19.2-4* Ключи 1, 2, ..., n добавляют по одному в пустое Б-дерево минимальной степени 2. Сколько вершин у полученного Б-дерева?

19.2-5 Так как у листьев нет указателей на детей, то в них может поместиться больше ключей, чем во внутренние вершины. Как будут выглядеть процедуры создания Б-дерева и добавления в него элемента, использующие это обстоятельство?

19.2-6 Заменим в процедуре B-Tree-Search линейный поиск двоичным. Показать, что тогда время вычислений для этой процедуры станет равным \( O(\log n) \) (константа не зависит от \( t! \)).

19.2-7 Предположим, что мы можем сами выбрать размер сектора, причем время чтения сектора, вмещающего вершину Б-дерева степени \( t \), будет \( a + bt \), где \( a \) и \( b \) — некоторые константы. Как следует выбрать \( t \), чтобы уменьшить время поиска в Б-дереве? Оцените оптимальное значение \( t \) в случае \( a = 30 \) миллисекунд, \( b = 40 \) микросекунд.

19.3 Удаление элемента из Б-дерева

Удаление элемента из Б-дерева (процедура B-Tree-Delete) происходит аналогично добавлению, хотя немного сложнее. Мы не будем приводить процедуру удаления полностью, а объясним, как она работает.

Пусть нужно удалить ключ \( k \) из поддерева с корнем в вершине \( x \). Наша процедура будет устроена так, что при каждом ее рекурсивном вызове вершина \( x \) содержит по меньшей мере \( t \) ключей, где \( t \)