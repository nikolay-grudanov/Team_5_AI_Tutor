---
source_image: page_149.png
page_number: 149
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 59.42
tokens: 11468
characters: 1822
timestamp: 2025-12-24T06:27:13.499527
finish_reason: stop
---

Описание быстрой сортировки

После этого массив \( A[p..r] \) отсортирован.

Итак, процедура сортировки QUICKSORT выглядит следующим образом:

QUICKSORT\((A, p, r)\)
1 if \( p < r \)
2 then \( q \leftarrow \text{PARTITION}(A, p, r) \)
3 QUICKSORT\((A, p, q)\)
4 QUICKSORT\((A, q + 1, r)\)

Для сортировки всего массива необходимо выполнить процедуру QUICKSORT\((A, 1, \text{length}[A])\).

Разбиение массива

Основной шаг алгоритма — процедура PARTITION, которая переставляет элементы массива \( A[p..r] \) нужным образом:

PARTITION\((A, p, r)\)
1 \( x \leftarrow A[p] \)
2 \( i \leftarrow p - 1 \)
3 \( j \leftarrow r + 1 \)
4 while TRUE
5 do repeat \( j \leftarrow j - 1 \)
6 until \( A[j] \leq x \)
7 repeat \( i \leftarrow i + 1 \)
8 until \( A[i] \geq x \)
9 if \( i < j \)
10 then поменять \( A[i] \leftrightarrow A[j] \)
11 else return \( j \)

Работа процедуры PARTITION показана на рис. 8.1. Элемент \( x = A[p] \) выбирается в качестве "граничного"; массив \( A[p..q] \) будет содержать элементы, не большие \( x \), а массив \( A[q+1..r] \) — элементы, не меньше \( x \). Идея состоит в том, чтобы накапливать элементы, не большие \( x \), в начальном отрезке массива (\( A[p..i] \)), а элементы, не меньше \( x \) — в конце (\( A[j..r] \)). В начале оба "накопителя" пусты: \( i = p - 1, j = r + 1 \).

Внутри цикла while (в строках 5–8) к начальному и конечному участкам присоединяются элементы (как минимум по одному). После выполнения этих строк \( A[i] \geq x \geq A[j] \). Если мы поменяем \( A[i] \) и \( A[j] \) местами, то их можно будет присоединить к начальному и конечному участкам.

В момент выхода из цикла выполнено неравенство \( i \geq j \). При этом массив разбит на части \( A[p], \ldots, A[j] \) и \( A[j+1], \ldots, A[r] \); любой элемент первой части не превосходит любого элемента второй