---
source_image: page_783.png
page_number: 783
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 62.80
tokens: 11796
characters: 2324
timestamp: 2025-12-24T06:57:18.305715
finish_reason: stop
---

Для \( q = 2, 3, \ldots, m \) определим множества \( E_{q-1} \) формулой

\[
E_{q-1} = \{ k : k \in \pi^*[q-1] \text{ и } P[k+1] = P[q] \}
\]

(словами: \( E_{q-1} \) состоит из таких \( k \), что \( P_k \) — суффикс \( P_{q-1} \), и за ними идут одинаковые буквы \( P[k+1] \) и \( P[q] \), так что \( P_{k+1} \) — суффикс \( P_q \)).

Следствие 34.7
Пусть \( P \) — строка длины \( m \) с префикс-функцией \( \pi \). Тогда для всех \( q = 2, 3, \ldots, m \) имеем:

\[
\pi[q] = \begin{cases}
0, & \text{если } E_{q-1} = \emptyset; \\
1 + \max\{ k \in E_{q-1} \}, & \text{если } E_{q-1} \neq \emptyset.
\end{cases}
\]

Доказательство.
Если \( r = \pi[q] \geq 1 \), то \( P[r] = P[q] \); кроме того (лемма 34.6), \( r - 1 \in \pi^*[q-1] \), так что \( r - 1 \in E_{q-1} \). Отсюда ясно, что если \( E_{q-1} \) пусто, то \( \pi[q] = 0 \), и что если \( E_{q-1} \) непусто, то \( \pi[q] \leq 1 + \max\{ k \in E_{q-1} \} \). Осталось показать, что если \( k \in E_{q-1} \), то \( \pi[q] \geq k + 1 \) — но это ясно, поскольку в этом случае \( P_{k+1} \) есть суффикс \( P_q \) (как мы отмечали после определения \( E_{q-1} \)).

Теперь мы можем завершить доказательство правильности процедуры Compute-Prefix-Function. Всех \( q \). Докажем индукцией по \( q \) следующее утверждение: при входе в цикл, начинающийся в строке 4, выполнено равенство \( k = \pi[q-1] \). При \( q = 2 \) это обеспечивается присваиваниями в строках 2 и 3. Шаг индукции: пусть \( k = \pi[q-1] \) при входе в цикл, тогда нам достаточно доказать, что при выходе из цикла будет \( k = \pi[q] \). В самом деле, в строках 5–6 ищется наибольший элемент множества \( E_{q-1} \); если это множество непусто (это равносильно тому, что \( P[k+1] = P[q] \) при выходе из цикла в строках 5–6), то после присваивания в строке 9 число \( k \) оказывается равным \( \pi[q] \) ввиду следствия 34.7. Если же это множество пусто (по выходе из цикла в строках 5–6 оказалось \( k = 0 \) и \( P[k+1] \neq P[q] \)), то оказывается \( \pi[q] = 0 \), что также верно (следствие 34.7).

34.4.4 Алгоритм КМР правилен

Доказательство правильности процедуры KMP-Matcher проходит по той же схеме, что и для процедуры Compute-Prefix-Function. Достаточно (индукцией по \( i \)) доказать такие утверждения:
• В момент исполнения строк 10–12 выполнено равенство \( q = \sigma(T_i) \);