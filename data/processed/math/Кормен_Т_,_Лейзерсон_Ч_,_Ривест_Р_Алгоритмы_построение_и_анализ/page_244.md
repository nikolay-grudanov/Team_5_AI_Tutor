---
source_image: page_244.png
page_number: 244
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 65.78
tokens: 11446
characters: 1794
timestamp: 2025-12-24T06:31:49.406512
finish_reason: stop
---

зывается preorder; порядок, в котором корень следует за ними, называется postorder.)

Вызов Inorder-Tree-Walk(root[T]) печатает (в указанном порядке) все ключи, входящие в дерево T с корнем root[T].

Inorder-Tree-Walk(x)
1 if x ≠ NIL
2 then Inorder-Tree-Walk(left[x])
3 напечатать key[x]
4 Inorder-Tree-Walk(right[x])

К примеру, для обоих деревьев рис. 13.1 будет напечатано 2, 3, 5, 5, 7, 8. Свойство упорядоченности гарантирует правильность алгоритма (индукция по высоте поддерева). Время работы на дереве с n вершинами есть \( \Theta(n) \): на каждую вершину тратится ограниченное время (помимо рекурсивных вызовов) и каждая вершина обрабатывается один раз.

Упражнения

13.1-1 Нарисуйте двоичные деревья поиска высоты 2, 3, 4, 5 и 6 для одного и того же множества ключей {1, 4, 5, 10, 16, 17, 21}.

13.1-2 Кучи из раздела 7.1 также были двоичными деревьями, и требование упорядоченности там тоже было. В чём разница между тем требованием и теперьшим? Как вы думаете, можно ли напечатать элементы двоичной кучи в неубывающем порядке за время \( O(n) \)? Объясните ваш ответ.

13.1-3 Напишите нерекурсивный алгоритм, печатающий ключи в двоичном дереве поиска в неубывающем порядке. (Указание: Простое решение использует в качестве дополнительной структуры стек; более изящное решение не требует стека, но предполагает, что можно проверять равенство указателей.)

13.1-4 Напишите рекурсивные алгоритмы для обхода деревьев в различных порядках (preorder, postorder). Как и раньше, время работы должно быть \( O(n) \) (где \( n \) — число вершин).

13.1-5 Покажите, что любой алгоритм построения двоичного дерева поиска, содержащего заданные n элементов, требует (в худшем случае) времени \( \Omega(n \lg n) \). Воспользуйтесь тем, что сортировка n чисел требует \( \Omega(n \lg n) \) действий.