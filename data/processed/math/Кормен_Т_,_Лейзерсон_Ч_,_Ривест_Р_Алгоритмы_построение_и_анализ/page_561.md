---
source_image: page_561.png
page_number: 561
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 71.01
tokens: 11751
characters: 2491
timestamp: 2025-12-24T06:47:18.351709
finish_reason: stop
---

Теперь докажем основную теорему этого раздела (max-flow min-cut theorem).

Теорема 27.7 (о максимальном потоке и минимальном разрезе)
Пусть \( f \) — поток в сети \( G = (V, E) \). Тогда следующие утверждения равносильны:
1. Поток \( f \) максимален (является потоком максимальной величины) в сети \( G \).
2. Остаточная сеть \( G_f \) не содержит дополняющих путей.
3. Для некоторого разреза \( (S, T) \) сети \( G \) выполнено равенство \( |f| = c(S, T) \). (В этом случае, как показывает следствие 27.6, разрез является минимальным, то есть имеет минимально возможную пропускную способность.)

Доказательство
(1) \( \Rightarrow \) (2)
Рассуждая от противного, допустим, что поток \( f \) максимален, но \( G_f \) содержит дополняющий путь \( p \). Рассмотрим сумму \( f + f_p \), где \( f_p \) задается равенством (27.6). По следствию 27.4 эта сумма является потоком в \( G \), величина которого больше \( |f| \), что противоречит максимальности \( f \).

(2) \( \Rightarrow \) (3)
Пусть в сети \( G_f \) нет пути из истока \( s \) в сток \( t \). Рассмотрим множество
\[
S = \{ v \in V \mid \text{в } G_f \text{ существует путь из } s \text{ в } v \}.
\]
Положим \( T = V \setminus S \). Очевидно, что \( s \in S \), а \( t \in T \), так как в \( G_f \) нет пути из \( s \) в \( t \). Поэтому пара \( (S, T) \) — разрез. Ни для каких \( u \in S \) и \( v \in T \) ребро \( (u, v) \) не принадлежит \( E_f \) (в противном случае вершина \( v \) попала бы в \( S \)). Поэтому \( f(u, v) = c(u, v) \). По лемме 27.5 \( |f| = f(S, T) = c(S, T) \).

(3) \( \Rightarrow \) (1)
Для любого разреза \( (S, T) \) выполнено \( |f| \leq c(S, T) \) (следствие 27.6). Поэтому из равенства \( |f| = c(S, T) \) следует, что поток \( f \) максимален.

Общая схема алгоритма Форда-Фалкерсона
Действуя по методу Форда-Фалкерсона, на каждом шаге мы выбираем произвольный дополняющий путь \( p \) и увеличиваем поток \( f \), добавляя поток величины \( c_f(p) \) по пути \( p \). Приводимый ниже алгоритм использует массив \( f[u, v] \) для хранения текущих значения потока. Мы считаем, что функция \( c(u, v) \) вычисляется за время \( O(1) \), при этом \( c(u, v) = 0 \) если \( (u, v) \notin E \). (При естественной реализации значение \( (u, v) \) хранится рядом с рёбрами в списках исходящих рёбер.)

В строке 5 величина \( c_f(u, v) \) понимается в соответствии с формулой (27.5). Символ \( c_f(p) \) обозначает локальную переменную, в которую помещается остаточная пропускная способность пути \( p \).