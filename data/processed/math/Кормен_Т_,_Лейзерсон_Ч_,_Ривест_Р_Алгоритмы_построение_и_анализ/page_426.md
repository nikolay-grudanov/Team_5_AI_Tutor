---
source_image: page_426.png
page_number: 426
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 65.33
tokens: 11578
characters: 2436
timestamp: 2025-12-24T06:40:34.203147
finish_reason: stop
---

Уменьшение ключа и удаление вершины

цедуры Cascading-Cut выполняется, лишь если выполнено условие в строке 2).

В какой-то момент вершина исключается из корневого списка, становясь ребёнком другой вершины при выполнении процедуры Consolidate. При этом её пометка (если она была) удаляется (строка 3 процедуры Fib-Link). С этого момента новых детей у неё не прибавляется, но может быть удалён один ребёнок, отчего она станет помеченной. При удалении второго ребёнка вершина вновь перемещается в корневой список, становясь непомеченной. Другой способ вернуться в корневой список — оказаться ребёнком изымаемой вершины при операции Fib-Heap-Extract-Min (при этом пометка не меняется).

После возвращения в корневой список к вершине вновь могут добавляться дети (при операции Consolidate). Дети могут и удаляться (операция Cut). В какой-то момент вершина снова может оказаться ребёнком другой вершины корневого списка, и так далее — до тех пор, пока эта вершина не будет изъята из дерева (или не будет уменьшен ключ).

На рис. 21.4 показаны две операции Fib-Heap-Decrease-Key, первая из которых не вызывает цепочки операций Cut, а вторая вызывает.

Покажем, что учётная стоимость операции Fib-Heap-Decrease-Key составляет \( O(1) \). Начнем с определения фактической стоимости. Процедуры Fib-Heap-Decrease-Key, Cut и Cascading-Cut не содержат циклов, так что время работы пропорционально длине цепочки рекурсивных вызовов (которую мы обозначим через \( c \)).

Как при этом меняется потенциал? Цепочка рекурсивных вызовов соответствует цепочке помеченных вершин в дереве, каждая из которых является ребёнком следующей. Эти вершины перемещаются в корневой список и становятся непомеченными. Таким образом, потенциал увеличивается примерно на \( c \) за счёт увеличения числа вершин в корневом списке, но и уменьшается примерно на \( 2c \) за счёт того, что уменьшается число помеченных вершин. (Правда, может появиться новая помеченная вершина, но эта поправка имеет порядок \( O(1) \).) В итоге потенциал уменьшается на \( c + O(1) \). (Теперь ясно, почему при определении потенциала число помеченных вершин учитывалось со вдвое большим весом, чем число вершин в корневом списке!)

Умножая потенциал на достаточную константу (выбирая большую "единицу работы"), можно считать, что уменьшение потенциала компенсирует фактическую стоимость цепочки рекурсивных вызовов, так что учётная стоимость операции Fib-Heap-Decrease-Key есть \( O(1) \).