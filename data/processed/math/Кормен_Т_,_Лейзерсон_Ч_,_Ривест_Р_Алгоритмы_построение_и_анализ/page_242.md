---
source_image: page_242.png
page_number: 242
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 53.40
tokens: 11353
characters: 1757
timestamp: 2025-12-24T06:31:31.989139
finish_reason: stop
---

Двоичные деревья поиска

Деревья поиска (search trees) позволяют выполнять следующие операции с динамическими множествами: SEARCH (поиск), MINIMUM (минимум), MAXIMUM (максимум), PREDECESSOR (предыдущий), SUCCESSOR (следующий), INSERT (вставить) и DELETE (удалить). Таким образом, дерево поиска может быть использовано и как словарь, и как очередь с приоритетами.

Время выполнения основных операций пропорционально высоте дерева. Если двоичное дерево "плотно заполнено" (все его уровни имеют максимально возможное число вершин), то его высота (и время выполнения операций) пропорциональны логарифму числа вершин. Напротив, если дерево представляет собой линейную цепочку из n вершин, это время вырастает до \( \Theta(n) \). В разделе 13.4 мы увидим, что высота случайного двоичного дерева поиска есть \( O(\lg n) \), так что в этом случае время выполнения основных операций есть \( \Theta(\lg n) \).

Конечно, возникающие на практике двоичные деревья поиска могут быть далеки от случайных. Однако, приняв специальные меры по балансировке деревьев, мы можем гарантировать, что высота деревьев с n вершинами будет \( O(\log n) \). В главе 14 рассмотрен один из подходов такого рода (красно-чёрные деревья). В главе 19 рассматриваются Б-деревья, которые особенно удобны для данных, хранящихся во вторичной памяти с произвольным доступом (на диске).

В этой главе мы рассмотрим основные операции с двоичными деревьями поиска и покажем, как напечатать элементы дерева в неубывающем порядке, как искать заданный элемент, как найти максимальный или минимальный элемент, как найти элемент, следующий за данным и предшествующий данному, и, наконец, как добавить или удалить элемент. Напомним, что определение дерева и основные свойства деревьев приводятся в главе 5.