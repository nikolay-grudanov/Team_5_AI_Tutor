---
source_image: page_712.png
page_number: 712
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 59.55
tokens: 11700
characters: 2334
timestamp: 2025-12-24T06:54:00.090795
finish_reason: stop
---

4 \quad do $m \leftarrow 2^s$
5 \qquad $\omega_m \leftarrow e^{2\pi i/m}$
6 \qquad $\omega \leftarrow 1$
7 \qquad for $j \leftarrow 0$ to $m/2-1$
8 \qquad\quad do for $k \leftarrow j$ to $n-1$ by $m$
9 \qquad\qquad\quad do $t \leftarrow \omega A [k+m/2]$
10 \qquad\qquad\qquad $u \leftarrow A[k]$
11 \qquad\qquad\qquad $A[k] \leftarrow u+t$
12 \qquad\qquad\qquad $A[k+m/2] \leftarrow u-t$
13 \qquad\qquad $\omega \leftarrow \omega \omega_m$

Каким образом процедура Bit-Reverse-Copy переставляет элементы входного вектора a, помещая их в массив A? Посмотрев на листья дерева на рис. 32.4, можно заметить, что они расположены "перевёрнутом двоичном" порядке ("bit-reverse binary"). Объясним, что имеется в виду. Через rev(k) при k = 0, 1, 2, ..., 2^n - 1 обозначим (lg n)-битовое целое число, двоичная запись которого получается, если написать двоичную запись числа k (всего lg n битов, включая начальные нули, если они есть) "задом наперёд". Так вот, процедура Bit-Reverse-Copy помещает элемент a_k в A[rev(k)]. На рисунке 32.4, например, листья a_0, a_1, a_2, ..., a_7 появляются в позициях 0, 4, 2, 6, 1, 5, 3, 7; в двоичной системе номера позиций записываются как 000, 100, 010, 110, 001, 101, 011, 111. (Отметим, что rev(rev(k)) = k.)

Чтобы понять, почему листья идут в перевёрнутом двоичном порядке, заметим, что в корне дерева налево идут индексы с нулевым младшим битом, а направо — с единичным, что после обращения битов соответствует обычному порядку (сначала числа с нулевым старшим битом, потом с единичным). Отбрасывая на каждом уровне младший бит, мы продолжаем этот процесс вниз по дереву, и в конце концов получаем перевёрнутый двоичный порядок в листьях.

Поскольку функцию rev(k) легко вычислять, можно записать процедуру Bit-Reverse-Copy (копирование в перевёрнутом двоичном порядке) следующим образом:

\textsc{Bit-Reverse-Copy}(a,A)
1 $n \leftarrow length[a]$
2 for $k \leftarrow 0$ to $n-1$
3 \quad do $A [\{\mathrm{rev}(k)] \leftarrow a_k$

Построенная итеративная реализация быстрого преобразования Фурье требует времени \Theta(n \lg n). В самом деле, вызов Bit-Reverse-Copy заведомо укладывается в O(n \lg n) операций, поскольку цикл исполняется n раз, а целое число от 0 до n - 1 занимает lg n битов, которые могут быть обращены за время O(\lg n). (На практике мы обычно заранее знаем значение n, поэтому мо-