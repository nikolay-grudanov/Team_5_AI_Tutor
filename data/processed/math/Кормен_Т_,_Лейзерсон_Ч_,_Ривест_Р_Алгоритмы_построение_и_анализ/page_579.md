---
source_image: page_579.png
page_number: 579
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 53.89
tokens: 11575
characters: 2065
timestamp: 2025-12-24T06:47:53.542808
finish_reason: stop
---

27.4-6
Докажите, что строку 7 процедуры INITIALIZE-PREFLOW можно заменить строкой

\[
h[s] \leftarrow |V[G]| - 2,
\]

не нарушая корректности и не меняя асимптотики времени работы алгоритма.

27.4-7
Обозначим через \( \delta_f(u, v) \) расстояние (количество рёбер) от вершины \( u \) до вершины \( v \) в остаточной сети \( G_f \). Покажите, что во время выполнения программы GENERIC-PREFLOW-PUSH остаётся верными следующие утверждения: если \( h[u] < |V| \), то \( h[u] \leq \delta_f(u, t) \); если \( h[u] \geq V \), то \( h[u] \leq \delta_f(u, s) \).

27.4-8*
Как и в предыдущем упражнении, \( \delta_f(u, v) \) обозначает расстояние от вершины \( u \) до вершины \( v \) в остаточной сети \( G_f \). Как изменить алгоритм проталкивания предпотока, чтобы во время его работы оставались верными такие утверждения: если \( h[u] < |V| \), то \( h[u] = \delta_f(u, t) \); если \( h[u] \geq V \), то \( h[u] = \delta_f(u, s) \). (Дополнительные действия должны укладываться в \( O(VE) \) операций.)

27.4-9
Покажите, что число ненасыщающих проталкиваний, выполненных программой GENERIC-PREFLOW-PUSH на сети \( G = (V, E) \), не превосходит \( 4|V|^2|E| \) (если \( |V| \geq 4 \)).

27.5 Алгоритм поднять-и-в-начало

Пользуясь методом проталкивания предпотока, мы применяли операции подъёма и проталкивания в более или менее произвольном порядке. Более продуманный порядок выполнения этих операций позволяет уменьшить время работы алгоритм (по сравнению с оценкой \( O(V^2 E) \) из следствия 27.25). В этом разделе мы рассмотрим алгоритм "поднять-и-в-начало" (lift-to-front algorithm), использующий эту идею; время его работы есть \( O(V^3) \), что асимптотически по крайней мере не хуже, чем \( O(V^2 E) \).

Алгоритм "поднять-и-в-начало" хранит все вершины сети в виде списка. Алгоритм просматривает этот список, начиная с головы, и находит в нем переполненную вершину \( u \). Затем алгоритм "обслуживает" эту вершину, применяя к ней операции подъёма и проталкивания до тех пор, пока избыток не станет равным нулю. Если для этого вершину пришлось поднять, её пере-