---
source_image: page_436.png
page_number: 436
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 49.09
tokens: 11472
characters: 2186
timestamp: 2025-12-24T06:40:45.435957
finish_reason: stop
---

Рис. 22.2
Подпись:
а) Представление двух множеств с помощью списков. Представителем множества \(\{b, c, e, h\}\) является элемент \(c\), представителем \(\{d, f, g\}\) является \(f\). Каждый объект в списке содержит элемент множества, указатель на следующий элемент и указатель на представителя (то есть на начало списка). б) Результат выполнения операции \(UNION(e, g)\). Представитель объединения множеств есть \(f\).

22.2 Реализация с помощью списков

Самый простой вариант реализации системы непересекающихся множеств хранит каждое множество в виде списка. При этом представителем множества считается первый элемент списка, и каждый элемент списка содержит ссылки на следующий элемент списка и на первый элемент списка (который считается представителем списка). Для каждого списка мы храним указатели на его первый и последний элементы (второй из них нужен при добавлении элементов в конец списка). Порядок элементов в списке может быть любым. На рис. 22.2 (а) изображены два представленных таким образом множества.

При такой реализации операции Make-Set и Find-Set требуют времени \(O(1)\): Make-Set создаёт список из одного элемента, а Find-Set возвращает указатель на начало списка.

Простейшая реализация объединения

При естественной реализации операция Union оказывается дорогостоящей. Выполняя \(UNION(x, y)\), мы добавляем список, содержащий \(x\), к концу списка, содержащего \(y\) (рис. 22.2 b). Представителем нового множества при этом будет начало нового списка, то есть представитель множества, содержащего \(y\). При этом нужно ещё установить правильные указатели на начало списка для всех бывших элементов множества, содержащего \(x\), и время на выполнение этой операции линейно зависит от размера указанного множества.

Легко привести пример, в котором время выполнения квадратично зависит от числа операций (рис. 22.3). Пусть даны \(n\) элементов \(x_1, x_2, \ldots, x_n\). Выполним операции Make-Set\((x_i)\) для всех \(i = 1, 2, \ldots, n\), а затем \(n - 1\) операций \(UNION(x_1, x_2), UNION(x_2, x_3), \ldots, UNION(x_{n-1}, x_n)\). Поскольку стоимость операции \(UNION(x_i, x_{i+1})\) пропорциональна \(i\), суммарная стоимость выполнения \(2n - 1\) опера-