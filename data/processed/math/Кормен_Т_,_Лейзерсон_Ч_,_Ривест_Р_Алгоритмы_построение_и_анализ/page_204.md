---
source_image: page_204.png
page_number: 204
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 53.71
tokens: 11381
characters: 1673
timestamp: 2025-12-24T06:29:42.460557
finish_reason: stop
---

Рисунок 11.4 Список \( L \), использующий фиктивный элемент \( nil[L] \) (тёмно-серый прямоугольник). Вместо \( head[L] \) используем \( next[nil[L]] \). (а) Пустой список. (б) Список рис. 11.3а (элемент с ключом 9 — голова, 1 — хвост). (в) Тот же список после процедуры List-Insert'(L, x), если \( key[x] = 25 \). (г) После удаления элемента с ключом 1. Новый хвост имеет ключ 4.

Хвоста списка занесём указатели на \( nil[L] \) (рис. 11.4). При этом \( next[nil[L]] \) — указатель на голову списка, так что атрибут \( head[L] \) становится лишним. Пустой список \( L \) теперь будет кольцом, в котором \( nil[L] \) — единственный элемент.

В процедуре List-Search нужно лишь заменить NIL на \( nil[L] \) и \( head[L] \) на \( next[nil[L]] \):

List-Search'(L, k)
1 \( x \leftarrow next[nil[L]] \)
2 while \( x \neq nil[L] \) and \( key[x] \neq k \)
3 do \( x \leftarrow next[x] \)
4 return \( x \)

Для удаления элемента годится процедура List-Delete', приведённая выше. Наконец, добавлять элемент к списку можно так:

List-Insert'(L, x)
1 \( next[x] \leftarrow next[nil[L]] \)
2 \( prev[next[nil[L]]] \leftarrow x \)
3 \( next[nil[L]] \leftarrow x \)
4 \( prev[x] \leftarrow nil[L] \)

Пример работы процедур List-Insert' и List-Delete' показан на рис. 11.4.

Использование фиктивных элементов едва ли может улучшить асимптотику времени работы алгоритма, но упрощает программу. Иногда (если использование фиктивных элементов позволяет сократить фрагмент кода, находящийся глубоко внутри цикла), можно ускорить исполнение программы в несколько раз.

Не следует применять фиктивные элементы без нужды. Если алгоритм использует много коротких списков, использование фиктив-