---
source_image: page_522.png
page_number: 522
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 61.08
tokens: 11727
characters: 2372
timestamp: 2025-12-24T06:45:09.970002
finish_reason: stop
---

для разреженных графов, который (как и алгоритмы поиска из одной вершины) использует списки смежности. Естественно сочетать сведения о наличии ребра и о его весе в одной матрице, полагая веса отсутствующих рёбер бесконечными.

Таким образом, при обработке взвешенного ориентированного графа \( G = (V, E) \) алгоритму даётся матрица \( W = (w_{ij}) \), где

\[
w_{ij} = \begin{cases}
0 & \text{если } i = j, \\
\text{вес (ориентированного) ребра } (i, j) & \text{если } i \neq j \text{ и } (i, j) \in E, \\
\infty & \text{если } i \neq j \text{ и } (i, j) \notin E.
\end{cases}
\]

Ребра могут иметь отрицательный вес. Мы будем, однако, предполагать, что циклов отрицательного веса в графе нет.

Представленные в данной главе алгоритмы нахождения кратчайших путей для всех пар вершин будут вычислять матрицу \( D = (d_{ij}) \) размером \( n \times n \), элемент \( d_{ij} \) которой содержит вес кратчайшего пути из вершины \( i \) в вершину \( j \), то есть равен \( \delta(i, j) \) в обозначениях предыдущей главы.

Решение задачи о кратчайших путях для всех пар вершин должно включать в себя не только веса кратчайших путей, но и матрицу предшествования (predecessor matrix) \( \Pi = (\pi_{ij}) \), в которой \( \pi_{ij} \) является вершиной, предшествующей \( j \) на одном из кратчайших путей из \( i \) в \( j \). (мы полагаем \( \pi_{ij} = \mathrm{NIL} \), если \( i = j \) или путей из \( i \) в \( j \) не существует). Для каждой вершины \( i \in V \) можно определить подграф предшествования (predecessor subgraph) \( G_{\pi, i} = (V_{\pi, i}, E_{\pi, i}) \), где

\[
V_{\pi, i} = \{ j \in V : \pi_{ij} \neq \mathrm{NIL} \} \cup \{ i \},
\]
и
\[
E_{\pi, i} = \{ (\pi_{ij}, j) : j \in V_{\pi, i} \text{ и } \pi_{ij} \neq \mathrm{NIL} \}.
\]

Мы будем требовать, чтобы для каждого \( i \) подграф предшествования \( G_{\pi, i} \) был деревом кратчайших путей из вершины \( i \) (в смысле главы 25). В этом случае следующая процедура печатает кратчайший путь из вершины \( i \) в вершину \( j \).

{\sc Print-All-Pairs-Shortest-Path}$(\Pi, i, j)$\\
1 if $i=j$\\
2 then print $i$\\
3 else if $\pi_{ij}=\mbox{\sc nil}$\\
4 then print 'Пути из' $i$ 'в' $j$ 'нет'\\
5 else {\sc Print-All-Pairs-Shortest-Path}$(\Pi, i, \pi_{ij})$\\
6 print $j$

Мы не будем подробно говорить о построении матрицы предшествования (её свойствам посвящено несколько упражнений).

План главы