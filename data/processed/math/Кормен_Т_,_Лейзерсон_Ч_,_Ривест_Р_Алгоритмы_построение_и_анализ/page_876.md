---
source_image: page_876.png
page_number: 876
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 56.71
tokens: 11658
characters: 1782
timestamp: 2025-12-24T07:01:24.423404
finish_reason: stop
---

Задача о сумме подмножества

\[
\langle x_1, x_2, \ldots, x_n \rangle \text{ из } n \text{ чисел (идущих в произвольном порядке), число } t, \text{ а также параметр приближения } \varepsilon \text{ (в интервале } 0 < \varepsilon < 1).
\]

\textsc{Approx-Subset-Sum}(S, t, \varepsilon)
1 n <- |S|
2 L_0 <- <0>
3 for i<-1 to n
4   do L_i <- Merge-Lists(L_{i-1}, L_{i-1}+x_i)
5   L_i <- Trim (L_i, \varepsilon/n)
6   все элементы $L_i$, большие $t$, удаляются
7 z <- наибольший элемент $L_n$
8 return z

Вначале (строка 2) в список $L_0$ помещается единственный элемент 0. В строках 3–6 мы последовательно (для $i = 1, \ldots n$) вычисляем список $L_i$, который окажется сокращением множества $P_i$ (всевозможных сумм, составленных из первых $i$ элементов) из которого удалены все элементы, большие $t$. Отметим, что это требует специальной проверки, так как сокращения производятся на каждом шаге, и в строке 4 соединяются уже сокращенные варианты списков.

Прежде чем проверять это, рассмотрим пример: пусть

\[
L = \langle 104, 102, 201, 101 \rangle
\]

при этом $t = 308$ и $\varepsilon = 0.2$. Тогда на каждом шаге производится 0,05-сокращение, и вычисления проходят так:

строка 2: L_0 = <0>,
строка 4: L_1 = <0, 104>
строка 5: L_1 = <0, 104>
строка 6: L_1 = <0, 104>

строка 4: L_2 = <0, 102, 104, 206>
строка 5: L_2 = <0, 102, 206>
строка 5: L_2 = <0, 102, 206>

строка 4: L_3 = <0, 102, 201, 206, 303, 407>
строка 5: L_3 = <0, 102, 201, 303, 407>
строка 6: L_3 = <0, 102, 201, 303>

строка 4: L_4 = <0, 101, 102, 201, 203, 302, 303, 404>
строка 5: L_4 = <0, 101, 201, 302, 404>
строка 6: L_4 = <0, 101, 201, 302>

В ответе получается $z = 302$, что отличается от оптимального варианта ($307 = 104 + 102 + 101$) менее чем на 2% (что много меньше разрешённого отклонения в 20%).