---
source_image: page_175.png
page_number: 175
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 52.90
tokens: 11397
characters: 1667
timestamp: 2025-12-24T06:28:21.941635
finish_reason: stop
---

Рисунок 9.4 Работа алгоритма Bucket-Sort. (а) На вход подан массив \( A[1..10] \). (б) Массив списков \( B[0..9] \) после выполнения строки 5. Список с индексом \( i \) содержит числа, у которых первый знак после запятой есть \( i \). Отсортированный массив получится, если последовательно выписать списки \( B[0], \ldots, B[9] \).

саны в разд. 11.2.

Bucket-Sort(\( A \))
1 \( n \leftarrow length[A] \)
2 for \( i \leftarrow 1 \) to \( n \)
3 do добавить \( A[i] \) к списку \( B[\lfloor nA[i] \rfloor] \)
4 for \( i \leftarrow 0 \) to \( n - 1 \)
5 do отсортировать список \( B[i] \) (сортировка вставками)
6 соединить списки \( B[0], B[1], \ldots, B[n-1] \) (в указанном порядке)

На рис. 9.4 показана работа этого алгоритма на примере массива из 10 чисел.

Чтобы показать, что алгоритм сортировки вычёрпыванием правилен, рассмотрим два числа \( A[i] \) и \( A[j] \). Если они попали в разные ящики, то меньшее из них попало в ящик с меньшим номером, и в выходной последовательности оно окажется раньше; если они попали в один ящик, то после сортировки содержимого ящика меньшее число будет также предшествовать большему.

Проанализируем время работы алгоритма. Операции во всех строках, кроме пятой, требуют (общего) времени \( O(n) \). Просмотр всех ящиков также занимает время \( O(n) \). Таким образом, нам остаётся только оценить время сортировки вставками внутри ящиков.

Пусть в ящик \( B[i] \) попало \( n_i \) чисел (\( n_i \) — случайная величина). Поскольку сортировка вставками работает за квадратичное время, математическое ожидание длительности сортировки чисел в ящике номер \( i \) есть \( O(M[n_i^2]) \), а математическое ожидание суммарного вре-