---
source_image: page_211.png
page_number: 211
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 47.84
tokens: 11300
characters: 1618
timestamp: 2025-12-24T06:29:56.850798
finish_reason: stop
---

Рисунок 11.9 Представление двоичного дерева T. Каждая вершина x включает поля p[x] (сверху), left[x] (внизу слева) и right[x] (внизу справа). Ключи на схеме не показаны.

Корневые деревья с произвольным ветвлением

Если известно, что число детей каждой вершины ограничено сверху константой k, то такое дерево можно реализовать аналогично двоичному дереву, помещая указатели на детей в поля child_1, child_2, ..., child_k, заменяющие поля left и right. Если количество детей может быть любым, так делать нельзя: заранее неизвестно, сколько полей (или массивов — при представлении с помощью нескольких массивов) надо выделить.

Проблема может возникнуть и в том случае, если количество детей ограничено заранее известным числом k, но у большинства вершин число детей много меньше k: описанная реализация тратит много памяти зря.

Как же быть? Заметим, что любое дерево можно преобразовать в двоичное. При этом у каждой вершины будет не более двух детей: левый ребёнок останется тем же, но правым ребёнком станет вершина, которая была правым соседом (непосредственно следующим ребёнком того же родителя). Теперь это двоичное дерево можно хранить описанным выше способом.

Опишем схему хранения деревьев с произвольным ветвлением, основанную на этой идее, более подробно. Она называется "левый ребёнок — правый сосед" (left-child, right-sibling representation) и показана на рис. 11.10. По-прежнему в каждой вершине хранится указатель p на родителя и атрибут root[T] является указателем на корень дерева. Кроме p, в каждой вершине хранятся ещё два указателя:

1. left-child[x] указывает на самого левого ребёнка вершины x;