---
source_image: page_653.png
page_number: 653
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 50.42
tokens: 11535
characters: 2244
timestamp: 2025-12-24T06:51:12.752371
finish_reason: stop
---

splice out = удаление
splice in = возвращение удалённых
рекурсивный вызов процедуры RANDOMIZED-LIST-PREFIX

Рисунок 30.9 30.9. Рекурсивный вероятностный алгоритм обработки префиксов списка на примере списка из 9 объектов. (а) Чёрные объекты намечены для удаления. (Среди них нет соседних.) (b) Значение каждого удаляемого объекта соединяется со значением следующего; алгоритм рекурсивно вызывается на уменьшенном списке. (c)-(d) В результате уцелевшие элементы получают правильные значения, а удалённые объекты вычисляют свои префиксы с помощью предыдущих.

splice out удаление splice in возвращение stage 1 уровень 1 (bottom) (внутренний) (top) (внешний)

Рисунок 30.10 30.10. Уровни рекурсии для алгоритма RANDOMIZED-LIST-PREFIX. Вначале список содержит 9 объектов. Рекурсивные вызовы осуществляются до тех пор, пока список не станет пустым.

саму себя на уменьшенном списке, если он ещё не пуст. После этого рекурсивного вызова все элементы уменьшенного списка содержат правильные значения префиксов, и остаётся лишь обрабатывать префиксы, соответствующие исключённым элементам.
Это сделать легко: если k-й объект был исключён, то (k - 1)-й объект остался в списке и после рекурсивного вызова содержит значение [1, k - 1]. Остаётся лишь вычислить [1, k] = [1, k - 1] ⊗ [k, k].
Условие 1 гарантирует, что для каждого исключённого объекта найдётся процессор, который будет производить вычисления. Условие 2 обеспечивает возможность обработать недостающий префикс, произведя всего одну операцию ⊗ (см. упр. 30-4.1). Итак, при выполнении требований 1 и 2 каждый шаг алгоритма требует времени O(1).

30.4.2 Выбор удаляемых объектов

Как же выбирать объекты для удаления? Прежде всего, необходимо соблюдать требования 1 и 2. Кроме того, сам процесс выбора должен занимать немного времени (лучше всего O(1)). Наконец, следует удалять как можно больше объектов, чтобы оставшийся список был как можно короче и глубина рекурсии — как можно меньше.
Укажем способ удовлетворить всем этим требованиям.
1. Каждый процессор случайно выбирает один из подведомственных ему объектов (из числа оставшихся в списке).
2. Каждый процессор бросает монету и с вероятностью 1/2 помечает выбранный им на предыдущем шаге объект (а с вероятностью 1/2 не делает ничего).