---
source_image: page_190.png
page_number: 190
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 41.98
tokens: 11241
characters: 1098
timestamp: 2025-12-24T06:28:53.905794
finish_reason: stop
---

а Опишите алгоритм, который находит \( i \)-й по величине элемент в множестве из \( n \) чисел, делая \( U_i(n) \) сравнений, причём

\[
U_i(n) = \begin{cases}
T(n) & \text{если } n \leq 2i, \\
n/2 + U_i(\lfloor n/2 \rfloor) + T(2i+1) & \text{иначе.}
\end{cases}
\]

(Указание: сделайте \( \lfloor n/2 \rfloor \) попарных сравнений и отберите \( i \) наименьших среди меньших элементов пар.)

б Покажите, что \( U_i(n) = n + O(T(2i) \log(n/i)) \).

в Покажите, что, при постоянном \( i \), имеем \( U_i(n) = n + O(\lg n) \).
[Та же оценка получится, если построить кучу из главы 7, а затем \( i \) раз выбрать из неё минимальный элемент.]

г Пусть \( i = n/k \), причём \( k \geq 2 \); покажите, что \( U_i(n) = n + O(T(2n/k) \lg k) \).

Замечания

Алгоритм для нахождения медианы за линейное в худшем случае время предложили Блюм, Флойд, Пратт, Ривест и Тарьян [29]. Вероятностный алгоритм с линейным средним временем работы принадлежит Хоару [97]. Флойд и Ривест [70] разработали усовершенствованную версию этого алгоритма, в которой граница разбиения определяется по небольшой случайной выборке.