---
source_image: page_169.png
page_number: 169
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 64.29
tokens: 11636
characters: 2343
timestamp: 2025-12-24T06:28:12.678467
finish_reason: stop
---

Сортировка подсчётом

мент первого участка меньше любого элемента второго и т.д. (так что остаётся лишь отсортировать элементы внутри участков). Покажите, что такая сортировка потребует не менее \( \Omega(n \lg k) \) сравнений в худшем случае. (Указание: недостаточно сослаться на необходимость \( n/k \) раз сортировать участок длиной \( k \).)

9.2 Сортировка подсчётом

Алгоритм сортировки подсчётом (counting sort) применим, если каждый из \( n \) элементов сортируемой последовательности — целое положительное число в известном диапазоне (не превосходящее заранее известного \( k \)). Если \( k = O(n) \), то алгоритм сортировки подсчётом работает за время \( O(n) \).

Идея этого алгоритма в том, чтобы для каждого элемента \( x \) предварительно подсчитать, сколько элементов входной последовательности меньше \( x \), после чего записать \( x \) напрямую в выходной массив в соответствии с этим числом (если, скажем, 17 элементов входного массива меньше \( x \), то в выходном массиве \( x \) должен быть записан на место номер 18). Если в сортируемой последовательности могут присутствовать равные числа, эту схему надо слегка модифицировать, чтобы не записать несколько чисел на одно место.

В приводимом ниже псевдокоде используется вспомогательный массив \( C[1..k] \) из \( k \) элементов. Входная последовательность записана в массиве \( A[1..n] \), отсортированная последовательность записывается в массив \( B[1..n] \).

Counting-Sort(\( A, B, k \))

1 for \( i \leftarrow 1 \) to \( k \)
2 do \( C[i] \leftarrow 0 \)
3 for \( j \leftarrow 1 \) to \( length[A] \)
4 do \( C[A[j]] \leftarrow C[A[j]] + 1 \)
5 ▷ \( C[i] \) равно количеству элементов, равных \( i \).
6 for \( i \leftarrow 2 \) to \( k \)
7 do \( C[i] \leftarrow C[i] + C[i-1] \)
8 ▷ \( C[i] \) равно количеству элементов, не превосходящих \( i \)
9 for \( j \leftarrow length[A] \) downto 1
10 do \( B[C[A[j]]] \leftarrow A[j] \)
11 \( C[A[j]] \leftarrow C[A[j]] - 1 \)

Работа алгоритма сортировки подсчётом проиллюстрирована на рис. 9.2. После инициализации (строки 1–2) мы сначала помещаем в \( C[i] \) количество элементов массива \( A \), равных \( i \) (строки 3–4), а затем, находя частичные суммы последовательности \( C[1], C[2], \ldots, C[k] \), — количество элементов, не превосходящих \( i \) (строки 6–7). Наконец, в строках 9–11 каждый из элементов