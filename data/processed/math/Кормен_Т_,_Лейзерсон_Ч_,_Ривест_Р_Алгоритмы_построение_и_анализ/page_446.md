---
source_image: page_446.png
page_number: 446
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 73.03
tokens: 11783
characters: 2876
timestamp: 2025-12-24T06:41:40.498750
finish_reason: stop
---

является монотонно возрастающей и что \( \beta(k) > k \) при всех \( k \). Будем говорить, что при переходе от вершины \( u \) к её родителю \( v = p[u] \) ранг сильно растёт, если \( rank[v] \geq \beta(rank[u]) \). При этом мы исключаем из рассмотрения случай, когда \( v \) является корнем — такой случай встречается по разу при выполнении каждой операции FIND-SET, и потому общее число таких ситуаций есть \( O(m) \).

Начнём с оценки числа шагов, при которых ранг не сильно растёт, и сгруппируем их по вершинам, из которых этот шаг делается. Для вершины ранга \( k \) ранги её предка могут меняться от \( k + 1 \) до \( \beta(k) \) (после этого ранг растёт сильно). Значит, число таких шагов (из данной вершины ранга \( k \)) заведомо не больше \( \beta(k) \), поскольку, как мы говорили, каждый новый шаг ведёт в вершину большего ранга, чем предыдущий. Поскольку вершин ранга \( k \) не более \( n/2^k \), то общее число шагов, при которых ранг не сильно растёт, не превосходит

\[
\sum_k \frac{n \beta(k)}{2^k}
\]

Если выбрать функцию \( \beta \) так, чтобы ряд \( \sum \beta(k)/2^k \) сходился, то общее число шагов такого рода есть \( O(n) \).

Прежде чем выбрать функцию \( \beta \), объясним, как оценить число шагов, при которых ранг сильно растёт. Такие шаги мы сгруппируем не по вершинам, а по путям: на каждом пути поиска таких шагов мало, так как ранг не может многократно сильно расти (он меняется всего лишь от 0 до \( \lg n \)). Таким образом, на каждом пути число шагов, при котором ранг сильно растёт, не превосходит числа итераций функции \( \beta \), которые нужно сделать, чтобы дойти от 0 до \( \lg n \).

Хотелось бы положить \( \beta(k) = 2^k \): тогда число итераций будет примерно равно \( \lg^* n \). К сожалению, тогда написанный выше ряд расходится. Придётся взять немного меньшую функцию. Например, положим \( \beta(k) = \lceil 1.9^k \rceil \), тогда ряд \( \sum \lceil 1.9^k \rceil / 2^k \leq \sum (1.9^k + 1) / 2^k \) сходится. С другой стороны, число итераций функции \( \beta \), которые нужно сделать, чтобы от 0 дойти до какого-то числа, возрастёт (по сравнению с функцией \( k \mapsto 2^k \)) не более чем вдвое, поскольку \( \beta(\beta(k)) \geq 2^k \), и потому есть \( O(\lg^* n) \). Итак, число шагов такого рода для всех \( m \) операций есть \( O(m \lg^* n) \).

Складывая вместе действия всех видов (операции Make-Set и Link, последние шаги в каждом пути, шаги, на которых ранг не сильно растёт, и шаги, на которых ранг сильно растёт), получаем общую оценку \( O(n) + O(m \lg^* n) = O(m \lg^* n) \) (напомним, что \( m \geq n \), так как \( m \) — общее число операций, а \( n \) — число операций textscMake-Set), что и требовалось доказать.

[Замечание. Доказательство этой теоремы слегка изменено по сравнению с английским оригиналом: в последнем используется функция \( \beta(k) \), равная наименьшему члену последовательности