---
source_image: page_207.png
page_number: 207
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 63.50
tokens: 11466
characters: 2203
timestamp: 2025-12-24T06:30:02.483467
finish_reason: stop
---

Рисунок 11.6 Тот же список, что на рис. 11.3а и 11.5, реализованный на базе единственного массива A. Каждой записи соответствует тройка идущих подряд элементов массива. Полям key, next и prev соответствуют сдвиги 0, 1 и 2. Указатель на запись — индекс первого из отведённых для неё элементов. Светлосерые записи входят в список; стрелками изображено действие указателей.

Ждый из которых имеет несколько полей, то на каждый элемент отводится непрерывный участок памяти, в котором друг за другом размещаются значения полей. Указателем на элемент обычно считают адрес первой ячейки этого участка; адреса полей получаются сдвигом на определённые константы.

При реализации записей на базе массива можно воспользоваться той же стратегией. Рассмотрим один-единственный массив A. Каждая запись будет занимать в нём непрерывный участок A[j..k]. Указатель на запись — это индекс j; каждому полю записи соответствует число из интервала [0..k - j] — сдвиг. Например, при представлении всё того же списка, что и на рис. 11.3а и 11.5, можно решить, что полям key, next и prev соответствуют сдвиги 0, 1 и 2. Тогда значение prev[i], где i — указатель (= индекс в массиве A), есть не что иное, как A[i + 2] (см. рис. 11.6).

Такое представление позволяет хранить в одном массиве записи разных типов (отводя под них участки разной длины), но для наших целей будет достаточно представления в виде нескольких массивов, поскольку большинство структур данных, с которыми мы будем иметь дело, состоят из однотипных записей.

Выделение и освобождение памяти

При добавлении нового элемента в список надо отвести под него место в памяти. Стало быть, необходимо вести учёт использования адресов. В некоторых системах этим ведает специальная подпрограмма — сборщик мусора (garbage collector), которая определяет, какие участки памяти более не используются, и возвращает их для повторного использования. Во многих случаях, однако, можно возложить обязанности по выделению и освобождению памяти на саму структуру данных. В этом разделе мы покажем, как это делается; в качестве примера рассмотрим двусторонне связанный список, представленный с помощью нескольких массивов.

Пусть массивы, с помощью которых мы представляем наш спи-