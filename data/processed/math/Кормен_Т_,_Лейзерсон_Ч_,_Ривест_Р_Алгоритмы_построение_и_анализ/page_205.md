---
source_image: page_205.png
page_number: 205
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 67.99
tokens: 11484
characters: 2164
timestamp: 2025-12-24T06:30:01.956124
finish_reason: stop
---

Связанные списки

ных элементов может обернуться серьезной дополнительной тратой памяти. В этой книге фиктивные элементы используются только тогда, когда это существенно упрощает программу.

Упражнения

11.2-1 Можно ли добавить элемент в множество, представленное односторонне связанным списком, за время \( O(1) \)? Тот же вопрос для удаления элемента.

11.2-2 Реализуйте стек на базе односторонне связанного списка. Операции PUSH и POP должны выполняться за время \( O(1) \).

11.2-3 Реализуйте очередь на базе односторонне связанного списка. Операции ENQUEUE и DEQUEUE должны выполняться за время \( O(1) \).

11.2-4 Реализуйте словарные операции INSERT, DELETE и SEARCH для свёрнутого в кольцо односторонне связанного списка. Каково время работы ваших процедур?

11.2-5 Операция UNION (объединение) получает на входе два не-пересекающихся множества и возвращает их объединение (сами исходные множества при этом пропадают). Реализуйте эту операцию так, чтобы она работала за время \( O(1) \), представляя множества списками подходящего типа.

11.2-6 Напишите процедуру, которая сливает два односторонне связанных упорядоченных списка в один (также упорядоченный), не используя фиктивных элементов. Затем сделайте это, используя фиктивный элемент с ключом \( \infty \) (добавляемый в конец списков). Какая из двух программ проще?

11.2-7 Напишите нерекурсивную процедуру, которая за время \( \Theta(n) \) переставляет элементы односторонне связанного списка в обратном порядке. Объём дополнительной (помимо необходимой для хранения исходного списка) памяти должен быть \( O(1) \).

11.2-8* Есть способ сэкономить место при реализации двусторонне связанного списка, сжав два указателя next и prev в одно значение \( pr[x] \). Будем считать, что все указатели суть \( k \)-битные числа и указателю NIL соответствует число нуль. Определим \( pr[x] \) по формуле \( pr[x] = next[x] \text{XOR} prev[x] \), где XOR — побитовое сложение по модулю 2 (исключающее ИЛИ). Не забудьте указать, каким образом хранится информация о голове списка. Как реализовать операции SEARCH, INSERT и DELETE? Объясните, как переставить такой список в обратном порядке за время \( O(1) \).