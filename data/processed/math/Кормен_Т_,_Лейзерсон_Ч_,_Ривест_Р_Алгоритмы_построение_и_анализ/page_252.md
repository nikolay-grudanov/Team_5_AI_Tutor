---
source_image: page_252.png
page_number: 252
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 60.00
tokens: 11461
characters: 2093
timestamp: 2025-12-24T06:32:05.934688
finish_reason: stop
---

13.3-3 Набор из n чисел можно отсортировать, сначала добавив их один за другим в двоичное дерево поиска (с помощью процедуры TREE-INSERT), а потом обойти дерево с помощью процедуры INORDER-TREE-WALK. Найдите время работы такого алгоритма в худшем и в лучшем случае.

13.3-4 Покажите, что, если вершина двоичного дерева поиска имеет двоих детей, то следующая за ней вершина не имеет левого ребёнка, а предшествующая ей вершина — правого.

13.3-5 Предположим, что указатель на вершину y хранится в какой-то внешней структуре данных и что предшествующая y вершина дерева удаляется с помощью процедуры TREE-DELETE. Какие при этом могут возникнуть проблемы? Как можно изменить TREE-DELETE, чтобы этих проблем избежать?

13.3-6 Коммутируют ли операции удаления двух вершин? Другими словами, получим ли мы одинаковые деревья, если в одном случае удалим сначала x, а потом y, а в другом — наоборот? Объясните свой ответ.

13.3-7 Если у z двое детей, мы можем использовать в TREE-DELETE не следующий за z элемент, а предыдущий. Можно надеяться, что справедливый подход, который в половине случаев выбирает предыдущий, а в половине — следующий элемент, будет приводить к лучше сбалансированному дереву. Как изменить текст процедуры, чтобы реализовать такой подход?

13.4 Случайные двоичные деревья поиска

Как мы видели, основные операции с двоичными деревьями поиска требуют времени O(h), где h — высота дерева. Поэтому важно понять, какова высота "типичного" дерева. Для этого необходимо принять какие-то статистические предположения о распределении ключей и последовательности выполняемых операций.

К сожалению, в общем случае ситуация трудна для анализа, и мы будем рассматривать лишь деревья, полученные добавлением вершин (без удалений). Определим случайное двоичное дерево (randomly built search tree) из n различных ключей как дерево, получающееся из пустого дерева добавлением этих ключей в случайном порядке (все n! перестановок считаем равновероятными). (Как видно из упр. 13.4-2, это не означает, что все двоичные деревья равновероятны, поскольку разные порядки добавления могут приводить к