---
source_image: page_354.png
page_number: 354
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 37.21
tokens: 11328
characters: 1468
timestamp: 2025-12-24T06:36:42.200049
finish_reason: stop
---

counter value — значение счетчика,
total cost — стоимость

Рисунок 18.2 Состояния восьмибитового двоичного счетчика в процессе выполнения 16 последовательных операций INCREMENT. Заштрихованы биты, значения которых изменяются при следующей операции INCREMENT. В правой графе показана общая стоимость всех операций по установке или очистке битов, необходимых, чтобы досчитать до данного числа. Заметьте, что в строке номер k эта стоимость не превосходит \(2k\).

Двоичный счётчик

В этом разделе мы применим метод группировки к анализу k-битного двоичного счётчика. Счётчик реализован как массив битов \(A[0..k-1]\) и хранит двоичную запись числа \(x = \sum_{i=0}^{k-1} A[i] \cdot 2^i\) (так что \(A[0]\) — младший бит). Первоначально \(x = 0\), т.е. \(A[i] = 0\) для всех \(i\). Определим операцию INCREMENT (увеличить на 1 по модулю \(2^k\)) так:

INCREMENT(\(A\))
1 \(i \leftarrow 0\)
2 while \(i < length[A]\) and \(A[i] = 1\)
3 do \(A[i] \leftarrow 0\)
4 \(i \leftarrow i + 1\)
5 if \(i < length[A]\)
6 then \(A[i] \leftarrow 1\)

По существу тот же алгоритм используется в реальных компьютерах (каскадное сложение — см. раздел 29.2.1). На рис. 18.2 изображены состояния двоичного счетчика при 16 последовательных применениях операции INCREMENT, начиная от 0 до 16. Увеличение счетчика на единицу происходит следующим образом: все начальные единичные биты в массиве \(A\) становятся нулями (цикл в строках 2–4), а следующий непосредственно за ними нулевой бит (если