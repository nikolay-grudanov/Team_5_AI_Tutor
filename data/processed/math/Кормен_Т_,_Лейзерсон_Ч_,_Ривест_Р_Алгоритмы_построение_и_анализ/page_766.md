---
source_image: page_766.png
page_number: 766
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 55.87
tokens: 11624
characters: 2210
timestamp: 2025-12-24T06:56:21.727975
finish_reason: stop
---

Простейший алгоритм

Если \( S[1..r] \) — строка длины \( r \), то ее префикс длины \( k \leq r \) будет обозначаться \( S_k = S[1..k] \) (в частности, \( S_0 = \varepsilon \) и \( S_r = S \)). В этих обозначениях задача о нахождении образца \( P \) длины \( m \) в тексте \( T \) длины \( n \) состоит в нахождении всех таких \( s \) из промежутка \( 0 \leq s \leq n - m \), что \( P \sqsubset T_{s+m} \).

При записи алгоритмов для поиска подстрок мы будем рассматривать проверку равенства двух строк как элементарную операцию, время выполнения которой пропорционально длине сравниваемых строк. Если сравнивать строки слева направо и останавливаюсь, как только обнаружено расхождение, то стоимость сравнения строк \( x \) и \( y \) есть \( \Theta(t + 1) \), где \( t \) — длина наибольшего общего префикса строк \( x \) и \( y \). (Мы пишем \( t+1 \) вместо \( t \), учитывая сравнение первых не совпавших символов.)

34.1 Простейший алгоритм

Первый приходящий в голову алгоритм для поиска образца \( P \) в тексте \( T \) последовательно проверяет равенство \( P[1..m] = T[s+1..s+m] \) для всех \( n - m + 1 \) возможных значений \( s \):

Naive-String-Matcher(T,P)
1 n \gets length[T]
2 m \gets length[P]
3 for s \gets 0 to n-m
4   do if P[1..m] = T[s+1..s+m]
5     then print 'Подстрока входит со сдвигом 's

Можно сказать, что мы двигаем образец вдоль текста и проверяем все его положения (рис. 34.3). Отметим, что проверка в строке 4 представляет собой ещё один цикл.

Время работы процедуры Naive-String-Matcher в худшем случае есть \( \Theta((n-m+1)m) \). В самом деле, пусть \( T = a^n \) (буква \( a \), повторённая \( n \) раз), а \( P = a^m \). Тогда для каждой из \( n - m + 1 \) проверок (строка 4) будет выполнено \( m \) сравнений символов, всего \( (n - m + 1)m \), что есть \( \Theta(n^2) \) (при \( m = \lfloor n/2 \rfloor \)).

Рис. 34.3
Подпись:
Рис. 34.3. Простейший алгоритм ищет образец \( P = aab \) в тексте \( T = asaabc \). Четыре последовательные попытки изображены на рис. (а)-(г). Буквы, для которых сравнение прошло успешно, соединены и показаны серым. Буквы, на которых выявлено несовпадение, соединены ломанными линиями. При этом \( s = 2 \) — единственный допустимый сдвиг.