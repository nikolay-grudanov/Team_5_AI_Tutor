---
source_image: page_139.png
page_number: 139
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 105.89
tokens: 13296
characters: 5836
timestamp: 2025-12-24T05:36:01.672672
finish_reason: stop
---

сываемым как \(a|b\). Для стандартизации в последующем изложении мы положим, что наши переменные \(a, b, c, \ldots, x, y, z\) принимают в качестве значений любые натуральные числа. Для последнего примера мы можем расширить отношение «делится», включив 0 (\(a|0\) истинно для любого \(a\); \(0|b\) ложно, кроме случая \(b = 0\)). Вопрос: «Чему равна сумма чисел \(a\) и \(b\)» очевидным образом передается функцией \(a + b\).

Обратно, отправляясь от произвольного теоретико-числового предиката \(P(a_1, \ldots, a_n)\), мы получаем счетно-бесконечный класс вопросов: «Для данных \(a_1, \ldots, a_n\) истинно ли \(P(a_1, \ldots, a_n)\)». Отправляясь от произвольной теоретико-числовой функции \(f(a_1, \ldots, a_n)\), мы получаем вопросы: «Для данных \(a_1, \ldots, a_n\) чему равно значение \(f(a_1, \ldots, a_n)\)».

Таким образом, безразлично, говорим ли мы о счетно-бесконечных классах вопросов или о теоретико-числовых предикатах и функциях. Если для предиката (или для получающегося из него класса вопросов) существует разрешающая процедура, мы называем этот предикат (или класс вопросов) разрешимым. Подобным образом, если для некоторой функции имеется процедура вычисления, мы называем эту функцию вычислимой.

Далее, случай предиката можно свести к случаю функции, если следующим образом определить представляющую функцию \(f(a_1, \ldots, a_n)\) предиката \(P(a_1, \ldots, a_n)\):

\[
f(a_1, \ldots, a_n) = \begin{cases}
0, & \text{если } P(a_1, \ldots, a_n) \text{ истинно}, \\
1, & \text{если } P(a_1, \ldots, a_n) \text{ ложно}.
\end{cases}
\]

В одноместном случае \(f(a)\) — та самая функция, которую в § 33 мы назвали «представляющей функцией» множества тех \(a\), для которых истинно \(P(a)\) (символически: множества \(\hat{a}P(a)\)). Безразлично, вычислять ли значение \(f(a_1, \ldots, a_n)\) и смотреть, равно оно 0 или нет, или решать, истинно или ложно \(P(a_1, \ldots, a_n)\). Другими словами, мы можем трактовать разрешающую процедуру как вычислительную, употребляя 0 вместо «да» и 1 вместо «нет» 1).

Чтобы отчетливее подчеркнуть идею алгорифма, рассмотрим еще некоторые случаи, когда не ясно, возможен ли алгорифм. Мы уже упоминали, что имеется алгорифм для вопроса: «Разрешимо ли в целых числах уравнение \(ax + by + c = 0\)» или, если записать его в виде предиката, для \((Ex)(Ey)[ax + by + c = 0]\). Здесь мы используем \((Ex)\) и \((Ey)\) в том же смысле, в котором использовали \(\exists x\) и \(\exists y\) в гл. II: мы хотим, чтобы впредь логический символизм, который мы используем вне рамок какой-либо данной формальной системы, отличался, насколько это возможно, от символизма, используемого в формальных системах 1). Существование такого алгорифма неочевидно с самого начала (в отличие от случая \(a|b\) и \(a + b\)). Этот алгорифм основан на определенной теории, при- надлежащей Евклиду.

Обобщим этот пример и рассмотрим вместо уравнения первой степени \(ax + by + c = 0\) уравнение второй степени \(ax^2 + bxy + cy^2 + dx + ey + f = 0\) (\(a, b, c\) не все равны 0) или даже произвольное алгебраическое уравнение (полиномиальное уравнение) любой степени \(n > 0\) от любого числа \(m > 0\) переменных \(x_1, \ldots, x_m\) и построим наш класс вопросов: «Разрешимо ли в целых числах любое данное алгебраическое уравнение с целыми коэффициентами?». Проблема разрешения для этого класса вопросов есть «десятая проблема Гильберта», включенная в его знаменитый список 23 важнейших нерешенных проблем математики [1900a]. Эта проблема не решена до сих пор 2).

Чтобы упростить ситуацию, рассмотрим некоторый двуместный предикат \(P(a, x)\), алгорифм для которого у нас имеется. Отсюда непосредственно не вытекает, что существует алгорифм для \((Ex)P(a, x)\). Единственная процедура, которую непосредственно дает определение этого предиката, состоит в том, чтобы, выбрав некоторое значение \(a\), начать проверять высказывания \(P(a, 0)\), \(P(a, 1)\), \(P(a, 2)\), ..., надеясь найти среди них истинное. Мы не можем рассчитывать, что с помощью этой процедуры узнаем за конечное число шагов, истинно ли \((Ex)P(a, x)\). Ведь (как мы уже отмечали относительно «\(\exists xP(x)\)» в § 36) если после некоторого конечного количества шагов мы не нашли \(x\), делающего \(P(a, x)\) истинным, то мы не будем знать, произошло ли это оттого, что \((Ex)P(a, x)\) ложно для рассматриваемого \(a\), или оттого, что мы не зашли еще достаточно далеко в нашей процедуре поиска.

Чтобы сформулировать этот пример в терминах теоретико-числовых функций вместо предикатов (т. е. вместо пропозициональных функций), допустим, что у нас имеется вычислительная процедура для \(f(a, x)\). Мы не можем сразу сказать, существует ли такая про-

1) Поскольку мы занимаемся здесь только вопросом о том, истинны или ложны предложения, получаемые в качестве значений предикатов, мы трактуем предикаты в этой теории экстенсионально, т. е. не различаем их от соответствующих логических функций, становящихся их представляющими функциями в результате замены t, f на 0, 1 (см. примечание 2 на стр. 166).

Ниже мы подчеркиваем, что иногда определение предиката или функции не дает для них алгорифма непосредственно, но алгорифм может даваться какой-то теорией, связанной с этой функцией или предикатом. Что касается предикатов, если мы возвращаемся к интенсиональному их пониманию, то мы могли бы тогда говорить, что (интенсиональный) предикат \(P\) может быть неразрешимым, в то время как эквивалентный ему предикат \(P_1\) разрешим.

1) Начиная с этой главы (и в нескольких случаях ранее, см. примечание на стр. 37) мы используем следующий неформальный логический символизм: \(=\) («эквивалентно»), \(\rightarrow\) («влечет»), \(\wedge\) («и»), \(\vee\) («или»), (так: \(\overline{A}\); «не»), (x) («для всех x»), \((Ex)\) («существует x (такой, что)»).
2) Матиясевич [1970] дал отрицательное решение десятой проблемы Гильберта.— Прим. ред.