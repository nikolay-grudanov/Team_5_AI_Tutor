---
source_image: page_172.png
page_number: 172
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 71.08
tokens: 12893
characters: 5337
timestamp: 2025-12-24T05:38:11.363273
finish_reason: stop
---

Есть две возможности приписать формуле \( P \supset Q(a_0) \) значение t: для этого необходимо и достаточно либо (i) приписать (7) P значение f, либо (ii) приписать (8) Q(a_0) значение t. Не обязательно делать и то и другое (хотя, конечно, этого было бы достаточно). Теперь поиск контрпримера раздваивается, и мы можем следовать по любому из двух путей.

Рассмотрим первый путь (i), когда мы хотим приписать P значение f. Но в (4) мы уже должны были приписать той же формуле P значение t. Эти два требования несовместимы. Таким образом, на этом пути мы не можем получить контрпример. Этот путь является «замкнутым» («тупиковым») — он закрыт для дальнейшего поиска.

Поэтому, если мы вообще можем найти контрпример, то должны следовать по второму пути (ii). В этом случае значение \( \forall x Q(x) \) должно быть f (см. (5)); для этого необходимо и достаточно, чтобы область D содержала такой элемент \( a_1 \), что (9) Q(a_1) имеет значение f. Нет оснований предполагать, что этот элемент совпадает с введенным в (6) элементом \( a_0 \), и поэтому мы обозначаем его через \( a_1 \). Теперь на пути (ii) мы приходим к контрпримеру. Действительно, наш последовательный анализ показывает, что для наших целей достаточно выбрать область D, содержащую по крайней мере два элемента, именуемых \( a_0 \) и \( a_1 \), и указать такое распределение параметров \( a_0, a_1, P \) и Q(x), при котором значения (4) P и (8) Q(a_0) суть t, а значение (9) Q(a_1) есть f. Теперь мы поступим следующим образом. Возьмем в качестве D область, состоящую ровно из двух элементов, скажем \( D = \{0, 1\} \). Пусть значения \( a_0 \) и \( a_1 \) будут 0 и 1 соответственно. Припишем P значение t. Значения для Q(x) зададим логической функцией I(x), такой, что I(0) есть t (тогда значение Q(a_0) есть t), а значение I(1) есть f (тогда значение Q(a_1) равно f). (Эта логическая функция с точностью до обозначений совпадает с функцией \( I_2(x) \) из § 17, пример 1: элементы области, обозначаемые в § 17 через «1» и «2», здесь обозначаются через «0» и «1».) Таким образом, формула F опровержима; поэтому \( \nvDash F \) неверно.

Анализ поиска контрпримера в словесной форме оказался весьма длинным. Мы дадим символическое представление для таких анализов. Выберем метод символического представления так, чтобы иметь абсолютно ясную картину поиска контрпримера, включая начальную ситуацию, последующие шаги и всю структуру поиска в целом. Символические представления могут быть довольно громоздкими, но сложность представлений не имеет большого значения, так как наша цель — их изучение, а не практическое применение.

В ходе поиска контрпримера мы после каждого шага по любому пути (если имеется выбор пути или последовательность выборов) получаем два (конечных) списка формул: список \( \Delta \) (из нуля или более) формул, которым мы хотим приписать значение t, и список \( \Lambda \) (из нуля или более) формул, которым мы хотим приписать значение f. Шаги анализа вплоть до последнего (включительно) показывают, что достаточно одновременно всем формулам из \( \Delta \) приписать значение t, а всем формулам из \( \Lambda \) — значение f, чтобы значение исходной формулы F было f. (В начале список \( \Delta \) пуст, а \( \Lambda \) — это просто F.) Чтобы F приняла значение f, надо хотя бы на одном из возможных путей приписать всем формулам из \( \Delta \) значение t, а всем формулам из \( \Lambda \) — значение f.

Таким образом, ситуация (начальная или наступающая после любого шага) может быть представлена упорядоченной парой \( \{\Delta, \Lambda\} \). По причинам, отчасти историческим, мы предпочитаем писать вместо \( \{\Delta, \Lambda\} \) «\( \Delta \rightarrow \Lambda \)». Здесь \( \rightarrow \) есть новый формальный символ (который можно читать как «дает»). Формальное выражение \( \Delta \rightarrow \Lambda \) (для любых двух конечных последовательностей \( \Delta \) и \( \Lambda \), состоящих из нуля или более формул) мы называем секвенцией; \( \Delta \) мы называем антецедентом, а \( \Lambda \) — сукцедентом секвенции.

Теперь остается описать структуру поиска контрпримера в целом. Для этого мы расположим секвенции в том порядке, в котором мы их получаем. По историческим причинам мы пишем исходную секвенцию \( \rightarrow F \) в основании нашей схемы. Выполняя каждый следующий шаг, мы проводим сверху горизонтальную черту и пишем одну или (если имеется выбор пути) две секвенции, к которым приводит данный шаг анализа.

Таким образом, мы опишем анализ (поиск) для примера 1 следующим «деревом» (слева):

\[
\begin{array}{c}
P \rightarrow \forall x Q(x), P \\
\hline
P, P \supset Q(a_0) \rightarrow \forall x Q(x)
\end{array}
\]

\[
\begin{array}{c}
Q(a_0), P \rightarrow Q(a_1) \\
Q(a_0), P \rightarrow \forall x Q(x)
\end{array}
\]

\[
\begin{array}{c}
\forall x(P \supset Q(x)) \rightarrow P \supset \forall x Q(x)
\end{array}
\]

Мы отметили крестом «×» вершину пути (ветви), чтобы показать, что путь (обрывается и) закрыт для дальнейшего поиска; отметка «∨» в вершине другого пути указывает, что поиск контрпримера закончился успешно. Символ «→ ⊃» указывает, что рассматриваемый шаг происходит в результате анализа импликации в сукцеденте (которой мы пытаемся приписать значение f), символ «∃ →» означает, что анализируется формула в антецеденте с квантором существования (которой мы пытаемся приписать значение t), и т. д.