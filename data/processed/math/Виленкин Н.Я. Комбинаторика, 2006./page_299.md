---
source_image: page_299.png
page_number: 299
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 27.89
tokens: 6442
characters: 2633
timestamp: 2025-12-24T07:48:39.366369
finish_reason: stop
---

В коде Хемминга мы делим исходную последовательность на блоки, содержащие по 4 информационных символа, и добавляем к каждому такому блоку 3 проверочных символа. Первый проверочный символ дополняет по четности символы с номерами 2, 3 и 4, второй — 1, 3 и 4, третий — 1, 2 и 4. Например, желая передать блок 1011, мы добавляем к нему проверочные символы 010 и посылаем блок 1011010. Иными словами, мы тратим 7 двоичных символов для того, чтобы передать лишь 4. Говорят, что мы передаем информацию со скоростью \(4/7\).

Проверим, что расстояние между любой парой кодовых слов не меньше 3. Проверки по четности формируются так, чтобы выполнялось два условия. Во-первых, любой информационный символ должен входить как минимум в две проверки. Во-вторых, для любой пары информационных символов должна существовать проверка, в которой проверяется только один из них. Тогда, если мы изменим один информационный символ, то в силу первого условия изменятся не менее двух проверочных и блоки окажутся друг от друга на расстоянии 3 (или больше). Если изменятся 2 информационных символа, то в силу второго условия будет также изменен хотя бы один проверочный и мы приходим к тому же выводу. Если же изменятся 3 или более информационных символа, то соответствующие кодовые слова уже окажутся на расстоянии не менее 3.

Разумеется, использование кодов, исправляющих ошибки, происходит не бесплатно — запас допустимых слов оказывается меньше, чем запас всех слов заданной длины \(n\) (как и в естественных языках — не любая совокупность знаков имеет смысл). Для оценки эффективности данного кода надо знать, каким вообще может быть объем \(M(n, r)\) кода, использующего кодовые слова длины \(n\) из цифр 0 и 1, отличающиеся друг от друга по крайней мере в \(2r + 1\) координате (ясно, что чем больше \(r\), тем меньше должно получиться «слов»).

Мы рассматриваем случай \(n = 7,\ r = 1\) — кодовые слова из 7 знаков, расстояние между ними 3. Всего слов длины 7 будет \(2^7\). К каждому допустимому примыкают \(C_7^1\) слов, находящихся от него на расстоянии 1 — они получаются изменением одного из 7 знаков. Всего получаем пачку из 8 слов на одно допустимое. Значит, допустимых слов не больше, чем \(2^7 : 8 = 16\). Таким образом, построенный код Хемминга оптимален.

В общем случае получается оценка числа \(M(n, r)\) допустимых «слов» \(\frac{2^n}{\sigma(n, 2r)} \leq M(n, r) \leq \frac{2^n}{\sigma(n, r)}\), где \(\sigma(n, r) = C_n^0 + C_n^1 + ... + C_n^r\).

Отметим, что если к построенному коду Хемминга добавить еще одну проверку на четность, проверяющую все имеющиеся 7 позиций, то построенный код будет не только исправлять любую одиночную