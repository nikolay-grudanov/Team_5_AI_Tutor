---
source_image: page_099.png
page_number: 99
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 31.19
tokens: 7739
characters: 1970
timestamp: 2025-12-24T09:12:39.370172
finish_reason: stop
---

c = aes_encrypt.update(p) + aes_encrypt.finalize()
print "enc(%s) = %s" % (blocks(p), blocks(c))

В результате выполнения этого скрипта мы получим блоки шифртекста, например:

$ ./aes_ecb.py
k = 50a0ebeff8001250e87d31d72a86e46d
enc(00000000000000000000000000000000 00000000000000000000000000000000) =
5eb4b7af094ef7aca472bbd3cd72f1ed 5eb4b7af094ef7aca472bbd3cd72f1ed

Как видим, в режиме ECB одинаковые блоки шифртекста являются для противника указанием на то, что блоки открытого текста одинаковы, — не важно, являются ли эти блоки частями одного шифртекста или разных. Это говорит о том, что блочные шифры в режиме ECB семантически небезопасны.

Еще одна проблема, связанная с ECB, заключается в том, что принимают только полные блоки данных, поэтому если длина блока составляет 16 байт, как в AES, то зашифровать можно будет сообщения размера 16 байт, 32 байта, 48 байт и вообще любого размера, кратного 16. Эту проблему можно решить несколькими способами, как мы увидим при обсуждении следующего режима, CBC. (Не буду рассказывать, как эти приемы работают с ECB, потому что использовать данный режим вообще не следует.)

Режим сцепления блоков шифртекста (CBC)

Режим сцепления блоков шифртекста (CBC) похож на ECB, но с одним маленьким отличием, которое всё меняет: результатом шифрования i-го блока, \( P_i \), является не \( C_i = E(K, P_i) \), а \( C_i = E(K, P_i \oplus C_{i-1}) \), где \( C_{i-1} \) — предыдущий блок шифртекста, т. е. блоки \( C_{i-1} \) и \( C_i \) сцепляются. Для первого блока \( P_1 \) предыдущего блока шифртекста не существует, поэтому берется случайное начальное значение (initial value — IV), как показано на рис. 4.8.

![Режим CBC](https://example.com/image.png)

Рис. 4.8. Режим CBC

В режиме CBC каждый блок шифртекста зависит от всех предыдущих блоков и гарантируется, что одинаковым блокам открытого текста не будут соответствовать одинаковые блоки шифртекста. А случайный выбор начального значения гарантирует, что при повторном