---
source_image: page_185.png
page_number: 185
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 41.59
tokens: 7942
characters: 2739
timestamp: 2025-12-24T09:15:21.513730
finish_reason: stop
---

шифртекст. Аутентификационный жетон (T) вычисляется по открытому тексту в виде \( T = \text{MAC}(K_2, P) \). С и T можно вычислять как последовательно, так и параллельно.

Сгенерировав шифртекст и аутентификационный жетон, отправитель передает то и другое получателю. Получатель дешифрирует C и получает открытый текст \( P = D(K_1, C) \). Затем он вычисляет \( \text{MAC}(K_2, P) \) по дешифрированному открытому тексту и сравнивает результат с полученным T. Проверка завершается неудачно, если C или T повреждены, в этом случае сообщение признается недействительным.

По крайней мере в теории, шифрование-и-MAC – наименее безопасное сочетание MAC и шифра, потому что даже из безопасной MAC может утекать информация о P, и тогда P будет легче восстановить. Поскольку цель MAC – всего лишь не допустить подделки жетонов, а жетоны необязательно выглядят случайными, аутентификационный жетон (T) открытого текста (P) все же может давать утечку информации, пусть даже MAC считается безопасной! (Разумеется, если MAC – псевдослучайная функция, то жетон ничего не выдаст о P.)

Но, несмотря на относительную слабость, схема шифрование-и-MAC по-прежнему поддерживается многими системами, в т. ч. безопасным протоколом транспортного уровня SSH, где каждый зашифрованный пакет C сопровождается жетоном \( T = \text{MAC}(K, N \| P) \), который передается в виде незашифрованного пакета P. В этом выражении N – 32-битовый порядковый номер, который увеличивается для каждого отправленного пакета, чтобы гарантировать обработку принятых пакетов в правильном порядке. На практике схема шифрование-и-MAC оказалась достаточно хорошей в SSH благодаря использованию стойких алгоритмов формирования MAC типа HMAC-SHA-256, которые не дают утечки информации о P.

MAC-затем-шифрование

Сочетание MAC-затем-шифрование защищает сообщение P, поскольку сначала вычисляется аутентификационный жетон \( T = \text{MAC}(K_2, P) \). Затем создается шифртекст путем совместного зашифровывания открытого текста и жетона: \( C = E(K_1, P \| T) \).

Завершив эти действия, отправитель передает только сообщение C, содержащее зашифрованные открытый текст и жетон. Получатель дешифрирует C, вычисляя \( P \| T = D(K_1, C) \), и получает открытый текст и жетон T. Затем получатель проверяет полученный жетон T, вычисляя по открытому тексту \( \text{MAC}(K_2, P) \), сравнивает вычисленный жетон с полученным.

Как и в случае схемы шифрование-и-MAC, при использовании схемы MAC-затем-шифрование получатель должен дешифрировать C, прежде чем сумеет определить, были ли повреждены пакеты, – таким образом он выявляет потенциально поврежденные открытые тексты. Тем не менее схема MAC-затем-шифрование безопаснее, чем шифрование-и-MAC, потому что скрывает аутентификационный жетон