---
source_image: page_303.png
page_number: 303
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 37.44
tokens: 7881
characters: 2710
timestamp: 2025-12-24T09:18:53.485539
finish_reason: stop
---

Квантовое ускорение

Квантовое ускорение имеет место, когда с помощью квантового компьютера задачу можно решить быстрее, чем с помощью классического. Например, для поиска элемента в неупорядоченном списке из n элементов на классическом компьютере в среднем необходимо выполнить n/2 операций, потому что придется просмотреть все элементы, предшествующие искомому. (В среднем элемент найдется после просмотра половины списка.) Никакой классический алгоритм не сможет добиться лучшего результата. Однако существует квантовый алгоритм поиска элемента примерно за \( \sqrt{n} \) операций, что на несколько порядков лучше, чем n/2. Например, если n равно 1 000 000, то n/2 равно 500 000, а \( \sqrt{n} \) — всего 1000.

Мы пытаемся измерить разницу между квантовыми и классическими алгоритмами в терминах временной сложности в нотации O(). В примере выше квантовый алгоритм работает за время O(\( \sqrt{n} \)), а классический не может быть быстрее, чем O(n). Такое различие во временной сложности называется квадратичным ускорением. Даже этот результат выглядит очень неплохо, но можно добиться гораздо большего.

Экспоненциальное ускорение и задача Саймона

Экспоненциальное ускорение — золотая мечта квантовых вычислений. Так бывает, когда задача, требующая экспоненциального времени при решении на классическом компьютере, например O(2^n), может быть решена за полиномиальное время на квантовом компьютере, т. е. за время O(n^k) для некоторого фиксированного k. Такое ускорение превращает практически неразрешимую задачу в разрешимую. (Напомню, что криптографы и специалисты по теории сложности считают задачи с экспоненциальным временем неразрешимыми, а с полиномиальным — практически осуществимыми.)

Каноническим примером экспоненциального ускорения является задача Саймона. В этой задаче функция f() преобразует n-битовые строки в n-битовые строки так, что выход f() выглядит случайно с одной оговоркой: существует такое значение m, что для любых двух значений x, y, удовлетворяющих условию f(x) = f(y), имеет место равенство y = x \( \oplus \) m. Требуется найти m.

Классический алгоритм решения задачи Саймона сводится к нахождению коллизии, что требует приблизительно \( 2^{n/2} \) обращений к f(). Квантовый же алгоритм, показанный на рис. 14.4, может решить ее примерно за n обращений, т. е. его временная сложность составляет всего O(n), что крайне эффективно.

Здесь мы инициализируем 2n кубитов значением |0⟩, применяем вентили Адамара (H) к первым n кубитам, затем применяем вентиль Q_f к обеим группам по n кубитов. Получив две группы по n кубитов, x и y, вентиль Q_f преобразует квантовое состояние |x⟩|y⟩ в состояние |x⟩|f(x) \( \oplus \) y⟩. То есть он вычисляет функцию f() на квантовом состоя-