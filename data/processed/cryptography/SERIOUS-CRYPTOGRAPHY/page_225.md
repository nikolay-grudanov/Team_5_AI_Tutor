---
source_image: page_225.png
page_number: 225
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 33.28
tokens: 7756
characters: 1999
timestamp: 2025-12-24T09:16:22.995740
finish_reason: stop
---

и \( q \) должны храниться в секрете, т. к. знание того или другого позволяет определить \( \varphi(n) \) по формуле \( (p-1)(q-1) = \varphi(n) \).

**Примечание** \( \varphi(n) \) называют также порядком группы \( \mathbb{Z}_n^* \); порядок — важная характеристика группы, являющаяся также неотъемлемой частью других систем с открытым ключом, например протокола Диффи–Хеллмана и эллиптической криптографии.

**Генерирование ключей и безопасность RSA**

Под генерированием ключей понимается процедура создания пары ключей RSA, а именно открытого ключа (модуля \( n \) и открытого показателя степени \( e \)) и закрытого ключа (секретного показателя степени \( d \)). Числа \( p \) и \( q \) (такие, что \( n = pq \)) и порядок \( \varphi(n) \) также следует хранить в секрете, поэтому они часто считаются частью закрытого ключа.

Чтобы сгенерировать пару ключей RSA, мы сначала выбираем два случайных простых числа \( p \) и \( q \), а затем вычисляем по ним \( \varphi(n) \) и элемент \( d \), обратный \( e \). Чтобы показать, как это работает, мы в листинге 10.1 воспользовались написанной на Python средой SageMath (http://www.sagemath.org/) с открытым исходным кодом, которая включает много математических пакетов.

**Листинг 10.1. Генерирование параметров RSA с помощью SageMath**

1 sage: p = random_prime(2^32); p
1103222539
2 sage: q = random_prime(2^32); q
17870599
3 sage: n = p*q; n
19715247602230861
4 sage: phi = (p-1)*(q-1); phi
19715246481137724
5 sage: e = random_prime(phi); e
13771927877214701
6 sage: d = xgcd(e, phi)[1]; d
15417970063428857
7 sage: mod(d*e, phi)
1

**Примечание** Чтобы избежать вывода на несколько страниц, я в листинге 10.1 использую 64-битовый модуль \( n \), но на практике модуль RSA должен быть по меньшей мере 2048-битовым.

Функция random_prime() возвращает случайные простые числа \( p \) 1 и \( q \) 2, меньше заданного аргумента. Затем мы перемножаем \( p \) и \( q \) и получаем модуль \( n \) 3 и значение \( \varphi(n) \) в переменной phi 4. Далее