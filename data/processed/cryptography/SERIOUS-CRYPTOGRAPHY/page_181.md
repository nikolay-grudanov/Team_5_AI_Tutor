---
source_image: page_181.png
page_number: 181
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 29.27
tokens: 7664
characters: 2280
timestamp: 2025-12-24T09:14:58.358297
finish_reason: stop
---

ответственно. Разница достаточно велика, чтобы понять, что происходит внутри алгоритма. Аналогичные различия во времени можно наблюдать, когда первый несовпадающий байт находится в другой позиции. Если MAC1 — правильный MAC-жетон, а MAC2 — жетон, опробованный противником, то легко определить позицию первого несовпадения, равную числу правильно угаданных байтов.

Разумеется, если время выполнения не зависит от секретного хронометража, то такая атака работать не будет, поэтому опытные разработчики стремятся к реализациям с постоянным временем — когда код выполняется одинаковое время при любом входном значении секрета. Например, функция на C в листинге 7.3 сравнивает два буфера размером size байт за постоянное время: временная переменная result будет отлична от нуля тогда и только тогда, когда буферы различаются хотя бы в одной позиции.

Листинг 7.3. Сравнение двух буферов за постоянное время дает более безопасную верификацию MAC

int cmp_const(const void *a, const void *b, const size_t size)
{
    const unsigned char *_a = (const unsigned char *) a;
    const unsigned char *_b = (const unsigned char *) b;
    unsigned char result = 0;
    size_t i;

    for (i = 0; i < size; i++) {
        result |= _a[i] ^ _b[i];
    }

    return result; /* возвращает 0, если *a и *b равны, иначе ненулевое значение */
}

Когда губки протекают

Алгоритмы на основе перестановок, в частности SHA-3 и SipHash, просты, легко реализуются и имеют компактный код, но они уязвимы к атакам по побочным каналам, которые восстанавливают снимок состояния системы. Например, если процесс может в любой момент времени прочитать оперативную память и значения регистров или дамп памяти, то противник способен определить внутреннее состояние SHA-3 в режиме MAC или внутреннее состояние SipHash, а затем вычислить обратную перестановку и восстановить начальное секретное состояние. После этого он может подделать жетон любого сообщения, нарушив тем самым безопасность MAC.

По счастью, эта атака бессильна против имитовставок на основе функций сжатия, в частности HMAC-SHA-256 и BLAKE2 с секретным ключом, потому что противнику понадобился бы снимок памяти точно в тот момент, когда используется ключ. Вывод: если вы работаете в среде, где части памяти процесса могут утекать наружу, то следу-