---
source_image: page_094.png
page_number: 94
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 52.97
tokens: 8043
characters: 2641
timestamp: 2025-12-24T09:12:52.871144
finish_reason: stop
---

Bytes(), за ней ShiftRows(), а за ней MixColumns(), потому что это было бы неэффективно. Вместо этого в быстрых программных реализациях AES используется специальная техника, называемая табличной реализацией, и машинные команды.

Табличные реализации

В табличных реализациях AES последовательность операций SubBytes-ShiftRows-MixColumns заменяется комбинацией XOR и поиска в таблицах, зашифтованных в код программы и загружаемых в память во время выполнения. Это возможно, потому что MixColumns эквивалентна XOR четырех 32-битовых значений, каждое из которых зависит от одного байта состояния и от SubBytes. Таким образом, можно построить четыре таблицы по 256 элементов (по одному для каждого возможного значения байта) и реализовать последовательность SubBytes-MixColumns с помощью выборки четырех 32-битовых значений из этих таблиц и применения к ним XOR.
Например, табличная реализация на C в пакете OpenSSL показана в листинге 4.2.

Листинг 4.2. Табличная реализация AES на C в OpenSSL

/* раунд 1: */
t0 = Te0[s0 >> 24] ^ Te1[(s1 >> 16) & 0xff] ^ Te2[(s2 >> 8) & 0xff] ^ Te3[s3 & 0xff] ^ rk[4];
t1 = Te0[s1 >> 24] ^ Te1[(s2 >> 16) & 0xff] ^ Te2[(s3 >> 8) & 0xff] ^ Te3[s0 & 0xff] ^ rk[5];
t2 = Te0[s2 >> 24] ^ Te1[(s3 >> 16) & 0xff] ^ Te2[(s0 >> 8) & 0xff] ^ Te3[s1 & 0xff] ^ rk[6];
t3 = Te0[s3 >> 24] ^ Te1[(s0 >> 16) & 0xff] ^ Te2[(s1 >> 8) & 0xff] ^ Te3[s2 & 0xff] ^ rk[7];
/* раунд 2: */
s0 = Te0[t0 >> 24] ^ Te1[(t1 >> 16) & 0xff] ^ Te2[(t2 >> 8) & 0xff] ^ Te3[t3 & 0xff] ^ rk[8];
s1 = Te0[t1 >> 24] ^ Te1[(t2 >> 16) & 0xff] ^ Te2[(t3 >> 8) & 0xff] ^ Te3[t0 & 0xff] ^ rk[9];
s2 = Te0[t2 >> 24] ^ Te1[(t3 >> 16) & 0xff] ^ Te2[(t0 >> 8) & 0xff] ^ Te3[t1 & 0xff] ^ rk[10];
s3 = Te0[t3 >> 24] ^ Te1[(t0 >> 16) & 0xff] ^ Te2[(t1 >> 8) & 0xff] ^ Te3[t2 & 0xff] ^ rk[11];
--опущено--

Для базовой табличной реализации шифрования AES необходимо 4 килобайта, поскольку в каждой таблице хранится 256 32-битовых значений, занимающих 256 × 32 = 8192 бита, или один килобайт. Для дешифрирования нужно еще четыре таблицы и, стало быть, еще четыре килобайта. Но существуют приемы, позволяющие уменьшить объем памяти с четырех до одного килобайта и даже меньше.
К сожалению, табличные реализации уязвимы к атакам с хронометражем кеша, в которых используются вариации во времени чтения или записи элементов кеш-памяти. Время доступа к элементу зависит от его относительной позиции в кеше. Поэтому хронометраж дает информацию о том, к какому элементу производилось обращение, а значит, и информацию о секретной части шифра.
От атак с хронометражем кеша трудно уклониться. Очевидное решение — вообще отказаться от справочных таблиц, написав програм-