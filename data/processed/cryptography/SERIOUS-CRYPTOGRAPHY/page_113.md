---
source_image: page_113.png
page_number: 113
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 35.04
tokens: 7711
characters: 2153
timestamp: 2025-12-24T09:13:07.761063
finish_reason: stop
---

ной связью (feedback shift register – FSR). Почти все аппаратные потоковые шифры так или иначе опираются на FSR, будь то шифр A5/1, который использовался в мобильных телефонах стандарта 2G, или более современный шифр Grain-128a.

Примечание Первый стандартный блочный шифр, Data Encryption Standard (DES), был оптимизирован для аппаратной, а не программной реализации. Когда в 1970-х годах правительство США стандартизировало DES, большая часть приложений, в которых он использовался, была реализована аппаратно. Поэтому неудивительно, что S-блоки в DES небольшие и быстрые, если реализовывать их в виде электронной схемы, но неэффективны в случае программной реализации. В отличие от DES, текущий стандарт Advanced Encryption Standard (AES) работает с байтами и потому программно реализуется более эффективно, чем DES.

Регистры сдвига с обратной связью

В бесчисленных потоковых шифрах использовались FSR, потому что они просты и понятны. FSR — это просто массив битов, снабжённый функцией обратной связи, которую я буду обозначать f. Состояние FSR хранится в массиве, или регистре, а при каждом обновлении FSR вызывается функция обратной связи, которая изменяет состояние и порождает один выходной бит.

На практике FSR работает следующим образом: если R_0 — начальное значение FSR, то следующее состояние R_1 определяется как результат сдвига R_0 влево на 1 бит. При этом бит, выдвинушийся из регистра, возвращается в виде выходного, а в освободившуюся позицию помещается f(R_0).

То же правило применяется для вычисления следующих состояний R_2, R_3 и т. д. То есть если известно состояние FSR в момент t, R_t, то следующее состояние R_{t+1} вычисляется по формуле

\[
R_{t+1} = (R_t << 1) | f(R_t).
\]

В этой формуле | обозначает оператор логического ИЛИ (OR), а << — оператор сдвига влево (как в языке C). Например, для 8-битовой строки 00001111 имеем:

\[
00001111 << 1 = 00011110 \\
00011110 << 1 = 00111100 \\
00111100 << 1 = 01111000
\]

Операция сдвига сдвигает биты влево, при этом самый левый бит теряется, а самый правый обнуляется. Операция обновления в FSR устроена аналогично, только в правый бит записывается не 0, а значение f(R_t).