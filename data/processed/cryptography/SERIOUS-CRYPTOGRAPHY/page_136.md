---
source_image: page_136.png
page_number: 136
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 28.82
tokens: 7646
characters: 1986
timestamp: 2025-12-24T09:13:41.849693
finish_reason: stop
---

тый и зашифрованный текст старой версии документа можно было использовать для дешифрирования более поздних зашифрованных версий. Если даже Microsoft допустила такую ошибку, то можете представить себе масштаб проблемы.

Некоторые потоковые шифры, спроектированные в 2010-х годах, пытались уменьшить риск повторного использования одноразового числа путем создания «устойчивых к неправильному применению» конструкций или шифров, остающихся безопасными даже при повторном использовании одноразового числа. Однако такой уровень безопасности сопряжен с потерей производительности, как мы увидим в главе 8 при обсуждении режима SIV.

Дефектная реализация RC4

И так уже слабый шифр RC4 может стать еще слабее в результате не-продуманной оптимизации его реализации. Например, рассмотрим следующее предложение, поданное в 2007 году на конкурс Underhanded C — неформальное состязание программистов по написанию безвредного, на первый взгляд, кода, который на самом деле включает вредоносную функцию.

Вот как это работает. Наивный способ реализации строки swap(S[i], S[j]) в алгоритме RC4 выглядит (на Python) следующим образом:

buf = S[i]
S[i] = S[j]
S[j] = buf

Этот способ обмена двух переменных, безусловно, работает, но нужно создавать новую переменную buf. Чтобы избежать этого, программисты часто применяют показанный ниже трюк XORswap для обмена значений переменных x и y:

x = x ⊕ y
y = x ⊕ y
x = x ⊕ y

Этот трюк работает, потому что во второй строке y присваивается значение x ⊕ y ⊕ y = x, а в третьей строке x получает значение x ⊕ y ⊕ x ⊕ y ⊕ y = y. Используя этот трюк в реализации RC4, мы получаем код, показанный в листинге 5.5 (немного адаптированный код из программы Вагнера и Бьонди, поданной на конкурс Underhanded C и опубликованной по адресу http://www.underhanded-c.org/_page_id_16.html).

Листинг 5.5. Неправильная реализация на С шифра RC4, ошибка связана с использованием трюка XORswap

# define TOBYTE(x) (x) & 255
# define SWAP(x,y) do { x^=y; y^=x; x^=y; } while (0)