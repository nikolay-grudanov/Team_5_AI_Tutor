---
source_image: page_240.png
page_number: 240
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 38.30
tokens: 7897
characters: 2622
timestamp: 2025-12-24T09:16:58.222768
finish_reason: stop
---

Вариант этой атаки работает, когда правильная подпись неизвестна, но известно, что сообщение подписано. Существует похожая атака внесением ошибки на значение модуля, а не на вычисление значений в китайской теореме об остатках, но здесь я не стану вдаваться в ее детали.

Разделение закрытых показателей степени или модулей

Теперь я покажу, почему ваш открытый ключ не должен иметь такой же модуль n, как чей-то еще.

Различные закрытые ключи, принадлежащие разным системам или физическим лицам, очевидно, должны иметь разные закрытые показатели степени d, даже если у ключей разные модули, иначе вы могли бы пробовать свое значение d для дешифрирования чужих сообщений, пока не наткнетесь на сообщение с таким же d. По тем же причинам в разных парах ключей должны быть разные значения n, даже если значения d различны, потому что p и q обычно являются частями закрытого ключа. Следовательно, если мы разделяем одно и то же n, а значит, одинаковые p и q, то я смогу вычислить ваш закрытый ключ по вашему открытому ключу e, используя p и q.

А что, если мой закрытый ключ — это просто пара (n, d₁), ваш закрытый ключ — пара (n, d₂), а ваш открытый ключ — пара (n, e₂)? Допустим, что я знаю n, но не знаю p и q, поэтому не могу напрямую вычислить ваш закрытый показатель степени d₂ по вашему открытому показателю степени e₂. Как бы вы вычислили p и q, зная только закрытый показатель степени d? Решение элегантное, хотя опирается на некоторые математические факты.

Вспомним, что d и e связаны соотношением ed = kφ(n) + 1, где φ(n) — секрет, знание которого помогло бы узнать p и q непосредственно. Мы не знаем ни k, ни φ(n), но можем вычислить kφ(n) = ed − 1.

Что можно сделать с этим значением kφ(n)? Во-первых, согласно теореме Эйлера, мы знаем, что для любого числа a, взаимно простого с n, \(a^{\varphi(n)} \equiv 1 \mod n\). Поэтому по модулю n имеет место равенство:

\[
a^{k\varphi(n)} = (a^{\varphi(n)})^k = 1^k = 1.
\]

Во-вторых, поскольку kφ(n) — четное число, мы можем записать его в виде 2^s t для некоторых s и t. То есть мы сможем записать равенство \(a^{k\varphi(n)} = 1 \mod n\) в виде \(x^2 = 1 \mod n\) для некоторого x, которое легко вычисляется по kφ(n). Такое x называется корнем из единицы.

Ключевое наблюдение заключается в том, что равенство \(x^2 = 1 \mod n\) равносильно тому, что \(x^2 - 1 = (x - 1)(x + 1)\) делится на n. Иными словами, либо x − 1, либо x + 1 должны иметь общий множитель с n, что может дать нам факторизацию n.

В листинге 10.7 показана реализация этого метода на Python, в которой, чтобы без труда найти множители p и q по n и d, мы использовали небольшие 64-битовые числа.