---
source_image: page_143.png
page_number: 143
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 27.56
tokens: 7565
characters: 1805
timestamp: 2025-12-24T09:13:52.429007
finish_reason: stop
---

Это безнадежно в случае \( n = 256 \), как в современных хеш-функциях типа SHA-256 или BLAKE2.

Листинг 6.1. Оптимальный алгоритм поиска прообраза для безопасной хеш-функции

find-preimage(H) {
    repeat {
        M = random_message()
        if Hash(M) == H then return M
    }
}

Почему стойкость к восстановлению второго прообраза ниже

Я утверждаю, что если можно найти первые прообразы, то можно найти и вторые прообразы (для той же хеш-функции). Действительно, если алгоритм solve-preimage() возвращает прообраз заданного хеш-значения, то его можно использовать для нахождения второго прообраза некоторого сообщения \( M \), как показано в листинге 6.2.

Листинг 6.2. Как найти вторые прообразы, если мы умеем находить первые прообразы

solve-second-preimage(M) {
    H = Hash(M)
    return solve-preimage(H)
}

Таким образом, мы сможем найти второй прообраз, рассматривая это как задачу восстановления прообраза и применив атаку на прообраз. Отсюда следует, что любая хеш-функция, стойкая к восстановлению второго прообраза, является также стойкой к восстановлению прообраза. (Иначе она не была бы стойкой к восстановлению второго прообраза, как показывает приведенный выше алгоритм solve-second-preimage.) Иными словами, наилучшая атака, которую можно применить для нахождения вторых прообразов, почти идентична наилучшей атаке для нахождения первых прообразов (если только у хеш-функции нет дефекта, открывающего возможность для более эффективных атак). Заметим также, что атака поиска прообраза, по сути дела, совпадает с атакой восстановления ключа на блочный или потоковый шифр — полный перебор в поисках одного-единственного значения.

Стойкость к коллизиям

Какую бы хеш-функцию ни выбрать, коллизии неизбежны вследствие принципа Дирихле, согласно которому если по \( m \) клеткам рассадить