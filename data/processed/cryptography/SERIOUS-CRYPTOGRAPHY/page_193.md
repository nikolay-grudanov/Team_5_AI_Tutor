---
source_image: page_193.png
page_number: 193
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 46.19
tokens: 7947
characters: 2304
timestamp: 2025-12-24T09:15:38.427267
finish_reason: stop
---

Полиномиальное умножение

Для нас полиномиальное умножение, очевидно, сложнее, чем классическое арифметическое умножение, но для компьютеров оно проще, потому что отсутствуют переносы. Например, пусть требуется вычислить произведение полиномов (1 + X + X^2) и (X + X^3). Сначала умножаем оба полинома, как обычно (два члена X^3 взаимно уничтожаются):

\[
(1 + X + X^2) \otimes (X + X^3) = X + X^3 + X^2 + X^4 + X^3 + X^5 \\
= X + X^2 + X^4 + X^5.
\]

Теперь применяем сокращение по модулю: X + X^2 + X^4 + X^5 по модулю 1 + X^3 + X^4 дает X^2, потому что X + X^2 + X^4 + X^5 можно записать в виде X + X^2 + X^4 + X^5 = X \otimes (1 + X^3 + X^4) + X^2. Вообще, A + BC по модулю B равно A, в силу определения сокращения по модулю.

Безопасность GCM

Самая серьезная слабость AES-GCM — уязвимость к повторению одноразового числа. Если одно и то же одноразовое число N используется дважды, то противник сможет получить ключ аутентификации H и с его помощью подделывать жетоны для любого шифртекста, ассоциированных данных или их комбинации.

Ознакомление с простой алгеброй, стоящей за вычислениями AES-GCM (показанными на рис. 8.2), поможет понять причины этой уязвимости. Жетон (T) вычисляется в виде T = GHASH(H, A, C) ⊕ AES(K, N||0), где GHASH — универсальная хеш-функция с линейной связью между входами и выходами.

И что будет, если вычислить два жетона, T_1 и T_2, с одним и тем же одноразовым числом N? Правильно, члены AES пропадут. Если T_1 = GHASH(H, A_1, C_1) ⊕ AES(K, N||0) и T_2 = GHASH(H, A_2, C_2) ⊕ AES(K, N||0), то, применив к ним операцию XOR, получим:

GHASH(H, A_1, C_1) ⊕ AES(K, N||0) ⊕ GHASH(H, A_2, C_2) ⊕ AES(K, N||0)
= GHASH(H, A_1, C_1) ⊕ GHASH(H, A_2, C_2) ⊕ AES(K, N||0) ⊕ AES(K, N||0)
= GHASH(H, A_1, C_1) ⊕ GHASH(H, A_2, C_2).

Итак, если одно и то же одноразовое число используется дважды, то противник может восстановить значение GHASH(H, A_1, C_1) ⊕ GHASH(H, A_2, C_2) для некоторых известных A_1, C_1, A_2 и C_2. Затем, в силу линейности GHASH, противник сможет легко определить H. (Было бы еще хуже, если бы в GHASH использовался тот же ключ K, что и при шифровании, но, поскольку H = AES(K, 0), простого способа определить K по H не существует.)

Совсем недавно — в 2016 году — исследователи просканировали интернет на предмет экземпляров AES-GCM в HTTPS-серверах; их ин-