---
source_image: page_204.png
page_number: 204
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 32.68
tokens: 7652
characters: 2195
timestamp: 2025-12-24T09:15:49.373669
finish_reason: stop
---

Вычислительная трудность

Вычислительная задача — это вопрос, на который можно получить ответ, проделав достаточное количество вычислений, например «является ли 2017 простым числом?» или «сколько букв i в слове in-comprehensibilities?». Вычислительная трудность — это общее свойство вычислительных задач, для которых не существует алгоритма с разумным временем работы. Такие задачи также называют неразрешимыми, поскольку на практике их зачастую невозможно решить.

Удивительно, что вычислительная трудность не зависит от типа используемого вычислительного устройства, будь то процессор общего назначения, интегрированная схема или механическая машина Тьюринга. Действительно, одно из первых открытий теории вычислительной сложности заключается в том, что все модели вычислений эквивалентны. Если задачу можно эффективно решить с помощью одного вычислительного устройства, то ее можно эффективно решить и на любом другом устройстве, перенеся алгоритм на язык этого устройства. Исключение составляют квантовые компьютеры, но их пока не существует. Таким образом, при обсуждении вычислительной трудности необязательно указывать конкретное вычислительное устройство или оборудование, достаточно обсуждать только алгоритмы.

Для оценки трудности мы сначала определим способ измерения сложности алгоритма, или время его работы. А затем по времени работы будем классифицировать задачи как трудные или легкие.

Измерение времени работы

Большинство разработчиков знакомы с вычислительной сложностью, или приблизительным количеством выполняемых алгоритмом операций, выраженным в виде функции от размера входных данных. Размер подсчитывается битах или в элементах ввода. Например, рассмотрим алгоритм в листинге 9.1, написанный на псевдокоде. Он ищет значение x в массиве n элементов и возвращает индекс найденной позиции.

Листинг 9.1. Простой алгоритм поиска, написанный на псевдокоде, вычислительная сложность которого линейно зависит от длины массива n. Алгоритм возвращает индекс позиции (число от 1 до n), в которой найдено значение x, или 0, если x отсутствует в массиве

search(x, array, n):
    for i from 1 to n {
        if (array[i] == x) {
            return i;
        }
    }
    return 0;