---
source_image: page_030.png
page_number: 30
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 34.05
tokens: 7763
characters: 2190
timestamp: 2025-12-24T09:10:44.444975
finish_reason: stop
---

более сложные операции, например сложение, умножение и т. д. Так работают современные шифры: имея ключ длиной 128 или 256 бит, они выполняют сотни поразрядных операций для шифрования одной-единственной буквы. На компьютере, выполняющем миллиарды поразрядных операций в секунду, это не занимает много времени, но на вычисления вручную пришлось бы потратить несколько часов, и все равно результат был бы уязвим для частотного анализа.

Идеальное шифрование: одноразовый блокнот

В принципе, классический шифр не может быть безопасным, если только не используется очень длинный ключ, но шифровать гигантским ключом практически неудобно. Однако такой шифр существует, он называется одноразовым блокнотом и является самым безопасным. По существу, он гарантирует идеальную секретность: даже располагая неограниченной вычислительной мощностью, противник не сможет узнать об открытом тексте ничего, кроме длины.
В следующих разделах я покажу, как работает одноразовый блокнот, а затем приведу набросок доказательства его безопасности.

Шифрование с помощью одноразового блокнота

Одноразовый блокнот принимает открытый текст P и случайный ключ K такой же длины, как P, и порождает шифртекст C, вычисляемый по формуле

\[
C = P \oplus K,
\]

где C, P, K — битовые строки одинаковой длины, а \( \oplus \) — операция по-разрядного исключающего ИЛИ (XOR), определенная следующим образом: \( 0 \oplus 0 = 0, 0 \oplus 1 = 1, 1 \oplus 0 = 1, 1 \oplus 1 = 0 \).

Примечание Я описываю одноразовый блокнот в стандартной форме, применяемой к битам, но его можно адаптировать и для других символов. Например, в случае букв мы получим вариант шифра Цезаря, в котором величина сдвига каждой буквы выбирается случайным образом.

Дешифрирование с одноразовым блокнотом выполняется точно так же, как шифрование; это просто операция XOR: \( P = C \oplus K \). Действительно, легко проверить, что \( C \oplus K = P \oplus K \oplus K = P \), поскольку \( K \oplus K \) дает строку, состоящую из одних нулей 000 ... 000. Вот так — даже проще, чем шифр Цезаря.
Например, если \( P = 01101101 \) и \( K = 10110100 \), то вычисление выглядит следующим образом:

\[
C = P \oplus K = 01101101 \oplus 10110100 = 11011001.
\]