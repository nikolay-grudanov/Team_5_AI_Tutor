---
source_image: page_192.png
page_number: 192
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 42.21
tokens: 7904
characters: 2684
timestamp: 2025-12-24T09:15:34.395835
finish_reason: stop
---

Затем блоки шифртекста перемешиваются с применением комбинации операций XOR и умножения (как будет описано ниже). Как видим, AES-GCM выполняет 1) шифрование в режиме CTR и 2) вычисление MAC по блокам шифртекста. Поэтому AES-GCM принадлежит к классу шифрование-затем-MAC, где AES-CTR шифрует с помощью 128-битового ключа (K) и 96-битового одноразового ключа (N), а мелкое отличие заключается в том, что счетчик начинается с 1, а не с 0, как в обычном режиме CTR (с точки зрения безопасности, это не играет роли).

Для аутентификации шифртекста в GCM используется имитовставка Вегмана–Картера (см. главу 7), которая с помощью XOR объединяет значение AES(K, N||0) с выходом универсальной функции хеширования GHASH. На рис. 8.2 функции GHASH соответствует серия операций \( \oplus_n \), сопровождаемая XOR с len(A)||len(C), т. е. длиной A (ассоциированных данных) в битах, конкатенированной с длиной C (шифртекста) в битах.

Таким образом, мы можем выразить значение аутентификационного жетона в виде \( T = \text{GHASH}(H, C) \oplus \text{AES}(K, N||0) \), где C — шифртекст, а H — хеш-ключ, или ключ аутентификации. Этот ключ определен как \( H = \text{AES}(K, 0) \), т. е. результат шифрования блока, состоящего из последовательности нулевых байтов (этот шаг опущен на рис. 8.2 для ясности).

**Примечание** В режиме GCM функция GHASH не использует ключ K напрямую. Это гарантирует, что если ключ GHASH окажется скомпрометирован, то главный ключ K останется секретным. Зная K, можно получить H, вычислив AES(K, 0), но восстановить K по этому значению нельзя, потому что K здесь выступает в роли ключа AES.

Как показано на рис. 8.2, в GHASH используется полиномиальная нотация для описания умножения каждого блока шифртекста на ключ аутентификации H. Благодаря такому использованию полиномиальной нотации GHASH работает быстро как при аппаратной, так и при программной реализации, поскольку во многих микропроцессорах имеется специальная команда полиномиального умножения (CLMUL, или carry-less multiplication, умножение без переносов).

К сожалению, GHASH далека от идеала. Во-первых, ее быстродействие не оптимально. Даже при использовании команды CLMUL уровень AES-CTR, который зашифровывает открытый текст, все равно быстрее, чем GHASH MAC. Во-вторых, GHASH очень трудно реализовать корректно. Даже опытные разработчики проекта OpenSSL, самого широко используемого криптографического ПО, умудрились реализовать функцию GHASH для AES-GCM неправильно. В одной из фиксаций была функция gcm_ghash_clmul, которая позволяла противнику подделать действительные имитовставки для AES-GCM. (К счастью, эту ошибку обнаружили инженеры Intel до того, как она попала в очередную версию OpenSSL.)