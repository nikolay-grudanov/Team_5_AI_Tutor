---
source_image: page_292.png
page_number: 292
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 37.10
tokens: 7772
characters: 2662
timestamp: 2025-12-24T09:18:34.917277
finish_reason: stop
---

приложении (например, Gmail), включив имя пользователя и пароль в запись, TLS, следующую за квитированием. Если клиент уже установил сеанс с удаленной службой, то может аутентифицироваться, отправив безопасный кук, который разрешено посылать только по TLS-соединению.

В некоторых случаях клиенты могут аутентифицироваться с помощью основанного на сертификатах механизма, аналогичного тому, что использует сервер: клиент отправляет серверу клиентский сертификат, а сервер проверяет его, перед тем как что-то разрешить клиенту. Однако клиентские сертификаты используются редко, потому что они усложняют работу и клиентов, и сервера (стороны, выпускающей сертификаты): клиенты должны выполнить сложную последовательность операций, чтобы включить сертификат в свою систему и защитить его закрытый ключ, а выпускающая сторона должна среди прочего гарантировать, что сертификат получили только авторизованные клиенты.

Секретность прошлого

Напомним, что протокол совместной выработки ключа обеспечивает секретность прошлого, если предыдущие сеансы остаются нескомпрометированными в случае компрометации текущего сеанса. В модели утечки данных компрометируются только временные секреты, а в модели вскрытия — долговременные секреты.

К счастью, секретность прошлого в TLS 1.3 не боится ни утечки, ни вскрытия. В случае модели утечки данных противник добывает временные секреты, например сеансовые ключи или закрытые ключи Диффи–Хеллмана для конкретного сеанса (значения c, s, secret и keys на рис. 13.1). Однако эти значения он может использовать только для дешифрирования данных в текущем сеансе, но не в предыдущих, потому что там действовали другие значения с и s (а значит, и другие ключи).

В модели вскрытия противник получает также долговременные секреты (закрытый ключ, соответствующий открытому ключу в сертификате). Однако это помогает при дешифрировании предыдущих сеансов ничуть не больше, чем знание временных секретов, потому что закрытый ключ применяется только для аутентификации сервера, так что безопасность прошлого снова устояла.

Но что может произойти на практике? Предположим, что противник скомпрометировал машину клиента и получил доступ ко всей ее памяти. Теперь противник может восстановить сеансовые ключи и секреты TLS для текущего сеанса из памяти. Но еще важнее другое — если предыдущие ключи все еще хранятся в памяти, то противник сможет найти и их тоже и использовать для дешифрирования предыдущих сеансов, обойдя тем самым теоретическую безопасность прошлого. Поэтому, чтобы реализация TLS действительно гарантировала безопасность прошлого, необходимо стирать ключи в памяти после окончания использования, обычно их просто обнуляют.