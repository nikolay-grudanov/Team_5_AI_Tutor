---
source_image: page_084.png
page_number: 84
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 34.05
tokens: 7695
characters: 2233
timestamp: 2025-12-24T09:12:08.130577
finish_reason: stop
---

В этой главе мы дадим обзор базовых алгоритмов, лежащих в основе блочных шифров, обсудим их режимы работы и объясним, как они сочетаются. Также мы рассмотрим, как работает шифр AES, и завершим главу описанием классической атаки из 1970-х годов — встреча посередине, а также любимой техники атак из 2000-х годов — оракулы дополнения.

Что такое блочный шифр?

Блочный шифр состоит из алгоритма шифрования и алгоритма дешифрирования.

• Алгоритм шифрования (E) принимает ключ K и блок открытого текста P и порождает блок шифртекста C. Операция шифрования записывается в виде C = E(K, P).
• Алгоритм дешифрирования (D) является обратным к алгоритму шифрования, т. е. восстанавливает исходный открытый текст P. Эта операция записывается в виде P = D(K, C).

Поскольку алгоритмы шифрования и дешифрирования взаимно обратны, обычно они включают похожие операции.

Цели безопасности

Если вы внимательно следили за обсуждением шифрования, случайности и неразличимости в предыдущих главах, то определение безопасного блочного шифра не вызовет удивления. Как и раньше, мы определим безопасность как подобие случайности.

Чтобы блочный шифр был безопасным, он должен являться псевдослучайной перестановкой (pseudorandom permutation — PRP), т. е. при условии, что ключ хранится в секрете, противник не должен иметь возможности вычислить результат применения блочного шифра к любому входу. Иными словами, коль скоро с точки зрения противника K неизвестен и случаен, он ничего не может сказать о том, как выглядит E(K, P) для любого заданного P.

Вообще, противник не должен иметь возможности выявить хоть какую-нибудь закономерность в связи входных и выходных данных блочного шифра. Иначе говоря, невозможно отличить блочный шифр от истинно случайной перестановки, имея доступ типа черного ящика к функциям шифрования и дешифрирования для фиксированного, но неизвестного ключа. И кроме того, противник не должен иметь возможность определить секретный ключ безопасного блочного шифра, в противном случае он мог бы воспользоваться этим ключом, чтобы отличить блочный шифр от случайной перестановки. Конечно, отсюда также следует, что противник не может предсказать открытый текст, соответствующий заданному шифртексту, порожденному блочным шифром.