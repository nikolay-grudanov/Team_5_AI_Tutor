---
source_image: page_063.png
page_number: 63
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 23.98
tokens: 7651
characters: 2127
timestamp: 2025-12-24T09:11:26.995892
finish_reason: stop
---

ми, а в некоторых случаях ключи были очень похожи (точнее, ключи RSA с общими простыми множителями): короче говоря, пары чисел \( n = pq \) и \( n' = p'q' \), где \( p = p' \), тогда как в идеале все \( p \) и \( q \) должны быть различны.

Изучение проблемы показало, что многие устройства генерируют свои открытые ключи при первой начальной загрузке, когда еще не набралось достаточно энтропии, хотя во всех остальных отношениях используемые PRNG (как правило, /dev/urandom) не вызывали нареканий. В итоге PRNG в различных системах порождали одинаковые случайные биты, поскольку базовый источник энтропии был один и тот же (например, зашитое в код начальное значение).

Не вдаваясь в детали, можно сказать, что идентичные ключи появляются, потому что схема генерации ключей устроена, как показано в следующем псевдокоде:

prng.seed(seed)
p = prng.generate_random_prime()
q = prng.generate_random_prime()
n = p*q

Если две системы выполняют этот код с одинаковым значением seed, то они вычислят одинаковые значения \( p, q \) и \( n \).

Общие простые множители в разных ключах появляются, когда в схему генерации ключей включается дополнительная энтропия, как в псевдокоде ниже:

prng.seed(seed)
p = prng.generate_random_prime()
prng.add_entropy()
q = prng.generate_random_prime()
n = p*q

Если две системы выполняют этот код с одинаковым значением seed, то они вычислят одинаковые значения \( p \), но благодаря включению энтропии в строке prng.add_entropy() значения \( q \) будут различны.

Проблема в том, что, зная \( n = pq \) и \( n' = p'q' \), можно без труда восстановить \( p \), вычислив наибольший общий делитель (НОД, англ. GCD) \( n \) и \( n' \). Детали см. в статье Heninger, Durumeric, Wustrow, and Halderman «Mining Your Ps and Qs», доступной на сайте https://factorable.net/.

Криптографически нестойкие PRNG

Выше мы обсудили различие между криптографически стойкими и нестойкими PRNG и объяснили, почему последние никогда не следует использовать в криптографических приложениях. Увы, многие системы пренебрегают этим предостережением, поэтому я чувствую себя обязанным привести хотя бы один такой пример.