---
source_image: page_213.png
page_number: 213
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 41.61
tokens: 7944
characters: 2910
timestamp: 2025-12-24T09:16:11.975673
finish_reason: stop
---

Задача факторизации

Задача факторизации заключается в нахождении простых чисел \( p \) и \( q \) по заданному большому числу \( N = p \times q \). Широко применяемые алгоритмы RSA основаны на том факте, что факторизация числа — трудная задача. На самом деле именно трудность задачи факторизации и делает схемы шифрования и цифровой подписи RSA безопасными. Но прежде чем показать, как в RSA используется задача факторизации (этому посвящена глава 10), я хочу убедить вас, что эта задача действительно трудная, хотя, вероятно, и не NP-полная.

Сначала немного математики для младших школьников. Простым называется число, которое делится только на себя и на 1. Например, числа 3, 7, 11 простые, а числа 4 = 2 × 2, 6 = 2 × 3 и 12 = 2 × 2 × 3 непростые. Основная теорема арифметики утверждает, что любое целое число можно единственным образом представить в виде произведения простых чисел; это представление называется разложением числа на множители, или факторизацией. Например, факторизация 123 456 имеет вид \( 2^6 \times 3 \times 643 \), факторизация 1 234 567 — 127 × 9721 и т. д. Для любого целого числа факторизация единственна, т. е. его можно записать в виде произведения простых чисел только одним способом. Но откуда нам знать, что данная факторизация состоит только из простых чисел? Иначе говоря, откуда мы знаем, что данное число простое? Ответ дают алгоритмы проверки на простоту, имеющие полиномиальное время работы. Однако переход от числа к его простым множителям — совсем другое дело.

Факторизация больших чисел на практике

Итак, как перейти от числа \( N \) к его факторизации, т. е. к разложению на простые множители? Самый простой способ — пробовать все числа, меньше \( N \), пока не найдется число \( x \), на которое \( N \) делится нацело. Затем попробовать следующее число \( x + 1 \) и т. д. В итоге получим список множителей \( N \). Какова временная сложность такого алгоритма? Для начала вспомним, что сложность выражается в виде функции от длины входных данных. Длина числа \( N \) в битах равна \( n = \log_2 N \). Согласно определению логарифма, отсюда следует, что \( N = 2^n \). Поскольку все числа, меньше \( N/2 \), могут считаться возможными множителями \( N \), нам придется перепробовать приблизительно \( N/2 = 2^n/2 \) значений. Следовательно, сложность нашего наивного алгоритма факторизации составляет \( O(2^n) \), поскольку коэффициент 1/2 в нотации \( O() \) можно игнорировать.

Разумеется, есть много чисел, которые легко факторизовать, определив сначала небольшие простые множители (2, 3, 5 и т. д.), а затем итеративно факторизуя остальные непростые множители. Но в данном случае нас интересуют числа вида \( N = p \times q \), где \( p \) и \( q \) велики.

Поступим немного умнее. Нам не нужно проверять все числа, меньше \( N/2 \), а только те из них, которые являются простыми. И при этом можно проверять только числа, меньше квадратного корня из \( N \).