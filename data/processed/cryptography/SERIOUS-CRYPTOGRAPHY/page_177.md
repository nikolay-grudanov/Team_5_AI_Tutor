---
source_image: page_177.png
page_number: 177
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 39.90
tokens: 7845
characters: 2475
timestamp: 2025-12-24T09:15:05.629716
finish_reason: stop
---

так чтобы сделать все блоки 129-битовыми. (Если последний блок короче 16 байт, то он дополняется одним единичным битом и последующими нулевыми битами перед добавлением последнего 129-го бита.) Затем Poly1305 вычисляет следующий полином:

\[
\text{Poly1305}(K_1, M) = M_1 K_1^n + M_2 K_1^n + ... + M_n K_1 \bmod 2^{130} - 5.
\]

Результатом вычисления является целое число длиной не более 129 бит. После прибавления 128-битового значения AES($K_2$, $N$) результат по модулю $2^{128}$ и принимается в качестве 128-битовой имитовставки.

**Примечание** AES представляет собой не PRF, а псевдослучайную перестановку (PRP). Однако здесь это не важно, потому что построение Вегмана–Картера работает с PRP точно так же, как с PRF, поскольку если задана функция, которая является либо PRF, либо PRP, трудно определить, что именно она собой представляет, глядя только на ее выходные значения.

Анализ безопасности Poly1305-AES (см. статью «The Poly1305-AES Message-Authentication Code» по адресу http://cr.yp.to/mac/poly1305-20050329.pdf) показывает, что уровень безопасности Poly1305-AES равен 128 бит, при условии что AES — безопасный блочный шифр и, конечно, что все реализовано корректно, но последнее относится к любому криптографическому алгоритму.

Универсальную функцию хеширования Poly1305 можно комбинировать с другими алгоритмами, а не только с AES. Например, Poly1305 использовалась с потоковым шифром ChaCha (см. RFC 7539, «Cha-Cha20 and Poly1305 for IETF Protocols»). Без сомнения, Poly1305 будет и дальше использоваться, когда необходима быстрая МАС.

*SipHash*

Алгоритм Poly1305 быстрый и безопасный, но у него есть несколько недостатков. Во-первых, полиномиальное вычисление трудно реализовать эффективно, особенно если не владеешь соответствующим математическим аппаратом (примеры см. по адресу https://github.com/floodyberry/poly1305-donna/). Во-вторых, он безопасен только для одного сообщения, если не использовать построение Вегмана–Картера. А если использовать, то необходимо одноразовое число, и алгоритм перестает быть безопасным, если это число применяется несколько раз. Наконец, Poly1305 оптимизирован для длинных сообщений, а при обработке коротких (скажем, меньше 128 байт) становится стрельбой из пушек по воробьям. В таких случаях решением является алгоритм SipHash.

Я спроектировал SipHash в 2012 году совместно с Дэном Бернштейном, первоначально ставилась цель решить некриптографическую проблему: атаку на хеш-таблицы, вызывающую отказ от обслужи-