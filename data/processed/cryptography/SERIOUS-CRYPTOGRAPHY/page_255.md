---
source_image: page_255.png
page_number: 255
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 44.58
tokens: 7989
characters: 3042
timestamp: 2025-12-24T09:17:31.779961
finish_reason: stop
---

Защита от подслушивания

Протокол DH с аутентификацией защищен от подслушивания, потому что противник не может добыть ни единого бита информации о разделяемом секрете \( g^{ab} \), не зная показателей степени. DH с аутентификацией обеспечивает также секретность прошлого: даже если противник скомпрометирует в какой-то момент любую сторону, как в модели атаки со вскрытием, он узнает закрытые ключи подписания, но не будет знать ни один из эфемерных показателей степени DH, а значит, не сможет узнать ни один из прошлых разделяемых секретов.

DH с аутентификацией также не дает ни одной из сторон управлять значениями разделяемого секрета. Алиса не может изготовить специальное значение \( a \), чтобы предсказать значение \( g^{ab} \), потому что не контролирует \( b \), влияющее на \( g^{ab} \) в той же мере, что и \( a \). (Есть одно исключение: если бы Алиса выбрала \( a = 0 \), то \( g^{ab} \) было бы равно 1 при любом \( b \). Но 0 не является допустимым значением, и протокол должен его отвергать.)

Тем не менее DH с аутентификацией не является безопасным относительно всех типов атак. Действительно, Ева может запоминать предыдущие значения \( A \) и \( sig_A \) и впоследствии воспроизводить их Бобу, чтобы притвориться Алисой. Тогда Боб поверит, что разделяет секрет с Алисой, хотя на самом деле это не так, — и это несмотря на то, что Ева не смогла узнать секрет. На практике этот риск можно устранить, добавив процедуру подтверждения ключа, в ходе которой Алиса и Боб доказывают друг другу, что владеют общим секретом. Например, Алиса и Боб могут подтвердить ключ, отправив соответственно \( \text{Hash}(pub_A \| pub_B, g^{ab}) \) и \( \text{Hash}(pub_B \| pub_A, g^{ab}) \), где \( \text{Hash} \) — некоторая хеш-функция. Когда Боб получит \( \text{Hash}(pub_A \| pub_B, g^{ab}) \), а Алиса — \( \text{Hash}(pub_B \| pub_A, g^{ab}) \), обе стороны смогут проверить правильность хеш-значений, используя \( pub_A, pub_B \) и \( g_{ab} \). Благодаря разному порядку конкатенации ключей (\( pub_A \| pub_B \) и \( pub_B \| pub_A \)) гарантируется, что Алиса и Боб отправят разные значения и, значит, противник не сможет притвориться Алисой, скопировав хеш-значение Боба.

Защита от утечки данных

Уязвимость DH с аутентификацией к утечке данных — более серьезная проблема. В атаке этого типа противник узнает значение эфемерных секретов с коротким временем жизни (а именно показателей степени \( a \) и \( b \)) и использует эту информацию для подмены одной из сторон. Если Ева сможет узнать значение показателя степени \( a \) вместе с соответствующими значениями \( A \) и \( sig_A \), отправленными Бобу, то она сможет инициировать новое выполнение протокола и притвориться Алисой, как показано на рис. 11.5.

В этом сценарии Ева узнает значение \( a \) и воспроизводит соответствующее \( A \) и подпись \( sig_A \), притворяясь Алисой. Боб верифицирует подпись, вычисляет \( g^{ab} \) по \( A \) и отправляет \( B \) и \( sig_B \), которые Ева использует для вычисления \( g^{ab} \), пользуясь все тем же украденным \( a \).