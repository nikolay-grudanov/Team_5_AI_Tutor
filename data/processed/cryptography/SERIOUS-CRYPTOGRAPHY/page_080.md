---
source_image: page_080.png
page_number: 80
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 27.77
tokens: 7652
characters: 2202
timestamp: 2025-12-24T09:12:01.274106
finish_reason: stop
---

пользуемый при шифровании (напомним, что RSA зашифровывает открытый текст, вычисляя \( C = P^e \bmod n \)).

Защита ключей

Получив секретный ключ, вы должны хранить его в тайне, но так чтобы он был доступен в любой момент, когда понадобится. Есть три способа решения этой проблемы.

Обертывание ключа (шифрование ключа другим ключом)
Проблема в том, что второй ключ должен быть доступен, когда понадобится дешифрировать защищенный ключ. На практике второй ключ часто генерируется из пароля, указанного пользователем в момент, когда ему нужно использовать защищенный ключ. Именно так закрытые ключи обычно защищаются в протоколе Secure Shell (SSH).

Динамическое генерирование из пароля
В этом случае никакой зашифрованный файл хранить не нужно, потому что ключ генерируется непосредственно из пароля. Этот метод используется в современных системах типа miniLock. Несмотря на сравнительную простоту, он менее распространен, чем обертывание ключа, т. к. уязвим к слабым паролям. Предположим, например, что противник перехватил какое-то зашифрованное сообщение; если использовалось обертывание ключа, то противнику нужно сначала получить файл с защищенным ключом, который обычно хранится в локальной файловой системе пользователя, так что добраться до него нелегко. Но если применялось динамическое генерирование, то противник может подобрать правильный пароль из числа кандидатов и попытаться таким образом дешифрировать сообщение. Если пароль слабый, то ключ будет скомпрометирован.

Хранение ключа в аппаратном устройстве (на смарт-карте или на электронном USB-ключе)
При таком подходе ключ хранится в защищенной памяти и останется в секрете, даже если компьютер будет скомпрометирован. Это самый безопасный способ хранения ключа, но и самый дорогой и неудобный, потому что аппаратное устройство нужно носить с собой, рискуя потерять. Смарт-карты и электронные ключи обычно не требуют ввода пароля, чтобы извлечь ключ из памяти.

Примечание Какой бы метод вы ни использовали, следите за тем, чтобы не перепутать открытый и закрытый ключи при обмене ключами и случайно не опубликовать закрытый ключ, отправив его по электронной почте или включив в исходный код (я сам находил закрытые ключи на GitHub).