---
source_image: page_226.png
page_number: 226
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 38.98
tokens: 7881
characters: 2569
timestamp: 2025-12-24T09:16:34.155407
finish_reason: stop
---

генерируется открытый показатель степени e ⑤ — случайное простое число, меньшее phi; его простота гарантирует, что у e будет обратный элемент по модулю phi. После этого с помощью функции xgcd() генерируется соответствующий закрытый показатель степени d ⑥. Эта функция, пользуясь обобщенным алгоритмом Евклида, вычисляет по данным числам a и b такие два числа s и t, что as + bt = GCD(a, b) (GCD — наибольший общий делитель, НОД). Наконец, мы проверяем, что ed mod φ(n) = 1 ⑦, чтобы удостовериться, что d позволит правильно обратить перестановку RSA.

Теперь можно применить перестановку с потайным входом, как показано в листинге 10.2.

Листинг 10.2. Вычисление перестановки с потайным входом в обе стороны

<table>
  <tr>
    <th>1</th>
    <td>sage: x = 1234567</td>
  </tr>
  <tr>
    <th>2</th>
    <td>sage: y = power_mod(x, e, n); y<br>19048323055755904</td>
  </tr>
  <tr>
    <th>3</th>
    <td>sage: power_mod(y, d, n)<br>1234567</td>
  </tr>
</table>

Мы присваиваем x целое значение 1234567 ①, а затем вызываем функцию power_mod(x, e, n) возведения в степень по модулю n для вычисления y ②. Вычислив y = x^e \bmod n, мы вычисляем y^d \bmod n ③, где d — потайной ход, и таким образом возвращаемся к исходному x.

Но насколько трудно найти x, не зная потайного входа d? Противник, умеющий факторизовать большие числа, может взломать RSA, найдя p и q, а затем φ(n), после чего сможет вычислить d по e. Но это не единственная опасность. Другой риск RSA вытекает из умения противника вычислять x по x^e \bmod n, т. е. корни степени e по модулю n, не факторизуя при этом n. Оба риска кажутся тесно связанными, хотя мы точно не знаем, эквивалентны ли они.

В предположении, что факторизация — действительно трудная задача, а вычислить корни степени e примерно столь же трудно, безопасность RSA зависит от трех факторов: величины n, выбора p и q и способа использования потайного входа. Если n слишком мало, то его можно разложить на множители за разумное время и тем самым узнать закрытый ключ. Для безопасности длина n должна быть не менее 2048 бит (при этом уровень безопасности составляет приблизительно 90 бит, так что для вскрытия требуется порядка 2^{90} операций), а лучше 4096 бит (уровень безопасности приблизительно 128 бит). Значения p и q должны быть не связанными между собой простыми числами примерно одинакового размера. Если они слишком малы или слишком близки друг к другу, то определить их по n будет проще. Наконец, перестановка с потайным входом не должна использоваться непосредственно для шифрования или подписания — об этом мы поговорим ниже.