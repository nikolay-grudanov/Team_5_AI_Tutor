---
source_image: page_199.png
page_number: 199
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 27.52
tokens: 7705
characters: 2141
timestamp: 2025-12-24T09:15:31.219348
finish_reason: stop
---

талях и получите небезопасный шифр. Почитайте написанные опытными криптографами спецификации таких алгоритмов, как Keccak (производный от Кессак) и NORX (спроектированный Филиппом Йовановичем, Сэмюэлем Нивсом и мной), и вы поймете, что шифры на основе перестановок гораздо сложнее, чем может показаться на первый взгляд.

Какие возможны проблемы

Поверхность атаки на шифры с аутентификацией больше, чем на хеш-функции или блочные шифры, потому что их задача — обеспечить конфиденциальность и подлинность сообщения. Они принимают различные входные значения и должны оставаться безопасными вне зависимости от входов, будь то только ассоциированные данные и никаких зашифрованных, очень большие открытые тексты или ключи разного размера. Они также должны сохранять безопасность при всех значениях одноразовых чисел и противостоять атакам со сбором многочисленных пар сообщение—жетон, в том числе (до некоторой степени) при случайном повторении одноразовых чисел.

Таким требованиям нелегко удовлетворить, и, как мы увидим далее, даже у шифра AES-GCM есть несколько недостатков.

AES-GCM и слабые хеш-ключи

Одна из слабостей AES-GCM связана с его алгоритмом аутентификации GHASH: некоторые значения хеш-ключа \( H \) существенно упрощают атаки против механизма аутентификации GCM. Точнее, если значение \( H \) принадлежит строго математически определенным подгруппам множества всех 128-битовых строк, то противник может угадать правильный аутентификационный жетон для некоторого сообщения, просто перетасовав блоки предыдущего сообщения.

Чтобы лучше разобраться в этом, посмотрим, как работает GHASH.

Внутренний механизм GHASH

На рис. 8.2 мы видели, что GHASH начинает работу со 128-битового значения \( H \), которое первоначально равно AES(\( K, 0 \)), а затем итеративно вычисляет выражение

\[
X_i = (X_{i-1} \oplus C_i) \otimes H,
\]

начиная с \( X_0 = 0 \) и обрабатывая блоки шифртекста \( C_1, C_2, ... \). Последнее значение \( X_i \) возвращается для вычисления окончательного жетона.

Теперь предположим для простоты, что все значения \( C_i \) равны 1, так что для любого \( i \) имеем:

\[
C_i \otimes H = 1 \otimes H = H.
\]