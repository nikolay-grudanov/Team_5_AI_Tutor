---
source_image: page_172.png
page_number: 172
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 44.16
tokens: 7944
characters: 2614
timestamp: 2025-12-24T09:15:01.656419
finish_reason: stop
---

Создание функций хеширования на основе блочных шифров: СМАС

Напомним (см. главу 6), что функции сжатия во многих хеш-функциях построены на основе блочных шифров. Например, псевдослучайная функция HMAC-SHA-256 представляет собой последовательность обращений к функции сжатия SHA-256, которая сама является блочным шифром с повторяющейся последовательностью раундов. Иными словами, HMAC-SHA-256 — это блочный шифр внутри хеш-функции, применяемой в построении HMAC. Так почему бы не использовать сам блочный шифр вместо такой многоуровневой конструкции?

СМАС (cipher-based MAC — имитовставка на основе шифра) как раз и является такого рода построением: оно создает MAC, пользуясь только блочным шифром, например AES. Хотя СМАС не столь популярна, как HMAC, она встречается во многих системах, включая протокол обмена ключей в интернете (Internet Key Exchange — IKE), являющийся частью набора протоколов IPSec. Например, IKE генерирует материал для ключей, применяя построение AES-CMACPRF-128 в качестве базового алгоритма (или СМАС на основе AES со 128-битовым выходом). Построение СМАС специфицировано в RFC 4493.

Взлом CBC-MAC

СМАС была спроектирована в 2005 году как усовершенствованная версия CBC-MAC, более простой имитовставки на основе блочного шифра, работающего в режиме сцепления блоков (CBC) (см. раздел «Режимы работы» главы 4).

CBC-MAC, предшественница СМАС, устроена просто: чтобы вычислить жетон сообщения M при заданном блочном шифре E, следует зашифровать M в режиме CBC с нулевым начальным значением (IV) и отбросить все, кроме последнего блока шифртекста. То есть мы вычисляем C_1 = E(K, M_1), C_2 = E(K, M_2 \oplus C_1), C_3 = E(K, M_3 \oplus C_2) и т. д. для каждого блока M и оставляем только последнее значение C_i, которое и является CBC-MAC-жетоном для M. Легко вычислить — и легко атаковать.

Чтобы понять, почему CBC-MAC небезопасен, рассмотрим CBC-MAC-жетон T_1 = E(K, M_1) одноблочного сообщения M_1 и жетон T_2 = E(K, M_2) другого одноблочного сообщения M_2. Зная обе пары (M_1, T_1) и (M_2, T_2), мы можем заключить, что T_2 является также жетоном двухблочного сообщения M_1 \| (M_2 \oplus T_1). Действительно, если применить CBC-MAC к M_1 \| (M_2 \oplus T_1) и вычислить C_1 = E(K, M_1) = T_1, а затем C_2 = E(K, (M_2 \oplus T_1) \oplus T_1) = E(K, M_2) = T_2, то можно создать третью пару сообщение–жетон из двух таких пар, не зная ключа. То есть мы можем подделать CBC-MAC-жетоны, а следовательно, нарушить безопасность CBC-MAC.

Исправление CBC-MAC

СМАС исправляет CBC-MAC, поскольку обрабатывает последний блок, используя не тот ключ, что при обработке предшествующих блоков.