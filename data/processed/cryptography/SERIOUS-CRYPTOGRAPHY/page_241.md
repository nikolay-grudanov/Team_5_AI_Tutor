---
source_image: page_241.png
page_number: 241
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 27.97
tokens: 7621
characters: 1518
timestamp: 2025-12-24T09:16:50.656148
finish_reason: stop
---

Листинг 10.7. Python-программа, вычисляющая простые множители p и q по закрытому показателю степени d

from math import gcd

n = 36567232109354321
e = 13771927877214701
d = 15417970063428857

① kphi = d*e - 1
    t = kphi

② while t % 2 == 0:
        t = divmod(t, 2)[0]

③ a = 2
    while a < 100:
        ④ k = t
            while k < kphi:
                x = pow(a, k, n)
                ⑤ if x != 1 and x != (n - 1) and pow(x, 2, n) == 1:
                    ⑥ p = gcd(x - 1, n)
                        break
                    k = k*2
                a = a + 2

q = n//p
⑦ assert (p*q) == n
print('p = ', p)
print('q = ', q)

Эта программа находит \( k\varphi(n) \) по \( e \) и \( d \) ①, отыскав число \( t \) такое, что \( k\varphi(n) = 2^s t \) для некоторого \( s \) ②. Затем она ищет \( a \) и \( k \) такие, что \( (a^k)^2 = 1 \bmod n \) ③, используя \( t \) как начальное значение \( k \) ④. Как только это условие будет выполнено ⑤, мы нашли решение. Затем программа находит множитель \( p \) ⑥ и проверяет ⑦, что \( pq \) равно \( n \). Наконец, печатаются найденные \( p \) и \( q \):

p = 2046223079
q = 17870599

Программа правильно нашла оба множителя.

Для дополнительного чтения

RSA заслуживает отдельной книги. Я вынужден был опустить много важных и интересных вещей, например атаку Блейхенбахера с оракулом дополнения на предшественника OAEP (стандарт PKCS#1 v1.5), по духу напоминающую атаку с оракулом дополнения на блочные шифры (см. главу 4). Существует также атака Винера на RSA с малыми