---
source_image: page_169.png
page_number: 169
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 39.42
tokens: 7894
characters: 2716
timestamp: 2025-12-24T09:14:49.851205
finish_reason: stop
---

Hash() будет обрабатывать значение \( K \| M = 123abcdef00 \). Если же \( K \) — 16-битовая строка 123a, а \( M \) равно bcdef000, то Hash() также будет обрабатывать \( K \| M = 123abcdef00 \). Следовательно, результат построения секретного префикса Hash(\( K \| M \)) будет одинаков для обоих ключей.

Эта проблема не зависит от хеш-функции, а для ее исправления достаточно хешировать длину ключа вместе с ключом и сообщением, например закодировав длину ключа в битах 16-битовым целым числом \( L \) и вычислив хеш Hash(\( L \| K \| M \)). Но делать это необязательно. Современные хеш-функции, в частности BLAKE2 и SHA-3, включают режим, который обходит эти подводные камни и дает безопасную PRF и безопасную MAC.

Построение секретного суффикса

Вместо того чтобы помещать ключ перед сообщением, а затем хешировать результат, как при построении секретного префикса, мы можем поместить его после. Именно так работает процедура построения секретного суффикса: строит PRF в виде Hash(\( M \| K \)).

Дописывание ключа в конец меняет всё. Прежде всего атака удлинением сообщения, работающая против построения MAC с секретным префиксом, бессильна против секретного суффикса. Применив удлинение к MAC с секретным суффиксом, мы получим Hash(\( M_1 \| K \| M_2 \)) по Hash(\( M_1 \| K \)), но такая атака ничего не дает, потому что Hash(\( M_1 \| K \| M_2 \)) не является действительной MAC с секретным суффиксом — ключ должен находиться в конце.

Однако построение с секретным суффиксом уязвимо для атаки другого типа. Предположим, что имеется коллизия Hash(\( M_1 \)) = Hash(\( M_2 \)), где \( M_1 \) и \( M_2 \) — разные сообщения, возможно, разной длины. В случае хеш-функции типа SHA-256 отсюда следует, что Hash(\( M_1 \| K \)) и Hash(\( M_2 \| K \)) тоже совпадают, потому что внутри ключ \( K \) будет обрабатываться на основе ранее хешированных данных, а именно Hash(\( M_1 \)) и равного ему Hash(\( M_2 \)). Поэтому мы получим одинаковое хеш-значение вне зависимости от того, находится ключ \( K \) после \( M_1 \) или после \( M_2 \), и значение самого ключа \( K \) при этом не играет роли.

Для эксплуатации этого свойства противник должен:

1) найти два сообщения, \( M_1 \) и \( M_2 \), образующих коллизию;
2) запросить MAC-жетон Hash(\( M_1 \| K \));
3) догадаться, что Hash(\( M_2 \| K \)) точно такой же, и тем самым подделать действительный жетон и нарушить безопасность MAC.

Построение HMAC

Построение имитовставки на основе функции хеширования (hash-based MAC — HMAC) позволяет получить MAC по хеш-функции, что более безопасно, чем секретный префикс или суффикс. HMAC является безопасной PRF при условии, что хеш-функция стойка к коллизиям, но даже если это не так, HMAC все же дает безопасную PRF,