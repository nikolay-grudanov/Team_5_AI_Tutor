---
source_image: page_197.png
page_number: 197
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 43.42
tokens: 7909
characters: 2754
timestamp: 2025-12-24T09:15:41.987254
finish_reason: stop
---

шифра с аутентификацией. Именно: следует вычислить жетон \( T = \operatorname{PRF}(K_1, N \| P) \), а затем шифртекст \( C = \mathbf{E}(K_2, T, P) \), где \( T \) играет роль одноразового числа для \( \mathbf{E} \). Таким образом, SIV нуждается в двух ключах (\( K_1 \) и \( K_2 \)) и одноразовом числе (\( N \)).

Главная проблема SIV — то, что он не допускает потоковой обработки: после вычисления \( T \) необходимо хранить весь открытый текст \( P \) в памяти. Иными словами, чтобы зашифровать открытый текст размером 100 ГБ с помощью SIV, нужно сначала сохранить все 100 ГБ, чтобы функция шифрования SIV могла их прочитать.

В документе RFC 5297, основанном на статье Rogaway and Shrimpton «Deterministic Authenticated-Encryption» 2006 года, сказано, что в SIV используется CMAC-AES (построение MAC с помощью AES) в качестве PRF и AES-CTR в качестве шифра. В 2015 году была предложена более эффективная версия SIV, GCM-SIV, в которой быстрая хеш-функция GHASH из GCM комбинируется с режимом SIV, в результате чего получается почти такой же быстрый шифр, как GCM. Но, как и оригинальный SIV, версия GCM-SIV не допускает потоковой обработки. (Дополнительные сведения см. по адресу https://eprint.iacr.org/2015/102/.)

**AEAD на основе перестановки**

Теперь поговорим о совершенно другом подходе к построению шифра с аутентификацией: вместо нового режима работы блочного шифра, например AES, мы рассмотрим шифр на основе перестановки. Перестановка — это просто обратимое преобразование входа в выход такого же размера, для которого не нужен ключ; проще не придумаешь. И вдобавок получающийся AEAD быстрый, доказуемо безопасный и более стойкий к повторному использованию одноразового числа, чем GCM и OCB.

На рис. 8.4 показано, как работает AEAD на основе перестановки: отправляясь от фиксированного начального состояния \( H_0 \), мы применяем XOR к конкатенации ключа \( K \) с одноразовым числом \( N \) и внутреннему состоянию. В результате получается новое внутреннее состояние того же размера, что первоначальное. Затем новое состояние подвергается перестановке \( \mathbf{P} \). Теперь первый блок открытого текста \( P_1 \) объединяется операцией XOR с текущим состоянием, и результат принимается в качестве первого блока шифртекста. Предполагается, что размер \( P_1 \) и \( C_1 \) одинаков, но меньше размера состояния.

Чтобы зашифровать второй блок, мы применяем к состоянию перестановку \( \mathbf{P} \) и выполняем XOR следующего блока простого текста \( P_2 \) с текущим состоянием — результат и будет значением \( C_2 \). Эта процедура повторяется для всех блоков открытого текста, а после последнего применения \( \mathbf{P} \) биты внутреннего состояния становятся аутентификационным жетоном \( T \), как показано справа на рис. 8.4.