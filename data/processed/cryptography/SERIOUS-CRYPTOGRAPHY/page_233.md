---
source_image: page_233.png
page_number: 233
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 29.75
tokens: 7666
characters: 2294
timestamp: 2025-12-24T09:16:35.966235
finish_reason: stop
---

с Hash(M). Скучно как просто, детерминировано, но при всем при том безопасно. Так зачем же нужна сложность PSS?

Основная причина — в том, что стандарт PSS был опубликован после FDH, в 1996 году, и для него имеется доказательство безопасности, которое вселяет больше уверенности, чем FDH. Точнее, это доказательство дает чуть более сильные гарантии безопасности, чем доказательство для FDH, чему немало способствует использование случайности.

Наличие более сильных теоретических гарантий — главная причина, по которой криптографы предпочитают PSS, а не FDH, но большинство современных приложений, использующих PSS, могли бы перейти на FDH практически без потери безопасности. Однако в некоторых контекстах существует веская причина использовать именно PSS, потому что случайность защищает от некоторых атак на реализацию, например атак на недочеты, которые мы обсудим в разделе «Какие возможны проблемы».

Реализации RSA

Я искренне надеюсь, что вам никогда не придется реализовывать RSA с нуля. Если вас попросят это сделать, бегите как можно быстрее и задайтесь вопросом, не безумен ли человек, обратившийся с такой просьбой. Криптографам и инженерам потребовалось несколько десятилетий, чтобы разработать реализации RSA, которые были бы быстрыми, достаточно безопасными и, хочется надеяться, не содержали деструктивных ошибок. Поэтому заново изобретать RSA точно не нужно. Даже при наличии всей документации решение этой грандиозной задачи заняло бы несколько месяцев.

Обычно при реализации RSA используется библиотека или API, предлагающие все необходимые функции для выполнения операций RSA. Например, в пакете crypto для языка Go имеется следующая функция (https://www.golang.org/src/crypto/rsa/rsa.go):

func EncryptOAEP(hash hash.Hash, random io.Reader, pub *PublicKey, msg []byte, label []byte) (out []byte, err error)

Функция EncryptOAEP() принимает хеш-функцию, PRNG, открытый ключ, сообщение и метку (факультативный параметр OAEP) и возвращает подпись и код ошибки. Она вызывает encrypt() для вычисления функции RSA, передавая ей дополненные данные, как показано в листинге 10.3.

Листинг 10.3. Реализация базовой функции RSA-шифрования в криптографической библиотеке для языка Go

func encrypt(c *big.Int, pub *PublicKey, m *big.Int) *big.Int {
    e := big.NewInt(int64(pub.E))