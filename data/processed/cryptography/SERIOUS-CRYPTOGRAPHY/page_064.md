---
source_image: page_064.png
page_number: 64
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 24.80
tokens: 7631
characters: 2046
timestamp: 2025-12-24T09:11:30.478448
finish_reason: stop
---

Популярное приложение MediaWiki работает в Википедии и на многих других вики-сайтах. Случайность используется в нем для генерирования маркеров безопасности и временных паролей, которые, конечно же, должны быть непредсказуемы. К сожалению, в теперь уже устаревшей версии MediaWiki для этой цели использовался криптографически нестойкий PRNG, вихрь Мерсенна. Ниже приведен фрагмент уязвимого исходного кода MediaWiki. Взгляните на функцию, вызываемую для получения случайного бита, и прочитайте комментарии.

```
/**
 * Генерирует кажущийся случайным маркер hex-u для различных целей.
 * Могла бы быть сделана более криптографически стойкой, если кому-нибудь это надо.
 * @return string
 */
function generateToken( $salt = '' ) {
    $token = dechex(mt_rand()).dechex(mt_rand());
    return md5( $token . $salt );
}
```

Вы обратили внимание на вызов mt_rand()? Здесь mt означает Mersenne Twister (вихрь Мерсенна), криптографически нестойкий PRNG, обсуждавшийся ранее. В 2012 году исследователи показали, как можно эксплуатировать предсказуемость вихря Мерсенна, чтобы предсказать будущие маркеры и временные пароли, если известно два маркера безопасности. Приложение MediaWiki было исправлено, теперь в нем используется криптографически стойкий PRNG.

Дефектная выборка при стойком PRNG

Следующая ошибка показывает, что даже криптографически стойкий PRNG с достаточной энтропией может порождать смещённое распределение. Программа организации чатов Cryptocat проектировалась для безопасного общения. В ней использовалась функция, которая должна была создавать строку равномерно распределенных десятичных цифр, т. е. цифр от 0 до 9. Однако брать случайные байты по модулю 10 недостаточно для получения равномерного распределения, потому что при делении чисел от 0 до 255 на 10 количество различных остатков (чисел от 0 до 9) неодинаково.

Для решения этой проблемы авторы Cryptocat поступили следующим образом:

Cryptocat.random = function() {
    var x, o = '';
    while (o.length < 16) {
        x = state.getBytes(1);
        if (x[0] <= 250) {