---
source_image: page_228.png
page_number: 228
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 33.19
tokens: 7734
characters: 2198
timestamp: 2025-12-24T09:16:32.309915
finish_reason: stop
---

Encryption Padding – OAEP). Этот метод, обычно называемый RSA-OAEP, предполагает создание битовой строки такого же размера, как модуль, для чего сообщение дополняется случайными данными перед применением функции RSA.

![RSA-шифрование симметричного ключа K с использованием (n, e) в качестве открытого ключа](../images/ch10_01.png)

Рис. 10.1. RSA-шифрование симметричного ключа К с использованием (n, e) в качестве открытого ключа

**Примечание** OAEP именуется RSAES-OAEP в официальных документах, например в стандарте PKCS#1, выпущенном компанией RSA, и в специальной публикации NIST 800-56B. OAEP является усовершенствованием более раннего метода, который теперь называется PKCS#1 v1.5 и был одним из первых в серии стандартов криптографии с открытым ключом (PKCS), созданных RSA. Он заметно менее безопасен, чем OAEP, но до сих пор используется во многих системах.

Безопасность OAEP

В OAEP используется генератор псевдослучайных чисел (PRNG), гарантирующий неразличимость и неподатливость шифртекстов, что делает шифрование вероятностным. Доказано, что схема безопасна при условии, что безопасны функция RSA и PRNG и, хотя это менее важно, функции хеширования не слишком слабые. При использовании RSA-шифрования всегда следует применять режим OAEP.

Как работает шифрование в режиме OAEP

Чтобы применить RSA-шифрование в режиме OAEP, необходимо сообщение (обычно симметричный ключ, K), PRNG и две функции хеширования. Для создания шифртекста используется заданный модуль n длиной m байт (т. е. 8m бит, так что должно быть меньше n \(2^{8m}\)). Чтобы зашифровать K, формируется кодированное сообщение \(M = H||00 ... 00||01||K\), где H — h-байтовая константа, определяемая схемой OAEP, за которой следует необходимое количество байтов 00 и один байт 01. Сообщение M затем обрабатывается, как описано ниже и изображено на рис. 10.2.

Затем генерируется h-байтовая случайная строка R и выполняется замена \(M = M \oplus \text{Hash1}(R)\), где Hash1(R) имеет такую же длину, как M. Далее мы полагаем \(R = R \oplus \text{Hash2}(M)\), где Hash2(M) имеет такую же длину, как R. Теперь новые значения M и R применяются для формирования m-байтовой строки \(P = 00||M||R\) такой же длины, как модуль