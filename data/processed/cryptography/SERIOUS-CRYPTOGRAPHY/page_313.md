---
source_image: page_313.png
page_number: 313
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 36.21
tokens: 7944
characters: 2810
timestamp: 2025-12-24T09:19:11.067881
finish_reason: stop
---

Криптография на основе функций хеширования

В отличие от предыдущих схем, криптография на основе функций хеширования базируется на хорошо изученной безопасности криптографических хеш-функций, а не на трудности математических задач. Поскольку квантовые компьютеры не могут взломать хеш-функции, они не смогут взломать никакую схему, основанную на трудности нахождения коллизий, а именно это ключевая идея схем цифровой подписи на базе хеш-функций.

Криптографические схемы на основе функций хеширования довольно сложны, поэтому я остановлюсь только на самом простом из входящих в них строительных блоков: одноразовой подписи — приеме, открытом примерно в 1979 году и получившем название одноразовая подпись Винтерница (Winternitz one-time signature — WOTS) по имени автора. Здесь «одноразовая» означает, что закрытый ключ можно использовать для подписания только одного сообщения, иначе схема станет небезопасной. (WOTS можно сочетать с другими методами для подписания нескольких сообщений, как мы увидим в следующем разделе.)

Но сначала посмотрим, как работает WOTS. Пусть требуется подписать сообщение, рассматриваемое как число от 0 до \( w - 1 \), где \( w \) — параметр схемы. Закрытым ключом является случайная строка \( K \). Чтобы подписать сообщение \( M \), где \( 0 \leq M < w \), мы вычисляем \( \text{Hash}(\text{Hash}(...(\text{Hash}(K))) \), где хеш-функция \( \text{Hash} \) повторяется \( M \) раз. Обозначим это значение \( \text{Hash}^M(K) \). Открытым ключом является \( \text{Hash}^w(K) \), или результат \( w \) вложенных итераций \( \text{Hash} \), начиная с \( K \).

WOTS-подпись, \( S \), верифицируется путем проверки того, что \( \text{Hash}^{w-M}(S) \) равно открытому ключу \( \text{Hash}^w(K) \). Заметим, что \( S \) — это \( K \) после \( M \) применений \( \text{Hash} \), поэтому если еще \( w - M \) раз применить \( \text{Hash} \), то мы получим значение, равное \( K \), хешированному \( M + (w - M) = w \) раз, а это и есть открытый ключ.

Эта схема выглядит довольно непритязательно и имеет ряд существенных ограничений.

Подписи можно подделать

Зная \( \text{Hash}^M(K) \), подпись \( M \), можно вычислить \( \text{Hash}(\text{Hash}^M(K)) = \text{Hash}^{M+1}(K) \), т. е. правильную подпись сообщения \( M + 1 \). Эту проблему можно решить, если подписывать не только \( M \), но и \( w - M \), используя второй ключ.

Схема работает только для коротких сообщений

Если сообщения 8-битовые, то всего их существует \( 2^8 - 1 = 255 \), так что для создания подписи нужно будет вычислить \( \text{Hash} \) 255 раз. Для коротких сообщений это может работать, а для длинных — нет: например, подписание 128-битовых сообщений потребовало бы \( 2^{128} - 1 \) вычислений \( \text{Hash} \) и продолжалось бы вечно. Решение — разбивать длинные сообщения на несколько коротких.