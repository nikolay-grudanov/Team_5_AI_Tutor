---
source_image: page_148.png
page_number: 148
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 36.57
tokens: 7863
characters: 2491
timestamp: 2025-12-24T09:14:10.381237
finish_reason: stop
---

общение, содержащее один 512-битовый блок, который можно обрабатывать функцией сжатия SHA-256.

Гарантии безопасности

Построение Меркла–Дамгора по существу преобразует безопасную функцию сжатия, принимающую небольшие блоки фиксированной длины, в безопасную функцию хеширования, принимающую данные произвольной длины. Если функция сжатия стойкая к коллизиям и восстановлению прообраза, то надстроенная над ней функция хеширования тоже будет обладать этими свойствами. Это верно, потому что любую успешную атаку с восстановлением прообраза для хеш-функции М-Д можно было бы превратить в успешную атаку с восстановлением прообраза функции сжатия, как показали Меркл и Дамгор в статьях 1989 года (см. раздел «Для дополнительного чтения» ниже). То же самое справедливо и для коллизий: противник не сможет преодолеть стойкость хеш-функции к коллизиям, не преодолев стойкости лежащей в ее основе функции сжатия, поэтому безопасность последней гарантирует безопасность хеш-функции.

Отметим, что обратное неверно, поскольку наличие коллизии у функции сжатия необязательно означает коллизию хеш-функции. Коллизия Compress(X, M₁) = Compress(Y, M₂) для цепных значений X и Y, отличающихся от H₀, не приводит к коллизии хеш-функции, потому что невозможно включить эту коллизию в итеративную цепочку хешей — если только одним из цепных значений не окажется X, а другим Y, но это крайне маловероятно.

Нахождение мультиколлизий

Мультиколлизия случается, когда три или более сообщений хешируются в одно и то же значение. Например, тройка (X, Y, Z) такая, что Hash(X) = Hash(Y) = Hash(Z), называется 3-коллизией. В идеале нахождение мультиколлизий должно быть гораздо более трудным, чем нахождение коллизий, но существует простой трюк, позволяющий найти их почти с такими же затратами, как одиночную коллизию. Вот как он работает.

1. Найти первую коллизию: Compress(H₀, M₁₁) = Compress(H₀, M₁₂) = H₁. Сейчас мы имеем 2-коллизию, т. е. два сообщения с одинаковым хеш-значением.
2. Найти вторую коллизию, для которой H₁ — начальное цепное значение: Compress(H₁, M₂₁) = Compress(H₁, M₂₂) = H₂. Теперь мы имеем 4-коллизию — четыре сообщения с одинаковым хеш-значением H₂: M₁₁ || M₂₁, M₁₁ || M₂₂, M₁₂ || M₂₁ и M₁₂ || M₂₂.
3. Повторив этот процесс N раз, мы найдем 2^N N-блочных сообщений с одинаковым хеш-значением, или 2^N-коллизию, произведя «всего» примерно N2^N вычислений хеш-функции.

На практике этот прием не дает серьезных преимуществ, потому что в любом случае требует нахождения опорной 2-коллизии.