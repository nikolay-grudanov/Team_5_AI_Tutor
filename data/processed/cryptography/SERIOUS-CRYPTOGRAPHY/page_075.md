---
source_image: page_075.png
page_number: 75
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 44.89
tokens: 7879
characters: 2866
timestamp: 2025-12-24T09:12:11.882749
finish_reason: stop
---

Например, рассмотрим решение задачи факторизации, одной из самых известных математических задач в криптографии: дано число, про которое известно, что оно является произведением двух простых чисел (\( n = pq \)), и требуется найти эти числа. Например, если \( n = 15 \), то множителями будут 3 и 5. Для небольших чисел это легко, но с ростом числа трудность задачи экспоненциально возрастает. Например, для числа \( n \) длиной 3000 бит (около 900 десятичных цифр) или более задача факторизации считается практически неразрешимой.

Одной из самых известных схем, опирающихся на задачу факторизации, является RSA. В этом случае открытый текст \( P \), рассматриваемый как большое число, шифруется путем вычисления \( C = P^e \bmod n \), где число \( e \) и \( n = pq \) составляют открытый ключ. При дешифрировании открытый текст восстанавливается по шифртексту путем вычисления \( P = C^d \bmod n \), где \( d \) — закрытый ключ, ассоциированный с \( e \) и \( n \). Если мы сможем факторизовать \( n \), то взломаем схему RSA (поскольку сможем найти закрытый ключ, зная открытый). И наоборот, зная закрытый ключ, мы сможем факторизовать \( n \). Таким образом, нахождение закрытого ключа RSA и факторизация \( n \) — эквивалентные трудные задачи. Именно такого рода сведение интересует нас при доказательстве безопасности. Однако нет никакой гарантии, что реконструкция открытого текста в RSA — задача столь же трудная, как факторизация \( n \), поскольку знания открытого текста недостаточно для нахождения закрытого ключа.

Доказательства относительно другой криптографической задачи

Вместо того чтобы сравнивать криптографическую схему с математической задачей, можно сравнить ее с другой криптографической схемой и доказать, что вторую можно взломать, только если возможно взломать первую. Доказательства безопасности симметричных шифров обычно строятся именно таким образом.

Например, имея всего один перестановочный алгоритм, можно построить симметричные шифры, генераторы случайных битов и другие криптографические объекты, например функции хеширования. Для этого нужно только сочетать перестановки с различными типами входных данных (как мы увидим в главе 6). Тогда доказательства показывают, что все созданные схемы безопасны, если безопасен перестановочный алгоритм. Иными словами, мы точно знаем, что новый алгоритм не слабее исходного. Такие доказательства обычно строятся путем конструирования атаки на меньший компонент, если известна атака на больший, т. е. посредством сведения.

При доказательстве того, что один криптоалгоритм не слабее другого, главным преимуществом является уменьшенная поверхность атаки: вместо того чтобы анализировать базовый алгоритм и комбинацию, мы можем просто рассмотреть базовый алгоритм нового шифра. Точнее, разрабатывая шифр, в котором используется новый перестановочный алгоритм и новая комбинация, можно доказать,