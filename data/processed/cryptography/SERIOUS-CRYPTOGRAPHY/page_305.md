---
source_image: page_305.png
page_number: 305
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 37.84
tokens: 7911
characters: 2735
timestamp: 2025-12-24T09:18:58.716249
finish_reason: stop
---

Известный специалист по теории сложности Скотт Ааронсон назвал алгоритм Шора «одним из выдающихся научных достижений конца XX века».

На самом деле алгоритм Шора решает более общий класс задач, чем факторизация и дискретное логарифмирование. А именно если функция f() периодическая, т. е. существует такое ω (период), что f(x + ω) = f(x) для любого x, то алгоритм Шора эффективно находит ω. (Это звучит похоже на рассмотренную выше задачу Саймона, и действительно алгоритм Саймона стал главным источником вдохновения для Шора.) Способность алгоритма Шора эффективно вычислять период функции важна для криптографов, потому что может быть использована для атаки на криптографию с открытым ключом, как станет ясно из дальнейшего.

Обсуждение того, как именно алгоритм Шора достигает экспоненциального ускорения, содержало бы слишком много технических деталей для этой книги, но ниже я покажу, как можно использовать его для атаки на криптографию с открытым ключом, а именно для решения задач факторизации и дискретного логарифмирования (см. главу 9), которые лежат в основе RSA и протокола Диффи–Хеллмана.

Решение задачи факторизации с помощью алгоритма Шора

Пусть требуется разложить на множители большое число N = pq. Сделать это будет легко, если мы сможем вычислить период a^x \bmod N; эта задача трудна для классического компьютера, но легко решается на квантовом. Сначала выбираем случайное число a, меньшее N, и просим алгоритм Шора найти период ω функции f(x) = a^x \bmod N. Если период найден, то мы имеем a^x \bmod N = a^{x+\omega} \bmod N (т. е. a^x \bmod N = a^x a^\omega \bmod N), а это означает, что a^\omega \bmod N = 1, или a^\omega - 1 \bmod N = 0. Иначе говоря, a^\omega - 1 кратно N, т. е. a^\omega - 1 = kN для некоторого неизвестного числа k.

Ключевое наблюдение — тот факт, что легко можно разложить число a^\omega - 1 в произведение двух множителей: a^\omega - 1 = (a^{\omega/2} - 1)(a^{\omega/2} + 1). Затем можно вычислить наибольший общий делитель a^{\omega/2} - 1 и N и проверить, получен ли нетривиальный множитель N (т. е. значение, отличное от 1 и N). Если нет, тот же алгоритм можно выполнить повторно с другим значением a. После нескольких попыток мы найдем множитель N. Таким образом, мы восстановили закрытый ключ RSA по открытому, что позволяет дешифрировать сообщения или подделывать подписи.

Но насколько легко проделать это вычисление? Заметим, что лучший классический алгоритм факторизации N работает за время, экспоненциально зависящее от n, длины N в битах (т. е. n = \log_2 N). А алгоритм Шора работает за время, полиномиально зависящее от n, а точнее за время O(n^2 (\log n)(\log \log n)). Это означает, что будь у нас квантовый компьютер, мы смогли бы выполнить алгоритм Шора и получить ре-