---
source_image: page_235.png
page_number: 235
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 43.96
tokens: 7968
characters: 2439
timestamp: 2025-12-24T09:16:55.873447
finish_reason: stop
---

1. Положить \( y = y^2 \bmod n \) (теперь \( y = 3^2 \bmod n \)).
2. Положить \( y = y^2 \bmod n \) (теперь \( y = (3^2)^2 = 3^4 \bmod n \)).
3. Положить \( y = y^2 \bmod n \) (теперь \( y = (3^4)^2 = 3^8 \bmod n \)).
4. Положить \( y = y^2 \bmod n \) (теперь \( y = (3^8)^2 = 3^{16} \bmod n \)).
5. Положить \( y = y^2 \bmod n \) (теперь \( y = 3^{16})^2 = 3^{32} \bmod n \)).

И так далее, пока не дойдем до \( y = 3^{65536} \), для чего понадобится 16 возведений в квадрат.
Для получения окончательного результата возвращаем \( 3 \times y \bmod n = 3^{65537} \bmod n = 26\ 652\ 909\ 283\ 612\ 267 \). Как видим, для вычисления результата понадобилось всего 17 умножений вместо 65 536.
В общем случае для быстрого возведения в квадрат нужно просматривать биты показателя степени слева направо, возводя текущий результат в квадрат, если очередной бит равен 0, и умножая его на исходное число, если бит равен 0. В рассмотренном выше примере показатель степени равен 65 537, или 10000000000000000001 в двоичном виде, поэтому мы каждый раз возводили \( y \) в квадрат, кроме первого и последнего шагов, на котором умножали на исходное число 3.
В листинге 10.5 показан общий псевдокод алгоритма быстрого вычисления \( x^e \bmod n \) в случае, когда показатель степени \( e \) содержит биты \( e_{m-1}e_{m-2}...e_1e_0 \), где \( e_0 \) — младший бит.

Листинг 10.5. Псевдокод алгоритма быстрого возведения в степень

expMod(x, e, n) {
    y = x
    for i = m - 1 to 0 {
        y = y * y mod n
        if e_i == 1 then
            y = y * x mod n
    }
    return y
}

Алгоритм expMod() в листинге 10.5 работает за время \( O(m) \), а наивный алгоритм за время \( O(2^m) \), где \( m \) — длина показателя степени в битах. Здесь \( O() \) обозначает асимптотическую сложность (см. главу 9).
В реальных системах часто реализуются варианты этого простейшего метода быстрого возведения в степень. В одном из них, методе скользящего окна, рассматриваются блоки битов, а не отдельные биты. Например, см. функцию expNN() на языке Go, исходный код которой доступен по адресу https://golang.org/src/math/big/nat.go.
Насколько безопасны алгоритмы быстрого возведения в степень? К сожалению, различные приемы ускорения процесса часто ведут к повышенной уязвимости к некоторым атакам. Посмотрим, какие могут возникнуть проблемы.
Слабость этих алгоритмов обусловлена тем, что операции возведения в степень сильно зависят от показателя степени. Операция if