---
source_image: page_209.png
page_number: 209
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 37.89
tokens: 7823
characters: 2734
timestamp: 2025-12-24T09:16:02.428711
finish_reason: stop
---

к памяти обычно занимает на несколько порядков больше времени, чем выполнение простой арифметической операции.

Формально потребление памяти алгоритмом можно определить как функцию от размера входных данных n точно так же, как мы определили временную сложность. Класс задач, разрешимых при использовании f(n) бит памяти, обозначается SPACE(f(n)). Например, SPACE(n^3) — класс задач, разрешимых при использовании порядка n^3 бит памяти. По аналогии с обозначением P для объединения всех классов TIME(n^k), мы обозначаем PSPACE объединение классов SPACE(n^k).

Очевидно, что чем меньше потребление памяти, тем лучше, но полиномиальный объем памяти еще не значит, что алгоритм практически осуществим. Почему? Возьмем, к примеру, поиск полным перебором: да, он потребляет пренебрежимо мало памяти, но при этом чудовищно медленный. Вообще, алгоритм может работатьечно, даже если для работы нужно всего несколько байтов памяти.

Любая задача, разрешимая за время f(n), нуждается самое большое в памяти объемом f(n), поэтому класс TIME(f(n)) входит в SPACE(f(n)). За время f(n) мы сможем записать не более f(n) бит, поскольку предполагается, что запись (или чтение) одного бита занимает одну единицу времени; поэтому любая задача, принадлежащая классу TIME(f(n)), не может потребить память более f(n) бит. Следовательно, P является подмножеством PSPACE.

Недетерминированное полиномиальное время

NP — второй по важности класс сложности после класса P всех алгоритмов с полиномиальным временем. Нет, NP означает не «неполиномиальное время», а «недетерминированное полиномиальное время». Что это такое?

NP — класс задач, для которых решение может быть проверено за полиномиальное время, т. е. эффективно, пусть даже найти решение может быть трудно. Говоря проверено, я имею в виду, что если дано потенциальное решение, то существует алгоритм с полиномиальным временем, который позволяет проверить, действительно ли это решение. Например, задача восстановления секретного ключа при наличии известного открытого текста принадлежит классу NP, потому что если даны P, C = E(K, P) и потенциальный ключ K_0, то можно проверить, является ли K_0 правильным ключом, убедившись, что E(K_0, P) равно C. Процесс нахождения потенциального ключа (решения) невозможно выполнить за полиномиальное время, но проверить, правилен ли ключ, можно с помощью полиномиального алгоритма.

А теперь контрпример: как насчет атак с известным шифртекстом? На этот раз у нас есть только значения E(K, P) для случайных неизвестных открытых текстов P. Если P неизвестны, то нет никакого способа проверить, является ли потенциальный ключ K_0 правильным. Иными словами, задача восстановления ключа в атаках с известным шифртекстом не принадлежит классу NP (и уж тем более P).