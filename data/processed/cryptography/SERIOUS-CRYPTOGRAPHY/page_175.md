---
source_image: page_175.png
page_number: 175
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 47.03
tokens: 8011
characters: 2954
timestamp: 2025-12-24T09:15:09.328971
finish_reason: stop
---

версальной функции хеширования предъявляется лишь одно требование безопасности: для любых двух сообщений \( M_1 \) и \( M_2 \) вероятность того, что \( \mathrm{UH}(K, M_1) = \mathrm{UH}(K, M_2) \), должна быть пренебрежимо мала для случайного ключа \( K \). В отличие от PRF, универсальная функция хеширования не обязана быть псевдослучайной; просто не должно существовать пары \( (M_1, M_2) \), которая дает один и тот же хеш для многих разных ключей. Поскольку удовлетворить таким требованиям проще, требуется меньше операций, и потому универсальные функции хеширования работают значительно быстрее PRF.

Однако использовать универсальный хеш в качестве МАС можно для аутентификации максимум одного сообщения. Рассмотрим, к примеру, универсальную функцию хеширования, используемую в алгоритме Poly1305: функцию полиномиального вычисления. (См. основополагающую статью Gilbert, MacWilliams, and Sloane «Codes Which Detect Deception», вышедшую в 1974 году, где приведены дополнительные сведения на эту тему.) Такого рода хеш-функции параметризуются простым числом \( p \) и принимают ключ, состоящий из двух чисел \( R \) и \( K \) в диапазоне \([1, p]\), и сообщение \( M \), состоящее из \( n \) блоков, \( (M_1, M_2, ..., M_n) \). Тогда результат универсальной функции хеширования вычисляется следующим образом:

\[
\mathrm{UH}(R, K, M) = R + M_1 K + M_2 K^2 + M_3 K^3 + ... + M_n K^n \bmod p.
\]

Знаком + обозначено сложение положительных целых чисел, \( K^i \) — результат возведения \( K \) в степень \( i \), а «\( \bmod p \)» — операция деления по модулю \( p \) (т. е. остаток от деления на \( p \), например \( 12 \bmod 10 = 2 \), \( 10 \bmod 10 = 0 \), \( 8 \bmod 10 = 8 \) и т. д.).

Поскольку мы хотим вычислять хеш максимально быстро, имитовставки на основе универсальной хеш-функции часто работают с блоками длиной 128 бит и простым числом \( p \), ненамного большим \( 2^{128} \), например \( 2^{128} + 51 \). При длине 128 можно добиться очень быстрой реализации благодаря эффективному использованию 32- и 64-разрядных АЛУ типичных процессоров.

**Потенциальные уязвимости**

У универсальных функций хеширования есть одна слабость: поскольку универсальный хеш может безопасно аутентифицировать только одно сообщение, противник мог бы взломать показанную выше МАС на основе полиномиального вычисления, запросив жетоны всего двух сообщений. Точнее, он мог бы запросить жетоны для сообщения с \( M_1 = M_2 = ... = 0 \) (для него жетон \( \mathrm{UH}(R, K, 0) = R \)), а затем использовать их для нахождения секретного значения \( R \). Или противник мог бы запросить жетоны для сообщения с \( M_1 = 1, M_2 = M_3 = ... = 0 \) (его жетон равен \( T = R + K \)), это позволило бы ему найти \( K \), вычтя \( R \) из \( T \). Теперь противник знает весь ключ \( (R, K) \) и может подделывать имитовставки для любого сообщения.

По счастью, существует способ перейти от безопасности для одного сообщения к безопасности для нескольких сообщений.