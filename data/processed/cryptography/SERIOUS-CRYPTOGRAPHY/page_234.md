---
source_image: page_234.png
page_number: 234
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 31.94
tokens: 7721
characters: 2089
timestamp: 2025-12-24T09:16:41.243077
finish_reason: stop
---

Основная операция, показанная в листинге 10.3, с.Exp(m, e, pub.N), возводит сообщение m в степень e по модулю pub.N и присваивает результат переменной с.

Если вы все-таки решили реализовывать RSA, а не пользоваться готовой библиотечной функцией, то хотя бы опирайтесь на имеющуюся библиотеку для работы с большими числами, содержащую набор функций и типов, позволяющих определять и вычислять арифметические операции над большими числами длиной тысячи бит. Например, можно воспользоваться арифметической библиотекой GNU Multiple Precision (GMP), написанной на C, или пакетом Go big. (Поверьте мне, лучше не стоит реализовывать арифметику больших чисел самостоятельно.)

Но даже если вы пользуетесь библиотечной функцией при реализации RSA, разберитесь, как она работает, чтобы понять меру риска.

**Алгоритм быстрого возведения в степень**

Операция \( x^e \bmod n \) называется **возведением в степень**. Будучи наивно реализована, эта операция может оказаться чрезвычайно медленной при работе с большими числами, в частности в RSA. Но как реализовать ее эффективно?

При наивном вычислении \( x^e \bmod n \) потребуется \( e - 1 \) умножений, как показано в алгоритме на псевдокоде в листинге 10.4.

**Листинг 10.4. Псевдокод наивного алгоритма возведения в степень**

expModNaive(x, e, n) {
    y = x
    for i = 1 to e - 1 {
        y = y * x mod n
    }
    return y
}

Этот алгоритм прост, но абсолютно не эффективен. Тот же результат можно получить экспоненциально быстрее, если не перемножать числа, а возводить их в квадрат, пока не дойдем до нужного показателя степени. Это семейство методов называется алгоритмами быстрого, или двоичного, возведения в степень.

Например, пусть требуется вычислить \( 3^{65537} \bmod 36567232109354321 \) (число 65 537 — открытый показатель степени, используемый в большинстве реализаций RSA). Можно было бы умножить 3 на себя 65 536 раз, или заметить, что \( 65\ 537 = 2^{16} + 1 \), и выполнить серию операций возведения в квадрат. Именно инициализируем переменную \( y = 3 \), а затем выполним такие операции возведения в квадрат (\( y^2 \)):