---
source_image: page_086.png
page_number: 86
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 37.80
tokens: 7844
characters: 2420
timestamp: 2025-12-24T09:12:23.363108
finish_reason: stop
---

3. Для дешифрирования блока неизвестного шифртекста найти соответствующий блок открытого текста в таблице.

При использовании 16-битовых блоков для справочной таблицы нужно всего \(2^{16} \times 16 = 2^{20}\) бит памяти, т. е. 128 КБ. Для 32-битовых блоков объем потребной памяти возрастает до 16 ГБ, это еще осуществимо. Но для 64-битовых блоков придется хранить \(2^{70}\) бит (один зетабит, или 128 экзабайт) — даже не думайте об этом. Для больших блоков атаки по кодовой книге не представляют проблемы.

Как устроены блочные шифры

Существуют сотни блочных шифров, но совсем немного способов их построения. Во-первых, используемые на практике блочные шифры — это не гигантские монолитные алгоритмы, а повторение раундов — коротких последовательностей операций, сила которых не в них самих, а в их числе. Во-вторых, есть две основные техники построения раунда: подстановочно-перестановочные сети (как в AES) и схемы Фейстеля (как в DES). В этом разделе мы обсудим, как они работают, но сначала рассмотрим атаку, которая приводит к успеху, если все раунды идентичны.

Раунды блочного шифра

Вычисление блочного шифра сводится к вычислению последовательности раундов. Раундом называется базовое преобразование, которое легко описать и реализовать и которое повторяется несколько раз, образуя алгоритм шифра. Такую конструкцию — небольшой компонент, повторяемый многократно, — проще реализовать и проанализировать, чем гигантский монолитный алгоритм.

Например, блочный шифр с тремя раундами шифрует открытый текст \(P\) путем вычисления \(C = R_3(R_2(R_1(P)))\), где \(R_1, R_2\) и \(R_3\) — раунды. Для каждого раунда должно существовать обращение, чтобы получатель мог восстановить открытый текст. Точнее, \(P = iR_1(iR_2(iR_3(C)))\), где \(iR_1\) — преобразование, обратное \(R_1\), и так далее.

Функции раундов — \(R_1, R_2\) и т. д. — обычно представляют собой одинаковые алгоритмы, параметризованные ключом раунда. Две функции раундов с разными ключами ведут себя по-разному, поэтому порождают разные выходы для одного и того же входа.

Ключи раундов выводятся из главного ключа \(K\) с помощью алгоритма развертки ключа. Например, \(R_1\) принимает ключ раунда \(K_1\), \(R_2\) — ключ раунда \(K_2\) и т. д.

Ключи всех раундов должны различаться. Поэтому не все ключи раунда равны ключу \(K\), иначе раунды были бы идентичны и блочный шифр оказался бы менее безопасным, как демонстрируется в следующем разделе.