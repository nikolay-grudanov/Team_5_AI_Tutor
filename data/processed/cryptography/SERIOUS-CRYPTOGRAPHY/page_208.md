---
source_image: page_208.png
page_number: 208
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 44.46
tokens: 7959
characters: 2872
timestamp: 2025-12-24T09:16:06.042196
finish_reason: stop
---

курсивно определена как \( f(x) = x^{f(x-1)} \) для любого х. Впрочем, на практике вам никогда не встретится алгоритм с такой абсурдной сложностью.

Алгоритм сложности \( O(n^2) \) или \( O(n^3) \) еще может считаться эффективным, но \( O(n^{9999999999}) \), очевидно, нет. Иными словами, полиномиальное время приемлемо, если показатель степени не слишком велик. По счастью, у всех известных полиномиальных алгоритмов решения реальных задач показатели степени невелики. Например, алгоритм умножения двух \( n \)-битовых целых чисел имеет сложность \( O(n^{1.465}) \), а алгоритм умножения двух матриц \( n \times n \) — сложность \( O(n^{2.373}) \). В 2002 году был открыт прорывной полиномиальный алгоритм нахождения простых чисел, сложность которого первоначально составляла \( O(n^{12}) \), но затем была улучшена до \( O(n^6) \). Таким образом, полиномиальное время — возможно, не идеальное определение практически осуществимого, но это лучшее из того, что мы имеем.

Развивая эту мысль, мы считаем практически неразрешимой, или трудной, задачу, которую нельзя решить за полиномиальное время. Например, в случае прямолинейного поиска ключа невозможно справиться со сложностью \( O(2^n) \), если только шифр не удастся каким-то образом взломать.

Мы точно знаем, что сложность \( O(2^n) \) поиска ключа полным перебором непреодолима (при условии что шифр безопасен), но не всегда знаем самый быстрый способ решения задачи. Значительная часть исследований по теории сложности посвящена установлению границ времени выполнения алгоритмов решения данной задачи. Чтобы упростить себе работу, теоретики различают несколько групп, или классов, задач по усилиям, которые необходимо предпринять для их решения.

Классы сложности

В математике классом называется группа объектов с похожим свойством. Например, все вычислительные задачи, разрешимые за время \( O(n^2) \), — множество, обозначаемое в теории сложности **TIME**\((n^2)\), — составляют один класс. Аналогично **TIME**\((n^3)\) — класс задач, разрешимых за время \( O(n^3) \), **TIME**\((2^n)\) — класс задач, разрешимых за время \( O(2^n) \), и так далее. По той же причине, по которой суперкомпьютер может вычислить все, что способен вычислить ноутбук, любая задача, разрешимая за время \( O(n^2) \), разрешима также за время \( O(n^3) \). Поэтому любая задача класса **TIME**\((n^2)\) принадлежит также классу **TIME**\((n^3)\), и оба они являются подмножествами **TIME**\((n^4)\) и т. д. Объединение всех классов **TIME**\((n^k)\), где \( k \) — константа, обозначается **P** (полиномиальное время).

Если вы когда-нибудь программировали, то знаете, что кажущиеся быстрыми алгоритмы могут обрушить систему, потребив всю доступную память. Поэтому при выборе алгоритма нужно учитывать не только временную, но и пространственную сложность — сколько памяти необходимо алгоритму. Это тем более важно, что одно обращение