---
source_image: page_052.png
page_number: 52
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 43.86
tokens: 7828
characters: 2535
timestamp: 2025-12-24T09:11:33.452085
finish_reason: stop
---

пула энтропии, он не сможет определить предыдущее состояние пула и ранее сгенерированные биты. Для обеспечения устойчивости к предсказанию PRNG должен регулярно выполнять операцию refresh, задавая значения R, неизвестные противнику и не поддающиеся угадыванию. Это помешает противнику определить будущие значения пула энтропии, даже если весь пул будет скомпрометирован. (Даже если список использованных значений R известен, для реконструкции пула нужно знать, в каком порядке вызывались операции refresh и next.)

PRNG Fortuna

PRNG-генератор Fortuna, используемый в Windows, был разработан в 2003 году Нильсом Фергюсоном и Брюсом Шнейдером. Этот алгоритм заменил систему Yarrow, которая была разработана в 1998 году Келси и Шнейдером и по сей день используется в операционных системах macOS и iOS. Я не стану здесь приводить спецификацию Fortuna и описывать его реализацию, но попытаюсь объяснить, как он работает. Полное описание Fortuna можно найти в главе 9 книги Ferguson, Schneier, Kohno «Cryptography Engineering» (Wiley, 2010).

Внутренняя память Fortuna включает следующие компоненты:

• 32 пула энтропии \( P_1, P_2, \ldots, P_{32} \), организованных так, что \( P_i \) используется в каждой \( 2^i \)-й доинициализации;
• ключ \( K \) и счетчик \( C \) (оба длиной 16 байт). Они образуют внутреннее состояние DRBG, применяемого в Fortuna.

Упрощенно работу Fortuna можно описать следующим образом:

• init() инициализирует \( K \) и \( C \) нулями и опустошает все 32 пула энтропии \( P_i \);
• refresh(R) добавляет данные \( R \) в один из пулов энтропии. Система выбирает, какие RNG использовать для порождения значений \( R \), и должна регулярно вызывать refresh;
• next(N) обновляет \( K \), используя один или несколько пулов энтропии, причем выбор пула определяется в первую очередь тем, сколько обновлений \( K \) уже было произведено. Затем \( N \) запрошенных бит порождаются путем шифрования \( C \) на ключе \( K \). Если шифрования \( C \) недостаточно, то Fortuna шифрует \( C + 1 \), потом \( C + 2 \) и т. д., пока не наберет достаточно битов.

Хотя работа алгоритма Fortuna выглядит довольно просто, правильно реализовать его нелегко. Во-первых, нужно тщательно продумать все детали алгоритма: как выбираются пулы энтропии, какой тип шифра использовать в next, что делать, если не получено никакой энтропии, и т. д. В спецификации описано большинство деталей, но не включен полный набор тестов для проверки правильности реализации, поэтому трудно убедиться, что реализация Fortuna ведет себя, как задумано.