---
source_image: page_095.png
page_number: 95
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 47.93
tokens: 7949
characters: 2600
timestamp: 2025-12-24T09:12:48.109916
finish_reason: stop
---

му, время выполнения которой не зависит от входных данных, но это почти невозможно сделать с сохранением быстродействия, поэтому производители микросхем выбрали радикальное решение: вместо того чтобы полагаться на потенциально уязвимое программное обеспечение, они полагаются на оборудование.

Машинные команды

Машинные команды AES (AES-NI) решают проблему атак с хронометражем кеша, присущую программным реализациям AES. Чтобы понять, как работает AES-NI, подумаем о том, как вообще программа исполняется на оборудовании: для выполнения программы микропроцессор транслирует двоичный код в последовательность команд, исполняемых компонентами интегральной схемы. Например, ассемблерная команда MUL умножения двух 32-разрядных значений активирует транзисторы, реализующие 32-разрядный умножитель в микропроцессоре. Для реализации криптографического алгоритма мы обычно просто записываем комбинацию таких элементарных операций — сложения, умножения, XOR и т. д., — а микропроцессор активирует свои цепи сложения, умножения и XOR в предписанном порядке.

Машинные команды AES переводят эту идею на новый уровень, предоставляя разработчикам специализированные ассемблерные команды для вычисления AES. Вместо того чтобы записывать раунд AES в виде последовательности обычных ассемблерных команд, разработчик просто использует команду AESENC, а микросхема вычисляет раунд, т. е. вся работа перекладывается на процессор.

Типичный ассемблерный код AES с применением машинных команд показан в листинге 4.3.

Листинг 4.3. Машинные команды AES

<table>
  <tr>
    <th>Регистры</th>
    <th>Команды</th>
  </tr>
  <tr>
    <td>PXOR</td>
    <td>%xmm5, %xmm0</td>
  </tr>
  <tr>
    <td>AESENC</td>
    <td>%xmm6, %xmm0</td>
  </tr>
  <tr>
    <td>AESENC</td>
    <td>%xmm7, %xmm0</td>
  </tr>
  <tr>
    <td>AESENC</td>
    <td>%xmm8, %xmm0</td>
  </tr>
  <tr>
    <td>AESENC</td>
    <td>%xmm9, %xmm0</td>
  </tr>
  <tr>
    <td>AESENC</td>
    <td>%xmm10, %xmm0</td>
  </tr>
  <tr>
    <td>AESENC</td>
    <td>%xmm11, %xmm0</td>
  </tr>
  <tr>
    <td>AESENC</td>
    <td>%xmm12, %xmm0</td>
  </tr>
  <tr>
    <td>AESENC</td>
    <td>%xmm13, %xmm0</td>
  </tr>
  <tr>
    <td>AESENC</td>
    <td>%xmm14, %xmm0</td>
  </tr>
  <tr>
    <td>AESENCLAST</td>
    <td>%xmm15, %xmm0</td>
  </tr>
</table>

Этот код зашифровывает 128-битовый открытый текст, первоначально помещенный в регистр xmm0, в предположении, что в регистрах от xmm5 до xmm15 хранятся предварительно вычисленные ключи раундов, а каждая команда помещает свой результат в xmm0. Первая команда PXOR выполняет XOR с первым ключом раунда до вычисле-