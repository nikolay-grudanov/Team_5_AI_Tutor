---
source_image: page_219.png
page_number: 219
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 34.32
tokens: 7858
characters: 2538
timestamp: 2025-12-24T09:16:13.018622
finish_reason: stop
---

тели \( p \) и \( q \) имеют определенный вид — например, когда \( N = pq \), причем \( p \) и \( q \) близки к некоторой степени двойки \( 2^b \), или когда \( N = pq \) и некоторые биты \( p \) или \( q \) известны, или когда \( N \) имеет вид \( N = p^rq^s \), где \( r > \log p \). Однако подробное обсуждение причин таких слабостей выходит за рамки этой книги.

Вывод: алгоритмы шифрования и цифровой подписи на основе RSA (рассматриваются в главе 10) должны работать со значением \( N = pq \), где \( p \) и \( q \) тщательно подобраны, чтобы факторизация \( N \) не была легкой, иначе возможно катастрофическое нарушение безопасности.

**Небольшие трудные задачи трудными не являются**

Вычислительно трудные задачи становятся легкими, если они достаточно малы — даже алгоритмы с экспоненциальным временем становятся практически пригодными, если уменьшить размер задачи. Симметричный шифр может быть безопасным в том смысле, что не существует атаки полным перебором менее \( 2^n \) вариантов, но если длина ключа \( n = 32 \), то для взлома шифра хватит нескольких минут. Это кажется очевидным, и вы, наверное, думаете, что никто в здравом уме не станет использовать короткие ключи, но в реальности есть немало причин, по которым такое возможно. Расскажу две правдивые истории.

Представьте себе разработчика, который ничего не знает о криптографии, но располагает каким-то API шифрования с помощью RSA и получил задание зашифровать сообщение с безопасностью 128 бит. Какой размер ключа RSA он выберет? Я встречал ситуации, когда выбирался 128-битовый RSA, т. е. основанный на 128-битовом числе \( N = pq \). Да, факторизация числа \( N \) длиной в тысячи бит практически неосуществима, но разложить на множители 128-битовое число легко. Команды библиотеки SageMath, показанные в листинге 9.2, выполняются мгновенно.

**Листинг 9.2. Генерирование модуля RSA путем выбора двух случайных простых чисел с последующей мгновенной факторизацией**

sage: p = random_prime(2**64)
sage: q = random_prime(2**64)
sage: factor(p*q)
6822485253121677229 * 17596998848870549923

Листинг 9.2 показывает, что 128-битовое число, равное произведению двух случайно выбранных 64-битовых простых чисел, легко факторизовать даже на типичном ноутбуке. Но если бы я выбрал 1024-битовые простые числа, \( p = \text{random\_prime}(2^{*1024}) \), то команда factor(p*q) никогда не завершилась бы, во всяком случае я бы до этого не дожил.

Откровенно говоря, имеющиеся инструменты не помогают предотвратить наивное использование опасно коротких параметров. На-