---
source_image: page_207.png
page_number: 207
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 28.12
tokens: 7576
characters: 1601
timestamp: 2025-12-24T09:15:49.666733
finish_reason: stop
---

Полиномиальное и суперполиномиальное время

Сложность \( O(n^2) \), упомянутая в предыдущем разделе (средняя кривая на рис. 9.1), — частный случай более широкого класса полиномиальной сложности \( O(n^k) \), где \( k \) — фиксированное число, например 3, 2.373, 7/10 или квадратный корень из 17. Алгоритмы с полиномиальной сложностью особенно важны в теории сложности в криптографии, потому что определяют предел практически осуществимого. Алгоритм, работающий за полиномиальное время, завершается в разумные сроки, даже если размер входных данных велик. Поэтому для специалистов по теории сложности и криптографов полиномиальное время — синоним эффективности.

С другой стороны, алгоритмы, требующие суперполиномиального времени, т. е. времени \( O(f(n)) \), где \( f(n) \) — произвольная функция, растущая быстрее любого полинома, считаются практически неосуществимыми. Я говорю «суперполиномиальная», а не просто «экспоненциальная», потому что существуют сложности, находящиеся между полиномиальной и хорошо известной экспоненциальной сложностью \( O(2^n) \), например \( O(n^{\log(n)}) \), показанная на рис. 9.2.

![График функций 2^n, n^{\log(n)}, n^2](https://i.imgur.com/3Q5z5QG.png)

Рис. 9.2. Функции, растущие как \( 2^n \), \( n^{\log(n)} \) и \( n^2 \), в порядке от самой быстрой к самой медленной

Примечание Экспоненциальная сложность \( O(2^n) \) — не худшее, с чем можно столкнуться. Есть сложности, растущие еще быстрее и, следовательно, характеризующие еще более медленные алгоритмы, например \( O(n^n) \) или экспоненциальный факториал \( O(n^{f(n-1)}) \), где функция \( f \) ре-