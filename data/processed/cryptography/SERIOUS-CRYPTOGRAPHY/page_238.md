---
source_image: page_238.png
page_number: 238
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 48.87
tokens: 8180
characters: 2951
timestamp: 2025-12-24T09:17:05.577020
finish_reason: stop
---

Китайская теорема об остатках позволяет ускорить дешифрирование за счет вычисления двух возведений степени, по модулям \( p \) и \( q \), а не по модулю \( n \). Поскольку \( p \) и \( q \) гораздо меньше \( n \), проще выполнить два «малых» возведения в степень, чем одно «большое».

Китайская теорема об остатках не имеет прямого отношения к RSA. Это общий арифметический результат; в простейшем виде она утверждает, что если \( n = n_1 n_2 n_3 ... \), где \( n_i \) — попарно взаимно простые числа (т. е. \( \gcd(n_i, n_j) = 1 \) для любых различных \( i \) и \( j \)), то значение \( x \bmod n \) можно вычислить, зная значения \( x \bmod n_1, x \bmod n_2, x \bmod n_3, ... \). Например, пусть число \( n = 1155 \), оно разлагается в произведение простых множителей \( 3 \times 5 \times 7 \times 11 \). Мы хотим найти такое \( x \), что \( x \bmod 3 = 2, x \bmod 5 = 1, x \bmod 7 = 6 \) и \( x \bmod 11 = 8 \) (числа 2, 1, 6, 8 выбраны произвольно).

Чтобы найти \( x \), воспользовавшись китайской теоремой об остатках, вычислим сумму \( P(n_1) + P(n_2) + ... \), где \( P(n_i) \) определено следующим образом:

\[
P(n_i) = (x \bmod n_i) \times n / n_i \times (1/(n/n_i) \bmod n_i) \bmod n.
\]

Заметим, что второй член, \( n / n_i \), равен произведению всех множителей, кроме \( n_i \).

Чтобы применить эту формулу к нашему примеру и восстановить \( x \bmod 1155 \), выберем произвольные значения 2, 1, 6, 8, вычислим \( P(3) \), \( P(5) \), \( P(7) \) и \( P(11) \), а затем сложим и получим:

\[
[2 \times 385 \times (1/385 \bmod 3) + 1 \times 231 \times (1/231 \bmod 5) + 6 \times 165 \times (1/165 \bmod 7) + 8 \times 105 \times (1/105) \bmod 11] \bmod n.
\]

Здесь я просто применил данное выше определение \( P(n_i) \). (Математическое обоснование способа вычисления каждого числа несложно, но я не буду на нем останавливаться.) Это выражение можно свести к [770 + 231 + 1980 + 1680] \bmod n = 41, и я действительно выбрал 41, так что мы получили правильный результат.

Применить китайскую теорему об остатках к RSA проще, чем в рассмотренном примере, потому что для каждого \( n \) есть всего два множителя (\( p \) и \( q \)). Получив подлежащий дешифрированию шифртекст \( y \), мы не будем вычислять \( y^d \bmod n \), а применим китайскую теорему об остатках и вычислим \( x_p = y^s \bmod p \), где \( s = d \bmod (p - 1) \), и \( x_q = y^t \bmod q \), где \( t = d \bmod (q - 1) \). Затем объединим оба выражения и вычислим \( x \) по формуле

\[
x = x_p \times q \times (1/q \bmod p) + x_q \times p \times (1/p \bmod q) \bmod n.
\]

Вот и все. Это быстрее, чем метод двоичного возведения в квадрат, потому что умножения выполняются по модулям \( p \) и \( q \), которые в два раза короче \( n \).

**Примечание** В последней операции числа \( q \times (1/q \bmod p) \) и \( p \times (1/p \bmod q) \) можно вычислить заранее, а значит, для нахождения \( x \) нужно будет выполнить только два умножения и сложение по модулю \( n \).