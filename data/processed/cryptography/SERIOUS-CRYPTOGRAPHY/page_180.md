---
source_image: page_180.png
page_number: 180
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 23.11
tokens: 7562
characters: 1778
timestamp: 2025-12-24T09:14:52.135257
finish_reason: stop
---

ния, многократно отправляя неправильные, — правильным будет тот, для проверки которого нужно наибольшее время. Проблема возникает, если сервер сравнивает строки правильного и неправильного жетонов побайтно, прекращая сравнение, как только встретятся два разных байта. Например, в листинге 7.1 показан код сравнения двух строк на Python, занимающий переменное время: если различаются первые байты, то функция возвращает управление после всего одного сравнения, а если строки x и y совпадают, то количество сравнений будет равно длине строки.

Листинг 7.1. Сравнение двух n-байтовых строк, занимающее переменное время

def verify_mac(x, y, n):
    for i in range(n):
        if x[i] != y[i]:
            return False
    return True

Чтобы продемонстрировать уязвимость функции verify_mac(), напишем программу, которая измеряет время выполнения 100 000 вызовов, сначала с одинаковыми 10-байтовыми значениями х и у, а затем со значениями, различающимися в третьем байте. Мы ожидаем, что второе сравнение потребует заметно больше времени, чем первое, потому verify_mac() будет сравнивать меньше байтов.

Листинг 7.2. Измерение времени при выполнении функции verify_mac() из листинга 7.1

from time import time

MAC1 = '0123456789abcdef'
MAC2 = '01X3456789abcdef'
TRIALS = 100000

# при каждом обращении к verify_mac() просматриваются все восемь байт
start = time()
for i in range(TRIALS):
    verify_mac(MAC1, MAC1, len(MAC1))
end = time()
print("%0.5f" % (end-start))

# при каждом обращении к verify_mac() просматриваются только три байта
start = time()
for i in range(TRIALS):
    verify_mac(MAC1, MAC2, len(MAC1))
end = time()
print("%0.5f" % (end-start))

На моей машине в результате типичного выполнения этой программы печаталось время приблизительно 0.215 и 0.095 секунды со-