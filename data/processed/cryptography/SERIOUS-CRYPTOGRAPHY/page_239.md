---
source_image: page_239.png
page_number: 239
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 37.18
tokens: 7830
characters: 2445
timestamp: 2025-12-24T09:16:53.977034
finish_reason: stop
---

К сожалению, эта техника сопряжена с угрозой безопасности, которую мы обсудим ниже.

Какие возможны проблемы

Схема RSA красива, но еще красивее серия атак, работающих либо потому, что реализация дает утечку информации о внутреннем механизме (или ее можно заставить дать такую утечку), либо потому, что RSA небезопасно используется. Ниже я опишу два классических примера атак такого рода.

Атака Bellcore на RSA-CRT

Атака Bellcore — одна из самых важных в истории RSA. Открытая в 1996 году, она стоит особняком, потому что эксплуатировала уязвимость RSA к внесению ошибок — атак, которые заставляют часть алгоритма вести себя неправильно и давать некорректные результаты. Например, аппаратные схемы или встраиваемые системы можно подвергнуть временным возмущениям, внезапно изменяя входное напряжение или направив лазерный импульс на тщательно выбранную часть микросхемы. Затем противник может воспользоваться возникшими ошибками в работе алгоритма, наблюдая влияние на конечный результат. Например, сравнение правильного результата с ошибочными может дать информацию о внутренних значениях алгоритма, в т. ч. секретных.

Атака Bellcore относится именно к такому классу атак. Она эффективна против детерминированных схем RSA-подписи, в которых применяется китайская теорема об остатках, т. е. против FDH, но не против вероятностной схемы PSS.

Чтобы понять, как работает атака Bellcore, вспомним, что, в силу китайской теоремы об остатках, результат, равный \( x^d \bmod n \), получается вычислением следующего выражения, в котором \( x_p = y^s \bmod p \) и \( x_q = y^t \bmod q \):

\[
x = x_p \times q \times (1/q \bmod p) + x_q \times p \times (1/p \bmod q) \bmod n.
\]

Теперь предположим, что противник вносит ошибку в вычисление \( x_q \), так что в итоге получается неправильное значение, отличающееся от настоящего \( x_q \). Обозначим это неправильное значение \( x'_q \), а конечный результат \( x' \). Тогда противник может вычесть неправильную подпись \( x' \) из правильной подписи \( x \), чтобы факторизовать \( n \):

\[
x - x' = (x_q - x'_q) \times p \times (1/p \bmod q) \bmod n.
\]

Таким образом, значение \( x - x' \) кратно \( p \), т. е. \( p \) является делителем \( x - x' \). Поскольку \( p \) также является делителем \( n \), то наибольшим общим делителем \( n \) и \( x - x' \) будет \( p \), \( \gcd(x - x', n) = p \). Тогда можно вычислить \( q = n/p \) и \( d \) и, следовательно, полностью взломать RSA-подписи.