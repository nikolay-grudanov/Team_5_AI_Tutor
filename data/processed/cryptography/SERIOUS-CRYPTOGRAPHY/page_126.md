---
source_image: page_126.png
page_number: 126
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 36.19
tokens: 7783
characters: 1798
timestamp: 2025-12-24T09:13:32.099591
finish_reason: stop
---

тем инициализируются на основе n-байтового ключа K с помощью алгоритма развертки ключа (key scheduling algorithm – KSA), работа которого иллюстрируется Python-кодом в листинге 5.1.

Листинг 5.1. Алгоритм развертки ключа в RC4

j = 0
# инициализировать массив S: S[0] = 0, S[1] = 1, ..., S[255] = 255
S = range(256)
# цикл по i от 0 до 255
for i in range(256):
    # вычислить сумму v
    j = (j + S[i] + K[i % n]) % 256
    # обменять S[i] и S[j]
    S[i], S[j] = S[j], S[i]

После завершения этого алгоритма массив S по-прежнему содержит все значения от 0 до 255, но уже в порядке, который выглядит как случайный. Например, если 128-битовый ключ состоит из одних нулей, то состояние S (элементы от S[0] до S[255]) выглядит так:

0, 35, 3, 43, 9, 11, 65, 229, (...), 233, 169, 117, 184, 31, 39.

Но если инвертировать первый бит ключа и снова выполнить KSA, то получится совершенно другое состояние, тоже выглядящее случайным:

32, 116, 131, 134, 138, 143, 149, (...), 152, 235, 111, 48, 80, 12.

Имея начальное состояние S, RC4 генерирует гамму KS такой же длины, как открытый текст P, и с ее помощью вычисляет шифртекст: C = P ⊕ KS. Байты гаммы KS вычисляются по S, как показано в листинге 5.2, где предполагается, что длина P равна m байт.

Листинг 5.2. Генерирование гаммы в RC4, где S – начальное состояние, инициализированное в листинге 5.1

i = 0
j = 0
for b in range(m):
    i = (i + 1) % 256
    j = (j + S[i]) % 256
    S[i], S[j] = S[j], S[i]
    KS[b] = S[(S[i] + S[j]) % 256]

В листинге 5.2 на каждой итерации цикла изменяется не более 2 байт внутреннего состояния RC4, S: элементы S[i] и S[j], значения которых меняются местами. То есть если i = 0, j = 4 и S[0] = 56, S[4] = 78, то в результате операции обмена будем иметь S[0] = 78, S[4] = 56. Если j равно i, то S[i] не изменяется.