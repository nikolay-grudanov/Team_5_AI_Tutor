---
source_image: page_161.png
page_number: 161
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 27.82
tokens: 7586
characters: 1664
timestamp: 2025-12-24T09:14:25.681823
finish_reason: stop
---

\[
a = a + b + M_i; \\
d = ((d \oplus a) >>> 32); \\
c = c + d; \\
b = ((b \oplus c) >>> 24); \\
a = a + b + M_j; \\
d = ((d \oplus a) >>> 16); \\
c = c + d; \\
b = ((b \oplus c) >>> 63).
\]

Базовая операция BLAKE2s похожа, но работает с 32-битовыми, а не 64-битовыми словами (поэтому величины циклических сдвигов другие).

**Какие возможны проблемы**

Несмотря на кажущуюся простоту, функции хеширования могут стать причиной серьезных проблем безопасности, если используются неправильно или не в том месте, например когда для проверки целостности файла в приложениях, передающих данные по сети, вместо криптографической хеш-функции применяется нестойкий алгоритм вычисления контрольной суммы типа CRC. Однако эта слабость бледнеет по сравнению с другими, способными привести к полной компрометации на первый взгляд безопасных хеш-функций. Мы рассмотрим два примера таких катастроф: первый относится к SHA-1 и SHA-2, но не к BLAKE2 или SHA-3, второй — ко всем четырем функциям.

**Атака удлинением сообщения**

Атака удлинением сообщения, показанная на рис. 6.9, — главная угроза построению Меркла–Дамгора.

![Атака удлинением сообщения](https://i.imgur.com/3Q5z5QG.png)

Рис. 6.9. Атака удлинением сообщения

Суть ее в следующем: если мы знаем **Hash(M)** для некоторого *неизвестного* сообщения \( M \), состоящего из блоков \( M_1 \) и \( M_2 \) (после дополнения), то можем определить **Hash(\( M_1 \| M_2 \| M_3 \))** для любого блока \( M_3 \). Поскольку хеш \( M_1 \| M_2 \) — это цепное значение, следующее непосредственно за \( M_2 \), можно добавить еще один блок \( M_3 \) к хешированному сообщению, даже не зная, какие данные хешировались. Более того,