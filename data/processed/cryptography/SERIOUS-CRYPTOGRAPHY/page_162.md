---
source_image: page_162.png
page_number: 162
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 42.95
tokens: 7978
characters: 2959
timestamp: 2025-12-24T09:14:42.672811
finish_reason: stop
---

этот прием обобщается на любое число блоков в неизвестном сообщении (здесь \( M_1 \parallel M_2 \)) или в суффиксе (здесь \( M_3 \)).

Атака удлинением сообщения неприменима к большинству приложений функций хеширования, но может скомпрометировать безопасность, если хеш используется чересчур творчески. К сожалению, хеш-функции семейства SHA-2 уязвимы к атаке удлинением сообщения, несмотря на то что проектировавшие их АНБ и отвечавший за стандартизацию NIST прекрасно знали об этом дефекте. Данного дефекта можно было бы избежать, просто сделав последний вызов функции сжатия отличающимся от всех остальных (например, добавив параметр, который принимает значение 1, тогда как для предыдущих вызовов он равен 0). Именно так, кстати, и поступает BLAKE2.

Обман протоколов доказательства хранения

В облачных приложениях хеш-функции используются в протоколах доказательства хранения, с помощью которых сервер (поставщик облачных услуг) доказывает клиенту (пользователю услуг облачного хранения), что он действительно хранит файлы, который должен хранить по поручению клиента.

В 2007 году в статье Ramakrishna Kotla, Lorenzo Alvisi, Mike Dahlin «SafeStore: A Durable and Practical Storage System» (https://www.cs.utexas.edu/~lorenzo/papers/p129-kotla.pdf) предложили следующий протокол доказательства хранения, верифицирующий хранение файла \( M \).

1. Клиент выбирает случайное значение \( C \), вопрос.
2. Сервер вычисляет ответ \( \text{Hash}(M \parallel C) \) и отправляет его клиенту.
3. Клиент также вычисляет \( \text{Hash}(M \parallel C) \) и проверяет, что результат совпадает со значением, полученным от сервера.

Идея заключается в том, что сервер не сможет обмануть клиента, потому что, не зная \( M \), не сумеет угадать значение \( \text{Hash}(M \parallel C) \). Но тут есть подвох: на самом деле функция \( \text{Hash} \) итеративно обрабатывает входные данные поблочно, вычисляя промежуточные цепные значения между блоками. Например, если \( \text{Hash} \) — хеш-функция SHA-256, а \( M \) — 512-битовый блок (размер блока в SHA-256), то сервер может обмануть клиента. Как? При первом получении \( M \) он вычисляет \( H_1 = \text{Compress}(H_0, M_1) \), цепное значение, полученное SHA-256 по начальному значению, \( H_0 \), 512-битовому \( M \). Затем он сохраняет \( H_1 \) в памяти и отбрасывает \( M \); начиная с этого момента он может уже не хранить \( M \).

Теперь, когда клиент посылает случайное значение \( C \), сервер вычисляет \( \text{Compress}(H_1, C) \), дополнив предварительно \( C \) до полного блока, и возвращает результат в виде \( \text{Hash}(M \parallel C) \). Поскольку сервер вернул правильное значение \( \text{Hash}(M \parallel C) \), клиент верит, что сервер хранит полное сообщение, хотя, как мы только что видели, это может быть не так.

Этот трюк будет работать для SHA-1, SHA-2, а также для SHA-3 и BLAKE2. Решение простое: запрашивать \( \text{Hash}(C \parallel M) \), а не \( \text{Hash}(M \parallel C) \).