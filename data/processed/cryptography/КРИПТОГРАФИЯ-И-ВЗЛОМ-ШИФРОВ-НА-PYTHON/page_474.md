---
source_image: page_474.png
page_number: 474
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 29.99
tokens: 7489
characters: 2117
timestamp: 2025-12-24T08:58:19.901930
finish_reason: stop
---

Вспомните, что формат зашифрованного файла — это три целых числа, разделенных символами подчеркивания. Они задают длину сообщения, размер блока и собственно зашифрованные блоки. В строке 140 вызывается метод split(), возвращающий указанные три значения в виде списка. С помощью операции группового присваивания эти значения сохраняются в переменных messageLength, blockSize и encryptedMessage соответственно.

Поскольку метод split() возвращает строки, содержимое переменных messageLength и blockSize преобразуется в целые числа с помощью функции int() (строки 141 и 142).

В функции также проверяется, чтобы размер блока не превышал длину ключа (строка 145).

144. # Проверяем, достаточно ли длины ключа для данного размера блока
145. if not (math.log(2 ** keySize, len(SYMBOLS)) >= blockSize):
146.     sys.exit('ERROR: Block size is too large for the key and symbol set size. Did you specify the correct key file and encrypted file? ')

Чаще всего это формальная проверка, ведь если бы размер блока был слишком большим, то зашифрованный файл вообще не был бы создан. Наиболее вероятной причиной ошибки может стать неверно заданный файл закрытого ключа в параметре keyFilename, а это означает, что сообщение в любом случае было бы дешифровано некорректно.

Строка encryptedMessage содержит несколько блоков, разделенных запятыми, которые мы преобразуем обратно в целые числа и сохраняем в списке encryptedBlocks.

148. # Преобразуем зашифрованное сообщение в целочисленные блоки
149. encryptedBlocks = []
150. for block in encryptedMessage.split(','):
151.     encryptedBlocks.append(int(block))

В цикле for, который начинается в строке 150, мы проходим по списку блоков, созданному путем вызова метода split() для строки encryptedMessage. Список содержит строковые значения блоков, которые преобразуются в целочисленный вид и добавляются в список encryptedBlock (строка 151). По завершении цикла список encryptedBlocks будет содержать целочисленные блоки зашифрованного сообщения.

В строке 154 список encryptedBlocks передается функции decryptMessage() вместе с аргументом messageLength (длина сообщения), закры-