---
source_image: page_455.png
page_number: 455
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 28.49
tokens: 7587
characters: 2236
timestamp: 2025-12-24T08:57:42.102183
finish_reason: stop
---

сложной. Для выполнения необходимых расчетов мы воспользуемся функцией isPrime() из программы primeNum.py, которую написали в главе 22.

Функцию isPrime() можно видоизменить таким образом, чтобы она возвращала первые из найденных множителей, поскольку нам известно, что для n могут существовать лишь два делителя, отличных от единицы и самого числа n.

def isPrime(num):
    # Возвращает (p,q), где p и q - делители num.
    # Проверяем, делится ли num на какое-либо из
    # чисел, меньших квадратного корня из num
    for i in range(2, int(math.sqrt(num)) + 1):
        if num % i == 0:
            return (i, num / i)
    return None  # делители не найдены, значит, num - простое число

Если бы мы захотели написать программу для взлома шифра с открытым ключом, то могли бы просто вызывать эту функцию, передавать ей число n (которое можно взять из файла открытого ключа) и ждать, пока она не найдет множители p и q. Далее можно было бы вычислить произведение (p - 1)(q - 1), а затем — модульное обращение e mod (p - 1)(q - 1), получив тем самым ключ дешифрования d. После этого не составило бы труда вычислить M, т.е. исходный текст.

Есть лишь одна проблема. Вспомните, что n представляет собой число, для записи которого требуется около 600 цифр. Функция math.sqrt() не в состоянии обрабатывать столь большие числа, поэтому она выдаст сообщение об ошибке. Но даже если бы она поддерживала такие числа, цикл for выполнялся бы очень долго. Компьютеру не хватило бы и 5 миллиардов лет непрерывной работы, настолько велики эти числа!

Именно этим и объясняется стойкость шифров с открытым ключом: с математической точки зрения никакого обходного пути для нахождения делителей больших чисел не существует. Нет ничего проще, чем взять два простых числа p и q и перемножить их для получения числа n. В то же время крайне трудоемко решить обратную задачу: найти для достаточно большого числа n простые делители p и q. Если взять небольшое число, скажем, 15, то легко определить, что его можно разложить на множители 5 и 3. Но ситуация кардинальным образом изменится, если попытаться разложить на множители такое, например, число, как 178 565 887 643 607 245 654 502 737. Вот почему шифры с открытым ключом практически невозможно взломать.