---
source_image: page_408.png
page_number: 408
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 27.88
tokens: 7397
characters: 1818
timestamp: 2025-12-24T08:56:24.778834
finish_reason: stop
---

да истинная случайность не нужна. Можно также воспользоваться функцией secrets.choice(), которая возвращает случайно выбранный элемент из переданной ей строки или списка.

>>> import secrets
>>> secrets.choice('ABCDEFGHIJKLMNOPQRSTUVWXYZ')
'R'
>>> secrets.choice(['cat', 'dog', 'mouse'])
'dog'

Для создания истинно случайного одноразового шифроблокнота размером 55 символов можно использовать следующий код.

>>> import secrets
>>> otp = ''
>>> for i in range(55):
...     otp += secrets.choice('ABCDEFGHIJKLMNOPQRSTUVWXYZ')
...
>>> otp
'MVOVAAYDPELIRNRUZNQHDNSOUWWNWPJUPIUAIMKFKNHQANIIYCHHDC'

Кроме того, существует еще одно обстоятельство, о котором никогда нельзя забывать при работе с одноразовым шифроблокнотом. Рассмотрим, почему следует избегать повторного использования одноразовых шифроблокнотов.

Избегайте двухразовых шифроблокнотов

Под двухразовым шифроблокнотом понимают использование одного и того же ключа одноразового шифроблокнота для шифрования двух разных сообщений. Это создает критическую уязвимость.

Как уже говорилось ранее, тот факт, что результат расшифровки сообщения, зашифрованного с помощью одноразового шифроблокнота, представляет собой осмысленный текст на английском языке, еще не означает, что найден правильный ключ. Но если вы используете один и тот же ключ для шифрования двух разных сообщений, то тем самым предоставите взломщику ценнейшую информацию. В этом случае взломщик, получив осмысленный текст в результате дешифрования первого шифротекста с помощью найденного ключа и увидев, что применение этого же ключа ко второму шифротексту дает случайный набор букв, сразу же поймет, что ключ не подходит. Как будет показано в следующем разделе, существует очень высокая вероятность того, что лишь один ключ позволяет получить осмысленные тексты при дешифровании обоих сообщений.