---
source_image: page_190.png
page_number: 190
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 41.08
tokens: 7556
characters: 2139
timestamp: 2025-12-24T08:50:49.510952
finish_reason: stop
---

Поскольку функция time.time() возвращает вещественное значение, оно может выводиться с точностью до миллисекунды (1/1000 секунды). Разумеется, числа, отображаемые функцией time.time(), зависят от того, в какой момент времени она вызывается, а их непосредственная интерпретация несколько затруднительна. С первого взгляда вовсе не очевидно, что значению 1540944000.7197928 соответствует примерное время 15:00, приходящееся на вторник, 30 октября 2018 года. В то же время функция time.time() очень удобна для определения количества секунд, прошедших между двумя ее вызовами. Мы используем эту функцию для определения того, как долго выполняется программа.

Например, если вычесть приведенные в предыдущем листинге вещественные значения, то можно узнать, сколько времени ушло на ввод второй инструкции в интерактивной оболочке.

>>> 1540944003.4817972 - 1540944000.7197928
2.7620043754577637

Если вам нужно написать код, работающий со значениями даты и времени, ознакомьтесь с описанием модуля datetime, доступным по следующему адресу:
https://automatetheboringstuff.com/chapter15/

Использование функции time.time() в программе

В строке 34 функция time.time() возвращает текущее время, которое сохраняется в переменной startTime. В строках 35–38 вызывается функция encryptMessage() или decryptMessage(), в зависимости от того, какая строка сохранена в переменной myMode: 'encrypt' или 'decrypt'.

33. # Измерить, как долго длится шифрование/дешифрование
34. startTime = time.time()
35. if myMode == 'encrypt':
36.     translated = transpositionEncrypt.encryptMessage(myKey, content)
37. elif myMode == 'decrypt':
38.     translated = transpositionDecrypt.decryptMessage(myKey, content)
39. totalTime = round(time.time() - startTime, 2)
40. print('%sion time: %s seconds' % (myMode.title(), totalTime))

В строке 39 функция time.time() вызывается вновь, и время, сохраненное в переменной startTime, вычитается из текущего времени. Результат представляет количество секунд, прошедших между двумя вызовами функции time.time(). Выражение time.time() - startTime передается функции round(), которая округляет его до двух десятичных знаков после