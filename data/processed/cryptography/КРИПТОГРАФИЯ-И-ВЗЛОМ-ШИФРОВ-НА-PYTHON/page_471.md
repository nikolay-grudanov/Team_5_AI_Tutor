---
source_image: page_471.png
page_number: 471
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 31.47
tokens: 7559
characters: 2276
timestamp: 2025-12-24T08:58:15.796358
finish_reason: stop
---

Функция имеет три строковых параметра: имя файла, в который необходимо записать зашифрованное сообщение (messageFilename), имя файла открытого ключа (keyFilename) и сообщение, подлежащее шифрованию (message). Необязательный четвертый параметр blockSize задает размер блока.

Первый шаг процесса шифрования — чтение значений keySize, n и e из файла ключа с помощью функции readKeyFile() (строка 107).

Для параметра blockSize предусмотрено значение по умолчанию None.

108. if blockSize == None:
109.     # Если параметр blockSize не задан, сделать его максимально допустимым для текущей длины ключа и размера набора символов
110.    blockSize = int(math.log(2 ** keySize, len(SYMBOLS)))

Если параметр blockSize не задан, то размер блока выбирается максимально допустимым для заданной длины ключа и используемого набора символов. Не забывайте о том, что должно выполняться условие \( 2^{\text{длина_ключа}} > \text{размер_набора_символов}^{\text{размер_блока}} \). Поэтому для определения предельного размера блока вызывается функция math.log(), которая вычисляет логарифм значения \( 2^{\text{длина_ключа}} \) по основанию len(SYMBOLS) (строка 110).

Арифметика шифрования с открытым ключом корректно работает лишь в том случае, если длина ключа равна или превышает размер блока, поэтому выполняемая в строке 112 проверка играет важную роль.

111.    # Проверяем, достаточно ли длины ключа для данного размера блока
112.    if not (math.log(2 ** keySize, len(SYMBOLS)) >= blockSize):
113.        sys.exit('ERROR: Block size is too large for the key and symbol set size. Did you specify the correct key file and encrypted file?')

Если длина ключа слишком мала, выводится сообщение об ошибке и программа завершает работу. В этом случае пользователь должен либо уменьшить значение параметра blockSize, либо использовать ключ большей длины.

Теперь, когда у нас имеются компоненты ключа n и e, можно вызвать функцию encryptMessage(), которая возвращает список целочисленных блоков.

114.    # Шифруем сообщение
115.    encryptedBlocks = encryptMessage(message, (n, e), blockSize)

Функция encryptMessage() ожидает, что ключ будет передан ей в виде кортежа из двух целых чисел. Именно поэтому переменные n и e помещаются в кортеж, который передается в качестве второго аргумента.