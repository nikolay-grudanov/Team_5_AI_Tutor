---
source_image: page_255.png
page_number: 255
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 43.09
tokens: 7771
characters: 2241
timestamp: 2025-12-24T08:52:32.347268
finish_reason: stop
---

8. key = keyA * len(affineCipher.SYMBOLS) + 1
9.
10. if cryptomath.gcd(keyA, len(affineCipher.SYMBOLS)) == 1:
11.     print(keyA, affineCipher.encryptMessage(key, message))

Эта программа импортирует модуль affineCipher, чтобы получить функцию encryptMessage(), и модуль cryptomath, чтобы получить функцию gcd(). Мы шифруем строку, содержащуюся в переменной message. Переменная цикла keyA пробегает значения в диапазоне от 2 до 80, поскольку значения 0 и 1 являются недопустимыми для ключа A, о чем было сказано выше.

На каждой итерации цикла ключ определяется в строке 8 на основе текущего значения keyA, а в качестве ключа B всегда используется значение 1, чем и объясняется прибавление 1 в конце. Учитывайте, что в допустимом ключе ключ A и размер символьного набора должны быть взаимно простыми числами. Для этого НОД ключа A и размера символьного набора должен быть равен 1, что проверяется в строке 10. Если данное условие не соблюдается, то вызов функции encryptMessage() в строке 11 будет пропущен.

Программа выводит одно и то же сообщение, зашифрованное с помощью различных целочисленных значений ключа A. Результаты работы программы выглядят примерно так.

5 0.xTvcin?dXv.XvXn8I3Tv.XvIDXnE3T,vEhcv?DcvXn8I3TS
7 Tz4Nn1ipKbtnztntpDY NnztnYRttp7 N,n781nKR1ntpDY Nm9
13 ZJHOP7ivuVtPJtPtvhGU0PJTPG8ttvWU0,PWF7Pu87PtvhGU0g3
17 HvTx.oizERX.vX.Xz2mkx.vX.mVXXz?kx,.?6o.EVo.Xz2mkxGy
--опущено--
67 Nblf!uijoht!bt!tjnqmf!bt!qpttjcmf,!cvu!opu!tjnqmfsA
71 0.xTvcin?dXv.XvXn8I3Tv.XvIDXnE3T,vEhcv?DcvXn8I3TS
73 Tz4Nn1ipKbtnztntpDY NnztnYRttp7 N,n781nKR1ntpDY Nm9
79 ZJHOP7ivuVtPJtPtvhGU0PJTPG8ttvWU0,PWF7Pu87PtvhGU0g3

Внимательно проанализировав результаты, можно заметить, что шифротексты, полученные с помощью ключей 5 и 71, совпадают! Более того, совпадение наблюдается еще и для ключей 7 и 73, а также ключей 13 и 79!

Обратите внимание на то, что, вычитая 5 из 71, мы получим 66, т.е. размер символьного набора. Вот почему ключ 71 приводит к тому же результату, что и ключ 5: результат повторяется через каждые 66 ключей. Как видите, аффинный шифр характеризуется тем же эффектом "завертывания" в отношении ключа A, что и в отношении ключа B. Резюмируя, можно утверждать, что значения ключа A также ограничены размером символьного набора.