---
source_image: page_243.png
page_number: 243
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 35.09
tokens: 7485
characters: 1572
timestamp: 2025-12-24T08:52:04.538928
finish_reason: stop
---

возвращает остаток от деления. Результатом вычисления выражения, содержащего оператор //, всегда будет целое, а не вещественное число. Как видите, результатом выражения 10 // 5 является 2, а не 2.0.

Исходный код модуля Cryptomath

Поскольку функции gcd() и findModInverse() будут использоваться в последующих главах, целесообразно поместить их в отдельный модуль. Откройте в редакторе файлов новое окно, введите в нем приведенный ниже код и сохраните его в файле cryptomath.py.

cryptomath.py

1. # Модуль Cryptomath
2. # https://www.nostarch.com/crackingcodes/ (BSD Licensed)
3.
4. def gcd(a, b):
5.     # Возвращает НОД чисел a и b, используя алгоритм Евклида
6.     while a != 0:
7.         a, b = b % a, a
8.     return b
9.
10.
11. def findModInverse(a, m):
12.     # Возвращает модульное обращение a % m,
13.     # т.е. такое число x, что a * x % m = 1
14.
15.     if gcd(a, m) != 1:
16.         return None    # модульное обращение отсутствует, если a и m не являются взаимно простыми числами
17.
18.     # Используем расширенный алгоритм Евклида
19.     u1, u2, u3 = 1, 0, a
20.     v1, v2, v3 = 0, 1, m
21.     while v3 != 0:
22.         q = u3 // v3   # здесь // - это оператор целочисленного деления
23.         v1, v2, v3, u1, u2, u3 = (u1 - q * v1), (u2 - q * v2),
24.             (u3 - q * v3), v1, v2, v3
25.     return u1 % m

Модуль содержит описанную ранее функцию gcd(), а также функцию findModInverse(), которая реализует расширенный алгоритм Евклида.

Импортировав модуль cryptomath.py, вы сможете поэкспериментировать с ним в интерактивной оболочке.