---
source_image: page_418.png
page_number: 418
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 37.20
tokens: 7672
characters: 1686
timestamp: 2025-12-24T08:56:47.123325
finish_reason: stop
---

Пример работы модуля primeNum

Чтобы увидеть, как работает модуль primeNum.py, введите в интерактивной оболочке следующие инструкции.

>>> import primeNum
>>> primeNum.generateLargePrime()
1228811683422110410305236835154432390074842906007015553694882717483780547
4400946375131251147129101194573241337844666680914050203700367321105215349
3607681619990563076859566835016382556518967124921538212397036345815983641
1460006716350196372183484555444359084284001925658496205096003124687579538
99553441648428119
>>> primeNum.isPrime(45943208739848451)
False
>>> primeNum.isPrime(13)
True

Благодаря модулю primeNum.py мы получаем возможность генерировать очень большие простые числа с помощью функции generateLargePrime(). Кроме того, можно передать любое число функции isPrime(), чтобы определить, является ли оно простым.

Как работает алгоритм перебора делителей

Чтобы узнать, является ли заданное число простым, мы используем алгоритм перебора делителей (trial division algorithm), в соответствии с которым делим число на целые числа (2, 3 и т.д.), проверяя, делится ли оно на них без остатка. Например, чтобы выяснить, является ли число 49 простым, мы проверим его делимость на целые числа, начиная с 2:

49 ÷ 2 = 24, остаток 1,
49 ÷ 3 = 16, остаток 1,
49 ÷ 4 = 12, остаток 1,
49 ÷ 5 = 9, остаток 4,
49 ÷ 6 = 8, остаток 1,
49 ÷ 7 = 7, остаток 0.

Поскольку 49 делится на 7 без остатка, мы определяем 7 как множитель 49. Это означает, что число 49 не может быть простым, поскольку имеет по крайней мере один множитель, отличный от единицы и самого числа.

Процесс можно ускорить, выполняя деление только на простые числа и пропуская составные. Как уже говорилось ранее, составные числа есть