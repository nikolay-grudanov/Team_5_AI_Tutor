---
source_image: page_449.png
page_number: 449
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 29.43
tokens: 7500
characters: 1682
timestamp: 2025-12-24T08:57:34.366048
finish_reason: stop
---

>>> 7 * (66 ** 0)
7
>>> blockInteger = blockInteger + 7

Далее находим аналогичный индекс для 'o' — второго символа в строке 'Howdy'. Так как это второй символ в сообщении, умножаем его индекс в символьном наборе на 66^1, а не на 66^0, и прибавляем результат к блоку.

>>> SYMBOLS.index('o')
40
>>> blockInteger += 40 * (66 ** 1)
>>> blockInteger
2647

Теперь целочисленное значение блока равно 2647. Мы можем сократить процесс нахождения индекса каждого символа, используя одну строку кода.

>>> blockInteger += SYMBOLS.index('w') * (len(SYMBOLS) ** 2)
>>> blockInteger += SYMBOLS.index('d') * (len(SYMBOLS) ** 3)
>>> blockInteger += SYMBOLS.index('y') * (len(SYMBOLS) ** 4)
>>> blockInteger
957285919

В результате кодирования строки 'Howdy' в один большой целочисленный блок мы получаем целое число 957 285 919, уникальным образом представляющее эту строку. Продолжая возводить число 66 во все большую степень, мы можем сформировать большое целое число для замещения строки любой длины вплоть до размера блока. Например, блок 277 981 представляет строку '42!', а блок 10 627 106 169 278 065 987 481 042 235 655 809 080 528 — строку 'I named my cat Zophie.'.

В связи с тем что размер нашего блока равен 169, в одном блоке можно зашифровать не более 169 символов. Если длина сообщения, которое мы хотим закодировать, превышает 169 символов, придется создавать дополнительные блоки. В программе publicKeyCipher.py блоки будут разделяться запятыми, чтобы пользователь видел, где заканчивается один блок и начинается следующий.

В табл. 24.1 приведен пример сообщения, разбитого на блоки, и показаны целые числа каждого блока. В блоке может храниться не более 169 символов сообщения.