---
source_image: page_115.png
page_number: 115
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 31.13
tokens: 7446
characters: 1764
timestamp: 2025-12-24T08:48:49.385264
finish_reason: stop
---

Дешифрование сообщения

В теле цикла программа добавляет дешифрованный текст в конец строки, хранящейся в переменной translated. В строке 11 значение translated устанавливается равным пустой строке.

7. # Цикл по всем возможным значениям ключа
8. for key in range(len(SYMBOLS)):
9.    # Важно присвоить пустую строку переменной translated,
10.   # чтобы очистить ее от значения из предыдущей итерации
11.   translated = ''

Очень важно то, что в начале цикла for мы каждый раз переустанавливаем переменную translated в пустую строку. Если этого не делать, то текст, дешифрованный с помощью текущего ключа, будет добавлен к хранящемуся в переменной translated дешифрованному тексту, оставшемуся после выполнения предыдущей итерации цикла.

Строки с 16 по 30 почти совпадают с аналогичными строками программы шифрования на основе шифра Цезаря, рассмотренной в главе 5, но они немного проще, поскольку предназначены только для дешифрования текста.

13.   # Остальная часть программы почти не изменилась
14.
15.   # Цикл по всем символам сообщения
16.   for symbol in message:
17.     if symbol in SYMBOLS:
18.       symbolIndex = SYMBOLS.find(symbol)

В строке 16 мы организуем цикл по всем символам зашифрованной строки, хранящейся в переменной message. На каждой итерации цикла в строке 17 проверяется, входит ли текущий символ в набор, хранящийся в константе SYMBOLS, и, если это так, символ дешифруется. В строке 18 с помощью метода find() мы находим индекс символа в строке SYMBOLS и сохраняем его в переменной symbolIndex.

Затем мы вычитаем значение ключа из переменной symbolIndex в строке 19.

19.   translatedIndex = symbolIndex - key
20.
21.   # Обработка заворачивания
22.   if translatedIndex < 0:
23.     translatedIndex = translatedIndex + len(SYMBOLS)