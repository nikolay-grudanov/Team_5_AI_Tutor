---
source_image: page_440.png
page_number: 440
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 26.38
tokens: 7531
characters: 1928
timestamp: 2025-12-24T08:57:13.552149
finish_reason: stop
---

помощью открытого ключа, необходимо использовать ключи длиной 2048 или даже 3072 бита.

Генерирование ключей с помощью функции generateKey()

Для создания ключей прежде всего необходимо получить два случайных простых числа \( p \) и \( q \). Эти числа должны быть достаточно большими и отличаться друг от друга.

13. def generateKey(keySize):
14.     # Создает открытый и закрытый ключи длиной keySize бит
15.     p = 0
16.     q = 0
17.     # Шаг 1: создаем два простых числа p and q и вычисляем n = p * q
18.     print('Generating p & q primes...')
19.     while p == q:
20.         p = primeNum.generateLargePrime(keySize)
21.         q = primeNum.generateLargePrime(keySize)
22.     n = p * q

Функция generateLargePrime() из программы primeNum.py (см. главу 22) возвращает два простых числа (строки 20 и 21), которые сохраняются в переменных p и q. Цикл продолжается до тех пор, пока переменные p и q не будут различаться. Переменная keySize определяет размеры чисел p и q в битах. В строке 22 мы перемножаем p и q и сохраняем их произведение в переменной n.

На следующем этапе вычисляется другая часть открытого ключа: e.

Вычисление значения e

Значение e вычисляется путем нахождения числа, являющегося взаимно простым с произведением \((p-1)(q-1)\). Мы не будем вдаваться в подробности того, почему e вычисляется именно так, а лишь отметим, что это необходимо для получения уникального шифротекста.

Число, взаимно простое с произведением чисел \(p-1\) и \(q-1\), вычисляется с помощью бесконечного цикла, который начинается в строке 26.

24.     # Шаг 2: создаем число e, взаимно простое с (p-1)*(q-1)
25.     print('Generating e that is relatively prime to (p-1)*(q-1)...')
26.     while True:
27.         # Перебираем случайные числа для e, пока не найдем допустимое
28.         e = random.randrange(2 ** (keySize - 1), 2 ** (keySize))
29.         if cryptomath.gcd(e, (p - 1) * (q - 1)) == 1:
30.             break