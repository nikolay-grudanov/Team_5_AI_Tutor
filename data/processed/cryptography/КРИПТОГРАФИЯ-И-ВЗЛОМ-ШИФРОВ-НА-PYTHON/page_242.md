---
source_image: page_242.png
page_number: 242
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 33.23
tokens: 7472
characters: 1697
timestamp: 2025-12-24T08:52:02.626952
finish_reason: stop
---

К счастью, для нахождения модульного обращения можно использовать расширенный алгоритм Евклида, пример реализации которого приведен ниже.

def findModInverse(a, m):
    if gcd(a, m) != 1:
        return None  # модульное обращение отсутствует, если a и m
                      # не являются взаимно простыми числами
    u1, u2, u3 = 1, 0, a
    v1, v2, v3 = 0, 1, m
    while v3 != 0:
        q = u3 // v3  # здесь // - это оператор целочисленного деления
        v1, v2, v3, u1, u2, u3 = (u1 - q * v1), (u2 - q * v2),
                                 (u3 - q * v3), v1, v2, v3
    return u1 % m

Чтобы использовать функцию findModInverse(), вам не обязательно знать, как работает расширенный алгоритм Евклида. Если два аргумента, которые вы передаете функции, являются взаимно простыми числами, то она вернет модульное обращение ключа a.

Более подробную информацию о том, как работает расширенный алгоритм Евклида, можно найти в Википедии:

https://ru.wikipedia.org/wiki/Алгоритм_Евклида

Оператор целочисленного деления

Возможно, вы обратили внимание на оператор //, который используется в функции findModInverse(), приведенной в предыдущем разделе. Это оператор целочисленного деления. Он выполняет деление двух целых чисел и округляет результат вниз до ближайшего целого. Чтобы увидеть, как работает оператор //, введите в интерактивной оболочке следующие выражения.

>>> 41 / 7
5.857142857142857
>>> 41 // 7
5
>>> 10 // 5
2

В то время как результатом выражения 41 / 7 является число 5,857142857142857, результат выражения 41 // 7 равен 5. В тех случаях, когда числа не делятся нацело, оператор // полезен для получения целочисленной части ответа (ее называют частным), тогда как оператор %