---
source_image: page_237.png
page_number: 237
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 30.94
tokens: 7460
characters: 1603
timestamp: 2025-12-24T08:51:51.859861
finish_reason: stop
---

a, b = b % a, a

a, b = 32 % 24, 24 ← Вычисление b mod a

a, b = 8 , 24 ← Цикл продолжается, поскольку a != 0

a, b = b % a, a ← Групповое присваивание с перестановкой значений

a, b = 24 % 8, 8 ← Вычисление b mod a

a, b = 0 , 8 ← Цикл завершается, поскольку a = 0

b = 8 ← Окончательным значением b является НОД

Рис. 13.8. Схема работы функции gcd()

Огромным достоинством функции gcd() является то, что она легко справляется с большими числами.

>>> gcd(409119243, 87780243)
6837

Функция gcd() пригодится нам при выборе допустимых ключей для мультипликативного и аффинного шифров, о чем мы поговорим далее.

Как работают мультипликативный и аффинный шифры

В шифре Цезаря шифрование и дешифрование символов реализуется путем их преобразования в числа, добавления или вычитания ключа и последующего обратного преобразования новых чисел в символы.

В случае шифрования с помощью мультипликативного шифра мы умножаем индекс на ключ. Например, если мы шифруем букву 'E' с помощью ключа 3, то нужно найти ее индекс (4) и умножить его на ключ (3), чтобы получить индекс зашифрованной буквы (4 · 3 = 12), которому соответствует буква 'M'.

Если результат умножения превышает общее количество букв, то мультипликативный шифр сталкивается с той же проблемой "завертывания", что и шифр Цезаря, но теперь мы можем использовать для решения проблемы оператор mod. Например, в шифре Цезаря переменная SYMBOLS содержала строку 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyzvwxyz1234567890 !?. '. Ниже приведена таблица, включающая несколько первых и последних символов строки SYMBOLS вместе с их индексами.