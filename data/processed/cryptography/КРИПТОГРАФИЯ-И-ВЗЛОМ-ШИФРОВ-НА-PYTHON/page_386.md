---
source_image: page_386.png
page_number: 386
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 31.74
tokens: 7515
characters: 2102
timestamp: 2025-12-24T08:55:48.514235
finish_reason: stop
---

жать словарь, сопоставляющий строковые последовательности со списками множителей интервалов повторения. Благодаря этому мы получаем информацию не только об интервалах повторения, но и об их множителях.

В строке 125 словарь seqFactors передается функции getMostCommonFactors(), возвращающей список кортежей из двух целых чисел, первое из которых представляет множитель, а второе — количество появлений этого множителя в словаре seqFactors. Данный список сохраняется в переменной factorsByCount.

125. factorsByCount = getMostCommonFactors(seqFactors)

Но нам все-таки нужно, чтобы функция kasiskiExamination() возвращала список множителей, а не список кортежей. Поскольку множители хранятся в первых элементах кортежей списка factorsByCount, мы должны извлечь их из кортежей и сформировать из них отдельный список.

Извлечение множителей из списка factorsByCount

В строках 130–134 список множителей сохраняется в переменной allLikelyKeyLengths.

130. allLikelyKeyLengths = []
131. for twoIntTuple in factorsByCount:
132.     allLikelyKeyLengths.append(twoIntTuple[0])
133.
134. return allLikelyKeyLengths

В цикле for, который начинается в строке 131, программа проходит по всем кортежам списка factorsByCount и добавляет элемент кортежа с индексом 0 в конец списка allLikelyKeyLengths. По завершении цикла переменная allLikelyKeyLengths будет содержать все целочисленные множители из словаря factorsByCount, которые возвращаются в виде списка функцией kasiskiExamination().

Теперь мы можем определить наиболее вероятную длину ключа, с помощью которого было зашифровано сообщение, но нам еще нужно иметь возможность выделить из сообщения буквы, зашифрованные одним и тем же подключом. Вспомните: в случае шифрования сообщения 'THEDOGANDTHECAT' ключом 'XYZ' подключ 'X' будет применяться для шифрования букв сообщения с индексами 0, 3, 6, 9 и 12. Поскольку буквы исходного сообщения шифруются одним и тем же подключом ('X'), частотность этих букв в дешифрованном тексте должна быть близка к частотности букв в типичных английских текстах. Данную информацию можно задействовать для нахождения подключа.