---
source_image: page_254.png
page_number: 254
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 35.40
tokens: 7554
characters: 2095
timestamp: 2025-12-24T08:52:20.715946
finish_reason: stop
---

37. if cryptomath.gcd(keyA, len(SYMBOLS)) != 1:
38.     sys.exit('Key A (%s) and the symbol set size (%s) are not relatively prime. Choose a different key.' % (keyA, len(SYMBOLS)))

Если все условия в функции checkKeys() возвращают значение False, то это означает, что никаких проблем с ключами нет. В таком случае выполнение программы продолжается со строки, следующей за той, из которой была вызвана функция checkKeys().

Сколько ключей может иметь аффинный шифр

Попробуем вычислить количество возможных ключей аффинного шифра. Ключ B ограничен размером символьного набора, равным len(SYMBOLS), т.е. 66. На первый взгляд кажется, будто ключ A может быть сколь угодно большим, лишь бы он и размер символьного набора были взаимно простыми числами. В результате складывается впечатление, будто аффинный шифр может иметь бесконечное количество ключей, а значит, его невозможно взломать методом грубой силы.

Однако это не так. Вспомните о том, что большие ключи в шифре Цезаря оказывались равными меньшим ключам благодаря эффекту "завертывания". В случае символьного набора размером 66 ключ 67 в шифре Цезаря создаст тот же зашифрованный текст, что и ключ 1. Аффинному шифру также свойственно подобное "завертывание".

Поскольку ключ B аффинного шифра совпадает с ключом шифра Цезаря, его значения могут изменяться в пределах от 1 до размера символьного набора. Чтобы проверить, не обнаружатся ли какие-то ограничения для ключа A, мы напишем небольшую программу, которая проверит целочисленные значения ключа A в определенном диапазоне, и посмотрим, как будет выглядеть соответствующий шифротекст.

Откройте в редакторе файлов новое окно, введите приведенный ниже код и сохраните его в файле affineKeyTest.py в той же папке, где находятся файлы affineCipher.py и cryptomath.py. Запустите программу, нажав клавишу <F5>.

affineKeyTest.py

1. # Эта программа доказывает, что размерность пространства ключей аффинного шифра ограничена значением len(SYMBOLS)^2
2.
3.
4. import affineCipher, cryptomath
5.
6. message = 'Make things as simple as possible, but not simpler.'
7. for keyA in range(2, 80):