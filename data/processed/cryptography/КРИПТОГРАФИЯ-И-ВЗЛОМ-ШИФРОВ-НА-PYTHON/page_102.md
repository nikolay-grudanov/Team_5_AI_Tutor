---
source_image: page_102.png
page_number: 102
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 26.65
tokens: 7377
characters: 1661
timestamp: 2025-12-24T08:48:24.840536
finish_reason: stop
---

>>> 'hello'.find('ello')
1
>>> 'hello'.find('lo')
3
>>> 'hello hello'.find('e')
1

Строковый метод find() напоминает более специализированную версию оператора in. Он сообщает не только о том, содержится ли одна строка в другой, но и том, начиная с какой именно позиции она встречается.

Шифрование и дешифрование символов

Теперь, когда мы разобрались в том, как работают инструкции if, elif и else, а также оператор in и строковый метод find(), вам будет проще понять, как работает оставшаяся часть программы шифрования на основе шифра Цезаря.

Программа способна шифровать и дешифровать только символы, входящие в состав заданного символьного набора.

23.    if symbol in SYMBOLS:
24.        symbolIndex = SYMBOLS.find(symbol)

Поэтому, прежде чем выполнить код в строке 24, программа должна определить, содержится ли символ в поддерживаемом наборе. После этого она определяет индекс строки SYMBOLS, начиная с которого располагается строка symbol. Индекс, возвращаемый методом find(), сохраняется в переменной symbolIndex.

Располагая индексом текущего символа, сохраненным в переменной symbolIndex, мы можем применить к нему операции шифрования/дешифрования. Шифр Цезаря добавляет значение ключа к индексу символа при его шифровании или вычитает значение ключа из индекса символа при его дешифровании. Полученное значение сохраняется в переменной translatedIndex, поскольку оно будет служить индексом в строке SYMBOLS, соответствующим преобразованному символу.

26.    # Выполнить шифрование/дешифрование
27.    if mode == 'encrypt':
28.        translatedIndex = symbolIndex + key
29.    elif mode == 'decrypt':
30.        translatedIndex = symbolIndex - key