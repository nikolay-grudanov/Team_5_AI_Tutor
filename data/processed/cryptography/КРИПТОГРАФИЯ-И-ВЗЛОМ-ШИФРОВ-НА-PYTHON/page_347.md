---
source_image: page_347.png
page_number: 347
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 35.55
tokens: 7621
characters: 2138
timestamp: 2025-12-24T08:54:49.656685
finish_reason: stop
---

30. # Во-вторых, создаем словарь счетчиков частотности
31. # со списком букв по каждому счетчику
32. freqToLetter = {}
33. for letter in LETTERS:
34.     if letterToFreq[letter] not in freqToLetter:
35.         freqToLetter[letterToFreq[letter]] = [letter]
36.     else:
37.         freqToLetter[letterToFreq[letter]].append(letter)

В строке 33 начинается цикл по всем буквам строки LETTERS. Инструкция if в строке 34 проверяет, содержится ли показатель частотности буквы, т.е. letterToFreq[letter], в виде ключа в словаре freqToLetter. Если это не так, то в строке 35 ключ добавляется в словарь, а в качестве спискового значения задается буква. Если же ключ уже содержится в словаре freqToLetter, то соответствующая буква добавляется в конец списка.

Если взять в качестве примера словарь letterToFreq, созданный для строки """Alan Mathison Turing...""", то словарь freqToLetter будет выглядеть так.

{1: ['Z'], 2: ['J', 'Q'], 3: ['X'], 135: ['A'], 8: ['K'], 139: ['I'], 140: ['T'], 14: ['V'], 21: ['Y'], 30: ['B', 'W'], 36: ['P'], 37: ['F', 'U'], 39: ['G'], 58: ['D', 'M'], 62: ['L'], 196: ['E'], 74: ['C'], 87: ['H'], 89: ['S'], 106: ['R'], 113: ['O'], 122: ['N']}

Обратите внимание на то, что теперь ключи словаря содержат счетчики частотности, а значения превратились в списки букв, имеющих данную частотность.

Сортировка списков букв в порядке, обратном порядку ETAOIN

Третий этап, выполняемый функцией getFrequencyOrder(), включает сортировку букв в каждом списке freqToLetter. Вспомните, что значением freqToLetter[freq] является список букв, соответствующих значению частотности freq. Мы используем список, поскольку одну и ту же частотность могут иметь несколько букв.

Когда у нескольких букв одинаковая частотность, мы сортируем их в порядке, обратном порядку их появления в строке ETAOIN. Это делает их сортировку согласованной и минимизирует вероятность случайного увеличения оценки частотного соответствия.

Предположим, например, что в оцениваемой строке у букв 'V', 'I', 'N' и 'K' одинаковая частотность. Также предположим, что у четырех букв в этой строке выше частотность, а у восемнадцати букв — меньше. Используем