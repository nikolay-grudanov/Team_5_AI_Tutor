---
source_image: page_407.png
page_number: 407
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 30.91
tokens: 7470
characters: 2013
timestamp: 2025-12-24T08:56:24.729734
finish_reason: stop
---

Причина, по которой мы вообще способны взломать какой-либо шифр, заключается в том, что обычно существует лишь один ключ, применение которого для дешифрования сообщения позволяет получить осмысленный текст на английском языке. Но, как только что было показано на конкретном примере, один и тот же шифротекст может быть получен для двух совершенно разных сообщений. В случае одноразового шифроблокнота у криптоаналитика нет возможности определить, какое из них является истинным. По сути, любое сообщение на английском языке, насчитывающее ровно 55 букв, может с равной вероятностью оказаться истинным. Одного лишь факта получения осмысленного текста на английском языке недостаточно для определения исходного ключа шифрования.

Поскольку для получения шифротекста с равной вероятностью мог быть использован любой текст на английском языке, сообщение, зашифрованное с помощью одноразового шифроблокнота, не поддается взлому.

Создание истинно случайного ключа

Как обсуждалось в главе 9, встроенный модуль random не позволяет получать истинно случайные числа. Применяемый алгоритм генерирует так называемые псевдослучайные числа, которые лишь кажутся случайными, чего вполне достаточно в большинстве задач. Однако в случае одноразового шифроблокнота ключ должен быть истинно случайным числом, в противном случае шифр теряет свою абсолютную криптографическую стойкость.

В Python версии 3.6 и выше имеется модуль secrets, который в качестве источника истинно случайных чисел использует операционную систему (чаще всего таким источником служат случайные события, например промежуток времени между последовательными нажатиями клавиш). Функция secrets.randbelow() возвращает истинно случайное число в диапазоне от 0 до значения, определяемого аргументом (не включая его самого).

>>> import secrets
>>> secrets.randbelow(10)
2
>>> secrets.randbelow(10)
0
>>> secrets.randbelow(10)
6

Функции модуля secrets работают медленнее по сравнению с функциями модуля random, поэтому последние предпочтительнее в ситуациях, ког-