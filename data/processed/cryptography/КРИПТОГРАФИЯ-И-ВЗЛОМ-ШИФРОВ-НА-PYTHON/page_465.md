---
source_image: page_465.png
page_number: 465
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 32.55
tokens: 7640
characters: 2481
timestamp: 2025-12-24T08:58:06.966571
finish_reason: stop
---

Для хранения создаваемого блока предназначена переменная blockInt, первоначально равная 0 (строка 45). Во вложенном цикле for, который начинается в строке 46, переменная i последовательно становится равной индексам всех символов сообщения, включаемых в блок. Индексы стартуют от значения blockStart и достигают значения blockStart + blockSize либо len(message), в зависимости от того, что меньше. Функция min() в строке 46 возвращает наименьшее из двух значений.

Второй аргумент функции range() в строке 46 должен быть наименьшим из значений blockStart + blockSize и len(message), поскольку каждый блок всегда состоит из 128 символов (или другого фиксированного значения, задаваемого переменной blockSize), за исключением последнего блока. Последний блок может содержать ровно 128 символов, но гораздо вероятнее, что их будет меньше. В таком случае мы хотим ограничить переменную цикла i значением len(message), поскольку оно соответствует индексу последнего символа в сообщении.

Определив диапазон символов, составляющих блок, мы выполняем арифметическую операцию для преобразования символов в одно большое число. Вспомните, как в разделе "Преобразование строки в блок" мы создавали большое целое число путем умножения индекса каждого символа в символьном наборе на 66 индекс_символа (66 — это длина строки SYMBOLS). В программе мы умножаем значение SYMBOLS.index(message[i]) (целочисленный индекс символа в наборе) на выражение (len(SYMBOLS) ** (i % blockSize)) для каждого символа, и прибавляем результат к значению blockInt.

<table>
  <tr>
    <th>47.</th>
    <td>blockInt += (SYMBOLS.index(message[i])) * (len(SYMBOLS) ** (i % blockSize))</td>
  </tr>
</table>

Мы хотим, чтобы показателем степени служил индекс относительно начала текущего блока, который всегда будет изменяться от нуля до blockSize. Мы не можем напрямую использовать переменную i в качестве показателя степени индекс_символа, поскольку она индексирует всю строку сообщения, проходя значения от 0 до len(message). В таком случае мы получили бы индекс, намного больший, чем 66. Выполнив деление i по модулю blockSize, мы получаем индекс относительно начала блока; именно поэтому в строке 47 выполняется операция len(SYMBOLS) ** (i % blockSize), а не просто len(SYMBOLS) ** i.

По завершении вложенного цикла мы получаем целочисленное значение блока. В строке 48 это значение добавляется в список blockInts. На следующей итерации основного цикла, начатого в строке 43, вычисляется следующий блок сообщения.