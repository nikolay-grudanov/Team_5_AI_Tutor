---
source_image: page_311.png
page_number: 311
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 29.81
tokens: 7542
characters: 2068
timestamp: 2025-12-24T08:53:46.558262
finish_reason: stop
---

>>> letterMapping = simpleSubHacker.removeSolvedLettersFromMapping(intersectedMapping)
>>> intersectedMapping
{'A': [], 'C': ['T'], 'B': ['S'], 'E': [], 'D': [], 'G': ['B'], 'F': [], 'I': ['O'], 'H': ['M'], 'K': ['A'], 'J': [], 'M': ['D'], 'L': ['N'], 'O': ['U'], 'N': ['L'], 'Q': ['C'], 'P': ['I'], 'S': ['P'], 'R': ['R'], 'U': [], 'T': [], 'W': [], 'V': [], 'Y': [], 'X': ['F'], 'Z': ['E']}

Обратите внимание на то, что у буквы 'М' остался лишь один вариант дешифрования — 'Д', как мы и предсказывали. Более того, теперь у каждой шифробуквы имеется единственный вариант дешифрования, а значит, мы можем приступить к дешифрованию сообщения, используя полученный словарь. Нам еще раз понадобится обратиться к примеру в окне интерактивной оболочки, поэтому оставьте его открытым.

Функция hackSimpleSub()

Теперь, когда вы увидели на конкретных примерах, как функции getBlankCipherletterMapping(), addLettersToMapping(), intersectMappings() и removeSolvedLettersFromMapping() манипулируют словарями шифробукв, мы можем воспользоваться ими для дешифрования сообщения.

В строке 113 определяется функция hackSimpleSub(), которая получает шифротекст сообщения и задействует вспомогательные функции для того, чтобы вернуть частично или полностью решенный словарь шифробукв.

113. def hackSimpleSub(message):
114.     intersectedMap = getBlankCipherletterMapping()
115.     cipherwordList = nonLettersOrSpacePattern.sub('', message.upper()).split()

В строке 114 мы создаем новый словарь шифробукв и сохраняем его в переменной intersectedMap. В конечном счете эта переменная будет содержать объединенный словарь, являющийся пересечением словарей каждого из шифрослов.

В строке 115 мы удаляем из сообщения все небуквенные символы. Объекту регулярного выражения nonLettersOrSpacePattern соответствует любая строка, не являющаяся буквой или пробельным символом. Для этого объекта вызывается метод sub(), имеющий два аргумента. Данный метод ищет поисковые шаблоны во втором аргументе и заменяет их строкой, указанной в первом аргументе, после чего возвращает строку, в которой