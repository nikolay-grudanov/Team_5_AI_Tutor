---
source_image: page_174.png
page_number: 174
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 33.13
tokens: 7464
characters: 2009
timestamp: 2025-12-24T08:50:19.635119
finish_reason: stop
---

граммой мы выводим определенную информацию, чтобы можно было наблюдать за ходом тестирования:

20. print('Test #%s: "%s..."' % (i + 1, message[:50]))

Строка 20 содержит вызов функции print(), которая отображает номер выполняемого теста (мы прибавляем 1 к i, поскольку i начинается с 0, а номера тестов — с 1). Так как строка message может быть слишком длинной, мы используем срез строки, чтобы отображать только первые 50 символов сообщения.

В строке 20 применяется строковое форматирование. Значение i + 1 заменяет первую пару символов %s в строке, а значение message[:50] — вторую пару символов %s. Используя строковое форматирование, следите за тем, чтобы количество символов %s в строке совпадало с количеством аргументов, указанных после нее в круглых скобках.

Далее мы тестируем все возможные ключи. Если ключ для шифра Цезаря мог иметь целочисленные значения в пределах от 0 до 65 (длина символьного набора), то значения ключа для перестановочного шифра могут находиться в пределах от 1 до половины длины сообщения. В цикле for, который начинается в строке 23, выполняются соответствующие проверки.

22. # Проверяем все возможные ключи для каждого сообщения
23. for key in range(1, int(len(message)/2)):
24.     encrypted =
25.         transpositionEncrypt.encryptMessage(key, message)
26.     decrypted =
27.         transpositionDecrypt.decryptMessage(key, encrypted)

В строке 24 строка message шифруется с помощью функции encryptMessage(). Так как эта функция содержится в файле transpositionEncrypt.py, мы должны снабдить ее префиксом transpositionEncrypt. (с точкой в конце).

Затем зашифрованная строка, возвращенная функцией encryptMessage(), передается функции decryptMessage(). В обоих вызовах функции мы должны использовать один и тот же ключ. Значение, возвращенное функцией decryptMessage(), сохраняется в переменной decrypted. Если функции работают корректно, то строки, содержащиеся в переменных message и decrypted, должны совпадать. Рассмотрим, как программа выполняет эту проверку.