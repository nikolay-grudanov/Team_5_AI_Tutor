---
source_image: page_381.png
page_number: 381
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 26.85
tokens: 7407
characters: 1736
timestamp: 2025-12-24T08:55:38.952854
finish_reason: stop
---

скорее всего, будет равна именно ему. Но прежде чем мы сможем приступить к анализу частотности каждого множителя, необходимо воспользоваться функцией set() для удаления дубликатов множителей из списка factors. Например, если передать функции getUsefulFactors() аргумент 9, то проверка 9 % 3 == 0 вернет значение True, и к списку factors будет присоединено как значение i, так и значение int(num / i). Но оба выражения равны 3, поэтому 3 будет включено в список дважды. Во избежание появления дубликатов мы передаем список функции set(), которая преобразует список в множество. Тип данных set аналогичен типу данных list, за исключением того, что множество может включать лишь уникальные значения.

Передав список функции set(), мы получим множество, содержащее лишь уникальные элементы. В то же время, если передать множество функции list(), мы преобразуем его в список. Чтобы убедиться в этом, введите в интерактивной оболочке следующие инструкции.

>>> set([1, 2, 3, 3, 4])
{1, 2, 3, 4}
>>> spam = list(set([2, 2, 2, 'cats', 2, 2]))
>>> spam
[2, 'cats']

Преобразование списка в множество приводит к удалению из него дубликатов. После обратного преобразования множества в список последний тоже не будет содержать повторяющихся элементов.

Удаление дублирующихся множителей и сортировка списка

В строке 74 список factors передается функции set() для удаления дубликатов:

74. return list(set(factors)) # удаляем дубликаты

Функция getItemAtIndexOne() (строка 77) почти идентична функции getItemAtIndexZero() программы freqAnalysis.py, которую мы написали в главе 19.

77. def getItemAtIndexOne(x):
78.     return x[1]

Впоследствии эта функция будет передаваться методу sort() для сортировки списка на основании элемента с индексом 1.