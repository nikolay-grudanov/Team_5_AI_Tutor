---
source_image: page_103.png
page_number: 103
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 45.20
tokens: 7647
characters: 2508
timestamp: 2025-12-24T08:48:47.233754
finish_reason: stop
---

Переменная mode содержит строку, которая сообщает программе, что именно необходимо сделать с сообщением: зашифровать или дешифровать. Если переменная равна 'encrypt', то условие в строке 27 равно True, что приведет к выполнению строки 28, которая прибавит значение ключа к значению symbolIndex (блок, следующий за инструкцией elif, будет пропущен). В противном случае, если переменная mode равна 'decrypt', будет выполнена строка 30, которая вычтет значение ключа.

Обработка "завертывания" символьного набора

Когда мы реализовывали шифр Цезаря с помощью карандаша и бумаги в главе 1, то в некоторых случаях добавление или вычитание ключа приводило к значениям, превышающим или равным размеру символьного набора или даже меньшим нуля. В подобных случаях мы должны добавлять или вычитать длину символьного набора, чтобы автоматически возвращаться к началу или концу символьного набора. С этой целью мы используем вызов len(SYMBOLS), который возвращает значение 66, т.е. длину строки SYMBOLS. Обработка "завертывания" осуществляется в строках 33–36.

<table>
  <tr>
    <th>32.</th>
    <td># Обработать "завертывание", если необходимо</td>
  </tr>
  <tr>
    <th>33.</th>
    <td>if translatedIndex &gt;= len(SYMBOLS):</td>
  </tr>
  <tr>
    <th>34.</th>
    <td>translatedIndex = translatedIndex - len(SYMBOLS)</td>
  </tr>
  <tr>
    <th>35.</th>
    <td>elif translatedIndex &lt; 0:</td>
  </tr>
  <tr>
    <th>36.</th>
    <td>translatedIndex = translatedIndex + len(SYMBOLS)</td>
  </tr>
</table>

Если значение переменной translatedIndex превышает или равно 66, то условие в строке 33 оказывается истинным, и выполняется строка 34 (тогда как инструкция elif в строке 35 пропускается). Вычитание длины строки SYMBOLS из значения translatedIndex переводит индекс переменной обратно в начало строки SYMBOLS. В противном случае Python проверяет, не меньше ли нуля значение переменной translatedIndex. Если это так, то выполняется строка 36, и переменная translatedIndex "завертывается" вокруг конца строки SYMBOLS.

Возможно, вас удивляет, почему мы использовали вызов len(SYMBOLS), а не непосредственно значение 66. Это позволяет нам добавлять или удалять символы из набора SYMBOLS, не нарушая работу остальной части программы.

Теперь, когда в переменной translatedIndex хранится индекс преобразованного символа, мы можем получить сам символ с помощью выражения SYMBOLS[translatedIndex]. В строке 38 этот зашифрованный/дешифрованный символ добавляется в конец строки translated путем конкатенации строк: