---
source_image: page_253.png
page_number: 253
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 35.35
tokens: 7547
characters: 2126
timestamp: 2025-12-24T08:52:20.551899
finish_reason: stop
---

няет его. Если ключ А равен 1 и при этом ключ В равен 0, то "зашифрованный" текст будет совпадать с исходным сообщением. Другими словами, текст вообще окажется незашифрованным!

Мы выясняем стойкость ключей с помощью функции checkKeys(). Инструкции if в строках 31 и 33 проверяют, не равен ли параметр keyA единице, а параметр keyB — нулю.

30. def checkKeys(keyA, keyB, mode):
31.    if keyA == 1 and mode == 'encrypt':
32.        sys.exit('Cipher is weak if key A is 1. Choose a different key.')
33.    if keyB == 0 and mode == 'encrypt':
34.        sys.exit('Cipher is weak if key B is 0. Choose a different key.')

Если выполняется хотя бы одно из этих условий, то выполнение программы прекращается и выводится диагностическое сообщение. В строках 32 и 34 вызывается функция sys.exit(), которой передается текст сообщения об ошибке. Это необязательный параметр функции, позволяющий отобразить на экране строку, прежде чем работа программы будет завершена.

Проверка, выполняемая в строках 31 и 33, предотвращает шифрование слабыми ключами, но если переменная mode равна 'decrypt', то такая проверка опускается.

В строке 35 проверяется, не является ли значение keyA отрицательным числом, а также не является ли значение keyB отрицательным числом и не выходит ли оно за верхнюю границу допустимого диапазона (размер символьного набора минус 1).

35.    if keyA < 0 or keyB < 0 or keyB > len(SYMBOLS) - 1:
36.        sys.exit('Key A must be greater than 0 and Key B must be between 0 and %s.' % (len(SYMBOLS) - 1))

Причины, по которым на значения ключей наложены такие ограничения, будут описаны в следующем разделе. Если проверка хотя бы одного из указанных условий возвращает True, то ключи считаются недействительными и программа завершает работу.

Дополнительное условие заключается в том, что ключ А и размер символьного набора должны быть взаимно простыми числами. Это означает, что наибольший общий делитель значений keyA и len(SYMBOLS) должен быть равен 1. Данное условие проверяется в строке 37, тогда как в строке 38 осуществляется выход из программы, если указанные значения не являются взаимно простыми числами.