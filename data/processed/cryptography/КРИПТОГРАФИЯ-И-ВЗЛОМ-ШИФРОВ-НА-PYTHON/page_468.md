---
source_image: page_468.png
page_number: 468
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 23.58
tokens: 7445
characters: 1822
timestamp: 2025-12-24T08:58:03.197863
finish_reason: stop
---

В этом примере мы создаем список spam, а затем вставляем в него строку 'hello', делая ее первым элементом списка (индекс 0). Как видите, элемент можно вставить в позицию с любым допустимым индексом, в том числе 2.

Объединение элементов списка message в одну строку

Мы используем вычисленное значение charIndex в качестве индекса в строке SYMBOLS, чтобы извлечь из нее нужный символ, который добавляется в начало списка blockMessage.

65.    blockMessage.insert(0, SYMBOLS[charIndex])
66.    message.extend(blockMessage)
67.    return ''.join(message)

В конце каждой итерации основного цикла все символы текущего блока добавляются в список message (строка 66). По завершении цикла функция getTextFromBlocks() возвращает список, преобразованный в строку.

Функция encryptMessage()

Функция encryptMessage() шифрует каждый блок, используя строку исходного сообщения, а также кортеж открытого ключа из двух целых чисел, создаваемый функцией readKeyFile(), которую мы напишем далее. Функция возвращает список зашифрованных блоков.

70. def encryptMessage(message, key, blockSize):
71.    # Преобразует строку сообщения в список целочисленных блоков
72.    # и шифрует каждый блок. Для шифрования нужен ОТКРЫТЫЙ ключ.
73.    encryptedBlocks = []
74.    n, e = key

В строке 73 создается список encryptedBlocks, в котором будут храниться зашифрованные блоки. В строке 74 два целых числа, хранящихся в кортеже key, присваиваются переменным n и e. Далее реализуется арифметика шифрования с открытым ключом.

Над каждым блоком исходного сообщения выполняются определенные арифметические операции, в результате которых мы получаем целое число, представляющее собой зашифрованный блок. В частности, мы возводим целочисленное значение блока в степень e и выполняем деление по модулю n, применяя функцию pow(block, e, n) (строка 78).