---
source_image: page_380.png
page_number: 380
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 25.57
tokens: 7401
characters: 1710
timestamp: 2025-12-24T08:55:35.115630
finish_reason: stop
---

В строке 61 проверяется особая ситуация, когда значение num меньше 2. В таком случае в строке 62 возвращается пустой список, поскольку параметр num не имеет полезных множителей.

Если же значение num больше 2, то необходимо вычислить все множители num и сохранить их в виде списка. В строке 64 создается пустой список factors, предназначенный для хранения таких множителей.

В цикле for, который начинается в строке 68, перебираются целые числа в диапазоне от 2 до MAX_KEY_LENGTH включительно. Вспомните, что функция range() возвращает диапазон, не включающий верхнее граничное значение, поэтому мы передаем ей MAX_KEY_LENGTH + 1 в качестве второго аргумента. Цикл предназначен для нахождения всех множителей числа num.

В строке 69 проверяется равенство выражения num % i нулю. Если это условие выполняется, то мы знаем, что num делится на i без остатка, а значит, i является множителем num. В таком случае в строке 70 значение i при-соединяется к списку множителей, хранящемуся в переменной factors. Поскольку частное num / i тоже является множителем числа num, его целочисленная форма сохраняется в переменной otherFactor в строке 71. (Вспомните, что результатом операции / всегда будет число с плавающей точкой. Например, выражение 21 / 7 возвращает не целое число 3, а вещественное число 3.0.) Если результирующее значение равно 1, то оно не включается в список factors; этот случай проверяется в строке 72.

Мы исключаем значение 1 по той причине, что в случае ключа длиной 1 шифр Виженера ничем не отличается от шифра Цезаря.

Удаление дубликатов с помощью функции set()

В методе Касиски мы должны определить наиболее часто встречающийся множитель интервалов повторения, поскольку длина ключа Виженера,