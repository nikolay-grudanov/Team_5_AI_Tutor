---
source_image: page_244.png
page_number: 244
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 30.92
tokens: 7457
characters: 1668
timestamp: 2025-12-24T08:52:00.870382
finish_reason: stop
---

>>> import cryptomath
>>> cryptomath.gcd(24, 32)
8
>>> cryptomath.gcd(37, 41)
1
>>> cryptomath.findModInverse(7, 26)
15
>>> cryptomath.findModInverse(8953851, 26)
17

Итак, теперь у нас есть возможность вызывать функции gcd() и findModInverse() для нахождения НОД и модульного обращения двух чисел.

Резюме

В этой главе было рассмотрено несколько важных математических понятий. Оператор % возвращает остаток от деления одного числа на другое. Функция gcd() возвращает наибольшее число, на которое нацело делятся оба ее аргумента. Если НОД двух чисел равен 1, то они взаимно простые. Наиболее полезным алгоритмом для нахождения НОД двух чисел является алгоритм Евклида.

В отличие от шифра Цезаря аффинный шифр использует для шифрования букв не просто сложение, а умножение и сложение. Однако не все числа годятся на роль ключей для аффинного шифра. Ключ и размер символьного набора должны быть взаимно простыми числами.

При дешифровании аффинного шифра вы умножаете индекс символа шифротекста на модульное обращение ключа. Модульным обращением a % m является такое число i, что (a * i) % m = 1. Для вычисления модульных обращений можно использовать расширенный алгоритм Евклида. В главе 23 модульные обращения будут использоваться в шифровании с открытым ключом.

В следующей главе мы напишем программу, реализующую аффинное шифрование. Поскольку мультипликативный шифр — это то же самое, что и аффинный шифр, в котором ключ B равен нулю, в написании отдельной программы для мультипликативного шифра нет никакой необходимости. А с учетом того, что мультипликативный шифр — всего лишь менее надежная версия аффинного шифра, его в любом случае не следует использовать.