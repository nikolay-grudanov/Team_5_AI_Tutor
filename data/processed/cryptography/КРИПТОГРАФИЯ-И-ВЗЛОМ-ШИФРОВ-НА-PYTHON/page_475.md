---
source_image: page_475.png
page_number: 475
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 31.16
tokens: 7441
characters: 1823
timestamp: 2025-12-24T08:58:23.469616
finish_reason: stop
---

тым ключом (кортеж из двух целых чисел n и d) и аргументом blockSize (размер блока).

153. # Дешифруем большие целочисленные блоки
154. return decryptMessage(encryptedBlocks, messageLength, (n, d), blockSize)

Возвращаемая функцией decryptMessage() строка дешифрованного сообщения в свою очередь возвращается функцией readFileAndDecrypt().

Вызов функции main()

Наконец, если файл publicKeyCipher.py запускается как программа, а не импортируется в виде модуля другой программой, то в строках 159 и 160 вызывается функция main().

157. # Если файл publicKeyCipher.py выполняется как программа
158. # (а не импортируется как модуль), вызвать функцию main()
159. if __name__ == '__main__':
160.     main()

Резюме

Примите поздравления — вы дочитали книгу до конца! Главы под названием "Взлом шифров с открытым ключом" не будет ввиду отсутствия простых методик взлома, способных справиться с этой задачей в сроки, которые не исчислялись бы трллионами лет.

В данной главе рассматривался упрощенный вариант RSA, и тем не менее это реальный шифр, применяемый в профессиональных криптографических приложениях. Например, когда вы регистрируетесь на сайте или совершаете покупки в Интернете, подобные шифры позволяют защищать пароли и номера кредитных карт от злоумышленников, которые могут перехватывать ваш сетевой трафик.

Несмотря на то что арифметика шифрования с открытым ключом везде одна и та же, вам не следует использовать рассмотренную здесь программу для защиты своих секретных файлов. Способы взлома подобных программ достаточно сложны, и тем не менее они существуют. Например, из-за того что случайные числа, генерируемые функцией random.randint(), не являются истинно случайными и могут быть предсказаны, злоумышленник способен выяснить, какие числа были выбраны в качестве простых чисел для вашего закрытого ключа.