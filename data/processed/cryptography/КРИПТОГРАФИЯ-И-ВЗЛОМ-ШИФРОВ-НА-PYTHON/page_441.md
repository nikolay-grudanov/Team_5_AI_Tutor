---
source_image: page_441.png
page_number: 441
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 21.42
tokens: 7430
characters: 1673
timestamp: 2025-12-24T08:57:10.285321
finish_reason: stop
---

Функция random.randrange(), вызываемая в строке 28, возвращает случайное целое число и сохраняет его в переменной e. Проверка взаимной простоты e и (p - 1) * (q - 1) выполняется с помощью функции gcd() из модуля cryptomath (строка 29). В случае положительного результата проверки инструкция break в строке 30 прерывает бесконечный цикл. Иначе программа возвращается к строке 26 и продолжает генерировать различные случайные числа до тех пор, пока не будет найдено число, взаимно простое с (p - 1) * (q - 1).

Далее мы переходим к вычислению закрытого ключа.

Вычисление значения d

Третий этап заключается в нахождении другой части закрытого ключа, т.е. числа d, которое представляет собой модульное обращение числа e. Для этого у нас уже есть соответствующая функция findModInverse() из модуля cryptomath (см. главу 13).

Функция findModInverse() вызывается в строке 34 и сохраняет результат в переменной d.

32. # Шаг 3: вычисляем d - модульное обращение e
33. print('Calculating d that is mod inverse of e...')
34. d = cryptomath.findModInverse(e, (p - 1) * (q - 1))

Теперь в нашем распоряжении имеются все числа, необходимые для получения открытого и закрытого ключей.

Возврат ключей

Вспомните, что в криптосистемах с открытым ключом открытый и закрытый ключи состоят из двух чисел каждый. Целые числа n и e образуют открытый ключ, а целые числа n и d — закрытый. В строках 36 и 37 эти пары чисел сохраняются в виде кортежей в переменных publicKey и privateKey.

36. publicKey = (n, e)
37. privateKey = (n, d)

Далее значения ключей выводятся на экран.

39. print('Public key:', publicKey)
40. print('Private key:', privateKey)
41.
42. return (publicKey, privateKey)