---
source_image: page_259.png
page_number: 259
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 28.81
tokens: 7426
characters: 1723
timestamp: 2025-12-24T08:52:20.714810
finish_reason: stop
---

71. def getRandomKey():
72.     while True:
73.         keyA = random.randint(2, len(SYMBOLS))
74.         keyB = random.randint(2, len(SYMBOLS))

В строках 73 и 74 определяются случайные значения для ключей keyA и keyB в диапазоне от 2 до размера символьного набора. Это гарантирует, что ключ А или В с недопустимым значением 0 или 1 не будет выбран.

Инструкция if в строке 75 проверяет, что являются ли ключ А и размер символьного набора взаимно простыми числами, вызывая функцию gcd () из модуля cryptomath.

75.     if cryptomath.gcd(keyA, len(SYMBOLS)) == 1:
76.         return keyA * len(SYMBOLS) + keyB

Если это условие выполняется, то два случайно выбранных ключа объединяются в один путем умножения keyA на размер символьного набора и прибавления keyB к полученному результату. (Обратите внимание на то, что эта операция противоположна той, которую выполняет функция getKeyParts (), разбивающая один целочисленный ключ на два целых числа.) В строке 76 данное значение возвращается функцией getRandomKey ().

Если условие в строке 75 равно False, то функция возвращается к началу цикла while в строке 73 и вновь выбирает случайные числа в качестве значений keyA и keyB. Бесконечный цикл гарантирует, что программа будет продолжать поиск допустимых ключей до тех пор, пока не найдет их.

Вызов функции main ()

В строках 81 и 82 функция main () вызывается в том случае, если файл был запущен как программа, а не импортирован другой программой как модуль.

79. # Если файл affineCipher.py выполняется как программа
80. # (а не импортируется как модуль), вызвать функцию main()
81. if __name__ == '__main__':
82.     main()

Это гарантирует, что функция main () будет вызвана только при автономном запуске программы.