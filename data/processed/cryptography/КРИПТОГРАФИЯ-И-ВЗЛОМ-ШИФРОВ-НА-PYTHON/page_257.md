---
source_image: page_257.png
page_number: 257
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 24.89
tokens: 7367
characters: 1477
timestamp: 2025-12-24T08:52:16.394384
finish_reason: stop
---

Чтобы зашифровать текст, необходимо вычислить индекс зашифрованной буквы. В строке 49 значение symbolIndex умножается на keyA и к полученному произведению прибавляется keyB. Далее вычисляется остаток от деления полученного результата на размер символьного набора, т.е. len(SYMBOLS). Это гарантирует, что вычисленный индекс всегда будет в диапазоне от 0 и len(SYMBOLS), исключая граничное значение. Результирующее число становится индексом зашифрованного символа в наборе SYMBOLS. Полученный символ присоединяется в конец строки, хранящейся в переменной ciphertext. И все это выполняется в одной строке 49!

Если символ не входит в символьный набор, то он конкатенируется со строкой ciphertext в строке 51. Например, кавычки и дефис не входят в символьный набор, поэтому они просто присоединяются.

После того как в цикле будут перебраны все символы исходного сообщения, переменная ciphertext будет содержать всю зашифрованную строку. Эта строка возвращается функцией encryptMessage() в строке 52.

Написание функции дешифрования

Функция decryptMessage(), предназначенная для дешифрования текста, во многом совпадает с функцией encryptMessage(). Строки 56–58 эквивалентны строкам 42–44.

Однако в процессе дешифрования вместо умножения на ключ A выполняется умножение на его модульное обращение, которое вычисляется путем вызова функции cryptomath.findModInverse() (см. главу 13).

Строки 61–68 почти идентичны строкам 45–52 функции encryptMessage(), отличается лишь строка 65.