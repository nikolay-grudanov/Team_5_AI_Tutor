---
source_image: page_464.png
page_number: 464
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 23.09
tokens: 7380
characters: 1462
timestamp: 2025-12-24T08:57:52.263573
finish_reason: stop
---

Мы хотим, чтобы размер каждого блока составлял blockSize байт, но если сообщение не делится равномерно на блоки такого размера, то количество символов в последнем блоке будет меньше, чем blockSize. Для обработки подобных ситуаций мы используем функцию min().

Функции min() и max()

Функция min() возвращает наименьший из своих аргументов. Чтобы увидеть, как она работает, введите в интерактивной оболочке следующий код.

>>> min(13, 32, 13, 15, 17, 39)
13

Аргументом функции min() также может быть список или кортеж. Чтобы убедиться в этом, введите в интерактивной оболочке следующие инструкции.

>>> min([31, 26, 20, 13, 12, 36])
12
>>> spam = (10, 37, 37, 43, 3)
>>> min(spam)
3

В данном случае функция min() возвращает наименьший из элементов списка или кортежа. Противоположная ей функция max() возвращает наибольший из своих аргументов.

>>> max(18, 15, 22, 30, 31, 34)
34

Теперь вернемся к программе и рассмотрим, как с помощью функции min() последний блок усекается до нужного размера.

Сохранение блоков в переменной blockInt

В цикле for, который начинается в строке 43, создаются целые числа для каждого блока. В качестве значения переменной blockStart устанавливается индекс первого символа создаваемого блока.

43.    for blockStart in range(0, len(message), blockSize):
44.        # Вычисляем целочисленный блок для текущей группы символов
45.        blockInt = 0
46.        for i in range(blockStart, min(blockStart + blockSize, len(message))):