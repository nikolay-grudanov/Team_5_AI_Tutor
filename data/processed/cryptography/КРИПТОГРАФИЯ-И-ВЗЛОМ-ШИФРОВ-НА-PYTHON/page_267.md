---
source_image: page_267.png
page_number: 267
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 37.36
tokens: 7540
characters: 1947
timestamp: 2025-12-24T08:52:43.680425
finish_reason: stop
---

Чтобы увидеть, как работает оператор **, введите в интерактивной оболочке следующие выражения.

>>> 5 ** 2
25
>>> 2 ** 5
32
>>> 123 ** 10
792594609605189126649

Результат вычисления выражения 5 ** 2 равен 25, поскольку \( 5 \cdot 5 = 25 \). Аналогичным образом выражение 2 ** 5 возвращает 32, поскольку в результате перемножения пяти двоек мы получаем 32.

Рассмотрим, как этот оператор ** применяется в программе.

Вычисление общего количества возможных ключей

В строке 33 с помощью оператора ** вычисляется общее количество возможных ключей.

32. # Перебор всех возможных ключей методом грубой силы
33. for key in range(len(affineCipher.SYMBOLS) ** 2):
34. keyA = affineCipher.getKeyParts(key)[0]

Мы знаем, что существует самое большое len(affineCipher.SYMBOLS) возможных целочисленных значений ключа A и столько же возможных целочисленных значений ключа B. Чтобы получить полный диапазон возможных значений ключей, мы возводим длину символьного набора в квадрат, используя оператор ** в выражении len(affineCipher.SYMBOLS) ** 2.

В строке 34 вызывается функция getKeyParts(), которую мы создали в файле affineCipher.py для разбивки одного целочисленного ключа на два целых числа. В данном случае мы используем ее для получения ключа A, который должен быть протестирован. Вспомните, что эта функции возвращает кортеж из двух целых чисел, одно из которых — ключ A, а второе — ключ B. В строке 34 первое число кортежа, задаваемое индексом [0], сохраняется в переменной keyA.

Например, если функция возвращает кортеж (42, 22), то выражение (42, 22)[0] равно 42. Подобным образом мы вычленяем часть возвращаемого значения, соответствующую ключу A, и сохраняем ее в переменной keyA. Ключ B (второе значение в возвращаемом кортеже) игнорируется, поскольку он никак не учитывается при оценке допустимости ключа A. В строках 35 и 36 проверяется, является ли значение keyA допустимым ключом A для аффинного шифра, и если это не так, то программа пере-