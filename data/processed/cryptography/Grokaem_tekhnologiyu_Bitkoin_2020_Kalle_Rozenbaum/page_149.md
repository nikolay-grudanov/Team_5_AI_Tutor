---
source_image: page_149.png
page_number: 149
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 28.51
tokens: 7363
characters: 1382
timestamp: 2025-12-24T08:34:39.004569
finish_reason: stop
---

ведении \(2^2 \times G\) умножается на 1, прибавим этот результат к результату, полученному на шаге 1.

Как видите, умножение выполняется как последовательность операций удвоения и сложения.

Почему такой подход считается безопасным?

Выполнить умножение довольно просто; для 256-битного закрытого ключа нужно сделать около 256 шагов. Но обратные вычисления — это совсем другая история. Не существует известного способа получить закрытый ключ по точке «делением» (например, «разделить» точку (6,6) на \(G\)). Единственный известный способ — попробовать разные закрытые ключи и посмотреть, совпадает ли открытый ключ, полученный из них, с искомым. Именно это обстоятельство делает функцию создания открытого ключа однонаправленной.

Создание хpriv

Теперь вы знаете, как путем умножения из закрытого ключа получается обычный открытый ключ. Но как сложить родительский открытый ключ с открытым ключом, полученным из левых 256 бит, чтобы получить дочерний открытый ключ? Взгляните на рис. 4.27.

![Дочерний открытый ключ получается сложением родительского открытого ключа с открытым ключом, полученным из левых 256 бит](../images/ch4_27.png)

Рис. 4.27. Дочерний открытый ключ получается сложением родительского открытого ключа с открытым ключом, полученным из левых 256 бит

Убедитесь, что это работает, можно, посмотрев, как создаются обычный и дочерний открытые ключи, на рис. 4.28.