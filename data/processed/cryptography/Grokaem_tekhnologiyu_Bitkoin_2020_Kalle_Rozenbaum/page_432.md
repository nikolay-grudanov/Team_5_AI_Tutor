---
source_image: page_432.png
page_number: 432
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 32.92
tokens: 7565
characters: 2034
timestamp: 2025-12-24T08:42:26.966331
finish_reason: stop
---

• в режиме с малой пропускной способностью блок cmrctblock отправляется только по запросу, в ответ на inv или headers.

★ Для экономии трафика в сообщениях cmrctblock посылаются не полные, а сокращенные идентификаторы транзакций. Но они достаточно длинные, чтобы почти всегда однозначно идентифицировать фактические транзакции.

Это по-настоящему полезное изменение, которое многие посчитают ценным. Вы выпускаете свое программное обеспечение, и люди начинают его использовать. Конечно, не все обновятся до этой версии. Но если хотя бы один из ваших соседей по сети начнет использовать его, вы выиграете, установив его у себя, потому что требования к пропускной способности между вами и этим соседним узлом уменьшатся. По мере того как все больше и больше узлов начнет использовать компактные блоки, ваши требования к общей пропускной способности будут снижаться.

Вы не внесли никаких изменений в правила согласования. Блоки проверяются с использованием вашего программного обеспечения точно так же, как и раньше. Старые узлы будут принимать новые блоки и наоборот.

Хард-форк

Как было сказано раньше, хард-форк — это изменение ПО, которое ослабляет правила согласования. Новые блоки, созданные новыми узлами, могут отклоняться старыми узлами. В примере с вегетарианским рестораном хард-форком станет ситуация, когда в этом ресторане начнут подавать мясо.

Предположим, вы изменили максимально допустимый вес блока — это обсуждалось в разделе «Увеличение максимального размера блока» в главе 10 — с 4 000 000 до 8 000 000 весовых единиц. Это позволяет добавлять больше транзакций в каждый блок. С другой стороны, более высокое ограничение может отрицательно повлиять на некоторые узлы в сети Биткоин, как говорилось в главе 10.

Как бы то ни было, вы вносите это изменение и начинаете использовать его в сети Биткоин. Когда ваш узел получает блок от старого узла, вы принимаете его, потому что блок определенно имеет вес ≤8 000 000 весовых единиц; старый узел не будет создавать или пересылать блоки с весом больше 4 000 000 единиц.