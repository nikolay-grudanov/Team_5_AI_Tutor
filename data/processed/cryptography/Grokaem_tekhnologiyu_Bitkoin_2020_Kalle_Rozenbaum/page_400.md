---
source_image: page_400.png
page_number: 400
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 31.43
tokens: 7513
characters: 1769
timestamp: 2025-12-24T08:41:27.985537
finish_reason: stop
---

p2wpkh — самый простой из двух типов, потому что похож на хорошо известный p2pkh. Давайте посмотрим, как они работают:

★ p2pkh — сценарий открытого ключа содержит фактический сценарий, который проверяет подпись в сценарии подписи;

★ p2wpkh — фактический сценарий является предопределенным шаблоном, а программа свидетеля является хешем открытого ключа, который требуется вставить в шаблон. Подпись и открытый ключ извлекаются из структуры свидетеля.

В результате получается одна и та же программа, которая обрабатывает оба эти типа. Разница лишь в том, откуда берутся компоненты. Однако между старыми и segwit-сценариями существуют и другие различия — например, значение OP_CHECKSIG изменилось, как будет показано в разделе «Новый метод хеширования подписей».

Зачем вообще использовать p2wpkh, если запускается та же программа-сценарий, что и в p2pkh? Напомню, что цель — устранить проблему пластичности транзакций. Это достигается удалением данных подписей из входов транзакции, чтобы никто не мог изменить ее идентификатор, внося небольшие изменения в сценарий подписи.

Полный узел проверил транзакцию и отправил своим соседям. Осталась только одна проблема: один из узлов не знает, что такое segwit. Это старый узел, который давно не обновлялся.

«Проверка» на старых узлах

Старый узел только что получил вашу транзакцию и должен ее проверить. Старые узлы ничего не знают о segwit или о свидетелях, приложенных к транзакциям. Старый узел загружает транзакцию как обычно, без сопровождающего ее свидетеля. На рис. 10.16 показано, что видит узел.

Поскольку узел не знает ничего другого, он создаст программу сценария, взяв пустой сценарий подписи и добавив сценарий открытого ключа. В результате получится программа:

00 c8052b799cde68ed8da8150c4cdef4ae3176cba8