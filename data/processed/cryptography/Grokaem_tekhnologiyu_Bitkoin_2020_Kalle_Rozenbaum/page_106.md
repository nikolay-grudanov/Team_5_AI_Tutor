---
source_image: page_106.png
page_number: 106
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 35.39
tokens: 7536
characters: 1791
timestamp: 2025-12-24T08:33:39.412451
finish_reason: stop
---

входных данных. Затем полученная строка переворачивается, и в результате получается адрес Джона в системе жетонов на булочки. Обратите внимание, что все адреса, не только Джона, будут начинаться с 1. Это объясняется тем, что байт с номером версии 0 кодируется символом 1.

Данные в кодировке base58, такие как адрес Джона, можно декодировать обратно в исходное значение. Я оставлю это как самостоятельное упражнение тем, кому это будет интересно.

Обратите внимание, что в кодировке base58 нет ничего нового. Она использует обобщенный алгоритм преобразования десятичного числа в систему счисления с любым другим основанием. Этот алгоритм с тем же успехом можно использовать для преобразования в base3, выполняя деление на 3 вместо 58. При этом, возможно, вы захотите изменить таблицу и отобразить 0 в 0, 1 в 1 и 2 в 2, чтобы получить привычные символы. Например, запишем число 17 в кодировке base3:

\[
17 = 5 \times 3 + 2 \\
5 = 1 \times 3 + 2 \\
1 = 0 \times 3 + 1
\]

Затем найдите остатки в таблице поиска (те же цифры, что и преобразованные), и вы получите 2 2 1. Переверните эту последовательность, чтобы получить конечный результат: 1 2 2. Убедитесь в его правильности, как показано ниже:

\[
1 \times 3^2 + 2 \times 3^1 + 2 \times 3^0 = 9 + 6 + 2 = 17
\]

Декодирование из формата base58check

Джон только что создал свой адрес в системе жетонов, применив кодирование base58check к своему РКН. Он дал адрес Фаизе, чтобы она могла отправить ему 20 СТ. Теперь Фаиза должна написать сообщение Лизе. Для этого ей нужен РКН Джона. Кодирование base58check обладает одним замечательным свойством — это обратимый процесс, то есть из адреса можно получить РКН и одновременно проверить наличие опечаток (рис. 3.15).

![Схема кодирования и декодирования адреса](../images/chapter3/fig_3_15.png)