---
source_image: page_430.png
page_number: 430
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 28.66
tokens: 7492
characters: 1681
timestamp: 2025-12-24T08:42:16.624811
finish_reason: stop
---

Рис. 11.2. Новое сообщение будет приниматься новыми и игнорироваться старыми узлами

Попробуем добавить что-нибудь более полезное

Предположим, вы изобрели что-то действительно очень полезное, пусть это будут особо компактные блоки. Компактные блоки позволяют одноранговому узлу отправить блок другому одноранговому узлу, не отправляя полный блок. Допустим, что этот метод опирается на тот факт, что узел-получатель уже получил большинство транзакций, включенных в блок. Напомню, что транзакции сначала рассылаются в сети поодиночке, а затем повторно рассылаются, но уже в составе блока, после подтверждения транзакции.

Рашид отправляет блок узлу Ци (рис. 11.3), и было бы здорово исключить из блока транзакции, которые у Ци и так есть. Требования к пропускной способности резко снизились бы.

Теперь Рашид может отправить только заголовок блока и список идентификаторов транзакций (рис. 11.4). Получив заголовок, Ци может восстановить блок, собрав его из транзакций, которые у нее уже имеются, и из сообщения Рашида. Если у Ци не окажется какой-то транзакции, она сможет запросить ее у Рашида.

Согласно протоколу, обмен начинается с того, что Рашид отправляет Ци сообщение compactblock. Ци использует это сообщение для воссоздания блока и включения в него транзакций, которые у нее уже имеются. Если ей это удастся, она сможет начать проверять блок. Если какие-то транзакции отсутствуют у нее, она запросит их у Рашида, послав сообщение getblocktxn

BIP152
Такое решение было реализовано в Bitcoin Core в 2016 году и значительно ускорило распространение блоков в сети Биткоин. Этот метод подробно описывается в BIP152, «Compact Block Relay». Здесь я приведу упрощенное описание.