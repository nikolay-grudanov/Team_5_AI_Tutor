---
source_image: page_212.png
page_number: 212
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 33.38
tokens: 7805
characters: 2891
timestamp: 2025-12-24T09:06:44.743076
finish_reason: stop
---

сор может сделать что-то (например, переместить такой-то бит в такой-то регистр ЦП, сложить такое-то и такое-то числа, стереть некоторое значение в таком-то регистре и т. д.). Каждое ядро в ЦП может выполнять только одно действие в цикле (если не выполняются параллельные операции), и это действие может происходить строго при каждом такте процессора. Тактовая частота процессора намного выше, чем частота тактов материнской платы, но обычно имеет точное соответствие тактовой частоте материнской платы (например, для каждого такта материнской платы процессор может выполнить в 100 раз больше операций, каждая из которых равномерно распределена по времени). Могут быть и другие таймеры, но часы материнской платы и процессора являются наиболее важными.

Лучшие аппаратные и программные процедуры обеспечивают то, что с виду очень приближено к истинной случайности, но эти результаты не являются действительно случайными. Лучшее, что мы можем сделать, — подобраться как можно ближе к истинной случайности, так что любые возникающие ошибки будут ничтожными для зависимых приложений.

Это не означает, что нет хороших и плохих PRNG или что некоторые не лучше других. NIST создал серию тестов, которые может применить любой поставщик или заказчик RNG, чтобы увидеть, насколько хорош или плох их RNG по сравнению с теоретически идеальным генератором случайных чисел. Тесты и требования задокументированы в специальной публикации NIST 800-22: https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-22r1a.pdf.

Примечание Официальное определение RNG требует, чтобы приближение случайности формируемых им чисел было недетерминированным (то есть не могло быть определено заранее), а PRNG является детерминированным. Что интересно, PRNG являются детерминированными, потому что должны начинаться с начального значения из RNG, которое, как мы знаем, на двоичном компьютере никогда не может быть действительно случайным. Как ни странно, хороший PRNG на двоичном компьютере может вернуть больше случайных чисел, чем поступающее ему начальное значение RNG.

Почему истинная случайность так важна?

Большинство криптографических алгоритмов требуют действительно случайное число при запуске (часто называемое вектором инициализации (initialization vector), начальным значением (seed value) или данным временем (nonce)). Затем используется сложная математика для получения результата, который действительно трудно оценить или угадать. Например, RSA требует двух больших, случайно выбранных простых чисел, являющихся частью алгоритма (обычно они представлены математически как p и q). После того как выбор этих случайных чисел сделан, они участвуют в сложных математических преобразованиях, которые дают результат, трудный для обратного разложения на множители.

Но предположим, что простые числа, какими бы большими они ни были, не были бы случайными вообще. Предположим, что по какой-то ошибке