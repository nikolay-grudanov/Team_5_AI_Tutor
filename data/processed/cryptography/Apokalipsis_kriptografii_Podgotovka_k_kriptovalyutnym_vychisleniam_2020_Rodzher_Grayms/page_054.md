---
source_image: page_054.png
page_number: 54
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 41.97
tokens: 7997
characters: 3121
timestamp: 2025-12-24T09:02:13.053070
finish_reason: stop
---

Поскольку бит в один момент времени может представлять только одно из двух состояний, мы можем легко подсчитать, сколько битов необходимо для представления определенного количества информации. Например, 1 бит может содержать две разные частицы информации (то есть 0 или 1), но это будет всегда 1 бит информации: до, во время и после измерения. Два бита могут быть четырьмя различными возможными частями информации (т. е. 00, или 01, или 10, или 11), но при измерении будут представлять только 2 бита информации. Три бита могут содержать восемь возможных различных частей информации (то есть 000, или 001, или 010, или 100, или 010, или 011, или 110, или 111), но при измерении будут представлять только 3 бита информации и т. д. Каждая дополнительная бинарная цифра дает экспоненциальный рост возможностей \((2^4, 2^5, 2^6\) и т. д.).

Ранние компьютеры были напрямую запrogramмированы путем включения или выключения отдельных битов с помощью физического манипулирования. У них были физические, электрические перемычки, которые были или не были подключены в компьютере, чтобы создавать или не создавать определенное соединение. По одной из версий, термин «компьютерная ошибка» (computer bug) возник в связи с тем, что насекомые (bugs — жучки) перегрызали часть кабелей и вызывали ошибки программирования. Длинные, гибкие соединительные кабели были заменены встроенными механическими переключателями и программированием бумажных «перфокарт», которые по существу манипулировали внутренними механическими переключателями, чтобы изменить в компьютере двоичные пути. Даже сегодня многие компьютерные устройства имеют остаточные перемычки, такие как «включено» и «выключено», которыми пользователь может физически манипулировать и определять двоичные варианты конкретных путей или решений в компьютере.

Механические переключатели были заменены электронными ключами, что в итоге привело к появлению транзисторов, резисторов и микропроцессоров, которые на элементарном уровне просто вводят необходимое количество двоичных «логических элементов» в как можно меньшее пространство. Но независимо от того, сколько двоичных коммутаторов мы можем втиснуть на печатную плату или кусок кремния, все осуществляется в двоичном виде. Просто больше двоичных путей вписывается в меньшее пространство.

Компьютерные языки самого низкого уровня, такие как язык ассемблера, представляют только один уровень абстракции, устранивший необходимость непосредственного введения битов в микропроцессор компьютера. Например, на языке ассемблера команда MOV AH, 1 инструктирует микропроцессор компьютера перемещать двоичное значение 1 в регистр AH (registры — области памяти микропроцессора, которые хранят и помогают манипулировать данными).

Каждый двоичный язык программирования в конечном итоге разбивается на двоичные инструкции, которые затем физически манипулируют электронами микропроцессора компьютера в предопределенных булевых логических элементах (И, ИЛИ, НЕ и т. д.). Классические компьютерные системы сверху донизу построены на двоичных манипуляциях и хранении двоичных данных, и это направило мир по безразмерному, неординарному пути. Все