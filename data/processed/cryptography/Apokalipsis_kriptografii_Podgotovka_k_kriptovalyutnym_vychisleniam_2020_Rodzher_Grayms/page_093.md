---
source_image: page_093.png
page_number: 93
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 38.11
tokens: 7930
characters: 3006
timestamp: 2025-12-24T09:03:10.234251
finish_reason: stop
---

ми искали лучший способ безопасного обмена частной информацией и/или симметричными ключами (последний называется обмен ключами).

**Асимметричные шифры**

Святой Грааль шифрования предполагал, что должен быть найден метод, который позволял бы двум или более сторонам обмениваться симметричными ключами по ненадежному (даже заведомо злонамеренному) каналу связи без необходимости заранее установить частный метод связи для обмена симметричными ключами для каждого участника. В середине 1970-х годов несколько разных команд независимо друг от друга, с разницей в несколько лет, разработали почти одинаковые решения.

**Целочисленная факторизация. Усиление рабочей нагрузки** Во всех решениях использовалась полиномиальная математическая задача (например, \( A \times B = C \)), которая была настолько сложна по своей природе, что сама нагрузка, необходимая для того, чтобы вернуться к ее отдельным составным частям (то есть множителям), уже становилась защитой. Математическая задача должна быть столь трудной, что, если кто-то узнает \( C \) (результат \( A \times B \)), он не сможет легко отобразить \( A \) или \( B \). Необходимый объем выполняемой работы (полиномиальная рабочая нагрузка, также известная как проблема целочисленной факторизации) является основной защитой для большей части современной криптографии с открытым ключом.

**Примечание** Требуемая рабочая нагрузка аналогична целочисленной факторизации и используется в различных, хотя и взаимосвязанных, типах асимметричных шифров, включая задачу дискретного логарифмирования и задачу дискретного логарифмирования эллиптической кривой. Они используют разные типы очень трудноразрешимой математики, но применяют при этом принципиально разные подходы.

Сегодня самые популярные асимметричные криптографические решения используют два больших простых числа (\( A \) и \( B \)), которые при умножении (или алгоритмическом представлении) давали бы намного больший результат (например, \( C \)). В качестве \( C \), как указывалось в главе 2, используется простое число — это целое число больше 1, которое может быть разделено только на само себя или 1, чтобы получилось целое число (2, 3, 5, 7, 11, 13, 17, 19, 23 и т. д.). Любая другая комбинация приводит к остатку или дроби. Традиционным двоичным компьютерам по своей природе трудно создать по требованию и проверить простые числа. Если очень большие простые числа имеют значения \( A \) и \( B \), то, даже если кто-то знает \( C \), ему очень сложно разложить результат на его основные составляющие (то есть \( A \) и \( B \)).

Чтобы было более понятно, начнем с простого примера. Давайте использовать общую криптографическую математику — уравнение, представляющее метод защиты целочисленной факторизации: \( p \times q = n \), где \( p \) и \( q \) — простые числа, а \( n \) — результирующий математический результат и открытый ключ пары ключей (объясню чуть позже). Если \( p \) и \( q \) — достаточно большие числа, то \( p \) и \( q \) очень трудно получить, если дано только \( n \).