---
source_image: page_149.png
page_number: 149
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 36.52
tokens: 7552
characters: 2290
timestamp: 2025-12-24T09:57:46.514912
finish_reason: stop
---

Оптимизация концевых вызовов относится к довольно простым операциям, но у нее масса вариантов применения. Если использовать обычный набор инструкций в качестве метафоры, то код, генерируемый continuize, может включать следующие машинные инструкции:

call    continuation      # вызов функции continuation
return                          # возвращение к функции, вызвавшей hero

Инструкция call помещает адрес следующей инструкции (в данном случае это return) в стек вызова. Затем она передает управление той функции, чей адрес числится в реестре с пометкой continuation. Когда функция continuation выполнит свою работу, адрес возврата будет извлечен из стека и на него будет выполнен переход. Инструкция return опять извлечет данные из стека и перейдет на инструкцию, вызвавшую hero.

Оптимизация заменит эти две инструкции одной:

jump    continuation      # переход к функции continuation

Теперь мы не помещаем в стек вызовов адрес инструкции return. Функция continuation возвращается к функции, вызвавшей hero, а не к самой hero. Концевой вызов похож на goto с аргументами, но без какой-либо опасности, присущей goto и подтолкнувшей к избавлению от нее.

Получается, что оптимизация сэкономила одну инструкцию, помещение данных в стек и извлечение их оттуда. Казалось бы, мелочь. Чтобы лучше разобраться, в чем тут преимущество, посмотрим, как на самом деле вызовы работают в JavaScript. Когда вызывается функция, происходит следующее.

• Вычисляются выражения аргументов.
• Создается объект активации, размер которого позволяет ему хранить все параметры и переменные функции.
• В новом объекте активации сохраняется ссылка на вызываемый функциональный объект.
• В новом объекте активации значения из аргументов сохраняются в параметрах. Пропущенные аргументы рассматриваются как содержащие значение undefined. Лишние аргументы игнорируются.
• Всем переменным в новом объекте активации присваивается значение undefined.
• Для поля активации next instruction field устанавливается значение, указывающее на инструкцию, следующую сразу же за вызовом.
• Для поля caller в новой активации устанавливается значение, указывающее на текущую активацию. Фактически это не стек вызовов, а связанный список активаций.
• Новая активация становится текущей.
• Начинается выполнение вызванной функции.