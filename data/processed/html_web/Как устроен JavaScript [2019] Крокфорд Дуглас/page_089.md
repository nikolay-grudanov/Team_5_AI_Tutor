---
source_image: page_089.png
page_number: 89
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 45.10
tokens: 7655
characters: 2642
timestamp: 2025-12-24T09:56:21.311956
finish_reason: stop
---

позволяющей устанавливать в ваши системы сомнительный код. Когда-нибудь неизменяемость поможет превратить все это в безопасный метод работы. Неизменяемые объекты можно будет снабдить высококачественными интерфейсами, способными их защитить.

Функция Object.freeze(объект) и инструкция const действуют абсолютно по-разному. Object.freeze оперирует значениями, а const — переменными. Если поместить изменяемый объект в const-переменную, вероятность изменения объекта сохранится, но вы не сможете заменить объект каким-либо другим значением. Если поместить неизменяемый объект в обычную переменную, вы не измените объект, но сможете присвоить переменной другое значение.

Object.freeze(my_copy);
const my_little_constant = my_little_object;

my_little_constant.foo = 7;                // разрешено
my_little_constant = 7;                     // СИНТАКСИЧЕСКАЯ ОШИБКА!
my_copy.foo = 7;                            // ИСКЛЮЧЕНИЕ!
my_copy = 7;                               // разрешено

Прототипы и заморозка не смешиваются

Одна из задач, решаемых с помощью прототипов, — это создание легких копий объектов. У нас есть объект, заполненный данными. Нам нужен другой точно такой же объект, но с одним измененным свойством. Как уже было показано, сделать это реально с помощью метода Object.create. Это позволит сэкономить немного времени на создании нового объекта, но извлечение свойств может обойтись дороже, поскольку придется просматривать цепочку прототипов.

К сожалению, это не сработает, если прототип заморожен. Если свойство в прототипе неизменяемое, экземпляр не способен иметь собственную версию этого свойства. В некоторых стилях функционального программирования для повышения надежности на основе неизменяемости требуется, чтобы все объекты были заморожены. Поэтому вместо создания копии для внесения изменения было бы неплохо получить возможность создать экземпляр, получающий наследство от замороженного прототипа, изменить его, а затем заморозить. Но работоспособных вариантов просто нет. При обновлении экземпляра выдается исключение. Кроме того, в целом замедляется вставка новых свойств. Когда вставляется новое свойство, то, чтобы определить, что у предка нет неизменяемого свойства, в поисках ключа нужно просмотреть всю цепочку прототипов. Избежать этого при создании объектов позволяет использование функции Object.create(null).

Одна из конструктивных ошибок в JavaScript заключается в том, что именами свойств в объектах должны быть строки. Бывают ситуации, когда требуется в качестве ключа воспользоваться объектом или массивом. К сожалению, объекты JavaScript в таком случае ведут себя неправильно, преобразуя ключ-объект