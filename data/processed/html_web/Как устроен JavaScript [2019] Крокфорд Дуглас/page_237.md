---
source_image: page_237.png
page_number: 237
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 41.09
tokens: 7597
characters: 2142
timestamp: 2025-12-24T10:00:10.288755
finish_reason: stop
---

• Функциональное выражение возвращает значение выражения. Тело функции должно возвращать значение в явном виде.

• Оператором значения по умолчанию является |выражение|. Если слева от выражения или параметра стоит значение или null, то находящееся справа выражение, заключенное в символы вертикальной черты, вычисляется для получения значения по умолчанию. Это краткая форма записи.

• Многоточие (...) аналогично применяемому в JavaScript, за исключением того, что оно всегда ставится после обозначения массива, а не перед ним:

    def continuize: f any (
        f callback, arguments... (callback(any(arguments...)))
    )

• Использование \(f\) в качестве префикса перед оператором создает указатель на функцию (functino), позволяя задействовать оператор как обычную функцию. То есть \(f+\) создает функцию сложения с двумя операндами, которая может быть передана функции свертки для получения сумм. \(f+(3, 4)\) возвращает 7.

    \(f/\) и \(f/\) или \(f=\) равно \(f\#\) не равно \(f<\) меньше \(f\geq\) больше или равно \(f>\)
    больше \(f\leq\) меньше или равно \(f\sim\) объединение \(f\approx\) объединение с пробелом
    \(f+\) сложение \(f-\) вычитание \(f>>\) максимум \(f<<\) минимум \(f*\) умножение \(f/\) деление
    \(f[]\) получение \(f()\) решение \(f?!\) тернарная функция \(f||\) получение значения по умолчанию

• Функция может быть вызвана как метод. Например:

    my little function.method(x, y)

делает то же самое, что и:

    my little function("method", [x, y])

Этот простой механизм позволяет использовать функцию в качестве посредника для записи.

• Инструкция def заменяет инструкцию const.
• Инструкция var объявляет переменные.
• Инструкция let может изменить значение переменной, или поля записи, или элемента массива. Инструкция let — единственное место, где разрешено изменение. Операторов присваивания нет. Я не могу избавиться от присваивания, но способен его ограничить.

    def pi: 3.14159265358979323846264338327950288419716939937510582097494459
    var counter: 0
    let counter: counter + 1

• Область видимости блоков отсутствует, поскольку нет самих блоков. Есть область видимости функций.