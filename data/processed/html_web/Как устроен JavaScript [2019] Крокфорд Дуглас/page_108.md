---
source_image: page_108.png
page_number: 108
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 23.00
tokens: 7301
characters: 1444
timestamp: 2025-12-24T09:56:27.237667
finish_reason: stop
---

10.2 Как работают ничтожно малые значения

Значение undefined, несомненно, лучше подходит для использования, чем null, но оно также страдает от проблемы пути. Вспомним, что значением отсутствующих свойств является undefined, что могло бы считаться положительным моментом, если бы undefined был замороженным пустым объектом, но он таковым не является. Значение undefined не объект, поэтому попытки получения из него свойства приводят к выдаче исключения. Это существенно усложняет написание путевых выражений. Например:

my_little_first_name = my_little_person.name.first;

выдает исключение, если в my_little_person нет свойства name или my_little_person имеет значение undefined. Поэтому нельзя рассматривать цепочку точек (.) и список индексов [ ] в качестве пути. Можно считать это последовательностью отдельно взятых операций, любая из которых способна дать сбой. Это приводит к созданию примерно следующего кода:

my_little_first_name = (
    my_little_person
    && my_little_person.name
    && my_little_person.name.first
);

Логический оператор И (&&) используют, чтобы избежать вычисления того, что находится справа от него, если то, что стоит слева, имеет лживое значение. Этот код весьма пространный, уродливый и медленный, но он избавляет от выдачи исключений и обычно делает то, что должен был бы делать код:

my_little_first_name = my_little_person.name.first;

если бы значение undefined работало как объект, а не как антиобъект.