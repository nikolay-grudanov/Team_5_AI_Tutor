---
source_image: page_250.png
page_number: 250
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 44.49
tokens: 7528
characters: 2264
timestamp: 2025-12-24T10:00:34.333029
finish_reason: stop
---

27.4 Как работает парсер

В свойстве origin фиксируется функция, создавшая переменную. В свойстве scope хранятся все переменные, созданные или используемые в функции. Свойство parent указывает на функцию, создавшую данную функцию.

Функции, применяющиеся для парсинга особенностей языка, содержатся в трех объектах: statements, prefixes и suffixes.

В объектах parse_statement, parse_prefix и parse_suffix содержатся функции, которые выполняют специализированный парсинг. Для их создания используется метод Object.create(null), поскольку нам не хочется, чтобы здесь вычищался какой-либо мусор, полученный из Object.prototype:

const parse_statement = Object.create(null);
const parse_prefix = Object.create(null);
const parse_suffix = Object.create(null);

Ядро этого парсера — функция expression (и ее помощник argument_expression). Выражение может рассматриваться как имеющее две части: левую и необязательную правую. Левая часть — это литерал, переменная или префикс, правая — оператор-суффикс, за которым могут следовать другие выражения. Если в правой части есть суффикс и у него более высокий приоритет, тогда левая часть передается парсеру правой части, в результате чего появляется новая левая часть. Вероятно, парсер правой части сам снова вызовет выражение, возможно, с другим приоритетом.

Выражения могут быть открытыми или закрытыми. Закрытое выражение должно полностью помещаться на одной строке. Открытые выражения должны начинаться с требуемого отступа и могут перед суффиксом иметь перевод строки:

function argument_expression(precedence = 0, open = false) {

Основу этого парсера составляет функция expression. В ней используется прием, называемый нисходящим приоритетом операторов (Top Down Operator Precedence).

Функция принимает необязательный параметр open, допускающий лояльное отношение к конкретным переводам строки. Если open имеет значение true, ожидается, что лексема будет находиться в точке отступа.

let definition;
let left;
let the_token = token;

Чем является лексема, числовым или текстовым литералом?

if (the_token.id === "(number)" || the_token.id === "(text)") {
    advance();
    left = the_token;

Является ли лексема буквенно-цифровой?

} else if (the_token.alphameric === true) {
    definition = lookup(the_token.id);