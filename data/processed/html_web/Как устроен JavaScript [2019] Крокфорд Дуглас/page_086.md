---
source_image: page_086.png
page_number: 86
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 31.42
tokens: 7507
characters: 2117
timestamp: 2025-12-24T09:55:56.118314
finish_reason: stop
---

8.2 Как работают объекты

Из объектов можно выстраивать сложные структуры данных, поскольку в объектах могут храниться ссылки на объекты. Можно построить разнообразные графы и циклические структуры. Глубина вложения не лимитирована, но благоразумие здесь не помешает.

Когда оператору typeof предоставляется объект, он выдает строку "object":

    typeof my_little_object === "object" // true

Регистр

Проверка на соответствие ключевому значению чувствительна к регистру символов. Поэтому my_little_object.cat — это не то же самое, что my_little_object.Cat или my_little_object.CAT. Соответствие строковых значений имен свойств определяется оператором ===.

Копирование

Функция Object.assign способна скопировать свойства из одного объекта в другой. Копию объекта можно создать, присвоив его пустому объекту.

    let my_copy = Object.assign({}, my_little_object);
    my_copy.bar        // "a long rod or rigid piece of wood or metal"
    my_copy.age         // 39
    my_copy.age += 1;
    my_copy.age         // 40
    delete my_copy.age;
    my_copy.age         // undefined

Объекту может присваиваться материал из множества объектов. Таким образом, сложный объект реально сконструировать путем сбора материала из более простых.

Наследование

В JavaScript объект может быть создан наследованием из другого объекта. Это совершенно иной тип наследования, чем тот, что практикуется в языках, имеющих такие тесно связанные программные структуры, как классы. В JavaScript это связанные данные, которые могут существенно уменьшить уязвимость, способную охватить всю структуру приложения.

Метод Object.create(proto тип) получает существующий объект и возвращает в качестве его наследника новый объект. Существующий объект становится прототипом нового объекта. Прототипом может стать любой объект. Объект — наследник прототипа может также стать прототипом еще более новых объектов. Ограничений на длину цепочки прототипов не существует, но лучше делать ее покороче.

При попытке обращения к несуществующему свойству перед возвращением undefined система сначала обращается к прототипу, а затем к его прототипу и т. д.