---
source_image: page_240.png
page_number: 240
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 26.16
tokens: 7458
characters: 1780
timestamp: 2025-12-24T09:59:58.328199
finish_reason: stop
---

25.9 Как работает транспиляция

Следующему языку нужно лучше поддерживать Юникод. Например, должна существовать какая-то форма разбиения текста на глифы, учитывающая наличие комбинированных символов.

В качестве внутреннего представления символов в следующем языке должен использоваться UTF-32, как бы экстравагантно это ни выглядело. Я помню времена, когда расточительством считались 8 бит на символ. Тогда память измерялась в килобайтах. Сейчас она измеряется в гигабайтах. Объем памяти вырос настолько, что размером символа можно пренебречь. С UTF-32 разница между единицами и точками кода исчезает, что упрощает написание программ, правильно работающих в международном формате.

Следующий язык должен непосредственно поддерживать BLOB-объекты. Требуется, чтобы некоторые данные были большими, запутанными, красиво упакованными и таинственными.

В следующем языке должна существовать более широкая поддержка событийного программирования, включая цикл обработки и механизм для отправки сообщений и упорядоченной доставки.

В следующем языке должна быть более качественная поддержка безопасной сетевой работы.

Следующий язык должен поддерживать управление процессами: запуском, обменом данными и уничтожением. Должна иметься возможность связывать процессы с целью их группового самоуничтожения. Если один из них дает сбой, он считается общим для всех и возникает возможность повторно запускать их с заново сформированным состоянием.

В следующем языке должна существовать поддержка параллельной обработки чистых функций. Процессоры не становятся быстрее, но их становится больше. В конечном счете наибольший прирост производительности достигается за счет параллелизма.

Neo — это не следующий язык, но он поможет нам не бояться следующей парадигмы. Далее мы будем создавать Neo.