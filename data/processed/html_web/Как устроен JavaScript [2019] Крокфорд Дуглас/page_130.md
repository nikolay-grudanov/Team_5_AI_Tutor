---
source_image: page_130.png
page_number: 130
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 35.28
tokens: 7615
characters: 2591
timestamp: 2025-12-24T09:57:13.621148
finish_reason: stop
---

14.2 Как работают исключения

на отображение перехвата. Если в нем есть предназначенный компонент catch, ему передается управление и выполнение продолжается с кода этого компонента.

Вот так все движеется вниз по виртуальному стеку вызовов, пока не будет найден компонент catch. Когда стек вызовов опустеет, мы получим неперехваченное исключение.

Это простой и весьма удачный механизм. Он позволяет использовать стиль программирования, в котором основное внимание уделяется успешному выполнению кода, но без абсолютного исключения сбоев. Однако, применяя его, легко наделать ошибок.

Обычные исключения

Наиболее распространенная ошибка в работе с исключениями — их использование для передачи обычных результатов. Например, если взять функцию, считывающую содержимое файла, то ошибка отсутствия файла не должна быть исключением. Это вполне обычное дело. Исключения должны применяться только при неожиданных проблемах.

В языке Java неправильное применение исключений упрощает способ обхода проблем с его системой типов. Метод Java может возвратить результат только одного типа, поэтому исключения используются в качестве альтернативного канала для возвращения обычных результатов, чей тип не разрешен системой типов. Из-за этого несколько компонентов catch могут оказаться прикрепленными к одному и тому же блоку try. Ситуация становится запутанной, поскольку обычные результаты смешиваются с реальными исключениями.

Это напоминает присваивание значения инструкции GOTO в языке Фортран, при котором переменная содержит адрес назначения перехода. Чтобы гарантировать выбор правильного компонента, следует выстроить компоненты catch в правильном порядке. Выбор не основывается на любом типе равенства, как в инструкции switch, он основан на правилах приведения типов, что само по себе отвратительно. Любая система типов, требующая явного приведения типов, порочна.

Пути управления продиктованы методом, создавшим объект исключения. Таким образом, создается тесная связь между объектом, который выдал исключение, и тем, который его перехватывает, что идет вразрез с построением четкой модульной конструкции.

Через этот клубок может проходить очень много путей, что способно существенно усложнить задачу высвобождения распределенных ресурсов. Для смягчения данной проблемы был добавлен компонент finally. Он представляет собой функцию без параметров, подразумеваемо вызываемую из каждой точки выхода try и из каждого компонента catch.

В то же время в JavaScript имеется намного более понятный подход. Если блок try выполнен успешно, получается либо нужный результат, либо нужное объяснение.