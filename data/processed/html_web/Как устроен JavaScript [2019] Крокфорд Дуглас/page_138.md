---
source_image: page_138.png
page_number: 138
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 26.99
tokens: 7411
characters: 1672
timestamp: 2025-12-24T09:57:14.073464
finish_reason: stop
---

Глава 16

Как работает this

Я изобрел термин «объектно-ориентированный» и могу сказать вам, что при этом не имел в виду C++.

Алан Кэй (Alan Kay)

Язык Self — это диалект языка Smalltalk, в котором классы заменены прототипами. Объект мог наследоваться непосредственно из другого объекта. Классическая модель страдала от нестабильности и раздувания по причине сильного сцепления классов посредством расширений extends. Прототипы языка Self были весьма удачным упрощением. Модель прототипов легче и выразительнее.

В JavaScript реализована весьма странная модель прототипов.

Когда объект создан, может быть назначен прототип, состоящий из части или всего содержимого нового объекта:

const new_object = Object.create(old_object);

Объекты, по сути, всего лишь контейнеры для свойств, а прототипы — это просто объекты. Методы — это всего лишь функции, сохраненные в объектах.

При попытке извлечения значения свойства, которого нет у объекта, получается значение undefined. Но если у объекта имеется прототип (как у показанного ранее new_object), в результате получается значение свойства прототипа. Если и его извлечь не удается и если у прототипа есть свой прототип, получается значение свойства прототипа, принадлежащего первому прототипу. И все спускается ниже и ниже.

У многих объектов может быть общий прототип. Эти объекты могут рассматриваться как экземпляры класса, но, по сути, это всего лишь отдельные объекты с общим прототипом.

Чаще всего прототипы используются в качестве места хранения методов. У схожих объектов, скорее всего, имеются одинаковые методы, поэтому, если методы помещаются в один общий прототип, а не в каждый объект, можно сэкономить память.