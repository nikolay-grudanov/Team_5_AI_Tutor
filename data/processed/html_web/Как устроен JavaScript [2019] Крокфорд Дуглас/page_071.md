---
source_image: page_071.png
page_number: 71
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 38.08
tokens: 7614
characters: 2144
timestamp: 2025-12-24T09:55:44.011760
finish_reason: stop
---

Логические операторы

Нелепости не обошли стороной и логические операторы.

<table>
  <tr>
    <th>!(восклицательный знак)</th>
    <th>Логическое НЕ</th>
    <th>Если операнд правдивый (truthy), результат — false.<br>Если операнд лживый (falsy), результат — true</th>
  </tr>
  <tr>
    <td>&& (знак амперсанда, знак амперсанда)</td>
    <td>Логическое И</td>
    <td>Если первый операнд лживый (falsy), результатом станет значение первого операнда, а второй операнд вычисляться не будет. Если первый операнд правдивый (truthy), результат будет определен значением второго операнда</td>
  </tr>
  <tr>
    <td>|| (вертикальная черта, вертикальная черта)</td>
    <td>Логическое ИЛИ</td>
    <td>Если операнд правдивый (truthy), результатом будет значение первого операнда, а второй операнд вычисляться не будет. Если первый операнд лживый (falsy), результат станет определяться значением второго операнда</td>
  </tr>
</table>

Not!

Логические выражения могут усложняться. Упростить их могут формальные преобразования. К сожалению, булевоподобность и NaN способны привести к тому, что формальные преобразования станут выдавать ошибки.

Обычно имеет смысл упрощать двойные отрицания. В логической системе:

\[
!!p === p
\]

что в JavaScript истинно, только когда p является булевым значением. Если p относится к какому-либо другому типу, то !!p эквивалентно выражению Boolean(p) и не обязательно эквивалентно p.

У некоторых операторов сравнения есть антиподы, например, < является антиподом >=, а > является антиподом <=. Поэтому есть возможность упростить !(a < b), применив выражение a >= b, поскольку:

\[
!(a == b) === (a !== b) \\
!(a <= b) === (a > b) \\
!(a > b) === (a <= b) \\
!(a >= b) === (a < b)
\]

Если либо a, либо b имеет значение NaN, то преобразование кода оказывается неудачным. Дело в том, что сравнение любого числа с NaN выдает результат false независимо от оператора сравнения. Следовательно:

7 < NaN // false
NaN < 7 // false
!(7 < NaN) === 7 >= NaN // false

Было бы разумнее, чтобы значение NaN было меньше всех остальных чисел или сравнение всех прочих чисел с NaN выдавало исключение. Но вместо этого в JavaScript