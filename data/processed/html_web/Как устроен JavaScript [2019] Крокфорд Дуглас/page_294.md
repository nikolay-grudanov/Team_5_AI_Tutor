---
source_image: page_294.png
page_number: 294
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 20.34
tokens: 7551
characters: 2317
timestamp: 2025-12-24T10:01:16.470039
finish_reason: stop
---

30.1 Как работают нелепости, или Что такое Wat!

нужно всегда использовать оператор ===, состоящий из трех знаков равенства. Всегда.

Кому-то оператор === не нравится, поскольку он выглядит на 50 % бестолковее оператора ==, который вдвое бестолковее оператора =. И все же правильным оператором равенства в JavaScript является ===. А применения оператора == нужно избегать, поскольку он некорректен.

Не могу посоветовать отказаться от использования оператора +, поскольку он обеспечивает единственный практический способ сложения чисел. Поэтому смиритесь с червями из банки.

    "" == false                // true
    [] == false                // true
    null == false              // false
    undefined == false         // false

Пустая строка — это логически лживое значение, поэтому дефектный оператор равенства может захотеть связать его с false. Пустой массив не является логически лживым, и все же он также сравнивается с false. А null и undefined являются логически лживыми значениями, но ни одно из них не сравнивается с false.

WAT!

    [] == []                   // false
    [] == ![ ]                 // true

Два пустых массива не являются одним и тем же объектом, поэтому они не равны. Но вторая строка вызывает недоумение. Получается, что JavaScript — это язык, в котором x и не x могут быть равны друг другу, что было бы серьезной, смеху подобной некомпетентностью. Происходит следующее: пустой массив считается логически правдивым, следовательно, ![ ] — ложь (false). Дефектный оператор равенства хочет сравнить [ ] и false в качестве чисел, хотя ни один из операндов числом не является. Пустой массив приводится к пустой строке, которая приводится к нулю. false также приводится к нулю. Нуль равен нулю, следовательно, ответом будет true.

WAT!

    [] + []                    // ""
    [] + {}                    // "[object Object]"
    {} + {}                    // "[object Object][object Object]"

Во всех эти случаях должно получаться значение NaN. Именно для этого оно и предназначено. А вместо этого, поскольку значения не являются числами, оператор + хочет их объединить. Сначала должно состояться их приведение к строкам. Метод Array.prototype.toString() преобразует пустой массив в пустую строку. Было бы лучше, если бы он работал как метод JSON.stringify() и возвращал "[ ]". Беспо-