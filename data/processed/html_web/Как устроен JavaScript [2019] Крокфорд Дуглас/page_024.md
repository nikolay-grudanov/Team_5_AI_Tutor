---
source_image: page_024.png
page_number: 24
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 51.40
tokens: 7774
characters: 2148
timestamp: 2025-12-24T09:54:47.629282
finish_reason: stop
---

2.9 Как работают числа

Хорошо известно, что JavaScript плохо справляется с обработкой десятичных дробей, в частности денежных величин. Когда в программу вводится \(0.1\) или большинство других десятичных дробей, JavaScript не способен в точности представить это значение, поэтому *использует иные величины*, подставляя значение, которое он способен представить.

Когда в программе набирается десятичная точка или же она считывает значение данных с десятичной точкой, вполне вероятно, что в программу вносится небольшая погрешность. Порой погрешности настолько малы, что их невозможно заметить. Иногда они взаимопоглощаются, а в некоторых случаях накапливаются.

При разборе \(0.3\) мы получим результат, отличный от получаемого при разборе \(0.1 + 0.2\):

{
    "sign": 1,
    "coefficient":5404319552844595,
    "exponent":-54,
    "number": 0.3
}

{
    "sign": 1,
    "coefficient":5404319552844596,
    "exponent":-54,
    "number": 0.300000000000000004
}

Заметьте, что ни \(0.299999999999999988897769753748434595763683319091796875\), ни \(0.3000000000000000444089209850062616169452667236328125\) не равны \(0.3\).

Рассмотрим еще один пример. При разборе \(100 / 3\) мы получим:

{
    "sign": 1,
    "coefficient": 9382499223688534,
    "exponent": -48,
    "number": 33.3333333333333336
}

Заметьте, JavaScript сообщил, что число равно \(33.3333333333333336\). Конечная цифра 6 свидетельствует о том, что JavaScript не в состоянии дать правильный или хотя бы приемлемый ответ. На самом деле все еще печальнее. JavaScript фактически полагает, что ответ в точности равен \(33.3333333333333570180911920033395290374755859375\).

Системы с плавающей точкой поставляются с функциями, выполняющими преобразования между внутренним двоичным представлением и внешним, более привычным для людей десятичным представлением. Эти функции разработаны таким образом, чтобы по возможности максимально скрыть истинное положение дел. Есть вполне обоснованная обеспокоенность тем, что постоянное столкновение с реалиями стандарта IEEE 754 вызвало бы настоящий бунт с выдвижением требований об использовании чего-то более подходящего. А на практике мы не желаем