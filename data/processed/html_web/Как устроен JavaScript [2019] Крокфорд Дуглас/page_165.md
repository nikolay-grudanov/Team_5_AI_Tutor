---
source_image: page_165.png
page_number: 165
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 37.44
tokens: 7678
characters: 2578
timestamp: 2025-12-24T09:58:11.598284
finish_reason: stop
---

ленных программ. К сожалению, когда промисы были перенесены в JavaScript, они потеряли все свои качества новой парадигмы. Остался лишь неуклюжий механизм потока управления. Промисы не были предназначены для управления локальным потоком управления, поэтому плохо справляются с этой задачей. Они, конечно же, лучше безрассудной череды обратных вызовов, но их работу все равно нельзя признать удовлетворительной.

Третья ошибка называется Async Await (асинхронные ожидания). Это пара ключевых слов, используемая для декорирования обычного последовательного кода и его волшебного превращения в событийный код. Прием похож на генераторы ES6 тем, что написанный вами код сильно отличается от получаемого кода. К его заслугам можно отнести сглаживание большей части разочарований, привнесенных промисами. Самое симпатичное в асинхронных ожиданиях — возможность продолжать создавать программы в стиле старой парадигмы. Но в этом кроется и самая серьезная проблема.

Новая парадигма играет важную роль. Понять ее может оказаться нелегко, потому что она новая, но именно так добиваются прогресса. Асинхронное ожидание дает нам возможность работать продуктивно, не стремясь двигаться вперед. Его пользователи пишут код, который сами не до конца понимают. А это плохо. Ширится проблема, связанная с программистами, которые повсюду ставят декораторы async и await. Поскольку они не осознают свои действия, то не понимают, как их правильно использовать. Не нужно отвергать или скрывать следующую парадигму. Ее нужно принять.

Общий признак всех трех ошибок — тесная связь логики и потока управления. Это снижает уровень связности, поскольку в одну структуру сводится слишком много разнородных действий. Их лучше разделить.

Запросчики

При конструировании нужно применять разбиение на модули. Каждая элементарная операция, которая может выполнять запрос к какому-то серверу или базе данных либо запускать процесс, должна стать отдельной функцией. Функция, которая просто выполняет элементарную операцию, обладает сильной связностью. Такие функции также принимают в качестве первого аргумента функцию обратного вызова. Когда элементарная операция завершена, результат передается обратному вызову. Это уменьшает зависимость от другого кода, давая нам слабое сцепление. Такова рекомендуемая норма модульного конструирования, помогающая нам в новой парадигме.

Для описания функции, принимающей обратный вызов и выполняющей элементарную операцию, которая может быть не завершена до будущего хода, используется слово «запросчик» (requestor):

function my_little_requestor(обратный_вызов, значение)