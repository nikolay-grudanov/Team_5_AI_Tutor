---
source_image: page_122.png
page_number: 122
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 17.53
tokens: 7328
characters: 1478
timestamp: 2025-12-24T09:56:42.108912
finish_reason: stop
---

13.1 Как работают генераторы

создает функцию-генератор, а та, в свою очередь, создает значение. Функциональная конструкция проще, понятнее и легче в использовании.)

И наконец, что хуже всего, генераторы стандарта ES6 совершенно не нужны. Я не рекомендую использовать функциональные особенности — есть более удачные варианты.

Рассмотрим пример генераторов стандарта ES6:

function* counter() {
    let count = 0;
    while (true) {
        count += 1;
        yield count;
    }
}

const gen = counter();

gen.next().value                // 1
gen.next().value                // 2
gen.next().value                // 3

А вот что я рекомендую использовать взамен:

function counter() {
    let count = 0;
    return function counter_generator() {
        count += 1;
        return count;
    };
}

const gen = counter();

gen()                            // 1
gen()                            // 2
gen()                            // 3

Вместо написания чего-то похожего на функцию, выдающего с помощью инструкции yield значение, фактически являющееся функцией, возвращающей объект, содержащий следующий метод, выдающий объект, содержащий свойство value, нужно просто написать функцию, возвращающую значение.

Более удачный способ применения

Генераторы нам не помешают. Давайте найдем им правильное применение. Начнем с функции, возвращающей функцию. Внешняя функция является фабрикой. Внутренняя функция представляет собой генератор. В общем виде получается следующий шаблон: