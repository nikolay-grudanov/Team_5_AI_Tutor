---
source_image: page_077.png
page_number: 77
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 36.64
tokens: 7596
characters: 2368
timestamp: 2025-12-24T09:55:50.749036
finish_reason: stop
---

Значение свертки передается функции add для каждого элемента наряду с текущим элементом массива. В качестве исходного значения свертки было явно передано число 0. Функция add видит аргументы в такой последовательности:

\[
\begin{align*}
(0, 3) & \quad // 3 \\
(3, 5) & \quad // 8 \\
(8, 7) & \quad // 15 \\
(15, 11) & \quad // 26
\end{align*}
\]

Каждое значение, возвращаемое add, становится значением свертки для следующего вызова add.

Исходное значение свертки не всегда должно быть нулевым. Если reduce передается функция multiply, то исходным значением свертки должно быть число 1. Если reduce передается Math.max, исходным значением свертки должно быть -Infinity. Здесь есть шанс допустить ошибку, поэтому при выборе исходного значения свертки нужно быть внимательными.

Другой способ создания reduce не требует исходного значения свертки. Вместо этого функция вызывается на один раз меньше. При первом вызове она получает нулевой и первый элементы. Нулевой элемент становится ее исходным значением.

total = my_little_array.reduce(add);        // 26

Теперь функция add видит аргументы в такой последовательности:

\[
\begin{align*}
(3, 5) & \quad // 8 \\
(8, 7) & \quad // 15 \\
(15, 11) & \quad // 26
\end{align*}
\]

Функция вызывается на один раз меньше, и возможность ошибки при выборе неверного исходного значения свертки исключается.

У JavaScript есть замечательная особенность, заключающаяся в том, что его метод reduce работает в любом случае. Если ему передается исходное значение свертки, функция вызывается для каждого элемента. Если исходное значение свертки не передается, то для первого элемента функция не вызывается. Вместо этого первый элемент становится исходным значением свертки. Таким образом, работают оба примера свертки путем сложения, показанные ранее.

Функция reduceRight действует практически аналогично, за исключением того, что начинает свою работу с конца массива. Мне хотелось бы, чтобы она называлась reduce_reverse.

Я использую метод reduce для вычисления контрольной цифры ISBN-номера данной книги:

function isbn_13_check_digit(isbn_12) {
    const string_of_digits = isbn_12.replace(/-/g, "");
    if (string_of_digits.length === 12) {
        const check = string_of_digits.split("").reduce(
            function (reduction, digit, digit_nr) {
                return reduction + (
                    digit_nr % 2 == 0