---
source_image: page_162.png
page_number: 162
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 35.61
tokens: 7551
characters: 2355
timestamp: 2025-12-24T09:58:01.831493
finish_reason: stop
---

20.3 Как работает событийное программирование

Событийность обеспечивает способ управления широкой активностью без предоставления приложений потокам. Фактически имеются системы, в которых есть потоки приложений, зависящие от событийности управления своими пользовательскими интерфейсами только потому, что это более простой и надежный способ обработки событий с течением времени. Событийное программирование основано на двух принципах: на применении функций обратного вызова и использовании цикла обработки.

Функцией обратного вызова является функция, которая будет вызвана в будущем, когда случится что-нибудь интересное, например:

• поступит сообщение;
• завершится какая-то работа;
• человек станет общаться с программой;
• датчик на что-то отреагирует;
• истечет определенное время;
• произойдет некий сбой.

Функция обратного вызова передается функции, которая запускает или отслеживает активность. В более простых системах функция обратного вызова прикрепляется к объекту, представляющему активность. В браузерах функцию обратного вызова можно прикрепить к DOM-узлу, назначив обратный вызов определенному свойству этого узла:

my_little_dom_node.onclick = функция обратного вызова;

или вызвав в отношении объекта метод регистрации события:

my_little_dom_node.addEventListener("click", функция обратного вызова, false);

Работают обе представленные формы. Когда пользователь щелкает кнопкой мыши на конкретном DOM-узле, функция обратного вызова (она же обработчик события) вызывается, вероятно выполняя какое-то полезное действие в ответ на событие.

Еще одной идеей, заложенной в основу событийного программирования, является цикл обработки, известный также как цикл обработки событий или цикл обработки сообщений. Цикл обработки принимает из очереди событие или сообщение с наивысшим приоритетом и вызывает функцию обратного вызова, которая зарегистрирована для получения этого события или сообщения. Функция обратного вызова выполняется до завершения своей работы. Обратный вызов не нуждается в блокировке области памяти или применении взаимного исключения. Обратный вызов не прерывается, поэтому вероятности возникновения состязательных условий нет. Когда управление из функции обратного вызова возвращается, цикл обработки извлекает из очереди ее следующий элемент и работа продолжается уже с ним. Это очень надежная модель программирования.