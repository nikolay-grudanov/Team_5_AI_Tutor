---
source_image: page_079.png
page_number: 79
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 35.48
tokens: 7569
characters: 2239
timestamp: 2025-12-24T09:55:49.876280
finish_reason: stop
---

• Метод findIndex похож на метод find, но вместо возвращения обработанного элемента, когда функция возвращает что-либо правдивое, он возвращает его порядковый номер.
• Метод filter также похож на метод find, но он всегда ведет обработку до конца и возвращает массив, собирающий все элементы, для которых функция возвратила правдивое значение. Стало быть, метод find возвращает первый соответствующий условию элемент, а метод filter — все соответствующие ему элементы.
• Метод map похож на метод forEach, но он собирает все возвращаемые значения и возвращает их в новом массиве. Этот метод — идеальный способ выполнения преобразований путем создания нового массива, являющегося усовершенствованной или развитой версией оригинала.

Эти методы обеспечивают более совершенный способ обработки массивов без использования цикла for. Но этот набор методов еще не полон.

Методы forEach и find способны на выход на ранних стадиях. (Формами forEach с возможностью выхода являются every и some.) А методы map, reduce и filter не имеют вариантов с ранним выходом. У метода reduce есть вариант, работающий в обратном направлении, — reduceRight, а у методов forEach, map, filter и find таких вариантов нет.

Эти функциональные пробелы не позволяют отказаться от применения инструкции for.

Сортировка

В JavaScript имеется метод sort. К сожалению, с ним возникает ряд проблем.

Он выполняет сортировку на месте, изменяя сортируемый массив. Это означает, что замороженный массив отсортировать невозможно, также небезопасно сортировать совместно используемый массив.

let my_little_array = ["unicorns", "rainbows", "butterflies", "monsters"];
my_little_array.sort()
    // my_little_array имеет значение ["butterflies", "monsters",
    //                                 "rainbows", "unicorns"]

Используемая им по умолчанию функция сравнения выстраивает значения таким образом, будто это строки, даже если они являются числами, например:

let my_little_array = [11, 2, 23, 13, 3, 5, 17, 7, 29, 19];
my_little_array.sort();
    // my_little_array имеет значение [11, 13, 17, 19, 2, 23, 29, 3, 5, 7]

Это не только абсолютно неэффективно, но и неверно. К счастью, этот негатив можно сгладить, передав методу sort функцию сравнения. Этой функции передаются