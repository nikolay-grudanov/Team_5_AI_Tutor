---
source_image: page_150.png
page_number: 150
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 30.87
tokens: 7429
characters: 1895
timestamp: 2025-12-24T09:57:41.273184
finish_reason: stop
---

Оптимизация работает несколько иначе.

• Вычисляются выражения аргументов.
• Если текущая активация достаточно велика, в качестве нового объекта активации используется текущий.
• В противном случае:
  ▪ создается объект активации, размер которого позволяет ему хранить все параметры и переменные функции;
  ▪ из текущего объекта активации в новый объект копируется поле caller;
  ▪ новый объект активации становится текущим.
• В новом объекте активации сохраняется ссылка на вызываемый функциональный объект.
• В новом объекте активации значения из аргументов сохраняются в параметрах. Пропущенные аргументы рассматриваются как содержащие значение undefined. Лишние аргументы игнорируются.
• Всем переменным в новом объекте активации присваивается значение undefined.
• Начинается выполнение вызванной функции.

Важность этого различия заключается в том, что если размер объекта активации достаточно велик, как чаще всего и бывает, то не нужно выделять еще один такой объект. Теперь можно повторно воспользоваться текущим объектом активации. Цепочки стека вызовов не очень длинные — обычно несколько сотен записей, поэтому, если ожидается применение концевых вызовов, есть смысл для реализации всегда выделять объекты активации одного максимального размера. Экономия времени на распределение памяти и сборку мусора может быть весьма существенной. Но это еще не все.

При оптимизации концевых вызовов рекурсивные вызовы способны стать такими же быстрыми, как и циклы. С функциональной точки зрения это важно, потому что циклы по своей природе не относятся к чистому коду. Чистота приходит с рекурсией. Благодаря данной оптимизации аргумент снижения производительности при рекурсии сведен на нет.

В общем виде структура цикла выглядит так:

    while (true) {
        выполнение каких-либо действий
        if (done) {
            break;
        }
        выполнение дополнительных действий
    }