---
source_image: page_164.png
page_number: 164
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 38.16
tokens: 7657
characters: 2683
timestamp: 2025-12-24T09:58:08.272227
finish_reason: stop
---

20.5 Как работает событийное программирование

суффикс -Sync, не допускаются. Функция, выполнение которой занимает много времени, запрещена.

Нарушения закона ходов превращают высокопроизводительную систему в систему с очень низкой производительностью. Нарушения вызывают задержки не только для текущего обратного вызова, но и для всего, что находится в очереди. Задержки могут накапливаться, что увеличивает очередь. Система перестает быть быстрой и отзывчивой.

Поэтому любая функция, нарушающая закон, должна быть исправлена или изолирована в отдельном процессе. Процесс похож на поток, который ни с кем не делит свою память. То есть для обратного вызова имеет смысл отправить часть работы процессу, а для этого процесса — отправить сообщение после его завершения. Сообщение попадает в очередь и в итоге доставляется.

JavaScript ничего не знает о процессах. Процессы — это сервисы, которые могут предоставляться системами, где выполняется JavaScript. Процессы — важная часть конечной модели, поэтому вполне вероятно, что они станут первой характерной чертой следующего языка.

Серверные проблемы

Язык JavaScript был создан для циклов событий и со своей ролью справляется весьма успешно. К сожалению, циклы сообщений потребовали от приложения гораздо больших усилий. Дело в том, что характер работы, выполняемой сервером, совершенно иной. В браузере основная часть работы программы — это реакция на события пользовательского интерфейса. Вызывается обработчик событий, он выполняет некоторую работу, обновляет отображение — и все.

У сервера типовой рабочий процесс гораздо сложнее. Вызывается приемник или обработчик сообщений, которому, прежде чем он сможет передать свой ответ, может потребоваться обмен данными с другими системами, возможно расположенными на других машинах. Иногда то, что он получит из одной системы, нужно передать другой системе. Эти операции способны выстраиваться в длинные цепочки. А результаты взаимодействия с другими системами будут передаваться с помощью обратных вызовов. Для этого есть весьма простое программное решение, но сначала давайте рассмотрим три самые популярные ошибки.

Первая ошибка называется Callback Hell (безрассудная череда обратных вызовов). Это шаблон, в котором каждая функция обратного вызова содержит код для запроса следующей элементарной операции. Этот запрос обеспечивает обратный вызов, который также запрашивает другую элементарную операцию и т. д. Программы, написанные таким образом, трудно поддаются чтению и обслуживанию и характеризуются невысокой надежностью.

Вторая ошибка называется Promises (промисы). В исходном виде промисы были отличной идеей. Они были созданы для поддержки разработки безопасных распреде-