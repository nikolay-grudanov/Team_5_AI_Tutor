---
source_image: page_204.png
page_number: 204
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 46.86
tokens: 7727
characters: 2654
timestamp: 2025-12-24T09:59:25.164092
finish_reason: stop
---

23.3 Как работает тестирование

Широкие функциональные возможности дают определенные преимущества, но за все приходится платить. Если не осознавать, какова будет цена, придется платить раздуванием.

TDD

Как методология разработка на основе тестирования (Test Driven Development (TDD)) мне нравится. А вот как религию я ее просто ненавижу. Ярые приверженцы TDD сказали мне, что небрежно скроенный ненадежный код вполне допустим и даже приветствуется TDD. Предполагается, что тесты выявят все ошибки, поэтому нет необходимости в дисциплинированном стиле программирования.

Именно так рациональные приемы программирования превращаются в весьма пагубную практику. Истина заключается в том, что нельзя полагаться на тесты при поиске всех ошибок. Нужно вкладываться в предотвращение ошибок. Рекомендуемая практика программирования заключается в малозатратных вложениях в качество. С годами мой собственный стиль программирования изменился, поскольку я наблюдаю за тем, как формируются ошибки и каким образом можно снизить вероятность их появления.

Я получил сообщение от сторонника использования JSLint об ошибке этого анализатора кода. Он включил в свою программу функцию, отклоненную JSLint, и сказал, что, видимо, в JSLint есть что-то неправильное, поскольку эта функция прошла все свои блочные тесты. Внеплановая проверка показала, что JSLint был прав. Он обнаружил ошибку в регулярном выражении, которую не нашли тесты. Ошибки были в самих тестах. Ложные отрицательные результаты всегда исправляются быстро, а вот ложные положительные — неистребимы. Такие тесты дают нам ложную уверенность, но не добавляют качества. Так какими же должны быть настоящие тесты?

Для низкоуровневого кода весьма эффективны блочные тесты. Например, упомянутая в главе 3 библиотека Big Integer низкоуровневая и слабо зависит от чего-либо еще. Я написал для нее множество блочных тестов, и они очень помогли в разработке.

По мере того как мы взбираемся наверх, блочные тесты постепенно становятся все менее эффективными. С ростом зависимостей значимость тестов уменьшается. Необходимость разработки заглушек, имитаторов и фиктивных объектов приводит к росту затрат на создание тестов. (Мне приходилось наблюдать, как разработчики впустую тратят время на споры о том, является ли тот или иной элемент фиктивным объектом или имитатором.) И при переходе на более высокие уровни сложность смещается от компонентов к соединениям между компонентами.

Когда теряется чистота, количество ошибок возрастает, но блочные тесты не проверяют степень чистоты. В случае плохой модульности вероятность появления ошибок возрастает, но блочные тесты не проводят проверку на модульность. С те-