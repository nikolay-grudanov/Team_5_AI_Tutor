---
source_image: page_019.png
page_number: 19
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 102.18
tokens: 8631
characters: 3220
timestamp: 2025-12-24T09:55:05.882192
finish_reason: stop
---

ществовать обычные математические умозаключения. В нем работают сочетательный и распределительный законы. Вне этого диапазона все становится более хаотичным. Например, порядок, в котором происходило сложение последовательности чисел, может изменить сумму. Так, результат сложения ((0.1 + 0.2) + 0.3) превышает результат сложения (0.1 + (0.2 + 0.3)). Метод Number.isSafeInteger(число) возвращает true, если число относится к безопасному диапазону.

Метод Number.isInteger(число) возвращает true, если число целое и из безопасного диапазона или оно выше этого диапазона. Все числа, превышающие значение константы Number.MAX_SAFE_INTEGER, рассматриваются как целые. Для некоторых из них это абсолютно верно. Но для большинства — нет.

В Number.MAX_VALUE содержится наибольшее число, которое может быть представлено в JavaScript. Его точное значение — Number.MAX_SAFE_INTEGER * 2 ** 971, или:

17976931348623157081452742373170435679807056752584499659891747680315726078002853
87605895586327668781715404589535143824642343213268894641827684675467035375169860
49910576551282076245490090389328944075868508455133942304583236903222948165808559
332123348274797826204144723168738177180919299881250404026184124858368

Это цифра 1, за которой следуют еще 308 цифр. Подавляющую часть этой конструкции составляет фиктивное значение. Эти числа могут дать 15,9 значимого десятичного разряда. Завершающие 292 цифры — это иллюзия, вызванная большей раздробленностью чисел с основанием 2 по сравнению с числами с основанием 10.

Прибавление к Number.MAX_VALUE любого безопасного целого числа дает сумму, также равную Number.MAX_VALUE. Это похоже на то, что программа в состоянии ошибки выдает в качестве результата значение Number.MAX_VALUE. Любой результат, превышающий Number.MAX_SAFE_INTEGER, вызывает подозрение. Стандарт IEEE 754 обещает возможности применения огромного диапазона, но если не действовать чрезвычайно осторожно, это, скорее всего, приведет к ошибкам.

Константа Number.MIN_VALUE содержит наименьшее представляемое число больше нуля. Его точное значение — 2 ** -1074, или:

4.940656458412465441765687928682213723650598026143247644255856825006755072702087
51865299836361635992379796564695445717730926656710355939796398774796010781878126
30071319031140452784581716784898210368871863605699873072305000638740915356498438
73124733972731696151400317153853980741262385655911710266585566867681870395603106
24931945271591492455329305456544401127480129709999541931989409080416563324524757
14786901472678015935523861155013480352649347201937902681071074917033322268447533
35720832431936092382893458368060106011506169809753078342277318329247904982524730
77637592724787465608477820373446969953364701797267771758512566055119913150489110
14510378627381672509558373897335989936648099411642057026370902792427675445652290
87538682506419718265533447265625e-324

Все положительные числа меньше Number.MIN_VALUE неотличимы от нуля. Заметьте, что значимая часть числа Number.MIN_VALUE состоит только из одного бита в младшем значащем разряде. Этот одинокий бит создает большое фиктивное значение.

Number.prototype — это объект, из которого наследуются все числа. Number.prototype содержит набор методов, к сожалению не приносящий особой пользы.