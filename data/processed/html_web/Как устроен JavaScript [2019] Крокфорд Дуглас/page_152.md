---
source_image: page_152.png
page_number: 152
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 33.20
tokens: 7478
characters: 1969
timestamp: 2025-12-24T09:57:46.894059
finish_reason: stop
---

18.4 Как работают концевые вызовы

Это также был не концевой вызов, поскольку им возвращается содержимое значения. Нам известно, что значение является результатом any(), но вызов был не в концевой позиции.

Рекурсия вообще не концевой вызов.

function factorial(n) {
    if (n < 2) {
        return 1;
    }
    return n * factorial(n - 1);        // <-- не концевой вызов
}

Рекурсивный вызов factorial не находится в концевой позиции, поэтому он создает запись активации при каждой итерации, но вызов можно переместить в концевую позицию:

function factorial(n, result = 1) {
    if (n < 2) {
        return result;
    }
    return factorial(n - 1, n * result);    // <-- концевой вызов
}

Эта версия будет оптимизирована. Рекурсивные вызовы не станут создавать объекты активации. Вместо этого произойдет переход в начало функции. Для освежения параметров здесь применяются аргументы, а не присваивание.

Возвращение нового функционального объекта не является концевым вызовом:

return function () {};                // <-- не концевой вызов

если только новый функциональный объект тут же не будет вызван:

return (function () {}());            // <-- концевой вызов

Исключительные случаи

Бывают ситуации, когда оптимизацию следует отменить, чтобы хорошие программы не превратились в плохие.

Концевой вызов внутри блока try оптимизировать невозможно. Оптимизация сэкономила бы время и память за счет отказа от привязки объекта активации для данного вызова к стеку вызовов. Но блок try может передать управление блоку catch этого вызова, и, чтобы это произошло, объект активации не следует оптимизировать. Кроме того, это станет еще одной веской причиной избавления от неправильного применения исключений.

Если рассматриваемая функция создает новый функциональный объект, имеющий какие-нибудь свободные переменные, то у нового функционального объекта должен быть доступ к объекту активации ее создателя, следовательно, объект активации не следует оптимизировать.