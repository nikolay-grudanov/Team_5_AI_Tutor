---
source_image: page_139.png
page_number: 139
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 25.42
tokens: 7388
characters: 1642
timestamp: 2025-12-24T09:57:13.756739
finish_reason: stop
---

А как функция в прототипе узнает, с каким объектом она работает? Здесь на сцену выходит привязка this.

Синтаксически вызов метода представляет собой тернарную операцию, использующую . и вызов () или ссылку [ ] и вызов (). Тремя подвыражениями в тернарном выражении являются:

• интересующий объект;
• имя метода;
• список аргументов.

Именованный метод ищут в объекте и в цепочке его прототипов. Если функция не найдена, выдается исключение. Это замечательно и подталкивает к использованию полиморфизма. Наследственность объекта вас волновать не должна. Нужно лишь побеспокоиться о его возможностях. Если возможностей у объекта нет, выдается исключение. Если они есть, мы ими пользуемся, не беспокоясь о том, каким образом они были приобретены.

Если функция найдена, она вызывается со списком аргументов. Функция также получает в качестве подразумеваемого параметр this, привязанный к интересующему объекту.

Если метод содержит внутреннюю функцию, последняя не получает доступа к this, поскольку внутренние функции вызываются в качестве функций, а привязку this получают только вызовы методов:

Old_object.bud = function bud() {
    const that = this;

    // lou не может видеть принадлежащий bud параметр this, но lou может видеть
    // принадлежащий bud параметр that.

    function lou() {
        do_it_to(that);
    }
    lou();
};

Привязка this работает только при вызове методов, поэтому вызов:

new_object.bud();

выполняется успешно, а:

const funky = new_object.bud;
funky();

нет. Здесь в funky содержится ссылка на ту же самую функцию, что и в new_object.bud, но funky вызывается как функция, поэтому не имеет привязки this.