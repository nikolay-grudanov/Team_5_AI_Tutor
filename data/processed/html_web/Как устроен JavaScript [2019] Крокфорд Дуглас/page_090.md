---
source_image: page_090.png
page_number: 90
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 41.05
tokens: 7633
characters: 2495
timestamp: 2025-12-24T09:56:17.373791
finish_reason: stop
---

8.6 Как работают объекты

в ключ-строку с помощью метода toString, что, как мы уже видели, приводит к разочарованиям.

Вместо предоставления нам объекта, правильно работающего для всех ключей, JavaScript дает другой тип объектов — WeakMap, который позволяет быть ключами объектам, а не строкам и у которого совершенно иной интерфейс.

<table>
  <tr>
    <th>Объект</th>
    <th>WeakMap</th>
  </tr>
  <tr>
    <td>object = Object.create(null);</td>
    <td>weakmap = new WeakMap();</td>
  </tr>
  <tr>
    <td>object[ключ]</td>
    <td>weakmap.get(ключ)</td>
  </tr>
  <tr>
    <td>object[ключ] = значение;</td>
    <td>weakmap.set(ключ, значение);</td>
  </tr>
  <tr>
    <td>delete object[ключ];</td>
    <td>weakmap.delete(ключ);</td>
  </tr>
</table>

В таком существенном синтаксическом различии двух типов объектов, работающих одинаково, нет никакого смысла. Также нет смысла в том, что их два, а не один. Вместо одного типа объекта, который позволяет задействовать в качестве ключей только строки, и другого, позволяющего использовать только объекты, должен быть один тип объекта, позволяющий брать в качестве ключей как строки, так и объекты.

При всем этом WeakMap — великолепный тип объекта. Рассмотрим два примера его использования.

Нам нужно поместить в объект секретное свойство. Для получения доступа к секретному свойству нужны доступ к объекту и секретный ключ. Получить доступ к свойству невозможно, пока не будет и того и другого. Это можно сделать с WeakMap, рассматривая его в качестве секретного ключа:

const secret_key = new WeakMap();
secret_key.set(object, secret);

secret = secret_key.get(object);

Чтобы раскрыть секрет, нужен доступ как к объекту, так и к секретному ключу. У этого приема есть весьма полезное качество: секретные свойства могут запросто добавляться к замороженным объектам.

Нам нужно получить возможность предоставления объекта некоторому коду, который способен сделать что-то полезное, например внести его в список или сохранить для дальнейшего извлечения, но при этом не хочется давать этому коду возможность изменить объект или вызвать какой-либо из его методов. В реальном мире нам хочется, чтобы работник запарковал машину, но при этом не рылся в бардачке и багажнике и не продал ее. В реальном мире доверять людям можно, но относиться с доверием к коду в компьютерной сети крайне неразумно.

Поэтому создадим устройство, называемое установщиком пломбы (sealer). Мы дадим ему объект для установки пломбы, а он вернет контейнер, который нельзя