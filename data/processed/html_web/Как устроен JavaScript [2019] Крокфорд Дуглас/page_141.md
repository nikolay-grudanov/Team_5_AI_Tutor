---
source_image: page_141.png
page_number: 141
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 35.59
tokens: 7611
characters: 2481
timestamp: 2025-12-24T09:57:30.063398
finish_reason: stop
---

Все переменные статически привязаны, и это хорошо. Динамическая привязка есть только у this. Это означает, что ее привязка определяется вызывающей функцией, а не создателем функции. Данная аномалия становится источником путаницы.

У функционального объекта есть два прототипных свойства. В нем имеется делегационная ссылка на Function.prototype. Также у него есть свойство prototype, содержащее ссылку на объект, используемый в качестве прототипа объектов, созданных функцией, вызванной с префиксом new.

Вызов конструктора записывается путем помещения префикса new перед вызовом функции. Наличие префикса new приводит к следующим действиям:

• созданию значения this с Object.create(функция.prototype);
• вызову функции с this, привязанной к новому объекту;
• принудительному возвращению this, если функция не возвращает объект.

Используя функцию Object.assign для копирования методов из одного прототипа в другой, можно организовать что-то вроде наследования. Но куда прочнее в обиход вошла замена свойства prototype функционального объекта объектом, созданным другим конструктором.

Поскольку каждая функция является потенциальным конструктором, узнать в нужный момент, следует ли в вызове применять префикс new, довольно трудно. Хуже того, когда он требуется, но по забывчивости не поставлен, никаких предупреждений не выдается.

Поэтому мы руководствуемся следующим соглашением: функции, предназначенные для вызова в качестве конструкторов с префиксом new, должны получать имена, начинающиеся с прописной буквы.

В JavaScript имеется также более привычный, похожий на классы синтаксис, созданный специально для тех разработчиков, которые не знают и никогда не узнают, как работает JavaScript. Он позволяет задействовать навыки работы с менее востребованными языками без обучения.

Синтаксис классов, несмотря на свой внешний вид, не реализует никакие классы. Это всего лишь «синтаксический сахар» в дополнение к странностям конструктора псевдоклассов. Он сохраняет самый худший аспект классической модели — расширения extends, создающие сильные сцепления между классами. Сильное сцепление становится причиной создания ненадежных и дефектных конструкций.

Избавление от this

В 2007 году было реализовано несколько исследовательских проектов, в рамках которых предпринимались попытки разработать безопасный поднабор JavaScript. Одной из важнейших проблем было управление привязкой this. В вызове метода this привязывается к интересующему объекту, что иногда полезно. Но, когда