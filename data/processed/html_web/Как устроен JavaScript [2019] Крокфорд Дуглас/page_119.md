---
source_image: page_119.png
page_number: 119
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 35.06
tokens: 7545
characters: 2348
timestamp: 2025-12-24T09:56:56.416738
finish_reason: stop
---

В языках, подобных C, объекты активации размещаются в стеке. Они покидают стек (или выводятся из него), когда функция возвращает управление. В JavaScript происходит иначе. Объекты активации JavaScript размещает в куче, как обычные объекты. При возвращении функцией управления объекты активации не проходят автоматическую деактивацию. Вместо этого объект активации может выживать, пока на него есть ссылка. Объекты активации подпадают под сборку мусора, как и обычные объекты.

В объекте активации содержатся:

• ссылка на функциональный объект;
• ссылка на объект активации вызывающей функции. Она используется инструкцией return для возврата управления;
• информация о возвращении, которая применяется для продолжения выполнения кода после вызова. Обычно это адрес инструкции, выполняемой сразу же после вызова функции;
• параметры функции, инициализированные аргументами;
• переменные функции, инициализированные значением undefined;
• временные переменные, используемые функциями для вычисления сложных выражений;
• содержимое this, которое может быть ссылкой на интересующий объект, если функциональный объект был вызван как метод.

Функциональный объект похож на обычный изменяемый объект тем, что он может быть контейнером свойств. Но в этом нет ничего хорошего. В идеале функциональные объекты должны быть неизменяемыми. В некоторых сценариях обеспечения безопасности с помощью совместно используемых изменяемых функциональных объектов упрощают применение вредоносного кода.

У функционального объекта имеется свойство prototype. Его используют (что, в общем-то, не рекомендуется делать) в модели создания псевдоклассов. Свойство prototype хранит ссылку на объект, содержащий свойство constructor, включающий обратную ссылку на функциональный объект и ссылку делегирования на Object.prototype. Более подробно эти вопросы рассматриваются в главе 16.

Функциональный объект имеет ссылку делегирования на Function.prototype. По этой ссылке функциональный объект наследует ненужные методы apply и call.

В функциональном объекте содержатся также два скрытых свойства:

• ссылка на исполняемый код функции;
• ссылка на объект активации, который был активен в момент создания функционального объекта. Это делает возможным создание замыкания. Функция может использовать это скрытое свойство для доступа к переменным той функции, которая ее создала.