---
source_image: page_087.png
page_number: 87
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 33.26
tokens: 7623
characters: 2635
timestamp: 2025-12-24T09:56:02.395729
finish_reason: stop
---

Если свойство с таким же именем будет найдено в цепочке прототипов, оно будет выдано, как будто было найдено в интересовавшем нас объекте.

При обращении к объекту изменяется только самый близкий объект. Объектов по цепочке прототипов изменения не касаются.

let my_clone = Object.create(my_little_object);
my_clone.bar                // "a long rod or rigid piece of wood or metal"
my_clone.age                 // 39
my_clone.age += 1;
my_clone.age                 // 40
delete my_clone.age;
my_clone.age                 // 39

Чаще всего прототипы задействуются в качестве места для хранения функций. Этот прием используется и в самом JavaScript. Объект, созданный с помощью литерала объекта, является наследником Object.prototype. Аналогично этому массивы наследуют методы от Array.prototype. Числа наследуют методы от Number.prototype. Строки наследуют методы от String.prototype. Даже функции наследуют методы от Function.prototype. Методы массивов и строк весьма полезны, а вот методы в Object.prototype в большинстве своем бесполезны.

Поскольку речь идет о наследовании, теперь у нас есть два типа свойств: собственные, присущие самому верхнему объекту, и унаследованные, присущие цепочке прототипов. В большинстве случаев они работают одинаково. Иногда необходимо знать, действительно ли свойство принадлежит самому объекту. Большинство объектов наследуют функцию hasOwnProperty(строка), но, к сожалению, ее надежность оставляет желать лучшего. Она получает строковое значение и возвращает true, если объект содержит свойство с указанным именем и это свойство неунаследованное. Если же у объекта есть свойство с именем hasOwnProperty, то вместо унаследованного метода Object.prototype.hasOwnProperty будет вызвано именно оно. Это может привести к сбоям или путанице. Было бы лучше, чтобы hasOwnProperty был не методом, а оператором, тогда состояние объекта не смогло бы привести к сбойному вызову hasOwnProperty. Еще лучше, если бы не было унаследованных свойств, что сделало бы этот проблемный метод ненужным.

my_little_object.hasOwnProperty("bar")        // true
my_copy.hasOwnProperty("bar")                 // false
my_clone.hasOwnProperty("bar")                // false
my_clone.hasOwnProperty = 7;
my_clone.hasOwnProperty("bar")                // ИСКЛЮЧЕНИЕ!

При наличии свойства hasOwnProperty воспользоваться унаследованным методом hasOwnProperty невозможно. Вместо него вызов будет обращен к собственному свойству объекта.

Тот же риск сбоев характерен и для метода Object.prototype.toString. Но, даже когда он работает, без разочарований не обходится.

my_clone.toString                        // "[object Object]"