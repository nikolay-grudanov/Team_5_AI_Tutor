---
source_image: page_146.png
page_number: 146
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 31.55
tokens: 7523
characters: 2198
timestamp: 2025-12-24T09:57:34.307933
finish_reason: stop
---

17.3 Как работает код без классов

Параметры конструктора

Однажды я создал конструктор, получающий десять аргументов. Им было очень сложно пользоваться, поскольку никто не мог запомнить порядок следования аргументов. Позже было подмечено, что никто не использует второй аргумент, я мне захотелось убрать его из списка параметров, но это сломало бы весь уже разработанный код.

Будь я предусмотрительнее, у меня был бы конструктор, получающий в качестве параметра один объект. Обычно он берется из объектного литерала, но может поступать и из других источников, например из JSON-содержимого.

Это дало бы множество преимуществ.

• Ключевые строки придают коду задокументированный вид. Код легче читается, поскольку он сам сообщает вам, что представляет собой каждый аргумент вызывающей стороны.
• Аргументы могут располагаться в любом порядке.
• В будущем можно добавлять новые аргументы, не повреждая существующий код.
• Неактуальные параметры можно игнорировать.

Чаще всего параметр используют для инициализации закрытого свойства. Это делается следующим образом:

function my_little_constructor(spec) {
    let {
        name, mana_cost, colors, type, supertypes, types, subtypes, text,
        flavor, power, toughness, loyalty, timeshifted, hand, life
    } = spec;

Этот код создает и инициализирует 15 закрытых переменных, используя свойства с такими же именами из spec. Если в spec нет соответствующего свойства, происходит инициализация новой переменной, которой присваивается значение undefined. Это позволяет заполнять все пропущенное значениями по умолчанию.

Композиция

Яркая выразительность и эффективность JavaScript позволяют создавать программы в классической парадигме, хотя этот язык и не относится к классическим. JavaScript позволяет также вносить улучшения. Мы можем работать с функциональной композицией. Итак, вместо добавления чего-то в качестве исключения можно получить понемногу того и этого. Конструктор имеет следующий общий вид:

function my_little_constructor(spec) {
    let {компонент} = spec;
    const повторно_используемый = other_constructor(spec);
    const метод = function () {
        // могут применяться spec, компонент, повторно_используемый, метод
};