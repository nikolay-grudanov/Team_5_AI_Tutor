---
source_image: page_295.png
page_number: 295
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 19.51
tokens: 7461
characters: 1633
timestamp: 2025-12-24T10:01:15.671955
finish_reason: stop
---

лезнй метод Object.prototype.toString() визуализирует объекты как "[object Object]". Затем эти строки объединяются.

WAT!

999999999999999999 // 1000000000000000000
1e23 + 2e23 === 3e23 // false

Многие целые числа, превышающие значение константы Number.MAX_SAFE_INTEGER, не могут быть представлены точно.

WAT!

"2" < 5 // true
5 < "11" // true
"11" < "2" // true

Сравнение значений разных типов должно приводить к выдаче исключения. Вместо этого JavaScript пытается выполнить приведение типов значений, чтобы сравнение могло состояться. Правила приведения типов способны нарушать транзитивность.

WAT!

1 < 2 < 3 // true
3 > 2 > 1 // false

Эти случаи должны быть синтаксическими ошибками, потому что язык не хочет их правильно обрабатывать. В первом случае сравниваются 1 и 2 и получается true. Затем сравниваются true и 3. В результате приведения типа true превращается в 1. А 1 меньше 3, в результате получается true. Таким образом, случайно дается правильный ответ. Ошибка, временами выдающая правильный ответ, может легко избежать обнаружения при тестировании.

Во втором случае сравниваются 3 и 2, в результате получается true. Затем сравниваются true и 1. В результате приведения типа true превращается в 1. А 1 не меньше 1, в результате получается false.

WAT!

"2" + 1 // "21"
"2" - 1 // 1

Другие арифметические операторы также выполняют приведение типов, но применяют совершенно другие правила, чем те, что использует оператор +. Во избежание этой небрежности нужно правильно управлять своими типами. Не выполняйте арифметические действия со строками. Для них предназначены числа.

WAT!

Math.min() > Math.max() // true