---
source_image: page_228.png
page_number: 228
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 44.72
tokens: 7673
characters: 2341
timestamp: 2025-12-24T10:00:01.248990
finish_reason: stop
---

существенно превзойти базовый уровень, они отклоняются. Они не позволили добиться ожидаемого улучшения, а сбои мы не проверяем.

Большинство оптимизаций усложняют код, добавляя альтернативные пути и удаляя общий код. Это увеличивает объем кода, сложность его поддержки и затрудняет проведение адекватного тестирования. Если будет получено существенное ускорение, то можно считать, что овчинка стоит выделки. Если же существенного ускорения нет, изменение можно считать ошибкой. Оно приводит к снижению качества кода, либо обеспечивая минимальную компенсацию, либо вовсе ее не давая. Чистый код легче поддается осмыслению и поддержке. И мы не хотим от этого отказываться.

Основная часть кода незначительно влияет на производительность. Оптимизировать код, который не замедляет работу программы, — пустая трата времени.

Тщетность усилий

Излишняя возня с кодом редко ускоряет его, поскольку не устраняет основную причину медлительности. Приведу ряд наиболее ярких примеров тщетности усилий.

• Неспособность к распараллеливанию. Parseq для ускорения наших творений позволяет воспользоваться преимуществами параллелизма, присущего Вселенной. Если взамен заставить все выполняться последовательно, мы от него откажемся. В больших масштабах параллельное побеждает последовательное.
• Нарушение закона о ходах (Law of Turns). Когда блокируется цикл обработки, задержки добавляются ко всему, что происходит далее, пока очередь наконец не опустеет. Накопление задержек может стать помехой для опустошения очереди.
• Слабая связность. Если наши модули не обладают сильной связностью, то, скорее всего, они заняты тем, в чем нет необходимости. Ненужная работа замедляет выполнение программы.
• Сильное сцепление. Когда модули сильно сцеплены друг с другом, мы жертвуем локальностью. Это может привести к чрезмерной загруженности протоколов ненужным обменом данными, добавляющим каждому этапу обработки сетевые задержки.
• Неверный алгоритм. Небрежно составленная функция \( O(n \log n) \) может при достаточно больших значениях \( n \) легко превзойти тонко проработанную, изощренно оптимизированную функцию \( O(n^2) \). А когда значения \( n \) невелики, то, какая из них работает быстрее, не так уж и важно.
• Переполнение памяти. Раньше эта проблема касалась систем виртуальной памяти, и она по-прежнему наблюдается при веб-кэшировании. Чрез кэш