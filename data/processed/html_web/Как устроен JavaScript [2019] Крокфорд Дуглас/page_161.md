---
source_image: page_161.png
page_number: 161
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 44.74
tokens: 7694
characters: 2731
timestamp: 2025-12-24T09:58:10.875963
finish_reason: stop
---

Здесь показано соревнование «чтение — изменение — запись». И Мо, и Ларри извлекают переменную, когда ее состояние равно нулю. Оба они прибавляют значение к извлеченной ими переменной, а затем каждый сохраняет получившуюся у него сумму. На этот раз изменение, внесенное Мо, переписывается. В другой раз переписывается изменение, внесенное Ларри. Возможно, большую часть времени Мо и Ларри не извлекают одно и то же значение, поэтому код зачастую работает правильно.

У данного кода есть возможность работать правильно, но есть и вероятность делать это неправильно. Увидеть в двух простых строках программы потенциальную ошибку довольно трудно. В сложных программах такие ошибки способны прятаться очень хорошо.

Вычислительная нагрузка способна изменить чередование инструкций. В ходе разработки и тестирования код может работать вполне корректно, а в производственном режиме давать сбой. Или он хорошо работает целый год, а в декабре дает сбой. Периодически проявляющиеся ошибки в потоках считаются самыми худшими, самыми затратными из всех ошибок. Когда на поведение программы способна повлиять космическая случайность, воспроизвести условия возникновения ошибки может оказаться практически невозможно. Проверка типов такие ошибки не находит. Тесты их также не находят. Ошибки могут появляться крайне редко, поэтому чрезвычайно сложно их отладить или обрести уверенность в том, что исправление не усугубит ситуацию.

Опасность состязания потоков реально снизить посредством взаимного исключения, которое блокирует доступ к критическим участкам памяти, а при возникновении конфликта блокирует потоки, препятствуя их выполнению. Применение блокировок способно оказаться затратным для вычислений. Может быть заблокирован поток, который окажется не способен снять свои блокировки. Такое состояние называется взаимной блокировкой и является еще одним режимом сбоя, трудно поддающимся предотвращению, воспроизведению или исправлению.

Самой серьезной ошибкой проектировщиков в Java и во многих похожих языках стало то, что они не смогли решить, что именно требуется от самого языка — быть языком системы или языком приложений. Попытка сделать его и тем и другим потребовала применения потоков в приложениях, что непростительно.

Потоки в операционных системах могут быть неизбежным злом. А в приложениях это просто зло. К счастью, JavaScript не использует потоки таким вот образом. Для обеспечения параллелизма есть более удачный способ.

Событийное программирование

Событийной называется функция, немедленно возвращающая управление, возможно, еще до завершения затребованной от нее работы. Результат со временем будет сообщен через функцию обратного вызова или путем отправки сообщения, но не в виде немедленно возвращаемого значения.