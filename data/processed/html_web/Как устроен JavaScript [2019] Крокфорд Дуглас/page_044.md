---
source_image: page_044.png
page_number: 44
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 43.38
tokens: 7568
characters: 1738
timestamp: 2025-12-24T09:55:09.794640
finish_reason: stop
---

3.18 Как работают большие целые числа

    while (!is_zero(a)) {
        let [quotient, remainder] = divrem(a, radish);
        digits.push(digitset[number(remainder)]);
        a = quotient;
    }
    digits.push(the_sign);
    return digits.reverse().join("");
}

Функция подсчета заполнения подсчитывает в большом целом числе количество разрядов, содержащих 1. Это может быть использовано для вычисления расстояния Хэмминга.

Получение общего количества единичных разрядов в 32-разрядном целом числе:

function population_32(int32) {

Подсчет 16 пар разрядов с получением 16 двухразрядных счетчиков (0, 1 или 2): для каждой пары выполняется вычитание самого старшего разряда из пары, что превращает два разряда в значение счетчика:

//                HL - H = count
//                00 - 0 = 00
//                01 - 0 = 01
//                10 - 1 = 01
//                11 - 1 = 10

int32 -= (int32 >>> 1) & 0x55555555;

Объединяя восемь пар двухразрядных счетчиков, получаем восемь четырехразрядных счетчиков в диапазоне от 0 до 4:

int32 = (int32 & 0x33333333) + ((int32 >>> 2) & 0x33333333);

Объединяя четыре пары четырехразрядных счетчиков, получаем четыре восьмиразрядных счетчика в диапазоне от 0 до 8. Переполнение с переходом в соседние счетчики больше невозможно, поэтому после сложения нам понадобится только одна операция наложения маски:

int32 = (int32 + (int32 >>> 4)) & 0x0F0F0F0F;

Объединяя две пары восьмиразрядных счетчиков, получаем два шестнадцатиразрядных счетчика в диапазоне от 0 до 16:

int32 = (int32 + (int32 >>> 8)) & 0x001F001F;

И наконец, объединяя два шестнадцатиразрядных счетчика, получаем число в диапазоне от 0 до 32:

return (int32 + (int32 >>> 16)) & 0x0000003F;
}

function population(big) {