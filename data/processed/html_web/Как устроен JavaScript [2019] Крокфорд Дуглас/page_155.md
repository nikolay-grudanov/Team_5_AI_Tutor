---
source_image: page_155.png
page_number: 155
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 38.09
tokens: 7594
characters: 2267
timestamp: 2025-12-24T09:57:52.229781
finish_reason: stop
---

• <<= — присваивание со сдвигом влево;
• &= — присваивание с поразрядным И;
• |= — присваивание с поразрядным ИЛИ;
• ^= — присваивание с поразрядным исключающим ИЛИ;
• ++ — преинкремент;
• ++ — постинкремент;
• -- — предекремент;
• -- — постдекремент.

Как и большинство широко востребованных языков, JavaScript любит всякий хлам, предпочитая изменения чистоте. В JavaScript символ равенства (=) выбран для изменений (нечистого кода), а не для обозначения эквивалентности (в чистом коде).

Благословение чистоте

Чистота дает несколько ценных преимуществ.

Чистота обычно предполагает возможность достижения превосходной модульности. В чистых функциях весьма сильное связывание. В функции есть все, что позволяет предоставить единый результат. Вне ее не происходит ничего, что могло бы ослабить ее связанность. Чистые функции характеризуются чрезвычайно слабым сцеплением. Чистая функция зависит только от своих входных данных. Создание качественных модулей может стать очень непростой задачей, но при соблюдении чистоты хорошая модульность приходит сама собой.

Чистые функции намного проще тестировать. Для этого не нужно использовать имитацию, фиктивный объект или заглушку. Поскольку известно, что чистая функция возвращает из входных данных правильные выходные данные, мы знаем, что никакие изменения среды окружения никогда не заставят чистую функцию возвратить какое-либо другое значение. Ошибки, исчезающие при выключении и включении питания, возникают из-за отсутствия чистоты.

Чистые функции обладают высокой сочетаемостью. Они легко собираются в более крупные и сложные функции, которые также могут быть чистыми и составными, поскольку у них нет побочных эффектов и внешних зависимостей или влияний.

Когда-нибудь чистота позволит добиться существенного повышения производительности. Чистота предоставляет отличные решения проблем надежности и производительности, мешающих потокам. Если в многопоточных системах два потока пытаются одновременно получить доступ к одной и той же области памяти, может возникнуть конфликт, переходящий в порчу данных или в системный сбой. Такие конфликты бывает очень трудно диагностировать. Смягчить конфликтную ситуацию способно взаимное исключение, но оно также может вызвать задержки, взаимные блокировки и сбои системы.