---
source_image: page_167.png
page_number: 167
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 18.77
tokens: 7355
characters: 1555
timestamp: 2025-12-24T09:57:56.159315
finish_reason: stop
---

Наиболее интересные фабрики создают запросчики, обменивающиеся данными с другими сервисами в диалогах, которые способны растягиваться на несколько ходов. Они могут принимать следующую форму:

function фабрика(адрес_сервиса, аргументы) {

// Функция фабрика возвращает функцию requestor, способную выполнять // элементарную операцию.

return function requestor(callback, value) {

// Работа начинается в блоке 'try' на тот случай, если функция, // отправляющая сообщение рабочему сервису, даст сбой.

try {

// Когда вызывается функция requestor, она отправляет сервису сообщение // с предписанием о начале работы. Когда результат будет получен, его // доставит функция callback. В данном примере предполагается, что система // сообщений отправит свой результат, используя соглашение // '(результат, исключение)'.

return отправить_сообщение(
    callback,
    адрес_сервиса,
    старт,
    value,
    аргументы
);
} catch (exception) {

// Если произошел перехват исключения, мы сигнализируем о сбое.

return callback(undefined, exception);
}

// Нам разрешено возвращать функцию отмены cancel, которая будет пытаться // отменить запрос, когда результат больше не нужен.

return function cancel(reason) {
    return отправить_сообщение(
        undefined,
        адрес_сервиса,
        stop,
        аргументы
    );
};
};

Parseq

Для управления потоком между функциями-запросчиками я разработал библиотеку Parseq. Фабрики Parseq пакуют массивы ваших функций-запросчиков с режимом потока управления: параллельным (parallel), последовательным (sequence),