---
source_image: page_131.png
page_number: 131
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 37.99
tokens: 7543
characters: 2166
timestamp: 2025-12-24T09:57:20.067150
finish_reason: stop
---

Система типов в JavaScript обладает достаточной гибкостью для обработки всех исключительных случаев.

Если случится что-нибудь по-настоящему неожиданное, запустится блок кода компонента catch и начнется альтернативная история, либо все закрывающая, либо запускающая все сначала. Мы следуем плану А. Если он реализован удачно, то все хорошо. Если он дал сбой, переходим напрямую к плану Б:

try {
    plan_a();
} catch {
    plan_b();
}

Рассуждать о восстановлении после ошибок сложно, а о тестировании — еще сложнее. Поэтому мы будем придерживаться простой и надежной схемы. Сделаем все ожидаемые результаты возвращаемыми значениями, а исключения оставим для исключительных случаев.

Проблема в том, что существует множество программ, разработанных людьми, которых испортил опыт работы на других языках. Они используют throw там, где должна быть инструкция return. Они создают сложные компоненты catch, в которых пытаются решить безнадежные проблемы и выполнить неподъемную работу. И в попытке навести порядок они применяют компонент finally, в котором JavaScript не нуждается.

Непредвиденные обстоятельства

Исключения работают за счет возвращения значений из стека. Выданные значения сообщаются вызовам функций, находящимся ниже в стеке. При программировании с учетом непредвиденных обстоятельств стек опустошается после каждого хода. Путешествие во времени для передачи выданного значения на активацию, которой больше нет, невозможно. Польза от исключений носит ограниченный характер. Они могут сообщать только о локальных проблемах на текущем временном отрезке. Эта особенность рассматривается в главе 20.

Безопасность

Существует весьма важная модель безопасности, ограничивающая возможности функций за счет передачи им лишь тех ссылок, в которых они нуждаются для выполнения своей работы. Исключения, исходя из сложившейся практики, обеспечивают канал, через который могут вступить в сговор две не пользующиеся доверием функции.

Происходит следующее: объект 1 и объект 2 представляют собой два пакета, установленные по нашей беспечности на сервере. Мы сильно рискуем, но полагаем, что риск приемлем, поскольку объекты 1 и 2 порой могут пригодиться. Мы даем