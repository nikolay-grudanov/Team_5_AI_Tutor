---
source_image: page_107.png
page_number: 107
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 30.94
tokens: 7529
characters: 2378
timestamp: 2025-12-24T09:56:33.379519
finish_reason: stop
---

Удаление одного из них помогает создавать более качественные программы. Мы не в состоянии удалить одно из этих значений из языка, но можем получить выгоду, убрав его из своих программ. Следует удалить null и пользоваться исключительно undefined.

Обычно, когда нужно выбирать между двумя словами, я предпочитаю то, что короче. У null есть известное значение в контексте программирования и структуры данных, а у undefined его нет. Более того, undefined звучит непонятно. С математическим понятием неопределенности оно не имеет ничего общего. Оно даже не означает то, что программисты подразумевают под неопределенностью.

Получается, что null выглядит более подходящим именем, так почему же я предпочел undefined? Дело в том, что undefined — это значение, используемое самим JavaScript. Если определить переменную, применяя let или var, и не инициализировать ее явным образом, JavaScript инициализирует ее значением undefined, что вызывает путаницу, поскольку только что определенная переменная приобретает значение undefined, означающее, что она не определена. Если не передать функции достаточное количество аргументов, дополнительные параметры устанавливаются в undefined. При попытке получить у объекта отсутствующее свойство будет получено значение undefined. При попытке получить у массива отсутствующий элемент будет получено значение undefined.

Единственный случай, когда я применяю null, — использование метода Object.create(null) для создания нового пустого объекта. Ошибка спецификации не позволяет задействовать Object.create() и Object.create(undefined).

Значения null и undefined могут быть протестированы с помощью оператора равенства:

function stringify_bottom(my_little_bottom) {
    if (my_little_bottom === undefined) {
        "undefined";
    }
    if (my_little_bottom === null) {
        return "null";
    }
    if (Number.isNaN(my_little_bottom)) {
        return "NaN";
    }
}

Иногда можно увидеть, что программисты со стажем пишут (typeof my_little_bottom === "undefined"), что также работает. Но (typeof my_little_bottom === "null") дает сбой, поскольку typeof null возвращает "object", а не "null". Это плохо, потому что (typeof my_little_object === "object") дает ложный положительный ответ, когда my_little_object имеет значение null, что приводит к ошибке, которую тест должен был предотвратить. Это еще одна причина избегать применения null.