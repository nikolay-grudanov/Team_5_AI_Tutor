---
source_image: page_160.png
page_number: 160
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 53.01
tokens: 7799
characters: 2536
timestamp: 2025-12-24T09:58:19.109059
finish_reason: stop
---

20.1 Как работает событийное программирование

Однородный параллелизм обеспечивает поддержку многих похожих операций, происходящих в одно и то же время. Его пример уже был показан при использовании методов работы с массивами, получающими чистые функции и обрабатывающими сразу все элементы массива.

Неоднородный параллелизм поддерживает совместные действия специализированных процессов, каждый из которых имеет различные обязанности, но все они работают вместе как единая команда. Сложность состоит в том, чтобы убедиться, что компоненты команды не ведут себя как три балбеса. Это весьма серьезная проблема. Неразумное поведение — неизбежное следствие плохой архитектуры.

Потоки

Потоки — один из самых старых, но по-прежнему широко востребованных механизмов неоднородного параллелизма. Потоки (реальные или виртуальные) — это одновременно работающие центральные процессоры, совместно использующие одну и ту же память. Потоки хорошо справляются с работой, когда в них запускаются чистые функции. Если функции нечисты, поведение становится неразумным.

Здесь показаны два потока, Мо и Ларри, совместно использующие переменную. Мо прибавляет к переменной единицу, Ларри — двойку. Ожидается, что результатом станет тройка.

<table>
  <tr>
    <th>Мо</th>
    <th>Ларри</th>
    <th>variable</th>
  </tr>
  <tr>
    <td></td>
    <td></td>
    <td>0</td>
  </tr>
  <tr>
    <td>variable += 1</td>
    <td></td>
    <td>1</td>
  </tr>
  <tr>
    <td></td>
    <td>variable += 2</td>
    <td>3</td>
  </tr>
</table>

Здесь Мо внес изменение первым. А может случиться так, что первым это сделает Ларри. В данном конкретном случае не имеет значения, кто из них выиграет гонку, потому что операции коммуникативные. Если бы Ларри использовал вместо инструкции присваивания += инструкцию *=, то результат зависел бы от того, кто из них вырвался вперед. Есть и другие, еще более проблематичные результаты.

Если посмотреть на этот код на более низком уровне, инструкция присваивания += может быть откомпилирована в три простые машинные инструкции: load (загрузить), add (прибавить) и store (сохранить).

<table>
  <tr>
    <th>Мо</th>
    <th>Ларри</th>
    <th>variable</th>
  </tr>
  <tr>
    <td></td>
    <td></td>
    <td>0</td>
  </tr>
  <tr>
    <td>load variable</td>
    <td></td>
    <td>0</td>
  </tr>
  <tr>
    <td>add 1</td>
    <td>load variable</td>
    <td>0</td>
  </tr>
  <tr>
    <td>store variable</td>
    <td>add 2</td>
    <td>1</td>
  </tr>
  <tr>
    <td></td>
    <td>store variable</td>
    <td>2</td>
  </tr>
</table>