---
source_image: page_291.png
page_number: 291
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 19.14
tokens: 6204
characters: 1384
timestamp: 2025-12-24T10:08:24.626909
finish_reason: stop
---

# ИЛИ просто получаем непосредственно файл с предв. изменениями
my @jslint = `/usr/local/bin/jslint $file`;
if ($?) {
    print STDERR '-' x 20, "\n";
    print STDERR "Ошибки JSLint в $file:\n";
    print STDERR '-' x 20;
    print STDERR @jslint;
    $failed++;
}
}
# STDERR возвращается к клиенту в случае отказа
exit $failed;

Этот пример получает сообщения протоколирования, но не использует их:

my @changes = `svnlook changed --transaction "$TXN" "$REPO"`;

А этот код также демонстрирует, как непосредственно получить текст измененного файла:

# my @cat = `svnlook cat "$REPO" --transaction "$TXN" $file`;

Захват текста сообщения о фиксации позволяет вам предписывать определенный формат для самого сообщения, гарантируя, что ID ошибки, связанной с этой фиксацией будет дополнено допустимыми именами пользователей. Другими словами, каждая фиксация (коммит) исправляет какую-то ошибку (баг) в коде. Обычно с фиксацией связывается только ID ошибки, но благодаря возможности захвата текста о фиксации вы можете получить имя пользователя, который произвел фиксацию.

Ловушки предварительной фиксации Git работают аналогично — в случае сбоя фиксации возвращается ненулевое значение. Разница заключается лишь в том, как захватываются сообщения протоколирования.

Давайте создадим предварительную фиксацию Git, которая отклонит любую фиксацию в случае любого из следующих нарушений: