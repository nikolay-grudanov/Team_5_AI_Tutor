---
source_image: page_056.png
page_number: 56
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 34.30
tokens: 6423
characters: 2130
timestamp: 2025-12-24T10:03:49.236731
finish_reason: stop
---

что функция «недостаточно грамотно и чисто спроектирована», что означает, что она должна быть пересмотрена, подвержена рефакторингу, на фоне того, что она слишком большая и пытается сделать слишком много и у нее, скорее всего, есть отсутствующий уровень абстракции, что и является причиной высоких значений разветвлений на входе и выходе.

Основываясь на измерениях сложности функций, Генри и Кэфура отмечают, что можно генерировать значения сложности модуля и оттуда можно измерить связь между самими модулями. Можно определить, какие модули имеют высокую сложность и должны быть пересмотрены, или же это свидетельствует о том, что необходим другой уровень абстракции. Внешним признаком слишком высокой сложности модуля может быть небольшое количество функций (например, три), но трактовка значения зависит от самого модуля. Когда модуль маленький и в нем 3 функции — это может быть хорошо, а когда модуль большой, а весь его код разбит всего на 3 функции — это плохо.

Генри и Кэфура исследовали длину функции и обнаружили, что всего у 28% функций, содержащих меньше 20 строк кода, были ошибки, тогда как в функциях, содержащих более 20 строк кода, были ошибки в 78% случаев. Остерегайтесь больших функций! Пусть код будет компактным!

Вернемся к определению разветвления на выходе и поговорим об его определяющих параметрах: данных и локальных потоков. Начнем с данных. В JavaScript достаточно просто объявить и использовать глобальные переменные, но стандарт JavaScript рекомендует нам не использовать глобальное пространство переменных и вместо этого использовать только локальные переменные. Это помогает уменьшать разветвление на выходе, поскольку мы уменьшаем число обновляемых структур данных.

Теперь о локальных потоках наших функций. Вы можете легко узнать число этих потоков, подсчитав количество инородных объектов, которые требует ваша функция. Следующий пример использует асинхронный механизм YUI, чтобы узнать зависимости кода для модуля myModule. Для интересующихся подробно загрузчик YUI описан по адресу http://yuilibrary.com/yui/docs/yui/loader.html. Здесь же нам нужно понимать только то, что мы просто гово-