---
source_image: page_057.png
page_number: 57
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 27.02
tokens: 6319
characters: 1820
timestamp: 2025-12-24T10:03:42.078927
finish_reason: stop
---

rim фреймворку YUI о зависимости нашего кода, который он получит от нас. Затем он вызовет нашу callback-функцию, когда зависимость будет загружена:

YUI.use('myModule', function(Y) {
    var myModule = function() {
        this.a = new Y.A();
        this.b = new Y.B();
        this.c = new Y.C();
    };
    Y.MyModule = myModule;
}, { requires: [ 'a', 'b', 'c' ] });

Разветвление на выходе для конструктора myModule равно 3 (в нашем случае объекты даже не используются, они просто созданы и сохранены для будущих методов, но они все еще требуются, поэтому увеличивают число разветвлений на выходе конструктора). Три неплохое число, но оно вырастет, когда внешний объект инстанцирует myModule и использует любое возвращаемое значение любого метода myModule.

Разветвление на выходе — мера, о которой вы должны помнить при редактировании метода. Это количество внешних методов и объектов, которыми этот метод манипулирует.

Независимо от локальных потоков закон Миллера утверждает, что задача запомнить и отследить больше чем 7 объектов — для человека является очень сложной. Причем более поздние исследования снизили эту планку до 4. А поскольку мы пишем код, который потом должен поддерживаться, читаться людьми, то поэтому мы должны учитывать эту человеческую особенность. И хотя формально нет какого-то определенного числа, которое является индикатором, предельным значением для разветвления на выходе, но когда значение разветвления на выходе больше 7 (или даже 4), пора задуматься от рефакторинге.

С технической точки зрения высокое разветвление на выходе проблематично по большому числу причин: код более сложен, его трудно понять и протестировать; нужно использовать мок-объекты и заглушки (stub) для каждого модуля, что делает тестирование сложным. Кроме того, высокое разветвление на выходе является показа-