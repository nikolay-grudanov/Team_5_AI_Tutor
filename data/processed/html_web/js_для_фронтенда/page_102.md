---
source_image: page_102.png
page_number: 102
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 28.09
tokens: 6285
characters: 1766
timestamp: 2025-12-24T10:04:40.939430
finish_reason: stop
---

событийно-ориентированный код обрабатывает междоменную (безопасную или нет) коммуникацию без всяких изменений. У нас нет никакой нужды в JSONP, Flash, скрытых фреймах (iframe) или любых других приемах, добавляющих сложность и коду, и к тестам. Сериализация и десериализация обрабатываются прозрачно. Ошибки передаются как объекты, а не как коды состояний HTTP. Конечные точки абстрагируются из URL в произвольные строки. И наконец (и что, возможно, наиболее важно), событийно-ориентированная архитектура полностью освобождает нас от тирании инстанцирования и поддержания сильно связанных указателей на внешние объекты.

Код теста для Ajax-запросов значительно увеличивается при использовании каких-то дополнительных фич XMLHttpRequest и Y.io (например, таких как обратные вызовы success и failure), которые также нуждаются в имитации.

Ответы на порожденные события

Есть три возможных варианта реакции на порожденное событие: нет ответа, универсальный ответ, определенный ответ.

Самый простой способ — когда вообще не нужен никакой ответ. В типичной системе событий отправка события очень проста, но получение ответов более проблематично.

Вместо занудных рассуждений об особенностях того или иного способа реакции на событие, давайте рассмотрим несколько примеров. Начнем с самого простого случая, когда ответ не нужен. В этом случае мы просто порождаем событие и двигаемся дальше:

eventHub.fire('LOG', { level: 'debug', message: 'This is cool' });

Если какой-то специфический ответ на порожденное событие не нужен и вас устроит универсальный ответ, удаленный слушатель может породить универсальное событие в ответ. Например, в случае регистрации нового пользователя может быть порождено универсальное событие USER_REGISTERED и этого будет более чем достаточно: