---
source_image: page_071.png
page_number: 71
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 27.41
tokens: 6278
characters: 1694
timestamp: 2025-12-24T10:04:03.021803
finish_reason: stop
---

На основании этой информации мы можем при необходимости осуществить рефакторинг системы. В то же время необходимо понимать, что это за числа, не полагаться всецело на них (и на утилиты вычисления метрик связности) и параллельно с ними осуществлять самостоятельную инспекцию и ревью своего кода.

Связанность в реальном мире

Давайте рассмотрим несколько примеров связанности в JavaScript. Начнем с сильной связанности, так как это не только иллюстрирует саму сильную связанность как таковую, но и показывает слабую связанность, так как по опыту лучший способ понять, что такое слабая связанность, — это посмотреть на сильную связанность. Итак, смотрим пример:

function setTable() {
    var cloth = new TableCloth();
    dishes = new Dishes();
    this.placeTableCloth(cloth);
    this.placeDishes(dishes);
}

Данный вспомогательный метод, вероятно, принадлежащий классу table, пытается, так сказать, «аккуратно накрыть стол». Однако этот метод жестко связан с объектами TableCloth и Dished. Создание новых объектов внутри методов создает жесткую, сильную связь.

Этот метод стал не изолируемым из-за жесткой связи, в результате, когда нам нужно протестировать его или сделать еще что-то с ним, нам для этого обязательно понадобятся и объекты TableCloth и Dishes. В случае с тестированием модульные тесты будут стремиться протестировать метод setTable в изоляции от внешних зависимостей, но вышеприведенный код делает данную задачу очень сложной. И это несмотря на наличие в JavaScript возможностей выполнить динамическую инъекцию имитаций (mocks) и заглушек (stub), как это будет показано далее в этой книге. В данном примере имитировать объекты TableCloth и Dished будет мучительно не-просто.