---
source_image: page_178.png
page_number: 178
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 27.18
tokens: 6293
characters: 1786
timestamp: 2025-12-24T10:06:14.787595
finish_reason: stop
---

Есть и альтернативное решение: если вы используете веб-сервер Apache, можно динамически инструментовать код с помощью правил mod_rewrite. В этом случае нужно пометить JavaScript-файлы, для которых нужно получить информацию о покрытии в HTML. Для этого удобнее всего использовать строку запроса:

<script src="/path/to/file/myModule.js?coverage=1"></script>

Соответствие правилу mod_rewrite перенаправит запросы этого типа сценарию, который примет исходный файл, сгенерирует для него файл покрытия и вернет его вместо обычной версии:

    RewriteEngine On
    RewriteCond %{QUERY_STRING} coverage=1
    RewriteRule ^(.*)$ make_coverage.pl?file=%{DOCUMENT_ROOT}/$1 [L]

В этом случае любой запрос файла с подстрокой coverage=1 в строке запроса будет перенаправлен сценарию make_coverage.pl, который вернет файл покрытия для запрошенного файла.

Сценарий make_coverage.pl предельно прост:

#!/usr/bin/perl
use CGI;
my $q = CGI->new;
my $file = $q->param('file');
system("java -jar /path/to/yuitest_coverage.jar -o /tmp/$$.js $file");
print $q->header('application/JavaScript');
open(C, "/tmp/$$.js");
print <C>;

Если у вашего модуля есть внешние зависимости, которые также должны быть включены для выполнения ваших тестов, вы можете также инструментовать и этот внешний код, чтобы видеть связь-занность вашего кода. Однако я не рекомендую делать это! Суть модульного тестирования — изолировать модуль и проверить, как он работает, а не в том, чтобы увидеть, что другие модули могут использовать ваш модуль.

В идеальном случае никакие внешние зависимости не должны загружаться при тестировании одного модуля. Их нужно или заглушить, или имитировать в коде теста. Мало того, есть хуже ситуации, когда вы вынуждены отлаживать другой модуль, выходящий за рамки тестируемого в данный момент.