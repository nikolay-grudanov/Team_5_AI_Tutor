---
source_image: page_130.png
page_number: 130
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 29.92
tokens: 6344
characters: 1989
timestamp: 2025-12-24T10:05:17.172216
finish_reason: stop
---

ции есть 100%-ое покрытие кода, она полностью протестирована и надежна.

Так как же написать совершенный тест? Есть несколько показателей, на которые нужно ориентироваться. И покрытие кода — это только один из показателей. Другим не менее важным показателем являются граничные и не граничные значения параметров. Учитывая, что зависимости функции будут имитироваться для изоляции тестирования, вам, как тестеру, нужно тщательно протестировать параметры функции. Для примера давайте возьмем уже известную нам функцию sum. Данная функция принимает два параметра. Каждый параметр может быть одного из шести типов (число, строка, объект, undefined, null или булевый). Таким образом, совершенный набор модульных тестов тестирует все возможные комбинации этих параметров. Но что он должен протестировать? Что означает сложить null и undefined?

Два самых важных фактора хорошего модульного тестирования — это изоляция и область действия. Как будет показано в следующих подразделах, изоляция и область действия тесно связаны.

Изоляция

Модульному тесту нужно передавать самый минимум кода, только то, что действительно нужно для выполнения теста. Причем чем меньше кода тестируется, тем лучше. Любой дополнительный код может повлиять либо на сам тест, либо на тестируемый код и вызвать дополнительные проблемы. Как правило, при модульном тестировании осуществляется тестирование одного метода (один метод — один тест). Этот метод, вероятно, является частью файла, содержащего класс или модуль. К сожалению, у тестируемого кода часто есть зависимости от других функций и методов, находящиеся в этом файле. Также вдобавок могут быть и внешние зависимости, то есть привязки к другим файлам.

Чтобы избежать загрузки внешних зависимостей, можно использовать имитацию (mock), заглушку (stub) и дублирование теста (test doubles). Все эти стратегии будут рассмотрены позже, а на данный момент важно отметить, что все они пытаются сделать тестируемый код максимально изолированным от других частей кода.