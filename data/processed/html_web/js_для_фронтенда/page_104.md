---
source_image: page_104.png
page_number: 104
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 24.15
tokens: 6234
characters: 1467
timestamp: 2025-12-24T10:04:41.066082
finish_reason: stop
---

, function(err, result) {
    if (!err) {
        console.log('Cart now has: ' + result.cart.items + ' items');
    }
});
}

Здесь мы порождаем универсальное событие ADD_TO_CART с некоторой информацией и ждем обратного вызова. Callback-функция, переданная концентратору событий, вызывается с данными, предоставленными слушателем.

3.3. Контекст применения событийно-ориентированной архитектуры

Событийно-ориентированная архитектура и MVC-методы

Можно ли сравнить событийно-ориентированную архитектуру с архитектурой MVC (Model-View-Controller, Модель-представление-контроллер)? Эти две архитектуры довольно похожи, но все-таки у них есть отличия.

Самое большое отличие между ними состоит в том, что в событийно-ориентированной архитектуре модели как бы устранены и неявны. Например, при использовании MVC класс Model инстанцируется для каждой строки базы данных, этот класс предоставляет данные и методы, которые оперируют этими данными.

В событийно-ориентированной архитектуре модели — это просто хэши, хранящие только данные; эти данные передаются с использованием событий для слушателей (при желании вы можете называть их моделями), чтобы работать с ними. Это разделение данных и функциональности по идее обеспечивает отличную тестируемость, экономию памяти и более высокую масштабируемость, и это все еще с преимуществами соединения данных и методов. Вместо множества отдельных созданных объектов Model есть много хэшей данных и один объект для работы с ними.