---
source_image: page_036.png
page_number: 36
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 25.95
tokens: 6266
characters: 1713
timestamp: 2025-12-24T10:03:15.022332
finish_reason: stop
---

У нас получился отличный компромисс. Функции проверки теперь доступны отдельно для упрощения тестирования и снижения сложности кода, они будут вызываться при установке новых значений, а все данные хранятся в одном централизованном расположении.

Но, с другой стороны, у нас все еще есть проблема. Что помешает кому-то ввести следующее:

config.docRoot = '/does/not/exist';

Наша функция проверки не будет работать. Есть отличное решение: использовать новые методы Object из ECMAScript 5 и 63. Они позволяют создавать свойства объекта со встроенными функциями проверки, методами get/set и многое другое, и к тому же они довольно хорошо тестируемые:

var obj = { realRoot : '/somewhere' };

Object.defineProperty(obj, 'docRoot',
{
    enumerable: true
    , set: function(value) {
        validateDocRoot(value); this.realRoot = value; }
});

Теперь при следующем вводе:

config.docRoot = '/does/not/exist';

будет запущена функция set, которая вызовет функцию проверки, которая породит исключение в случае отсутствия указанного пути, поэтому проверка прервана не будет.

Но это странно. Вышеуказанный оператор присваивания мог бы теперь породить исключение и должен быть заключен в блок try/catch. Даже если вы избавитесь от вызова исключения, во что вы теперь установите config.docRoot, если значение не пройдет проверку? Независимо от установленного значения, результат будет неожиданным. А неожиданные результаты становятся проблемой.

3 ECMAScript — это встраиваемый расширяемый не имеющий средств ввода/вывода язык программирования, используемый в качестве основы для построения других скриптовых языков. Стандартизирован международной организацией ECMA. Язык JavaScript является расширением языка ECMAScript.