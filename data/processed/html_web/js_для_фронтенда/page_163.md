---
source_image: page_163.png
page_number: 163
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 23.82
tokens: 6242
characters: 1570
timestamp: 2025-12-24T10:05:52.967726
finish_reason: stop
---

Мы опять регистрируем новую имитацию для объекта fs, возвращающую фиксированный объект для конкатенации строк после проверки параметров readFileSync.

В качестве альтернативы, если бы мы хотели фактически прочитать JSON-объекты с диска, перед включением Mockery можно было бы создать реальный объект fs и мы бы делегировали вызовы из имитированного метода readFileSync к данному объекту — все это (процесс создания реального объекта и делегирование вызовов из имитированного метода) называется тестовым шпионом. Хранение данных тестирования в самих тестах очень полезно, особенно для таких небольших тестов, как наши.

Если имитируемые объекты будут большими или вам нужно будет хранить библиотеку таких объектов, вы можете указать Mockery заменить ваш оригинальный объект имитируемым с помощью следующего кода:

mockery.registerSubstitute('fs', 'fs-mock');

Как показано в документации по Mockery, теперь каждый вызов require('fs') на самом деле будет вызовом require('fs-mock').

Mockery — отличный инструмент. Просто помните, что после его активации все вызовы require будут перенаправляться через Mockery!

Шпионы

Шпионы в Jasmine в основном используются для внедрений (инъекций) кода. При этом они обычно и заглушки, и имитации, все в одном лице.

Итак, допустим мы решили, что наша функция sum, читающая JSON-строку из файла, и функция sum, читающая операнды из списка параметра, могут быть объединены так:

exports.sum = function(func, data) {
    var data = JSON.parse(func.apply(this, data));
    return data.a + data.b;
};
exports.getByFile = function(file) {