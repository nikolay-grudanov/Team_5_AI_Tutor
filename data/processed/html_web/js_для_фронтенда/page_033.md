---
source_image: page_033.png
page_number: 33
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 28.74
tokens: 6263
characters: 1697
timestamp: 2025-12-24T10:03:14.891205
finish_reason: stop
---

expect(config.zany).toEqual('crazy');
expect(config.docRoot).toEqual('/tmp');
});
it("проверка value1 успешно...", function() {
});
it("проверка value1 не успешно...", function() {
});
// ... ожидается много других проверок...
});

Наша изначальная функция делает слишком много. После установки значений конфигурации по умолчанию она проверяет корректность этих значений; при этом фактически при тесте проверяется более пяти значений. Метод у нас большой, а каждая проверка полностью независима от предыдущих проверок, то есть вся логика проверки допустимости для каждого значения впишнута в эту единственную функцию. Проверить какое-то значение изолированно невозможно. Таким образом, тестирование инициирует множество проверок всех возможных значений при проверке каждого конфигурационного значения.

Точно так же эта функция требует множества модульных тестов со всеми проверками в рамках модульного теста основного функционала самой функции. Это плохо. Особенно на фоне того, что, скорее всего, спустя некоторое время будет добавлено еще больше конфигурационных значений, а значит, данная проверка станет еще более уродливой. Также, погружение ошибок в блоки try/catch просто-напросто выводит эти блоки из строя.

Наконец, сбивает с толку возвращаемое значение: или оно не определено, если какое-то значение не было проверено, или это весь допустимый хэш. И надо не забывать о побочных эффектах операторов console.log (но об этом попозже).

Давайте посмотрим, как описанные проблемы могут быть разрешены за счет разделения функции на несколько частей. Вот один из вариантов:

function configure(values) {
    var config = { docRoot: '/somewhere' }
        , key
    ;
    for (key in values) {