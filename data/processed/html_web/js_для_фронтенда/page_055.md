---
source_image: page_055.png
page_number: 55
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 25.23
tokens: 6293
characters: 1620
timestamp: 2025-12-24T10:03:40.123265
finish_reason: stop
---

дение, что чем сложнее функция или модуль, измеренный их формулой, тем больше вероятность ошибки в этой функции или модуле.

Дадим соответствующее формальное определения:

Разветвление на выходе процедуры А — это число локальных потоков из процедуры А плюс число структур данных, которые процедура А обновляет.

В этом определении поток А считается локальным:

1. Если А вызывает некий поток В.
2. Если некий поток В вызывает А и А возвращает значение в В, которое впоследствии используется В.
3. Если некий поток С вызывает два потока А и В, передавая результат (выходное значение) потока А в поток В.

Так, добавив все потоки для функции А, плюс число глобальных структур (внешних к А), которые А обновляет, мы получим разветвление на выходе для функции А. Разветвление на входе определяется по тому же принципу, в чем мы вскоре и убедимся (см. следующий раздел этой главы).

Согласно вышеприведенной формуле, для вычисления сложности кода вам нужно умножить значение разветвления на входе на разветвление на выходе, а затем возвести в квадрат полученное значение.

Используя эту меру, Генри и Кэфура отмечают три проблемы,ственные очень сложному коду, которые данная мера позволяет выявить. Во-первых, высокое разветвление на входе и на выходе могут помочь найти функцию, которая пытается сделать слишком много. Эту функцию нужно разбить на несколько мелких. Во-вторых, высокие значения разветвлений на входе и выходе указывают на «точки стресса» в системе. Поддержка этих функций будет слишком сложной, поскольку они касаются многих других частей системы. И в-третьих, высокие значения этих параметров говорят о том,