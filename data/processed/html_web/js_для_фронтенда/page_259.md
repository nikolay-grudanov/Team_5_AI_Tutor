---
source_image: page_259.png
page_number: 259
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 29.51
tokens: 6249
characters: 1712
timestamp: 2025-12-24T10:07:57.417796
finish_reason: stop
---

maxCallStackDepth: 10
}
};
Данное сообщение указывает браузеру Chrome отправлять нам сообщения веб-сокета, которые являются событиями отладчика Chrome, то есть отправлять все события, которые изначально предназначены для отображения на панели Timeline. Как только мы отправили вышеуказанное сообщение, мы вызываем обратный вызов webdriverjs так, что наша цепочка webdriverjs2 может быть продолжена (помните это?).

Примечание.

Спецификация для вышеприведенного JSON-сообщения доступна на сайте инструментов разработчика Chrome (https://developer.chrome.com/devtools/docs/debugger-protocol).

Теперь нам остается поделать какие-то действия в Selenium, для которых мы хотим получить события Timeline — в данном случае мы загрузим Yahoo! и поищем строку «JavaScript». Пока все это происходит, Chrome отправляет нам события Timeline.eventRecorded, которые мы покорно получаем и сохраняем через обратный вызов веб-сокета onmessage.

Наконец, по завершению всех этих действий, мы закрываем Selenium, который закроет Chrome, а он, в свою очередь, вызовет наш обработчик onclose, который выведет все наши сохраненные

2 Пакет webdriverjs позволяет нам определить свой пользовательский метод, который может быть объединен в цепочку вместе с другими стандартными методами webdriverjs события в HTML-файл. Формат этого файла такой же, какой использует рассмотренный нами ранее Speed Tracer, что очень удобно. Поэтому если вы загрузите получившийся HTML-файл в Chrome с установленным расширением Speed Tracer, тот загрузит интерфейс Speed Trace с этими данными. Это позволяет вам по сути «захватывать» ввод Speed Tracer, что можно использовать для сравнения с предыдущими версиями вашего кода или исследовать его на досуге.