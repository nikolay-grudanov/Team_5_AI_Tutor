---
source_image: page_255.png
page_number: 255
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 31.34
tokens: 6286
characters: 1695
timestamp: 2025-12-24T10:07:53.919809
finish_reason: stop
---

 удаленном коде и позволяет удаленному отладчику подключаться к Chrome для отладки выполняющегося в нем JavaScript-кода.

Для удаленной отладки выполняющегося в браузере JavaScript-кода вам нужно запустить исполнимый файл Chrome, указав номер порта, который будет прослушиваться отладчиком. В Windows команда будет следующей:

% chrome.exe --remote-debugging-port=9222

В MacOS команда будет немного другой (все в одну строку):

% /Applications/Google\ Chrome.app/Contents/MacOS/Google\ Chrome --remote-debugging-port=9222

Вы также можете запустить Chrome с таким параметром:

--user-data-dir=<some directory>

Это будет эквивалентно запуску Chrome с новым особым профилем, например, с вашим профилем Firefox. Теперь вы можете присоединиться к порту 9222 и взаимодействовать с профилем отладчика 1.1.

Вот пример того, как использовать эту функциональность, чтобы извлечь статистику таймингов — эту статистику визуализируют Speed Tracer и панель Timeline отладчика Chrome. Мы будем использовать Selenium, чтобы автоматически породить экземпляр Chrome, слушающий порт 9222 для соединений отладчика. Интересно, что JSON-отладка API работает на основе веб-сокетов, а не на основе HTTP. Использование веб-сокетов делает распространение события более тривиальным. Использование EventHub или socket.io предоставляет ту же функциональность по обычному HTTP.

Теперь давайте взглянем на сценарий Node.js, использующий пакет webdriverjs (см. гл. 6). Этот сценарий довольно длинный, поэтому мы разобьем его на две части. Первая часть запускает Selenium с соответствующими опциями командной строки Chrome и выполняет браузер с потоком, который мы хотим захватить:

var webdriverjs = require("webdriverjs")