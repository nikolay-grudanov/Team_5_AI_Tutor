---
source_image: page_231.png
page_number: 231
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 27.16
tokens: 6229
characters: 1466
timestamp: 2025-12-24T10:07:22.545775
finish_reason: stop
---

При использовании современных браузеров основной канал утечки памяти в JavaScript заключается в хранении ссылок на объекты, в которых вы больше не нуждаетесь. Также утечка памяти может произойти при выделении памяти для больших объектов, которые ни разу не использовались.

Рассмотрим пример:

function createClosure() {
    var bigHairyVariable = { ... }, wow = 'wow';
    return {
        a: bigHairyVariable
        , b: wow
        , c: 87
        , d: function() { return bigHairyVariable; }
    };
}
// никогда не используется global.a — потраченная впустую память — утечка?
var global = createClosure();

Конечно, здесь утечка памяти не так явно видна, как в языках вроде C, где память явно выделяется. Фактически это может вообще не быть утечкой, если использование переменной bigHairyVariable запланировано в будущем.

Переменные объекта и функции в JavaScript являются ссылками. В предыдущем примере bigHairyVariable выходит за пределы области действия, когда функция возвращается, но на ее память все еще ссылаются две другие переменные — global.a и global.d. Установка global.a = null освобождает ссылку на bigHairyVariable, но все еще не освобождает память, поскольку на нее все еще ссылается global.d. Чтобы освободить память, нужно еще установить global.d в null:

    global.d = null;    // или global = null

Память освобождается не сразу, а при следующем проходе сборщика "мусора", который освободит все участки памяти, отмеченные для освобождения.