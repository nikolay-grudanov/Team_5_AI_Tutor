---
source_image: page_172.png
page_number: 172
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 25.22
tokens: 6261
characters: 1654
timestamp: 2025-12-24T10:06:07.005171
finish_reason: stop
---

getPrice(symbol, function(err, price) {
    _this.resume(function() {
        Y.Assert.areEqual(stockPrice, price, "Цены не равны!");
    }, http); // Вводим наш объект 'http'
    http.fire('data', stockPrice); // Наши "поддельные" данные
    this.wait(1000);
}
}

Это базовый тест для успешного случая. Для тестирования случая ошибки нужно отправить событие error:

testPriceError: function() {
    var symbol = 'YHOO'
    , _this = this
    , http = new myhttp()

    getPrice(symbol, function(err, price) {
        _this.resume(function() {
            Y.Assert.areEqual(err, 'ошибка', "Нет ошибки!");
        }, http);
        http.fire('error', { message: 'ошибка' });
        this.wait(1000);
    }
}

С этими двумя тестами метрика покрытия кода покажет 100%-ное покрытие кода — это удивительно! И что же это значит? Значит ли это, что больше не нужно тестировать функцию getPrice, поскольку она работает правильно, как и планировалось? Ну, конечно же, нет.

Даже если большинство (или даже все) строк выполнены тестом или набором тестов, это не обязательно означает, что были протестированы все граничные случаи или что даже общий случай был полностью протестирован во всем своем многообразии. Именно поэтому я и сказал в самом начале главы, что высокие проценты покрытия кода могут вводить в заблуждение. В данном случае мы запустили все строки кода, но не протестировали все возможные варианты запуска кода. Наша функция не полностью протестирована, но процент покрытия кода говорит об обратном. Таким образом, получается, что даже если мы достигли 100%-го покрытия кода, мы не можем сказать с уверенностью, что функция getPrice на 100% надежна.