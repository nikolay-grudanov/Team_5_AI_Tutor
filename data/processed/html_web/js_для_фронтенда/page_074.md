---
source_image: page_074.png
page_number: 74
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 23.07
tokens: 6231
characters: 1632
timestamp: 2025-12-24T10:04:03.234971
finish_reason: stop
---

так это создать фабрику, чтобы сгенерировать надлежащую фабрику TableCloth:

    var AbstractTableClothFactory = {
        getFactory: function(kind) {
            if (kind !== 'TEST') {
                return TableClothFactory;
            } else {
                return TableClothTestFactory;
            }
        }
    };

Все, что мы сделали, — это параметризовали фабрику так, чтобы она возвратила фактическую фабрику, которая возвращает требуемый вид объекта TableCloth. Этого монстра и называют абстрактной фабрикой. Вот как использовать ее в тесте:

    var tcFactory = AbstractTableClothFactory.getFactory('TEST')
        , tc = tcFactory.getTableCloth('purple');
    // мы получили mock-объект

Теперь у нас есть способ инстанцирования объектов без жесткой связи между ними. Мы отказались от сильных связей на уровне содержимого в пользу более слабой связи уровня управления. Теперь тестирование стало намного проще, поскольку мы можем создать версии фабрик, которые возвращают имитированные версии объектов вместо реальных, что позволяет нам протестировать код, не волнуясь обо всех его зависимостях. Код стал лучше.

Тестирование связанного кода

Понятно, что чем более сильно связан код, тем больше ресурсов нужно для его сопровождения и тестирования. Давайте пройдемся по уровням связывания и взглянем на них через призму тестирования.

Код, связанный на уровне содержимого, трудно протестировать, потому что модульное тестирование стремится тестировать код в изоляции. Но по определению код, связанный на уровне содержимого, сильно связан как минимум с одним другим внешним объектом. Вам потребуется полный диапазон