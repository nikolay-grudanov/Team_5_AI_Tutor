---
source_image: page_142.png
page_number: 142
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 23.63
tokens: 6218
characters: 1463
timestamp: 2025-12-24T10:05:25.388965
finish_reason: stop
---

Несмотря на все это, асинхронное тестирование просто необходимо использовать при тестировании событийно-ориентированного кода типа такого:

hub.on('log', function(severity, message) {
    console.log(severity + ':' + message);
});

Тестирование такого кода требует имитации глобального объекта console (это команда, а не запрос):

console = Y.Mock();
testLogHandler: function () {
    var sev = 'DEBUG', message = 'TEST';
    Y.Mock.expect(console, { method: log
        , arguments: [sev, message] });
    hub.fire('log', sev, message);
    this.wait(function() {
        Y.Mock.verify(console);
    }, 1000);
}

Здесь мы используем реальный концентратор событий, поскольку сейчас мы не тестируем функциональность самого концентратора. Данный тест проверяет, что метод log имитированного объекта вызывается с ожидаемыми аргументами.

4.8. Запуск тестов: сторона клиента

Допустим, вы написали ряд тестовых сценариев и поместили их в один из тестовых наборов. Что дальше? А дальше — запуск тестов в вашем браузере путем двойного щелчка мыши по связующему HTML-документу, содержащему связывающий код (связывающий тестовый сценарий и тестируемый код).

Это, конечно, прикольно, но автоматизацией здесь и не пахнет. А что это за сапожник без сапог: пишем код для автоматизации всего и вся, а свои собственные процессы автоматизировать не можем, что ли? Можем. Существует несколько стратегий по автоматизации процесса тестирования в рамках общего процесса разработки.