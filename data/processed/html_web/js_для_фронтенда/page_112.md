---
source_image: page_112.png
page_number: 112
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 21.92
tokens: 6173
characters: 1481
timestamp: 2025-12-24T10:04:47.170035
finish_reason: stop
---

user: user
    , success: true
    , message: 'ok'
    );
}
}
, result
;
DB(dbHandle); // Тестовые версии
result = addUser(user);
Y.Assert.areSame(result.user, user.user);
Y.Assert.isTrue(result.success);
Y.Assert.areSame(result.message, 'ok');
}
});
;
Y.Test.Runner.add(addUserTests);
Y.Test.Runner.run();
});

Чтобы клиент мог добавить нового пользователя, нужно создать новый протокол между клиентом и сервером, также нужно создать маршрут в сервере, чтобы передать сообщение «add user» объекту DB, после чего результаты добавления пользователя должны быть сериализованы и переданы обратно вызывающей стороне. Нужно проделать огромную работу, чтобы создать подобную инфраструктуру для каждого типа сообщений. В конечном счете вы придетете к необходимости реализовать мощную систему RPC (Remote Procedure Call (RPC)) — класс технологий, позволяющих компьютерным программам вызывать функции или процедуры в другом адресном пространстве), которую концентратор событий предоставляет вам просто так.

Это яркий пример тех самых 85% шаблонного кода, который вы не должны реализовывать самостоятельно. Все приложения по сути сводятся к передаче сообщений и управлению заданиями. Приложения передают сообщения и ожидают ответы на них. Написание и тестирование шаблонного кода добавляет много лишних издержек любому приложению. Что, если вы также хотите добавить интерфейс командной строки вашему приложению? Это уже другой путь выполнения кода, который вы также должны реализовать и об-