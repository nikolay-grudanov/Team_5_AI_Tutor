---
source_image: page_139.png
page_number: 139
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 30.08
tokens: 6282
characters: 1732
timestamp: 2025-12-24T10:05:31.463800
finish_reason: stop
---

var shoppingCart = new ShoppingCart()
    , item = { inStock: function() { return false; } }
    , back = shoppingCart.addToShoppingCart(item)
    ;
    Y.Assert.isNull(back, "Возвращенный элемент не Null ");
    Y.ArrayAssert.isEmpty(shoppingCart.cart, "Корзина не пуста!");
}

Данное тестирование захватывает оба ответвления функции путем заглушки объекта item. Конечно, могут быть заглушены не только параметры, обычно глушатся или имитируются все внешние зависимости.

Шпионы

Тестовый шпион как бы окутывает «реальный» объект, переопределяя некоторые его методы, а со всеми остальными методами объекта позволяя работать как ни в чем не бывало (режим полной прозрачности, как будто шпиона и нет вовсе). При этом действия шпиона при перекрытии чаще всего сводятся либо к возврату некоторых фиксированных значений в местах вызова определенных методов объекта (с определенными параметрами), либо просто к подсчету того, сколько раз был вызван тот или иной метод. Остальные методы, которые не прерываются шпионом, работают в обычном режиме. Шпионы отлично подходят для объектов, которые содержат как «тяжелые» операции, которые вам нужно имитировать, так и легковесные операции, с которыми можно справиться без имитации.

В качестве небольшого отступления дам несколько рекомендаций:

• Вы не обязательно должны использовать только заглушки или только имитации, тут ограничений никаких нет. Можно использовать и то и другое. Более того, вы можете в рамках одной дублирующей конструкции заложить как некоторые функции имитации, так заглушки. Нужно гибридное решение? Создавайте!

• В тех случаях, когда вам нужно отследить, сколько раз была вызвана какая-либо внешняя функция, лучшее решение состоит в использовании тестового шпиона.