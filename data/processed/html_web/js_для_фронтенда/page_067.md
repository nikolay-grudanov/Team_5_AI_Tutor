---
source_image: page_067.png
page_number: 67
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 28.11
tokens: 6327
characters: 1779
timestamp: 2025-12-24T10:04:00.121386
finish_reason: stop
---

Как уже было сказано, разветвление на входе помогает вам обнаружить повторное использование кода. А мы знаем, что повторное использование кода — это хорошо, плохо — рассеянное журналирование и отладка функций через ваш код. Учитесь централизовать совместно используемые функции (и модули)!

2.7. Связанность

Если разветвление на выходе подсчитывает число модулей и объектов, зависимых от какого-либо модуля или функции (для которых и определяется значение разветвления на выходе), то связанность призвана показать то, как все эти модули используются вместе.

Подмодули могут уменьшить абсолютное число разветвлений на выходе, но они не уменьшают сумму связей между исходным модулем (фрагментом кода) и необходимыми ему другими фрагментами кода (независимо от того, оформлен он в виде подмодуля или внешней библиотеки). Необходимость никуда не исчезла. Просто благодаря контролю разветвления на выходе можно локализовать взаимосвязи до определенных пределов.

Существуют подходы, метрики, которые пытаются выразить связанность в виде одного числа. Основываются эти подходы на шести уровнях, определенных Норманом Фэнтоном и Шари Лоуренс Пфлиджер в их работе «Software Metrics: A Rigorous & Practical Approach, 2nd Edition» (Course Technology), еще в 1996 г. При этом каждый уровень характеризуется своим числом — чем оно выше, тем сложнее связи. Далее мы рассмотрим эти шесть уровней (от самого сложного до самого простого) в последующих подразделах.

Связанность на уровне содержимого

Связанность на уровне содержимого — самая сложная форма связывания, подразумевающая вызовы методов или функций внешнего объекта и/или непосредственно изменяющая его путем редактирования свойств внешнего объекта. Пример:

Obj.property = 'bla'; // непосредственное изменение свойств объекта Obj