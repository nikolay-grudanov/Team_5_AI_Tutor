---
source_image: page_109.png
page_number: 109
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 24.05
tokens: 6239
characters: 1592
timestamp: 2025-12-24T10:04:47.212976
finish_reason: stop
---

принять соответствующие меры. Например, слушатель на стороне клиента может обновить интерфейс пользователя, а слушатель на стороне сервера может обновить какие-то внутренние структуры.

Здесь eventHub и databaseHandle введены в конструктор, что помогает тестированию и принципу модульности. При этом мы не создаем объекты, мы только регистрируем слушателей событий во введенном eventHub. Это и есть сущность событийно-ориентированной архитектуры: регистрируем слушателей событий и не инстанциируем объекты.

Браузеро-ориентируемый обработчик события может выглядеть так:

eventHub.on('USER_CREATED', function(data) {
    dialog.show('User created: ' + data.success);
});

Обработчик стороны сервера может быть примерно таким:

eventHub.on('USER_CREATED', function(data) {
    console.log('User created: ' + data.success);
});

Предыдущий код откроет диалоговое окно при создании пользователя (не имеет разницы, где было инициировано создание пользователя — в этом браузере, в каком-то другом браузере или даже на стороне сервера). Если это то, чего вы пытаетесь достичь, используйте широковещательные события, если нет — используйте обратный вызов. Также возможно породить событие, как на стороне клиента, так и сервера. Код на стороне клиента может выглядеть так:

eventHub.fire('CREATE_USER', user);

На стороне сервера:

eventHub.fire('CREATE_USER', user);

Проще уже некуда!

Для тестирования этой функции вы можете использовать имитацию концентратора событий и заглушенный обработчик базы данных, что позволит проверить, правильно ли порождаются события:

YUI().use('test', function(Y) {