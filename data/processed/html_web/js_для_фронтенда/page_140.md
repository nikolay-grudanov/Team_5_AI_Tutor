---
source_image: page_140.png
page_number: 140
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 29.95
tokens: 6278
characters: 1604
timestamp: 2025-12-24T10:05:31.488395
finish_reason: stop
---

Возвращаясь к нашим баранам, то есть шпионам, рассмотрим пример тестового сценария с использованием шпиона для нашей функции sum:

```javascript
testWithSpy: function() {
    var origSum = sum
    , sumSpy = function(a, b) {
        Y.Assert.areSame(a, 2, 'первый аргумент = 2!');
        Y.Assert.areSame(a, 9, 'второй аргумент = 9!');
        return origSum(a, b);
    }
    ;
    sum = sumSpy;
    Y.Assert.areSame(sum(2, 9), 11
        , '2 + 9 does not equal 11?');
    sum = origSum; // сбрасываем ее
}
```

Данный шпион является локальным для этого теста, он просто проверяет, что переданные аргументы являются ожидаемыми. Хорошим стилем в использовании шпионов является подход, при котором шпион не должен вызывать базовый "реальный" метод, если это займет много системных ресурсов (например, сетевой вызов), и вместо этого он может просто вернуть фиксированные значения (как ожидаемые, в рамках позитивного тестирования, так и запредельные в рамках негативного тестирования (например, смоделировав отказ сети)). В таких случаях шпион проявляет себя в качестве заглушки.

В качестве инструмента, позволяющего эффективно создавать и использовать всевозможные тестовые дубли (имитации, заглушки) и шпионы, хотелось бы отметить фреймворк Jasmine. И чуть дальше в этой главе мы подробнее поговорим о нем.

4.7. Асинхронное тестирование

JavaScript в значительной мере опирается на события. Поэтому в рамках рассмотрения тестирования мы должны учесть этот факт. Для таких случаев (тестирования событийно-ориентированных приложений/взаимодействий) предусмотрено так называемое асинхронное тестирование.