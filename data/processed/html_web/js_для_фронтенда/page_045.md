---
source_image: page_045.png
page_number: 45
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 21.88
tokens: 6235
characters: 1465
timestamp: 2025-12-24T10:03:22.940332
finish_reason: stop
---

Используя «хорошие» функции JavaScript и программируя идиоматически, вы создаете чистый, понятный и тестируемый код, а значит, делаете его «идеальным».

2.3. Цикломатическая сложность

Цикломатическая сложность — это мера числа линейно независимых путей в вашем исходном коде. Цикломатическая сложность равна увеличенному на единицу цикломатическому числу графа программы. Где граф программы — это как раз граф путей реализации вашей программы, а цикломатическое число — минимальное число ребер, которые надо удалить, чтобы граф стал ациклическим (то есть без циклов).

С точки зрения тестирования цикломатическая сложность — это минимальное число модульных тестов, необходимых для тестового покрытия всего вашего кода. Рассмотрим следующий пример:

function sum(a, b) {
    if (typeof(a) !== typeof(b)) {
        throw new Error("Не могу вычислить сумму разных типов!");
    } else {
        return a + b;
    }
}

Цикломатическая сложность этого метода равна 2. Это означает, что вам нужно написать два модульных теста, чтобы покрыть все 100% кода.

Примечание.

В приведенном выше коде мы используем оператор !== для проверки типов аргументов с помощью typeof. Хотя это не строго необходимо, использование операторов !== и === является хорошей привычкой. Использование строгого равенства (=== и !==) поможет быстро обнаруживать ошибки в вашем коде.

Вычислить цикломатическую сложность вашего кода можно, например, утилитой командной строки под названием jsmeter