---
source_image: page_392.png
page_number: 392
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 36.40
tokens: 7602
characters: 2429
timestamp: 2025-12-24T10:56:12.488073
finish_reason: stop
---

let mut one_borrow = self.sent_messages.borrow_mut();
let mut two_borrow = self.sent_messages.borrow_mut();

one_borrow.push(String::from(message));
two_borrow.push(String::from(message));
}

Мы создаем переменную one_borrow для умного указателя RefMut<T>, возвращаемого из функции loan_mut. Затем мы создаем еще одно изменяемое заимствование таким же образом в переменной two_borrow. В результате в одной области видимости создаются две изменяемые ссылки, что недопустимо. Когда мы выполним тесты для библиотеки, код в листинге 15.23 будет скомпилирован без ошибок, но тест не сработает:

---- tests::it_sends_an_over_75_percent_warning_message stdout ----
    thread 'tests::it_sends_an_over_75_percent_warning_message' panicked
at 'already borrowed: BorrowMutError', src/libcore/result.rs:906:4
note: Run with 'RUST_BACKTRACE=1' for a backtrace.

Обратите внимание, что код поднял панику с сообщением already borrowed: BorrowMutError («уже заимствовано»). Именно так умный указатель RefCell<T> обрабатывает нарушения правил заимствования во время выполнения.

Фиксация ошибок заимствования во время выполнения, а не во время компиляции означает, что в процессе разработки вы либо поздно найдете ошибку в коде, либо она обнаружится, лишь когда код будет запущен в производство. Кроме того, из-за отслеживания заимствований во время выполнения, а не во время компиляции произойдет небольшое снижение производительности времени выполнения кода. Однако благодаря умному указателю RefCell<T> можно написать имитационный объект, способный модифицировать себя, чтобы отслеживать сообщения, которые он видел, пока вы используете его в контексте, где разрешены только неизменяемые значения. Вы можете использовать умный указатель RefCell<T> несмотря на его компромиссы, чтобы воспользоваться большими преимуществами, чем дают регулярные ссылки.

Наличие нескольких владельцев изменяемых данных путем сочетания Rc<T> и RefCell<T>

Умный указатель RefCell<T> часто используется в сочетании с умным указателем Rc<T>. Напомним, что Rc<T> позволяет иметь несколько владельцев данных, но он дает только неизменяемый доступ к этим данным. Если у вас есть умный указатель Rc<T>, содержащий RefCell<T>, то можно получить значение, способное иметь нескольких владельцев, которое можно изменять!

Вспомните пример cons- списка из листинга 15.18, где мы использовали умный указатель Rc<T>, чтобы разрешить нескольким спискам совместно владеть дру-