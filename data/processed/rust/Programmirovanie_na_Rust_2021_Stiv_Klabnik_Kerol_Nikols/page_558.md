---
source_image: page_558.png
page_number: 558
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 35.79
tokens: 7620
characters: 2354
timestamp: 2025-12-24T11:00:34.843662
finish_reason: stop
---

Ошибка выглядит довольно загадочно, потому что и сама проблема довольно загадочная. Чтобы вызвать замыкание FnOnce, которое хранится в умном указателе Box<T> (являющемся псевдонимом типа Job), замыканию требуется переместиться из Box<T>, потому что оно берет self во владение, когда мы его вызываем. В общем, Rust не позволяет перемещать значение из Box<T>, потому что он не знает, насколько большим будет значение внутри Box<T>. Вспомните, что в главе 15 мы использовали умный указатель Box<T> именно потому, что у нас было нечто неизвестного размера, которое мы хотели сохранить в Box<T>, чтобы получить значение известного размера.

Как вы видели в листинге 17.15, мы можем писать методы, использующие синтаксис self: Box<Self>, который позволяет методу брать во владение значение Self, хранящееся в Box<T>. Здесь мы хотим сделать именно так, но, к сожалению, компилятор не позволит: та часть Rust, которая реализует поведение при вызове замыкания, не выполняется с self: Box<Self>. И поэтому Rust еще не понимает, что может использовать self: Box<Self> в этой ситуации, чтобы брать замыкание во владение и перемещать его из Box<T>.

Язык Rust по-прежнему находится в стадии разработки мест, где компилятор может быть усовершенствован, но в будущем код из листинга 20.20 должен работать без проблем. Мы будем рады, если вы присоединитесь к нам после прочтения этой книги и внесете свой вклад в развитие языка.

Но пока давайте обойдем эту проблему, используя хитрый трюк. Мы скажем компилятору, что в этом случае можно взять значение внутри Box<T> во владение, используя self: Box<Self>, и тогда, после того как мы овладеем замыканием, можно его вызвать. Это предусматривает определение нового типажа FnBox с методом call_box, который будет использовать self: Box<Self> в своей сигнатуре, определение FnBox для любого типа, реализующего FnOnce(), изменение псевдонима типа, чтобы он использовал новый типаж, и изменение структуры Worker, чтобы она использовала метод call_box. Эти изменения показаны в листинге 20.21.

Листинг 20.21. Добавление нового типажа FnBox для обхода текущих ограничений умного указателя Box<FnOnce()>

src/lib.rs

trait FnBox {
    fn call_box(self: Box<Self>);
}

impl<F: FnOnce()> FnBox for F {
    fn call_box(self: Box<F>) {
        (*self)()
    }
}

type Job = Box<FnBox + Send + 'static>;

// --пропуск--
impl Worker {