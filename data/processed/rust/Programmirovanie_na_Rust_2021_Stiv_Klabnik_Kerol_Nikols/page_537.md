---
source_image: page_537.png
page_number: 537
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 36.65
tokens: 7609
characters: 2132
timestamp: 2025-12-24T11:00:00.950678
finish_reason: stop
---

Проверка запроса и выборочный ответ

Прямо сейчас веб-сервер будет возвращать HTML-код файла независимо от того, что запросил клиент. Давайте добавим функциональность, которая проверяет, что браузер запрашивает ресурс / перед возвратом HTML-файла, и возвращает ошибку, если браузер запрашивает что-то еще. Для этого нужно изменить функцию handle_connection, как показано в листинге 20.6. Этот новый код проверяет содержимое полученного запроса на соответствие тому, что мы знаем о том, как выглядит запрос ресурса /, и добавляет блоки if и else, которые трактуют запросы по-разному.

Листинг 20.6. Сопоставление запроса и обработка запросов ресурса / иначе, чем другие запросы

src/main.rs

// --пропуск--

fn handle_connection(mut stream: TcpStream) {
    let mut buffer = [0; 512];
    stream.read(&mut buffer).unwrap();

    let get = b"GET / HTTP/1.1\r\n"; // ①

    if buffer.starts_with(get) { // ②
        let contents = fs::read_to_string("hello.html").unwrap();
        let response = format!("HTTP/1.1 200 OK\r\n\r\n{}", contents);
        stream.write(response.as_bytes()).unwrap();
        stream.flush().unwrap();
    } else { // ③
        // какой-то другой запрос
    }
}

Во-первых, мы жестко закодируем данные, соответствующие запросу ресурса /, в переменную get ①. Поскольку мы читаем сырье байты в буфер, мы трансформируем get в байтовую строку, добавляя синтаксис байтовой строки b"" в начало данных содержимого. Затем мы проверяем, начинается ли значение переменной buffer с байтов в get ②. Если это так, значит, мы получили хорошо сформированный запрос ресурса / — это случай успеха, который мы будем обрабатывать в блоке if, возвращающем содержимое HTML-файла.

Если буфер не начинается с байтов в get, значит, мы получили какой-то другой запрос. Вскоре мы добавим код в блок else ③, который будет отвечать на все остальные запросы.

А сейчас выполните этот код и запросите 127.0.0.1:7878. Вы должны получить HTML в hello.html. Если вы сделаете какой-то другой запрос, например 127.0.0.1:7878/что-то-еще, то получите ошибку соединения, подобную тем, которые вы видели при запуске кода в листингах 20.1 и 20.2.