---
source_image: page_520.png
page_number: 520
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 23.40
tokens: 7417
characters: 1640
timestamp: 2025-12-24T10:59:19.085219
finish_reason: stop
---

указывает, какой тип процедурной макрокоманды мы создаем. В одной упаковке можно иметь несколько видов процедурных макрокоманд.

Давайте рассмотрим разные виды процедурных макрокоманд. Мы начнем с настраиваемой макрокоманды derive, а затем объясним небольшие различия, которые есть у других форм.

Как написать настраиваемую макрокоманду derive

Давайте создадим упаковку с именем hello_macro, которая определяет типаж HelloMacro с одной связанной функцией hello_macro. Вместо того чтобы заставлять пользователей упаковки реализовывать типаж HelloMacro в каждом типе, мы предоставим процедурную макрокоманду, с помощью которой пользователи могут аннотировать свой тип с #[derive(HelloMacro)], получая реализацию по умолчанию функции hello_macro. Реализация по умолчанию будет печатать Здравствуй, Макро! Меня зовут TypeName!, где TypeName — это имя типа, для которого был определен этот типаж. Другими словами, мы напишем упаковку, которая позволит другому программисту писать код, подобный представленному в листинге 19.30, используя нашу упаковку.

Листинг 19.30. Код, который пользователь нашей упаковки сможет писать во время использования процедурной макрокоманды

src/main.rs
use hello_macro::HelloMacro;
use hello_macro_derive::HelloMacro;

#[derive(HelloMacro)]
struct Pancakes;

fn main() {
    Pancakes::hello_macro();
}

Когда дело будет сделано, этот код выведет:

Здравствуй, Макро! Меня зовут Pancakes!

Первый шаг — создать новую библиотечную упаковку, как показано ниже:

$ cargo new hello_macro --lib

Далее мы определим типаж HelloMacro и связанную с ним функцию:

src/lib.rs
pub trait HelloMacro {
    fn hello_macro();
}