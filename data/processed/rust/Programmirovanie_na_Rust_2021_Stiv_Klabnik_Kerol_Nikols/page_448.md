---
source_image: page_448.png
page_number: 448
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 35.07
tokens: 7583
characters: 2504
timestamp: 2025-12-24T10:57:39.480088
finish_reason: stop
---

```rust
struct PendingReview {}

impl State for PendingReview {
    fn request_review(self: Box<Self>) -> Box<dyn State> {
        self
    }
}
```

Мы даем экземпляру структуры Post публичный метод request_review, который будет брать изменяемую ссылку на self ①. Затем мы вызываем внутренний метод request_review для текущего состояния структуры Post ③, и этот второй метод request_review поглощает текущее состояние и возвращает новое состояние.

Мы добавили метод request_review в типаж State ④. Все типы, которые реализуют указанный типаж, теперь должны будут реализовывать метод request_review. Обратите внимание, что вместо self, &self или &mut self в качестве первого параметра метода у нас self: Box<Self>. Этот синтаксис означает, что метод допустим только при вызове для умного указателя Box, содержащего тип. Этот синтаксис берет Box<Self> во владение, делая старое состояние недействительным, благодаря чему значение состояния структуры Post способно трансформироваться в новое состояние.

Для того чтобы поглотить старое состояние, метод request_review должен стать владельцем значения состояния. Именно здесь появляется тип Option в поле state структуры Post: мы вызываем метод take, чтобы взять значение Some из поля state и не трогать None, потому что в языке Rust нельзя иметь незаполненные поля в структурах ②. Это позволяет нам переместить значение state из структуры Post, а не заимствовать его. Затем мы установим значение state статьи равным результату этой операции.

Чтобы завладеть значением state, нужно временно установить state равным None, а не устанавливать его непосредственно с помощью кода, такого как self.state = self.state.request_review();. Благодаря этому структура Post не сможет использовать старое значение state после того, как мы трансформировали его в новое состояние.

Метод request_review в структуре Draft должен возвращать новый, обернутый в умный указатель Box экземпляр новой структуры PendingReview ⑤, которая представляет состояние, когда статья ожидает проверки. Структура PendingReview тоже реализует метод request_review, но он не выполняет никаких трансформаций. Напротив, он возвращает себя ⑥, потому что, когда мы запрашиваем проверку статьи, уже находящейся в состоянии PendingReview, она должна оставаться в состоянии PendingReview.

Теперь мы видим преимущества паттерна переходов между состояниями: метод request_review в структуре Post остается тем же, независимо от значения его поля state. Каждое состояние отвечает за собственные правила.