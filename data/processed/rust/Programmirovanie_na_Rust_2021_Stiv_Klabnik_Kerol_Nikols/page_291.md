---
source_image: page_291.png
page_number: 291
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 37.11
tokens: 7597
characters: 2318
timestamp: 2025-12-24T10:53:28.270641
finish_reason: stop
---

ненный цикл», что &'static str является типом строковых литералов, который пока что является типом сообщения об ошибке.

Мы сделали два изменения в теле функции new: вместо вызова panic!, когда пользователь не передает достаточного числа аргументов, мы теперь возвращаем значение Err, и мы завернули в Ok значение, возвращаемое из структуры Config. Эти изменения подчиняют функцию новой сигнатуры типа.

Возвращение значения Err из функции Config::new позволяет функции main обрабатывать значение Result, возвращаемое из функции new, и лучше завершать работу в случае ошибки.

Вызов функции Config::new и обработка ошибок

Для того чтобы обработать ошибку и напечатать удобное для пользователя сообщение, нужно обновить функцию main в части обработки Result, возвращаемого из функции Config::new, как показано в листинге 12.10. Мы также займемся выходом из программы командной строки с ненулевым кодом ошибки из макрокоманды panic! и реализуем его вручную. Ненулевой статус завершения работы традиционно сигнализирует процессу, вызвавшему программу, о том, что программа завершила работу с ошибкой.

Листинг 12.10. Завершение работы с кодом ошибки, если не получается создать новый экземпляр структуры Config
src/main.rs
① use std::process;

fn main() {
    let args: Vec<String> = env::args().collect();

    ② let config = Config::new(&args).unwrap_or_else(③|err④| {
        ⑤ println!("Проблема при разборе аргументов: {}", err);
        ⑥ process::exit(1);
    });
}

// --пропуск--

В этом листинге мы использовали метод, который ранее не рассматривали: unwrap_or_else, определенный стандартной библиотекой для Result<T, E> ②. Использование метода unwrap_or_else позволяет определять настраиваемую обработку ошибок без вызова макрокоманды panic!. Если Result равен значению Ok, то поведение этого метода аналогично методу unwrap: он возвращает внутреннее значение, обернутое ok. Однако если это значение равно Err, то метод вызывает код в замыкании, то есть анонимную функцию, которую мы определяем и передаем в качестве аргумента в методе unwrap_or_else ③. Мы рассмотрим замыкание подробнее в главе 13. А пока вам просто нужно знать, что метод unwrap_or_else передаст внутреннее значение Err, которое в данном случае является статической строкой недостаточно аргументов, добавленной в листинг 12.9. Она находится