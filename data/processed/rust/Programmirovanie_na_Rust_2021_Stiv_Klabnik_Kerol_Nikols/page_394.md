---
source_image: page_394.png
page_number: 394
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 37.48
tokens: 7628
characters: 2261
timestamp: 2025-12-24T10:56:14.007372
finish_reason: stop
---

RefMut<T>, и мы используем для него оператор разыменования и изменяем внутреннее значение.

Когда мы печатаем a, b и c, мы видим, что все они имеют модифицированное значение 15, а не 5:

    a после = Cons(RefCell { value: 15 }, Nil)
    b после = Cons(RefCell { value: 6 }, Cons(RefCell { value: 15 }, Nil))
    c после = Cons(RefCell { value: 10 }, Cons(RefCell { value: 15 }, Nil))

Этот технический прием довольно хорош! Используя умный указатель RefCell<T>, мы получаем внешне неизменяемое значение типа List. Но с умным указателем RefCell<T> мы можем использовать методы, которые обеспечивают доступ к его внутренней изменяемости, благодаря чему при необходимости можно модифицировать данные. Проверки правил заимствования во время выполнения защищают от гонки данных, и иногда есть смысл пожертвовать скоростью ради гибкости в структурах данных.

Стандартная библиотека имеет другие типы, которые обеспечивают внутреннюю изменяемость. Например, похожий тип Cell<T>, но в нем нет ссылки на внутреннее значение, значение копируется в Cell<T> и из него. Существует также тип Mutex<T>, обеспечивающий внутреннюю изменяемость, безопасную для использования между потоками. Мы обсудим этот тип в главе 16. Дополнительные сведения о различиях между этими типами смотрите в документации стандартной библиотеки.

Циклы в переходах по ссылкам приводят к утечке памяти

В языке Rust из-за гарантий безопасности памяти непросто, но в вместе с тем возможно случайно создать пространство памяти, которое никогда не очищается (так называемая «утечка памяти»). Всеобъемлющее предотвращение утечки памяти — это гарантия Rust, так же как и запрещение гонки данных во время компиляции. То есть в Rust утечка памяти безопасна. Мы видим, что Rust допускает утечку памяти путем использования умных указателей Rc<T> и RefCell<T>: можно создавать ссылки, где элементы ссылаются друг на друга в цикле. Это приводит к утечке памяти, потому что число ссылок для каждого элемента в цикле никогда не достигнет 0, а значения никогда не будут отброшены.

Создание цикла в переходах по ссылкам

Давайте посмотрим, как происходит цикл в переходах по ссылкам (так называемый «референсный цикл») и как его предотвращать, начав с определения перечисления List и метода tail в листинге 15.25.