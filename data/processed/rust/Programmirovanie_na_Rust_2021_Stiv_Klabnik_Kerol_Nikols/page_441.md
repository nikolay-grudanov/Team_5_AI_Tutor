---
source_image: page_441.png
page_number: 441
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 28.46
tokens: 7441
characters: 1786
timestamp: 2025-12-24T10:57:21.583894
finish_reason: stop
---

Например, в листинге 17.10 показано, что произойдет, если мы попытаемся создать структуру Screen с типом String в качестве компонента.

Листинг 17.10. Попытка использовать тип, который не реализует типаж типажного объекта

src/main.rs
use gui::Screen;

fn main() {
    let screen = Screen {
        components: vec![
            Box::new(String::from("Привет")),
        ],
    };

    screen.run();
}

Мы получим эту ошибку, потому что тип String не реализует типаж Draw:

error[E0277]: the trait bound `std::string::String: gui::Draw` is not satisfied
  --> src/main.rs:7:13
   |
7  |         Box::new(String::from("Привет")),
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait gui::Draw is not implemented for `std::string::String`
   |
   = note: required for the cast to the object type `gui::Draw`

Эта ошибка показывает, что либо в экземпляр структуры Screen передается что-то, что мы не задумывали передавать, и нам следует передать другой тип, либо нужно реализовать Draw в типе String, в результате чего структура Screen сможет вызывать для него метод draw.

Типажные объекты выполняют динамическую диспетчеризацию

Напомним, что в разделе «Производительность кода с использованием обобщений» мы обсуждали процесс мономорфизации, выполняемый компилятором при использовании границ типа для обобщений: компилятор генерирует необобщенные реализации функций и методов для каждого конкретного типа, используемые вместо параметра обобщенного типа. Код, полученный в результате мономорфизации, выполняет статическую диспетчеризацию, когда компилятор знает, какой метод вы вызываете во время компиляции. Это противоречит динамической диспетчеризации, когда компилятор не может сказать во время компиляции, какой метод вы вызываете. В случаях динамической диспетчеризации компиля-