---
source_image: page_329.png
page_number: 329
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 38.14
tokens: 7600
characters: 2139
timestamp: 2025-12-24T10:54:31.472111
finish_reason: stop
---

Не разрешается использовать v1_iter после вызова sum, потому что sum берет во владение итератор, для которого мы его вызываем.

Методы, которые производят другие итераторы

Другие методы, определенные для типажа Iterator, — «итераторные адаптеры» — позволяют переделывать итераторы в разные виды. Вы можете выстроить несколько вызовов итераторных адаптеров в цепь, выполняя сложные действия в удобном виде. Но поскольку все итераторы являются ленивыми, то для того чтобы получить результаты вызовов итераторных адаптеров, вам придется вызвать один из методов потребляющего адаптера.

В листинге 13.17 показан пример вызова метода map итераторного адаптера, который берет замыкание вызова для каждого элемента, производя новый итератор. Замыкание здесь создает новый итератор, в котором каждый элемент из вектора был увеличен на 1. Однако этот код выдает предупреждение.

Листинг 13.17. Вызов метода map итераторного адаптера для создания нового итератора
src/main.rs
```rust
let v1: Vec<i32> = vec![1, 2, 3];
v1.iter().map(|x| x + 1);
```

Мы получаем такое предупреждение¹:

```
warning: unused `std::iter::Map` which must be used: iterator adaptors are lazy and do nothing unless consumed
 --> src/main.rs:4:5
  |
4 |     v1.iter().map(|x| x + 1);
  |     ^^^^^^^^^^^^^^^^^^^^^^^^
= note: #[warn(unused_must_use)] on by default
```

Код в листинге 13.17 ничего не делает, указанное нами замыкание никогда не вызывается. Это предупреждение напоминает, почему итераторные адаптеры являются ленивыми, и здесь нам нужно употребить итератор.

Для того чтобы это исправить и употребить итератор, мы применим метод collect, использованный с env::args в листинге 12.1. Указанный метод потребляет итератор и собирает результирующие значения в коллекционный тип данных.

В листинге 13.18 мы собираем результаты перебора итератора, возвращаемые после вызова метода map, в вектор. Этот вектор в конечном итоге будет содержать каждый элемент из исходного вектора, увеличенный на 1.

¹ предупреждение: неиспользуемый 'std::iter::Map', который должен быть использован: итераторные адаптеры являются ленивыми и ничего не делают, если они не потребляются