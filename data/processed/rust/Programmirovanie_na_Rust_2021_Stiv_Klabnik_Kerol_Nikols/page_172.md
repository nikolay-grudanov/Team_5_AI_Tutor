---
source_image: page_172.png
page_number: 172
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 30.91
tokens: 7477
characters: 1890
timestamp: 2025-12-24T10:50:14.911099
finish_reason: stop
---

Компиляция этого кода приведет к ошибке¹:

error[E0502]: cannot borrow `v` as mutable because it is also borrowed as immutable
--> src/main.rs:6:5
|        let first = &v[0];
|                        - immutable borrow occurs here
|        v.push(6);
|                ^^^^^^^^ mutable borrow occurs here
|        println!("The first element is: {}", first);
|                        ----- immutable borrow later used here

Код в листинге 8.7 выглядит так, будто должен работать. Почему для использования ссылки на первый элемент должно быть важно, что изменяется в конце вектора? Эта ошибка связана с тем, как работают векторы: добавление нового элемента в конец вектора может потребовать выделения новой памяти и копирования старых элементов в новое пространство, если не хватает места для того, чтобы поместить все элементы рядом, туда, где в данный момент находится вектор. В этом случае ссылка на первый элемент будет указывать на освобожденную память. Правила заимствования не позволяют программам оказываться в такой ситуации.

ПРИМЕЧАНИЕ
Дополнительные сведения о реализации типа Vec<T> см. в «Растономиконе», книге тайных знаний о Rust, по адресу https://doc.rust-lang.org/stable/nomicon/vec.html, которая затрагивает самые «ужасные» подробности языка.

Перебор значений в векторе

Если мы хотим обращаться к каждому элементу вектора по очереди, то можем перебирать все элементы в цикле вместо того, чтобы использовать индексы для доступа по одному за раз. В листинге 8.8 показано, как использовать цикл for, получая неизменяемые ссылки на каждый элемент вектора значений типа i32 и печатая их.

Листинг 8.8. Печать каждого элемента в векторе путем перебора элементов с помощью цикла for
let v = vec![100, 32, 57];
for i in &v {
    println!("{}", i);
}

¹ ошибка[E0502]: не получается позаимствовать переменную `v` как изменяемую, потому что она также заимствуется как неизменяемая