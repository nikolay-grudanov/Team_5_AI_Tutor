---
source_image: page_417.png
page_number: 417
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 28.64
tokens: 7476
characters: 1908
timestamp: 2025-12-24T10:56:42.695473
finish_reason: stop
---

let val = String::from("привет");
    tx.send(val).unwrap();
    println!("val равна {}", val);
});
    let received = rx.recv().unwrap();
    println!("Получено: {}", received);
}

Здесь мы пытаемся напечатать переменную val после того, как отправили ее по каналу через tx.send. Разрешить это — плохая идея: как только значение отправлено в другой поток, она может его изменить или отбросить, прежде чем мы попытаемся использовать значение снова. Модификации другого потока потенциально могут приводить к ошибкам или неожиданным результатам из-за несогласованных или несуществующих данных. Однако компилятор выдает ошибку, если мы пытаемся скомпилировать код в листинге 16.9.

error[E0382]: use of moved value: `val`
 --> src/main.rs:10:31
  |
9 |     tx.send(val).unwrap();
   |                --- value moved here
10 |     println!("val is {}", val);
   |                        ^^^ value used here after move
= note: move occurs because `val` has type `std::string::String`, which does not implement the `Copy` trait

Неточность конкурентности стала причиной ошибки времени компиляции. Функция send берет свой параметр во владение, а когда значение перемещается, получатель становится его владельцем. Благодаря этому мы не можем случайно использовать значение снова после его отправки. Система владения проверяет, что все в порядке.

Отправка нескольких значений и ожидание приемника

Код в листинге 16.8 скомпилирован и выполнен, но он не совсем ясно показал, что два отдельных потока разговаривают друг с другом по каналу. В листинг 16.10 мы внесли несколько модификаций, которые докажут, что код в листинге 16.8 выполняется параллельно: порожденный поток теперь будет отправлять несколько сообщений и делать секундную паузу между каждым сообщением.

Листинг 16.10. Отправка нескольких сообщений и пауза между ними
src/main.rs
use std::thread;
use std::sync::mpsc;
use std::time::Duration;

fn main() {