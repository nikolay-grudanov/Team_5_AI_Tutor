---
source_image: page_422.png
page_number: 422
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 36.70
tokens: 7604
characters: 2408
timestamp: 2025-12-24T10:56:56.785944
finish_reason: stop
---

мьютекса, мы используем метод lock для получения замка ②. Его вызов заблокирует текущий поток, в результате чего он не сможет ничего сделать до тех пор, пока не наступит наша очередь блокировки.

Вызов метода lock не сработает, если еще один поток, удерживающий этот замок, поднимет панику. В этом случае никто не сможет получить этот замок, поэтому мы решили использовать метод unwrap и позволить потоку поднимать панику в подобной ситуации.

После получения замка мы можем трактовать возвращаемое значение, в данном случае именуемое num, как изменяемую ссылку на данные внутри ③. Система типов отвечает за то, чтобы мы получали замок перед использованием значения в m: Mutex<i32> не является типом i32, поэтому мы должны получить замок, чтобы иметь возможность использовать значение типа i32. Мы не забудем это сделать, в противном случае система типов не позволит нам обратиться к внутреннему типу i32.

Как вы можете догадаться, тип Mutex<T> представляет собой умный указатель. Точнее, вызов метода lock возвращает умный указатель под названием MutexGuard. Этот умный указатель реализует типаж Deref для указания на внутренние данные. У этого умного указателя также есть реализация типажа Drop, которая автоматически освобождает замок, когда умный указатель MutexGuard выходит из области видимости, что и происходит в конце внутренней области ④. В результате мы точно не забудем открыть замок и заблокировать мьютекс от использования другими потоками, потому что замок открывается автоматически.

После снятия блокировки мы выводим значение мьютекса и видим, что нам удалось изменить внутренний экземпляр типа i32 на 6 ⑤.

Совместное использование Mutex<T> несколькими потоками

Теперь давайте попробуем поделиться значением между несколькими потоками с помощью умного указателя Mutex<T>. Мы раскрутим 10 потоков, каждый из них будет увеличивать значение счетчика на 1, и поэтому счетчик движется от 0 до 10. Обратите внимание, что в следующих примерах будут ошибки компилятора. Мы будем использовать эти ошибки, чтобы узнать больше об умном указателе Mutex<T> и о том, как Rust помогает нам реализовать его правильно. Листинг 16.13 показывает первый пример.

Листинг 16.13. Десять потоков исполнения, каждый из которых увеличивает счетчик, охраняемый умным указателем Mutex<T>
src/main.rs
use std::sync::Mutex;
use std::thread;

fn main() {
    let counter = Mutex::new(0);
    let mut handles = vec![];