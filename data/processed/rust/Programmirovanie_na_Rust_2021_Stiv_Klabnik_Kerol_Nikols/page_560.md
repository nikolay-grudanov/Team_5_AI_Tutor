---
source_image: page_560.png
page_number: 560
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 31.39
tokens: 7485
characters: 1736
timestamp: 2025-12-24T11:00:34.469448
finish_reason: stop
---

--> src/lib.rs:61:5
|
61 |     id: usize,
|     ^^^^^^^^
|
= note: #[warn(dead_code)] on by default

warning: field is never used: `thread`
--> src/lib.rs:62:5
|
62 |     thread: thread::JoinHandle<()>,
|     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
|
= note: #[warn(dead_code)] on by default

    Finished dev [unoptimized + debuginfo] target(s) in 0.99 secs
    Running `target/debug/hello`
Работник 0 получил задание; исполняется.
Работник 2 получил задание; исполняется.
Работник 1 получил задание; исполняется.
Работник 3 получил задание; исполняется.
Работник 0 получил задание; исполняется.
Работник 2 получил задание; исполняется.
Работник 1 получил задание; исполняется.
Работник 3 получил задание; исполняется.
Работник 0 получил задание; исполняется.
Работник 2 получил задание; исполняется.

Получилось! Теперь у нас есть пул потоков, который выполняет соединения асинхронно. Никогда не создается более четырех потоков, поэтому система не будет перегружена, если сервер получит много запросов. Если мы сделаем запрос ресурса /sleep, то сервер будет способен обслуживать другие запросы, имея еще один поток, который будет их выполнять.

ПРИМЕЧАНИЕ
Если вы откроете ресурс /sleep в нескольких окнах браузера одновременно, то они могут загружаться по одному с интервалом в 5 секунд. Некоторые веб-браузеры исполняют несколько экземпляров одного и того же запроса последовательно из-за кэширования. Это ограничение не обусловлено нашим веб-сервером.

Узнав о цикле while let в главе 18, вы, возможно, задаетесь вопросом, почему мы не написали код потока Worker, как показано в листинге 20.22.

Листинг 20.22. Альтернативная реализация функции Worker::new с использованием цикла while let
src/lib.rs
    // --пропуск--
    impl Worker {