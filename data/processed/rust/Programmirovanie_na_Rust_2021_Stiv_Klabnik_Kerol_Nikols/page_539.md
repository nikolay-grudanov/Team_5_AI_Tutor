---
source_image: page_539.png
page_number: 539
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 30.65
tokens: 7517
characters: 2109
timestamp: 2025-12-24T10:59:59.003801
finish_reason: stop
---

являются строка состояния и имя файла. Давайте сделаем код более сжатым, выделив эти различия в отдельные блоки if и else, которые будут передавать значения строки состояния и имени файла переменным. Тогда мы сможем использовать эти переменные в безусловном порядке в коде для чтения файла и записи ответа. В листинге 20.9 показан итоговый код после замены крупных блоков if и else.

Листинг 20.9. Рефакторинг блоков if и else, в результате которого они содержат только тот код, который отличается в обоих случаях

src/main.rs
    // --snip--

    fn handle_connection(mut stream: TcpStream) {
        // --snip--

        let (status_line, filename) = if buffer.starts_with(get) {
            ("HTTP/1.1 200 OK\r\n\r\n", "hello.html")
        } else {
            ("HTTP/1.1 404 НЕ НАЙДЕНО\r\n\r\n", "404.html")
        };

        let contents = fs::read_to_string(filename).unwrap();

        let response = format!("{}{}", status_line, contents);

        stream.write(response.as_bytes()).unwrap();
        stream.flush().unwrap();
    }

Теперь блоки if и else возвращают только подходящие значения для строки состояния и имени файла в кортеже. Затем мы используем деструктурирование, передавая эти два значения переменным status_line и filename, применяя паттерн в инструкции let, как описано в главе 18.

Ранее повторенный код теперь находится вне блоков if и else и использует переменные status_line и filename. Так легче увидеть разницу между двумя случаями, и это означает, что есть только одно место для обновления кода, если мы хотим изменить способ чтения файла и записи ответа. Поведение кода в листинге 20.9 будет таким же, как и в листинге 20.8.

Потрясающе! Теперь у нас есть простой веб-сервер примерно в 40 строках кода Rust, который отвечает на один запрос страницей контента, а на все остальные — ответами 404.

Сейчас сервер работает в одном потоке, а значит, может обслуживать только один запрос за раз. Давайте узнаем, когда это может стать проблемой, разобрав несколько медленных запросов. Затем мы это исправим, в результате чего сервер сможет обрабатывать несколько запросов сразу.