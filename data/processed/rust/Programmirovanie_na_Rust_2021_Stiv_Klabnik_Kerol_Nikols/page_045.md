---
source_image: page_045.png
page_number: 45
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 33.92
tokens: 7581
characters: 2405
timestamp: 2025-12-24T10:46:57.435255
finish_reason: stop
---

Следующая часть кода .read_line(&mut guess) вызывает метод read_line, заданный для дескриптора стандартного ввода данных для получения данных от пользователя. Мы также передаем в метод read_line один аргумент: &mut guess.

Работа метода read_line состоит в том, чтобы брать все, что пользователь набирает в стандартном вводе данных, и помещать это в экземпляр типа String, поэтому он берет этот строковый экземпляр в качестве аргумента. Указанный аргумент должен быть изменяемым, чтобы этот метод мог изменять содержимое строкового экземпляра путем добавления вводимых пользователем данных.

Символ & указывает на то, что этот аргумент является ссылкой, которая дает возможность многочисленным частям кода обращаться к одному фрагменту данных без многократного копирования этих данных в память. Ссылки являются сложным языковым средством, и одно из главных преимуществ Rust состоит в том, что в нем можно совершенно безопасно и легко использовать ссылки. Для того чтобы завершить программу, не нужно знать многих подробностей. На данный момент вам нужно лишь знать, что, как и переменные, ссылки по умолчанию являются неизменяемыми. Следовательно, чтобы сделать ее изменяемой, нужно написать &mut guess вместо &guess. (В главе 4 ссылки будут объяснены подробнее.)

Обработка потенциального сбоя с помощью типа Result

Мы еще не закончили с этой строкой кода. Хотя темой нашего обсуждения до сих пор была одна-единственная строка текста, она является лишь первой частью одной логической строки кода. Вторая часть заключается в следующем методе:

    .expect("Не получилось прочитать строку");

Когда вы вызываете метод с помощью синтаксиса .foo(), часто бывает разумно добавить новую строку и другие пробелы с целью разбиения длинных строк кода. Мы могли бы написать этот код следующим образом:

    io::stdin().read_line(&mut guess).expect("Не получилось прочитать строку");

Однако одну длинную строку кода трудно читать, поэтому лучше всего ее разделить: две строки кода для двух вызовов метода. Теперь давайте рассмотрим, что делает эта строка кода.

Как уже упоминалось ранее, метод read_line помещает то, что пользователь набирает, в переменную типа String, которую мы ему передаем, но также возвращает значение — в данном случае io::Result. Стандартная библиотека языка Rust имеет ряд типов с именем Result: обобщенный тип Result, а также специальные версии для подмодулей, такие как тип io::Result.