---
source_image: page_435.png
page_number: 435
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 33.45
tokens: 7558
characters: 2331
timestamp: 2025-12-24T10:57:16.399047
finish_reason: stop
---

Другая причина использования наследования связана с системой типов: оно необходимо для возможности использовать тип потомков в тех же местах, что и родительский тип. Это также называется «полиморфизм», то есть вы можете заменять одни объекты другими во время выполнения, если у них есть некоторые общие характеристики.

ПОЛИМОРФИЗМ

Для многих людей полиморфизм является синонимом наследования. Но на самом деле это более широкое понятие, относящееся к коду, который может работать с данными нескольких типов. Для наследования эти типы обычно являются подклассами.

Вместо этого Rust использует обобщения для абстрагирования от всевозможных типов и границы типажа для ограничения того, что эти типы должны обеспечивать. Этот подход иногда называют ограниченным параметрическим полиморфизмом.

Во многих языках программирования наследование в последнее время стало выходить из употребления как техническое решение для создания программ, потому что из-за него часто есть риск поделиться большим объемом кода, чем необходимо. Подклассы не обязательно будут все время делиться всеми характеристиками своего родительского класса, но будут делать это с наследованием. Вследствие этого проектирование программы может стать менее гибким. Кроме того, из-за этого возникает вероятность бессмысленного вызова методов для подклассов, что может привести к ошибкам, потому что методы не применимы к подклассу. В дополнение к этому, некоторые языки допускают наследование подкласса только от одного класса, что еще больше ограничивает гибкость программы.

По этим причинам в языке Rust есть другой подход — использование типажных объектов вместо наследования. Давайте посмотрим, как типажные объекты обеспечивают полиморфизм в языке Rust.

Использование типажных объектов, допускающих значения разных типов

В главе 8 мы упоминали, что одним из ограничений векторов является то, что они могут хранить элементы только одного типа. В листинге 8.10 мы создали обходной путь, где определили перечисление SpreadsheetCell, которое имело варианты для хранения целых чисел, чисел с плавающей точкой и текста. Это означало, что мы могли хранить разные типы данных в каждой ячейке и при этом иметь вектор в виде серии ячеек. Это идеальное решение, когда взаимозаменяемые элементы представляют собой фиксированный набор типов, при которых код компилируется.