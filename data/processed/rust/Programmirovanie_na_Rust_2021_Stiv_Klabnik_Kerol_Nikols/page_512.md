---
source_image: page_512.png
page_number: 512
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 28.23
tokens: 7453
characters: 1694
timestamp: 2025-12-24T10:59:13.015380
finish_reason: stop
---

fn generic<T>(t: T) {
    // --пропуск--
}

На самом деле это определение рассматривается так, как будто мы написали вот это:

fn generic<T: Sized>(t: T) {
    // --пропуск--
}

По умолчанию обобщенные функции будут работать только с типами, размер которых известен во время компиляции. Однако для ослабления этого ограничения можно использовать специальный синтаксис:

fn generic<T: ?Sized>(t: &T) {
    // --пропуск--
}

Граница типажа для ?Sized противоположна границе типажа Sized: мы читаем это как «Т может быть, а может и не быть Sized». Этот синтаксис доступен только для Sized, а не для других типажей.

Также обратите внимание, что мы переключили тип параметра t с T на &T. Поскольку тип может и не быть Sized, нужно использовать его за каким-то указателем. В данном случае мы выбрали ссылку.

Далее мы поговорим о функциях и замыканиях.

Продвинутые функции и замыкания

Наконец мы познакомимся с несколькими эффективными языковыми средствами, связанными с функциями и замыканиями, которые включают указатели функций и возвращение замыканий.

Указатели функций

Мы уже говорили о том, как передавать замыкания в функции. Вы также можете передавать регулярные функции в функции! Этот технический прием полезен, когда нужно передать функцию, которую вы уже определили, а не определять новое замыкание. Его выполнение с указателями функций позволит использовать функции в качестве аргументов для других функций. Функции принудительно приводятся к типу fn (со строчной буквой f), не путать с типажом Fn замыкания. Тип fn называется указателем функции. Синтаксис, который описывает, что параметр является указателем функции, аналогичен синтаксису замыканий, как показано в листинге 19.27.