---
source_image: page_391.png
page_number: 391
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 34.25
tokens: 7635
characters: 2413
timestamp: 2025-12-24T10:56:06.643027
finish_reason: stop
---

ем borrow_mut для RefCell<Vec<String>> в self.sent_messages 3, чтобы получить изменяемую ссылку, указывающую на значение внутри RefCell<Vec<String>>, которое является вектором. Затем мы можем вызвать push для изменяемой ссылки, указывающей на вектор, чтобы отслеживать сообщения, отправляемые во время теста.

Последнее изменение, которое мы должны внести, расположено в проверочном утверждении: чтобы увидеть число элементов во внутреннем векторе, мы вызываем метод borrow для RefCell<Vec<String>>, получая неизменяемую ссылку на вектор 4.

Теперь вы знаете, как использовать умный указатель RefCell<T>. Давайте углубимся в принцип его работы!

Отслеживание заимствований во время выполнения с помощью RefCell<T>

При создании неизменяемых и изменяемых ссылок мы используем синтаксис & и &mut соответственно. С умным указателем RefCell<T> мы используем методы заимствования borrow и borrow_mut, являющиеся частью безопасного API, который принадлежит умному указателю RefCell<T>. Метод borrow возвращает тип умного указателя Ref<T>, а borrow_mut возвращает тип умного указателя RefMut<T>. Оба типа реализуют типаж Deref, поэтому мы можем рассматривать их как регулярные ссылки.

Умный указатель RefCell<T> отслеживает, сколько умных указателей Ref<T> и RefMut<T> активны в настоящий момент. Всякий раз, когда мы вызываем метод borrow, умный указатель RefCell<T> увеличивает число активных неизменяемых заимствований. Когда значение умного указателя Ref<T> выходит из области видимости, число неизменяемых заимствований уменьшается на единицу. Как и правила заимствования времени компиляции, умный указатель RefCell<T> позволяет в любой момент иметь много неизменяемых заимствований либо одно изменяемое заимствование.

Если мы попытаемся эти правила нарушить, то вместо ошибки компилятора, как это было бы со ссылками, реализация умного указателя RefCell<T> поднимет панику во время выполнения. Листинг 15.23 показывает модификацию реализации метода send из листинга 15.22. Мы намеренно пытаемся создать два изменяемых заимствования, активных для одной и той же области видимости, чтобы проиллюстрировать, что умный указатель RefCell<T> не позволяет нам делать это во время выполнения.

Листинг 15.23. Создание двух изменяемых ссылок в одной области видимости как иллюстрация того, что умный указатель RefCell<T> будет паниковать

src/lib.rs

impl Messenger for MockMessenger {
    fn send(&self, message: &str) {