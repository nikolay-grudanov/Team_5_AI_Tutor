---
source_image: page_114.png
page_number: 114
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 32.14
tokens: 7466
characters: 1933
timestamp: 2025-12-24T10:48:46.263267
finish_reason: stop
---

изменяемую ссылку, а это не получается. Язык Rust не только упростил использование API, но и устранил целый класс ошибок во время компиляции!

Строковые литералы — это срезы

Напомним, что мы говорили о строковых литералах, хранящихся внутри двоичного файла. Теперь, когда мы знаем о срезах, мы можем правильно понять строковые литералы:

    let s = "Hello, world!";

Тип переменной s здесь равен &str. Это срез, указывающий на конкретную точку двоичного файла. Именно поэтому строковые литералы являются неизменяемыми, &str — это неизменяемая ссылка.

Строковые срезы в качестве параметров

Знание о том, что можно брать срезы литералов и значений типа String, приводит к еще одному улучшению в функции first_word, к изменениям в его сигнатурае:

    fn first_word(s: &String) -> &str {

Более опытный растинанин написал бы сигнатуру, показанную в листинге 4.9, поскольку она позволяет использовать одну и ту же функцию для значений String и &str.

Листинг 4.9. Улучшение функции first_word с помощью строкового среза для типа параметра s

    fn first_word(s: &str) -> &str {

Если у нас есть строковый срез, то можно передать его напрямую. Если у нас есть значение типа String, то мы можем передать срез всего значения типа String. Определение функции для взятия строкового среза вместо ссылки на значение типа String делает API более общим и полезным без потери функциональности:

src/main.rs

    fn main() {
        let my_string = String::from("hello world");

        // first_word работает на срезах экземпляров типа `String`
        let word = first_word(&my_string[..]);

        let my_string_literal = "hello world";

        // first_word работает на срезах строковых литералов
        let word = first_word(&my_string_literal[..]);

        // Так как строковые литералы уже *являются* строковыми срезами,
        // это также работает без срезового синтаксиса!
        let word = first_word(my_string_literal);
    }