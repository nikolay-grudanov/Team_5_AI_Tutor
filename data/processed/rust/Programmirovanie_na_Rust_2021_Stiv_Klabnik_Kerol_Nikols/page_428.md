---
source_image: page_428.png
page_number: 428
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 36.74
tokens: 7586
characters: 2273
timestamp: 2025-12-24T10:57:05.674001
finish_reason: stop
---

Этот код выведет следующее:

Результат: 10

У нас получилось! Мы подсчитали числа от 0 до 10, что само по себе выглядит не очень впечатляюще, но это действительно дало нам много информации о Mutex<T> и безопасности потоков. Вы также могли бы использовать структуру этой программы для выполнения более сложных операций, чем просто увеличение подсчета. Используя эту стратегию, вы можете разделить вычисление на независимые части, которые можно разложить по потокам, а затем использовать тип Mutex<T> так, чтобы каждый поток обновлял конечный результат своей частью.

Сходства между RefCell<T>/Rc<T> и Mutex<T>/Arc<T>

Возможно, вы заметили, что переменная counter неизменяемая, но мы можем получить изменяемую ссылку на значение внутри нее. Это означает, что тип Mutex<T> обеспечивает внутреннюю изменяемость, как и семейство Cell. Мы используем тип Mutex<T>, чтобы изменять содержимое внутри типа Arc<T>, точно так же как мы использовали тип RefCell<T> в главе 15, который позволял нам изменять содержимое внутри типа Rc<T>.

Следует отметить еще одну деталь — Rust не может защитить вас от всех видов логических ошибок, когда вы используете тип Mutex<T>. Вспомните из главы 15, что использование типа Rc<T> сопряжено с риском создания циклов в переходах по ссылкам, где два значения типа Rc<T> ссылаются друг на друга, вызывая утечку памяти. Схожим образом тип Mutex<T> связан с риском создания взаимоблокировок (deadlock). Это происходит, когда операции требуется запереть два ресурса на замок, а оба потока получают один из замков, вследствие чего они ожидают друг друга. Если вас интересуют взаимоблокировки, попробуйте создать программу Rust с взаимоблокировкой. Затем изучите, как избежать взаимоблокировок для мьютексов в любом языке и попробуйте реализовать их в Rust. Документация об API стандартной библиотеки по темам Mutex<T> и MutexGuard предлагает полезную информацию.

Мы завершим эту главу рассказом о типажах Send и Sync и о том, как их использовать с настраиваемыми типами.

Расширяемая конкурентность с типажами Send и Sync

Интересно, что в Rust очень мало средств конкурентности. Почти все средства, о которых мы говорили в этой главе, были частью стандартной библиотеки, а не самого языка. Ваши варианты работы с конкурентностью не ограничиваются язы-