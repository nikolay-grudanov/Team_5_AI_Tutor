---
source_image: page_209.png
page_number: 209
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 29.67
tokens: 7547
characters: 2124
timestamp: 2025-12-24T10:51:12.105488
finish_reason: stop
---

с этим требованием, то такая проверка в каждой функции была бы утомительной (и могла бы повлиять на производительность).

Вместо повторных проверок всего кода мы можем создать новый тип и поместить проверки на допустимость в функцию, создав экземпляр типа. Благодаря этому функции будут безопасно использовать новый тип в своих сигнатаурах и уверенно применять получаемые ими значения. Листинг 9.10 показывает один из способов определения типа Guess, который будет создавать экземпляр типа Guess только в том случае, если новая функция получает значение между 1 и 100.

Листинг 9.10. Тип Guess, который продолжит работу только со значениями между 1 и 100

pub struct Guess {
    value: i32,
}

impl Guess {
    pub fn new(value: i32) -> Guess {
        if value < 1 || value > 100 {
            panic!("Значение догадки должно быть между 1 и 100, получено {}.", value);
        }
        Guess {
            value
        }
    }

    pub fn value(&self) -> i32 {
        self.value
    }
}

Сначала мы определяем структуру под названием Guess, имеющую поле с именем value, которое содержит значение типа i32 ①. Именно тут будет храниться число.

Затем мы реализуем связанную функцию new в структуре Guess, которая создает экземпляры значений типа Guess ②. new определяется как функция, имеющая один параметр value типа i32 и возвращающая тип Guess. Код в теле функции new проверяет параметр value, убеждаясь, что он находится между 1 и 100 ③. Если параметр value этот тест не проходит, то мы делаем вызов макрокоманды panic! ④, которая будет оповещать программиста, пишущего вызывающий код, о том, что у него есть дефект, который необходимо устранить, потому что создание экземпляра типа Guess со значением вне этого интервала нарушит контракт, на который полагается функция Guess::new. Условия, при которых функция Guess::new, возможно, будет паниковать, должны обсуждаться в документации к ее публичному API. В главе 14 мы рассмотрим документационные соглашения, указывающие на возможность вызова макрокоманды panic! в создаваемой вами документации API. Если параметр value тест не проходит, то мы создаем новый экземпляр