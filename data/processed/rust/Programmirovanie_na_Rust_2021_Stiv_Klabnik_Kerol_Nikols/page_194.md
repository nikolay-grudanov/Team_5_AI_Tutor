---
source_image: page_194.png
page_number: 194
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 35.34
tokens: 7626
characters: 2355
timestamp: 2025-12-24T10:50:55.107311
finish_reason: stop
---

at libstd/rt.rs:59
    at libstd/panicking.rs:310
15: macho_symbol_search
    at libpanic_unwind/lib.rs:102
16: std::alloc::default_alloc_error_hook
    at libstd/panicking.rs:289
    at libstd/panic.rs:392
    at libstd/rt.rs:58
17: std::rt::lang_start
    at libstd/rt.rs:74
18: panic::main

Уж очень длинный результат! Точный результат, который вы увидите, возможно, будет отличаться в зависимости от вашей операционной системы и версии Rust. Для получения обратных трассировок с этой информацией необходимо использовать отладочные символы. Отладочные символы задействуются по умолчанию при использовании команды cargo build или cargo run без флага --release, как у нас здесь.

Строка 12 обратной трассировки в листинге 9.2 указывает на строку кода в проекте, которая служит причиной проблемы, — строку 4 файла src/main.rs. Если мы не хотим, чтобы программа поднимала панику, то место, на которое указывает первая строка, упоминающая написанный нами файл, является местом, откуда мы должны начать расследование. В листинге 9.1, где мы намеренно написали код, который будет вызывать панику, чтобы продемонстрировать использование обратных трассировок, способ устранить панику состоит в том, чтобы не запрашивать элемент с индексом 99 из вектора, который содержит только три элемента. Когда код будет поднимать панику в будущем, вам нужно будет выяснить, какие действия и с какими значениями выполняет код, которые в итоге становятся причиной паники, и что код должен вместо этого делать.

Мы еще вернемся к макрокоманде panic! и к вопросу о том, когда следует, а когда не следует использовать макрокоманду panic! для обработки условий ошибки, в разделе «Паниковать! Или не паниковать». Далее мы посмотрим, как восстанавливать работу после ошибки с помощью Result.

Устранимые ошибки с помощью Result

Большинство ошибок не настолько серьезны, чтобы требовать полной остановки программы. Порой, когда функция не срабатывает, это происходит по причине, которую можно легко объяснить и на которую можно отреагировать. Например, если вы попытаетесь открыть файл, а операция завершится безуспешно, так как файл не существует, то вместо окончания процесса вы можете создать файл.

Напомним из раздела «Обработка потенциального сбоя с помощью типа Result» (с. 45), что Result определяется как перечисление, имеющее два варианта — Ok и Err, — следующим образом: