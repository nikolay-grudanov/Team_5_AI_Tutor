---
source_image: page_416.png
page_number: 416
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 33.49
tokens: 7522
characters: 2097
timestamp: 2025-12-24T10:56:46.021386
finish_reason: stop
---

Принимающий конец канала имеет два полезных метода: recv и try_recv. Мы используем метод recv, сокращенно от англ. receive, который блокирует выполнение главного потока исполнения и ждет до тех пор, пока значение не будет отправлено вниз по каналу. Как только значение будет отправлено, метод recv вернет его в экземпляре типа Result<T, E>. Когда передающий конец канала закроется, метод recv вернет ошибку, сигнализирующую о том, что больше никаких значений не будет.

Метод try_recv не блокирует, а вместо этого сразу возвращает экземпляр типа Result<T, E>: значение Ok, содержащее сообщение, если оно имеется, и значение Err, если на этот раз никаких сообщений нет. Метод try_recv полезен, если у потока во время ожидания сообщений есть другие задачи. Мы могли бы написать цикл, который регулярно вызывает метод try_recv, обрабатывает сообщение, если оно имеется, а в противном случае некоторое время выполняет другую работу до тех пор, пока не проверит снова.

В данном примере мы использовали метод recv, поскольку он простой; главный поток должен только ожидать сообщения, поэтому блокировка главного потока исполнения уместна.

Когда мы выполним код из листинга 16.8, то увидим значение, выведенное из главного потока исполнения:

Получено: привет

Идеально!

Каналы и передача владения

Правила владения играют важную роль в отправке сообщений, поскольку помогают писать безопасный конкурентный код. Благодаря владению во всех программах на языке Rust у вас есть преимущество — вы можете предотвращать ошибки в конкурентном программировании. Давайте проведем эксперимент, чтобы показать, как каналы и владение работают вместе и предотвращают проблемы. Мы попробуем использовать значение переменной val в порожденном потоке исполнения после того, как отправили его по каналу. Попробуйте скомпилировать код из листинга 16.9, чтобы увидеть, почему этот код не выполняется.

Листинг 16.9. Попытка использовать переменную val после того, как мы отправили ее по каналу
src/main.rs
use std::thread;
use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();
    thread::spawn(move || {