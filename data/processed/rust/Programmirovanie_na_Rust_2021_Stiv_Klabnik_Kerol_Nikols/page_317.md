---
source_image: page_317.png
page_number: 317
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 40.70
tokens: 7631
characters: 2302
timestamp: 2025-12-24T10:54:10.521640
finish_reason: stop
---

expensive_closure(intensity)
    );
}
}
}

Теперь затратное вычисление вызывается только в одном месте, и мы выполняем этот код только там, где нужны результаты.

Однако мы вновь ввели одну из проблем из листинга 13.3: мы по-прежнему вызываем замыкание дважды в первом блоке if, который вызовет затратный код дважды и будет заставлять пользователя ждать вдвое дольше, чем нужно. Мы могли бы решить эту проблему, создав локальную для блока if переменную, которая будет содержать результат вызова замыкания. Но замыкание предоставляет нам другое решение. Мы вскоре поговорим о нем. Но сначала давайте разберемся, почему нет аннотаций типов в определении замыкания и типажей, связанных с замыканиями.

Логический вывод типа и аннотация замыкания

Замыкания не требуют аннотирования типов параметров или возвращаемого значения, как это делают функции fn. Аннотации типов являются обязательными для функций, потому что это часть интерфейса, демонстрируемого пользователям. Строгое определение этого интерфейса важно для проверки, что все согласны с тем, какие типы значений функция использует и возвращает. Но замыкания не применяются в таком публичном интерфейсе, как этот: они хранятся в переменных и используются без именования и демонстрации пользователям библиотеки.

Замыкания обычно бывают короткими и релевантными только в узком контексте, а не в любом произвольном сценарии. Внутри таких лимитированных контекстов компилятор способен надежно логически выводить типы параметров и возвращаемый тип, подобно тому, как он может определять типы большинства переменных.

Аннотировать типы в этих малых анонимных функциях будет для программистов надоедливой работой и в значительной степени избыточной с учетом информации, которая у компилятора уже есть.

Как и в случае с переменными, мы можем добавлять аннотации типов, если хотим повысить явную выраженность и ясность за счет большей детализации, чем это необходимо. Аннотирование типов для замыкания, которое мы определили в листинге 13.5, будет выглядеть так же, как определение в листинге 13.7.

Листинг 13.7. Добавление необязательных аннотаций типов параметров и возвращаемых значений в замыкание
src/main.rs
let expensive_closure = |num: u32| -> u32 {
    println!("вычисляется медленно...");
    thread::sleep(Duration::from_secs(2));
    num
};