---
source_image: page_462.png
page_number: 462
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 39.03
tokens: 7645
characters: 2150
timestamp: 2025-12-24T10:58:03.051166
finish_reason: stop
---

Код из листинга 18.3 выводит следующее:

    а находится в индексе 0
    b находится в индексе 1
    с находится в индексе 2

Мы используем метод enumerate, чтобы переделать итератор для порождения значения и индекса этого значения в итераторе, помещенных в кортеж. Первый вызов метода enumerate порождает кортеж (0, 'a'). Когда это значение сочетается с паттерном (index, value), то index равен 0, а value равно 'a', выводится первая строка данных.

Инструкции let

До этой главы мы прямо обсуждали использование паттернов только с выражениями match и if let, но на самом деле мы использовали паттерны и в других местах, в том числе в инструкциях let. Рассмотрим простую передачу значения переменной с помощью let:

    let x = 5;

На протяжении всей книги мы сотни раз использовали инструкции let подобного рода, и хотя вы, возможно, не осознавали этого, вы использовали паттерны! В более формальном плане инструкция let выглядит так:

    let ПАТТЕРН = ВЫРАЖЕНИЕ;

В таких инструкциях, как let x = 5; , с именем переменной в слоте ПАТТЕРН, имя переменной — это всего лишь простая форма паттерна. Rust сравнивает выражение с паттерном и назначает любые имена, которые он находит. Поэтому в примере let x = 5; паттерном является x, который означает «связать то, что совпадает здесь, с переменной x». Поскольку имя x представляет весь паттерн, то этот паттерн фактически означает «связать все с переменной x, каким бы ни было значение».

Чтобы четче увидеть сопоставление с паттерном инструкции let, рассмотрим листинг 18.4, который использует паттерн с let для деструктурирования кортежа.

Листинг 18.4. Использование паттерна для деструктурирования кортежа и создания сразу трех переменных

    let (x, y, z) = (1, 2, 3);

Здесь мы сопоставляем кортеж с паттерном. Rust сравнивает (1, 2, 3) с (x, y, z) и видит, что это значение совпадает с паттерном, поэтому Rust связывает 1 с x, 2 с y и 3 с z. Можно думать об этом кортежном паттерне как о вложении в него трех отдельных паттернов переменных.

Если число элементов в паттерне не совпадает с числом элементов в кортеже, то совокупный тип не будет совпадать и мы получим ошибку компилятора. Напри-