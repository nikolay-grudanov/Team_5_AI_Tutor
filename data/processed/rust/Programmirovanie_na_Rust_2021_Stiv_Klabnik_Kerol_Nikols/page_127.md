---
source_image: page_127.png
page_number: 127
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 36.18
tokens: 7609
characters: 2428
timestamp: 2025-12-24T10:49:06.783230
finish_reason: stop
---

1 impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }
}

fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };

    println!(
        "Площадь прямоугольника равна {} квадратным пикселам.",
        rect1.area()
    );
}

Для того чтобы определить функцию внутри контекста структуры Rectangle, мы начинаем блок impl (реализация) ①. Затем переносим функцию area в фигурные скобки impl ② и изменяем первый (и в этом случае единственный) параметр на параметр self в сигнатуре и в теле. В функции main, где мы вызывали функцию area и передавали rect1 в качестве аргумента, мы вместо этого используем синтаксис вызова метода area для экземпляра структуры Rectangle ③. Синтаксис вызова метода идет после экземпляра: мы добавляем точку с последующим именем метода, скобками и любыми аргументами.

В сигнатуре для функции area мы используем &self вместо rectangle: &Rectangle, потому что язык Rust знает, что типом параметра self является Rectangle, поскольку этот метод находится внутри контекста impl Rectangle. Обратите внимание, что нам по-прежнему нужно использовать & перед параметром self, так же, как мы делали в &Rectangle. Методы могут брать self во владение, заимствовать параметр self неизменяемо, как мы это сделали, либо заимствовать параметр self изменяемо, как и любой другой параметр.

Мы выбрали &self по той же причине, по которой использовали &Rectangle в функциональной версии. Мы не хотим владеть, нужно просто читать данные в структуре, а не писать их. Если бы мы хотели изменить экземпляр, в котором вызвали метод, в рамках того, что этот метод делает, то в качестве первого параметра использовали бы &mut self. Метод, который берет экземпляр во владение, используя в качестве первого параметра только параметр self, встречается редко. Этот технический прием обычно используется, когда метод трансформирует параметр self во что-то другое, и вы хотите запретить вызывающей его стороне использовать исходный экземпляр после этой трансформации.

Главное преимущество использования методов вместо функций, помимо применения синтаксиса методов и отсутствия необходимости повторять тип параметра self в сигнатуре каждого метода, заключается в организации. Мы поместили все, что можем сделать с экземпляром типа в один блок impl вместо того, чтобы заставлять будущих пользователей кода искать возможности структуры Rectangle в различных местах библиотеки, которая есть в языке.