---
source_image: page_310.png
page_number: 310
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 21.05
tokens: 7278
characters: 1265
timestamp: 2025-12-24T10:53:45.457760
finish_reason: stop
---

Теперь мы видим ошибку на экране, а файл output.txt ничего не содержит, что и является ожидаемым поведением программ командной строки.

Давайте снова выполним программу, теперь уже с аргументами, которые не являются причиной ошибки, но все-таки перенаправляют стандартный вывод данных в файл, как тут:

    $ cargo run to poem.txt > output.txt

Мы не увидим данных в терминале, а файл output.txt будет содержать результаты:

output.txt
    Are you nobody, too?
    How dreary to be somebody!

Это показывает, что теперь мы используем стандартный вывод данных для вывода успешных данных и стандартный вывод ошибок для вывода ошибок сообразно обстоятельствам.

Итоги

Мы свели воедино основные уже изученные идеи, а также всесторонне описали принцип работы операций ввода-вывода, часто встречающихся в Rust. Применяя аргументы командной строки, файлы, переменные среды и макрокоманду eprintln! для вывода ошибок, теперь вы готовы писать приложения командной строки. Используя идеи, описанные в предыдущих главах, вы сможете хорошо организовать код, проверить его, эффективно хранить данные в соответствующих структурах данных и обрабатывать ошибки.

Далее мы рассмотрим некоторые средства Rust, на которые оказали влияние функциональные языки — замыкания и итераторы.