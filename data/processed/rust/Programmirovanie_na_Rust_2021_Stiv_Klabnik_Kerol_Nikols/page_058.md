---
source_image: page_058.png
page_number: 58
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 34.67
tokens: 7567
characters: 2265
timestamp: 2025-12-24T10:47:17.701146
finish_reason: stop
---

Обработка ввода недопустимых данных

Чтобы уточнить, как поведет себя игра, вместо аварийного завершения программы, когда пользователь вводит нечисловое значение, давайте сделаем так, чтобы игра игнорировала нечисловое значение, предоставив пользователю возможность продолжить угадывать. Мы можем сделать это, изменяя строку кода, в которой переменная guess конвертируется из типа String в тип u32, как показано в листинге 2.5.

Листинг 2.5. Игнорирование нечислового загаданного числа и запрос следующего загаданного числа вместо аварийного завершения программы

src/main.rs

```rust
// --пропуск--

io::stdin().read_line(&mut guess)
    .expect("Не получилось прочитать строку");

let guess: u32 = match guess.trim().parse() {
    Ok(num) => num,
    Err(_) => continue,
};

println!("Вы загадали: {}", guess);

// --пропуск--
```

Переключаясь с вызова метода expect на выражение match, вы применяете способ, который обычно используется для перехода от аварийного завершения программы к обработке ошибки. Помните, что метод parse возвращает тип Result, а Result — это перечисление, имеющее варианты Ok или Err. Здесь мы используем выражение match, как и в случае с результатом типа Ordering метода cmp.

Если метод parse в состоянии успешно превратить строку в число, то он вернет значение Ok, содержащее результирующее число. Это значение Ok совпадет с паттерном первого рукава, а выражение match просто вернет значение num, которое метод parse произвел и поместил внутрь значения Ok. Это число окажется именно там, где мы хотим, в новой создаваемой нами переменной guess.

Если метод parse не в состоянии превратить строку в число, то он возвращает значение Err, содержащее дополнительную информацию об ошибке. Значение Err не совпадает с паттерном Ok(num) в первом рукаве выражения match, но оно совпадает с паттерном Err(_) во втором рукаве. Подчеркивание _ является всеохватывающим значением. В данном примере мы хотим, чтобы совпали все значения Err, независимо от того, какая информация у них внутри. Поэтому программа выполнит код второго рукава continue, который говорит программе перейти к следующей итерации цикла и запросить еще одно загаданное число. Таким образом, по сути, программа игнорирует все ошибки, с которыми может столкнуться метод parse!