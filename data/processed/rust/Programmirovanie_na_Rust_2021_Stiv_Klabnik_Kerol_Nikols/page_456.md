---
source_image: page_456.png
page_number: 456
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 34.64
tokens: 7546
characters: 2109
timestamp: 2025-12-24T10:57:50.943859
finish_reason: stop
---

держимое черновика и поста, ожидающего проверки, является пустыми строками, вместе с тем они нам и не нужны. Больше нельзя компилировать код, который пытается использовать содержимое постов в этих состояниях. Обновленный код в функции main показан в листинге 17.21.

Листинг 17.21. Изменения в функции main для новой реализации процесса создания поста

src/main.rs
use blog::Post;

fn main() {
    let mut post = Post::new();

    post.add_text("Сегодня на обед я ел салат");

    let post = post.request_review();

    let post = post.approve();

    assert_eq!("Сегодня на обед я ел салат", post.content());
}

Изменения, которые нужно было внести в функцию main для переназначения переменной post, означают, что эта реализация больше не соответствует объектно-ориентированному паттерну переходов между состояниями в полной мере. Трансформации между состояниями больше не инкапсулируются полностью в структуре Post. Однако преимущество заключается в том, что недопустимые состояния теперь невозможны из-за системы типов и их проверки, которая происходит во время компиляции! Благодаря этому некоторые дефекты, такие как показ содержимого неопубликованного поста, будут обнаружены до того, как попадут в продакшен.

Опробуйте предложенные задачи о дополнительных требованиях, которые мы упомянули в начале этого раздела об упаковке blog после листинга 17.20, и оцените дизайн этой версии кода. Обратите внимание, что некоторые задачи могли бы быть выполнены уже в таком дизайне.

Мы видели, что даже если в Rust применимы объектно-ориентированные паттерны проектирования, другие паттерны, такие как кодирование состояния в систему типов, также в нем доступны. У этих паттернов разные преимущества. Хотя вы, возможно, хорошо знакомы с объектно-ориентированными паттернами, все-таки посмотрите на задачи с другой стороны и воспользуйтесь преимуществами средств Rust, благодаря которым, к примеру, можно предотвратить некоторые дефекты во время компиляции. Объектно-ориентированные паттерны не всегда будут лучшим решением в Rust из-за таких средств, как владение, которых нет в объектно-ориентированных языках.