---
source_image: page_219.png
page_number: 219
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 32.93
tokens: 7516
characters: 2080
timestamp: 2025-12-24T10:51:33.458094
finish_reason: stop
---

let both_integer = Point { x: 5, y: 10 };
let both_float = Point { x: 1.0, y: 4.0 };
let integer_and_float = Point { x: 5, y: 4.0 };
}

Теперь все приведенные выше экземпляры структуры Point разрешены! Вы можете использовать в определении столько параметров обобщенного типа, сколько захотите, но использование более одного-двух параметров затрудняет чтение кода. Если в коде требуется много обобщенных типов, то это означает, что код нуждается в реструктуризации на меньшие части.

В определениях перечислений

Как и в случае со структурами, мы можем определять перечисления, которые содержат в своих вариантах обобщенные типы данных. Давайте еще раз взглянем на перечисление Option<T>, предоставляемое стандартной библиотекой, которое мы использовали в главе 6:

enum Option<T> {
    Some(T),
    None,
}

Теперь это определение должно иметь больше смысла. Как вы видите, перечисление Option<T> является обобщением над типом T и имеет два варианта: Some, который содержит одно значение типа T, и None, который не содержит никакого значения. Используя перечисление Option<T>, мы можем выражать абстрактную идею наличия необязательного значения, а поскольку Option<T> является обобщением, можно использовать эту абстракцию независимо от типа варианта значения.

Перечисления также могут использовать более одного обобщенного типа. Определение перечисления Result, которое мы использовали в главе 9, является одним из таких примеров:

enum Result<T, E> {
    Ok(T),
    Err(E),
}

Перечисление Result является обобщением двух типов — T и E. У него два варианта: Ok, который содержит значение типа T, и Err, который содержит значение типа E. Это определение позволяет удобно использовать перечисление Result везде, где есть операция, которая может быть успешной (возвращать значение некоторого типа T) или неуспешной (возвращать ошибку некоторого типа E). По сути дела, это то, что мы использовали для открытия файла в листинге 9.3, где T заполнялся типом std::fs::File, когда файл успешно открывался, а E заполнялся типом std::io::Error, когда возникали проблемы с открытием файла.