---
source_image: page_240.png
page_number: 240
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 37.03
tokens: 7709
characters: 2606
timestamp: 2025-12-24T10:52:10.539928
finish_reason: stop
---

### Аннотации жизненных циклов в сигналах функций

Теперь давайте рассмотрим аннотации жизненных циклов в контексте функции longest. Как и в случае с параметрами обобщенных типов, нужно объявить параметры обобщенных жизненных циклов внутри угловых скобок, между именем функции и списком параметров. В этой сигнатурае мы хотим выразить ограничение, которое заключается в том, что все ссылки в параметрах и возвращаемое значение должны иметь одинаковый жизненный цикл. Мы дадим жизненному циклу имя 'а и затем добавим его в каждую ссылку, как показано в листинге 10.22.

**Листинг 10.22. Определение функции longest, описывающее, что все ссылки в сигнатуре должны иметь одинаковый жизненный цикл 'а**

src/main.rs

```rust
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```

Этот код должен компилироваться и производить желаемый результат, когда мы используем его внутри функции main в листинге 10.20.

Сигнатаура функции теперь сообщает Rust о том, что для некоторого жизненного цикла 'а функция берет два параметра, оба они являются строковыми срезами, живущими, по крайней мере, в течение жизненного цикла 'а. Сигнатаура функции также говорит о том, что возвращаемый из функции строковый срез будет жить, по крайней мере, в течение жизненного цикла 'а. Мы хотим, чтобы Rust обеспечил соблюдение именно этих ограничений. Помните, что, когда мы описываем параметры жизненных циклов в этой сигнатуре функции, мы не изменяем жизненный цикл каких-либо передаваемых или возвращаемых значений. Наоборот, мы описываем, что контролер заимствования должен отклонять любые значения, которые не соответствуют этим ограничениям. Обратите внимание, что функции longest не нужно знать точную протяженность жизни х и у, а только то, что некая область может быть заменена на 'а, которая будет удовлетворять этой сигнатуре.

Во время аннотирования жизненных циклов в функциях аннотации находятся в сигнатуре функции, а не в теле функции. Rust может анализировать код внутри функции без какой-либо помощи. Но когда у функции есть ссылки на код или ссылки из кода вне этой функции, компилятору становится почти невозможным выяснить жизненный цикл параметров или возвращаемых значений самостоятельно. Всякий раз, когда функция вызывается, жизненные циклы могут быть разными. Вот почему нужно аннотировать жизненный цикл вручную.

Когда мы передаем конкретные ссылки в функцию longest, конкретный жизненный цикл, подставляемый вместо 'а, является частью области видимости х, которая частично совпадает с областью у. Другими словами, обобщенный жизненный