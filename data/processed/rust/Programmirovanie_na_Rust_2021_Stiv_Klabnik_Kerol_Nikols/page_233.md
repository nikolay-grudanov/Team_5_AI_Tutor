---
source_image: page_233.png
page_number: 233
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 30.02
tokens: 7470
characters: 1872
timestamp: 2025-12-24T10:51:53.023219
finish_reason: stop
---

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&number_list);
    println!("Наибольшее число равно {}", result);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&char_list);
    println!("Наибольший символ равен {}", result);
}

Если мы не хотим ограничивать функцию largest типами, которые реализуют типаж Copy, можно уточнить, что у T есть граница типажа Clone вместо Copy. Тогда мы могли бы клонировать каждое значение в срезе, чтобы функция largest могла иметь владение. Использование функции clone означает, что в случае с типами, которые владеют данными кучи, такими как String, потенциально выполняется больше операций выделения памяти в куче, и такое выделение будет медленным, если мы работаем с крупными объемами данных.

Еще один способ, которым мы могли бы реализовать функцию largest, заключается в том, чтобы указанная функция возвращала ссылку на значение T в срезе. Если мы заменим тип возвращаемого значения с T на &T, тем самым изменив тело функции так, чтобы она возвращала ссылку, то нам не понадобятся границы типа Clone или Copy, и мы сможем избежать выделения памяти в куче. Попробуйте реализовать эти альтернативные решения самостоятельно!

Использование границ типажа для условной реализации методов

Используя типаж с блоком impl, который применяет параметры обобщенного типа, мы можем условно реализовать методы для типов, реализующие перечисленные типажи. Например, тип Pair<T> в листинге 10.16 всегда реализует функцию new. Но Pair<T> реализует метод cmp_display только в том случае, если его внутренний тип T реализует типаж PartialOrd, позволяющий сравнивать, и типаж Display, позволяющий печатать.

Листинг 10.16. Условная реализация методов для обобщенного типа в зависимости от границ типажа
use std::fmt::Display;

struct Pair<T> {
    x: T,
    y: T,
}

impl<T> Pair<T> {