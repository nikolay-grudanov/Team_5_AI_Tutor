---
source_image: page_161.png
page_number: 161
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 31.71
tokens: 7466
characters: 1762
timestamp: 2025-12-24T10:49:57.047762
finish_reason: stop
---

    add_to_waitlist();
    add_to_waitlist();
}

Хотя оба листинга — 7.11 и 7.13 — выполняют одну и ту же задачу, листинг 7.11 является идиоматическим способом введения функции в область видимости с помощью use. Введение родительского модуля функции в область видимости с помощью use так, что нам приходится указывать родительский модуль при вызове функции, дает понять, что указанная функция не определена локально, но при этом минимизирует повторы полного пути. Код в листинге 7.13 неясен относительно того, где определена функция add_to_waitlist.

С другой стороны, при введении структур, перечислений и других элементов с помощью use, идиоматический способ состоит в указании полного пути. В листинге 7.14 показан идиоматический способ введения структуры HashMap стандартной библиотеки в область двоичной упаковки.

Листинг 7.14. Введение структуры HashMap в область видимости идиоматическим способом
src/main.rs

use std::collections::HashMap;

fn main() {
    let mut map = HashMap::new();
    map.insert(1, 2);
}

Эта идиома не имеет никакой серьезной причины, это просто возникшая условность, и люди привыкли читать и писать код на Rust таким образом.

Исключение из этой идиомы возникает, если мы вводим в область видимости два элемента с одинаковым именем с помощью инструкций use, потому что язык Rust не разрешает это делать. В листинге 7.15 показано, как ввести в область видимости два типа Result, у которых одинаковые имена, но разные родительские модули, и как на них ссылаться.

Листинг 7.15. Введение двух типов с одинаковыми именами в одну область требует использования их родительских модулей
src/lib.rs

use std::fmt;
use std::io;

fn function1() -> fmt::Result {
    // --пропуск--
}

fn function2() -> io::Result<()> {
    // --пропуск--
}