---
source_image: page_214.png
page_number: 214
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 32.57
tokens: 7494
characters: 1923
timestamp: 2025-12-24T10:51:25.883673
finish_reason: stop
---

println!("Наибольшее число равно {}", result);

let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

let result = largest(&number_list);
println!("Наибольшее число равно {}", result);
}

Функция largest имеет параметр list, представляющий любой конкретный срез значений типа i32, которые можно передать в функцию. В результате, когда мы вызываем функцию, указанный код выполняется для конкретных значений, которые мы передаем внутрь.

В общем случае вот шаги, которые мы предприняли, чтобы изменить код из листинга 10.2 на код в листинге 10.3:

1. Выявить повторяющийся код.
2. Извлечь повторяющийся код в тело функции и указать входные данные и возвращаемые значения этого кода в сигнатуру функции.
3. Обновить два экземпляра повторяющегося кода так, чтобы они вызывали функцию.

Далее мы предпримем те же самые шаги с обобщениями, чтобы сократить повторяющийся код другими способами. Обобщения позволяют коду производить операции над абстрактными типами точно так же, как тело функции способно производить операции над абстрактным списком вместо конкретных значений.

Допустим, у нас есть две функции: одна отыскивает наибольший элемент в срезе значений типа i32, а другая ищет наибольший элемент в срезе значений типа char. Как нам устранить этот повтор? Давайте выясним!

Обобщенные типы данных

Мы можем использовать обобщения для создания определений таких элементов, как сигнатуры функций или структуры, которые затем могут использоваться с разными конкретными типами данных. Давайте сначала посмотрим на способы определения функций, структур, перечислений и методов с использованием обобщений. Затем мы обсудим вопрос влияния обобщений на производительность кода.

В определениях функций

Во время определения функции, которая использует обобщения, мы помещаем обобщения в сигнатуру функции, где обычно указываем типы параметров и возвращаемое значение. Это делает код более гибким и обеспечивает большей функ-