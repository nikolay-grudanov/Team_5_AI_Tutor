---
source_image: page_373.png
page_number: 373
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 32.31
tokens: 7566
characters: 2138
timestamp: 2025-12-24T10:55:36.482780
finish_reason: stop
---

треннный стандартной библиотекой, требует реализации одного метода с именем deref, который заимствует self и возвращает ссылку на внутренние данные. Листинг 15.10 содержит реализацию типажа Deref, добавляемую в определение типа MyBox.

Листинг 15.10. Реализация типажа Deref в типе MyBox<T>
src/main.rs
use std::ops::Deref;

impl<T> Deref for MyBox<T> {
    type Target = T;

    fn deref(&self) -> &T {
        &self.0
    }
}

Синтаксис type Target = T; ① определяет связанный тип, который используется типажом Deref. Связанные типы — это несколько иной способ объявления обобщенного параметра, но сейчас вам не нужно думать о них, мы подробнее рассмотрим эти типы в главе 19.

Мы заполняем тело метода deref, используя &self.0, в результате чего deref возвращает ссылку на значение, к которому мы хотим обратиться с помощью оператора * ②. Функция main в листинге 15.9, которая вызывает * для значения типа MyBox<T>, теперь компилируется, и проверочные утверждения проходят успешно!

Без типажа Deref компилятор может применять оператор разыменования * только к ссылкам &. Метод deref наделяет компилятор способностью брать значение любого типа, который реализует типаж Deref, и вызывать метод deref, чтобы получить ссылку &, по которой можно пройти к существующему значению.

Когда мы ввели *у в листинге 15.9, компилятор фактически выполнил этот код:

*(y.deref())

Язык Rust заменяет оператор * вызовом метода deref, а затем просто следует по ссылке к существующему значению, и поэтому нам не приходится вызывать метод deref. Это средство языка Rust позволяет писать код, который функционирует одинаково независимо от того, что у нас есть: регулярная ссылка либо тип, который реализует Deref.

Из-за системы владения метод deref возвращает ссылку на значение, и по-прежнему нужно просто идти по ссылке к существующему значению вне скобок в *(y.deref()). Если бы метод deref возвращал вместо ссылки на значение непосредственно само значение, то это значение было бы перемещено из self. Мы не хотим брать во владение внутреннее значение MyBox<T> в данном случае, да и в большинстве случаев, когда используется оператор разыменования *.