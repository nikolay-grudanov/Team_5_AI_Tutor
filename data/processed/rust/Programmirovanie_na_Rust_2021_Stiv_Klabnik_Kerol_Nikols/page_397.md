---
source_image: page_397.png
page_number: 397
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 37.54
tokens: 7599
characters: 2245
timestamp: 2025-12-24T10:56:20.010643
finish_reason: stop
---

Рис. 15.4. Цикл в переходах по ссылкам в списках а и b, которые указывают друг на друга

В этом случае сразу после того, как мы создадим цикл в переходах по ссылкам, программа завершится. Последствия этого цикла не очень страшны. Однако, если бы более сложная программа выделяла много памяти в цикле и удерживала ее в течение длительного времени, то программа использовала бы больше памяти, чем нужно, и могла бы переполнить систему, приведя к исчерпанию доступной памяти.

Создавать циклы в переходах по ссылкам не так просто, но реально. Если у вас есть значения умного указателя RefCell<T>, которые содержат значения Rc<T> или схожие вложенные сочетания типов с внутренней изменяемостью и подсчетом числа ссылок, то вы должны убедиться, что не создаете циклы. Нельзя рассчитывать, что компилятор их выявит. Создание цикла в переходах по ссылкам в программе было бы логической ошибкой, которую следует минимизировать с помощью автотестов, ревизий кода и других практик разработки ПО.

Можно избежать циклов в переходах по ссылкам, если реорганизовать структуры данных таким образом, чтобы некоторые ссылки выражали владение, а некоторые — нет. Как результат, циклы будут состоять из нескольких связей владения и нескольких связей отсутствия владения. Только связи владения влияют на то, может ли значение быть отброшено. В листинге 15.25 мы хотим, чтобы варианты Cons всегда владели своим списком, и поэтому реорганизация структуры данных невозможна. Давайте рассмотрим пример с графами, состоящими из родительских и дочерних узлов, и выясним, когда связи отсутствия владения подходят для предотвращения циклов в переходах по ссылкам.

Предотвращение циклов в переходах по ссылкам: превращение Rc<T> в Weak<T>

Вы видели, что вызов функции Rc::clone увеличивает число strong_count экземпляра Rc<T>, а экземпляр Rc<T> очищается только в том случае, если его число strong_count равно 0. Вы также можете создавать слабую ссылку на значение внутри экземпляра Rc<T> путем вызова функции Rc::downgrade и передачи ссылки на Rc<T>. Когда вы вызываете функцию Rc::downgrade, вы получаете умный указатель типа Weak<T>. Не увеличивая число strong_count в экземпляре Rc<T> на 1, вызов функции Rc::downgrade увеличивает на 1 число weak_count. Тип Rc<T> ис-