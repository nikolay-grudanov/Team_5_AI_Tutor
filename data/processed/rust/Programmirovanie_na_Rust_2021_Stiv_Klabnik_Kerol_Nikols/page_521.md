---
source_image: page_521.png
page_number: 521
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 28.77
tokens: 7515
characters: 2098
timestamp: 2025-12-24T10:59:24.937989
finish_reason: stop
---

У нас есть типаж и его функция. Здесь пользователь упаковки может реализовать этот типаж для достижения желаемой функциональности, например:

use hello_macro::HelloMacro;

struct Pancakes;

impl HelloMacro for Pancakes {
    fn hello_macro() {
        println!("Здравствуй, Макро! Меня зовут Pancakes!");
    }
}

fn main() {
    Pancakes::hello_macro();
}

Однако ему нужно будет написать блок реализации для каждого типа, который он хотел бы использовать с hello_macro. Мы хотим избавить его от необходимости выполнять эту работу.

Кроме того, мы пока не можем предоставить функцию hello_macro с реализацией по умолчанию, которая будет печатать имя типа, в котором выполнен типаж. В языке Rust нет возможности рефлексии (интроспекции), поэтому он не может найти имя типа во время выполнения. Нам нужна макрокоманда, которая будет генерировать код во время компиляции.

Следующий шаг — определить процедурную макрокоманду. На момент написания книги процедурные макрокоманды должны находиться в собственной упаковке. В перспективе это ограничение может быть снято. Общепринято структурировать упаковки и макроупаковки следующим образом: для упаковки с именем foo упаковка для настраиваемых процедурных макрокоманд с атрибутом derive называется foo_derive. Давайте создадим новую упаковку под названием hello_macro_derive внутри проекта hello_macro:

$ cargo new hello_macro_derive --lib

Обе упаковки тесно связаны, поэтому мы создаем упаковку для процедурных макрокоманд в каталоге упаковки hello_macro. Если мы изменим определение типажа в hello_macro, то нам также придется изменить реализацию процедурной макрокоманды в hello_macro_derive. Эти две упаковки нужно будет опубликовать по отдельности, а программисты, использующие эти упаковки, должны будут добавить обе в качестве зависимостей и ввести их в область видимости. Вместо этого мы могли бы использовать упаковку hello_macro в качестве зависимости и реэкспортировать код процедурной макрокоманды. Однако то, как мы структурировали проект, позволяет программистам использовать hello_macro, даже если они не хотят функциональности derive.