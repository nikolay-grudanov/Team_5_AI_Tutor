---
source_image: page_504.png
page_number: 504
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 36.89
tokens: 7575
characters: 2144
timestamp: 2025-12-24T10:59:11.333840
finish_reason: stop
---

Мы получаем ошибку, сообщающую о том, что необходим типаж Display, но он не реализован:

error[E0277]: the trait bound `Point: std::fmt::Display` is not satisfied
 --> src/main.rs:20:6
  |
20 | impl OutlinePrint for Point {}
   | ^^^^^^^^^^^^ `Point` cannot be formatted with the default formatter;
try using `:?` instead if you are using a format string
   |
= help: the trait `std::fmt::Display` is not implemented for `Point`

Для того чтобы это исправить, мы реализуем типаж Display в структуре Point и удовлетворяем ограничение, которое требует OutlinePrint:

src/main.rs
use std::fmt;

impl fmt::Display for Point {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "({}, {})", self.x, self.y)
    }
}

Тогда реализация типажа OutlinePrint в структуре Point будет успешно скомпилирована, и мы сможем вызывать outline_print для экземпляра структуры Point, чтобы выводить ее на экран в контуре из звездочек.

Использование паттерна newtype для реализации внешних типажей во внешних типах

В разделе «Реализация типажа в типе» (с. 224) мы упомянули о сиротском правиле, которое гласит, что нам разрешено реализовывать типаж в типе до тех пор, пока либо типаж, либо тип являются локальными для упаковки. Обойти это ограничение можно с помощью паттерна newtype, который включает в себя создание нового типа в кортежной структуре. (Мы рассмотрели кортежные структуры в разделе «Использование кортежных структур без именованных полей для создания разных типов» (с. 119).) Кортежная структура будет иметь одно поле и станет тонкой оберткой вокруг типа, для которого мы хотим реализовать типаж. Тогда оберточный тип является локальным для упаковки, и мы можем реализовать типаж в обертке. Newtype («новый тип») — это термин, который пришел из языка Haskell. При использовании этого паттерна производительность времени выполнения не страдает, а оберточный тип элиминируется во время компиляции.

Допустим, мы хотим реализовать типаж Display для типа Vec<T>, что сиротское правило запрещает делать непосредственно, потому что типаж Display и тип Vec<T> определены вне упаковки. Мы можем создать структуру Wrapper, содержа-