---
source_image: page_517.png
page_number: 517
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 32.28
tokens: 7556
characters: 1977
timestamp: 2025-12-24T10:59:24.248163
finish_reason: stop
---

рах», «макрокомандами macro_rules!» или просто «макросами». По своей сути декларативные макрокоманды позволяют писать что-то похожее на выражение match языка Rust. Как отмечалось в главе 6, выражения match — это управляющие структуры, которые берут выражение, сравнивают результирующее значение выражения с паттернами, а затем исполняют код, связанный с совпадающим паттерном. Макрокоманды тоже сравнивают значение с паттернами, связанными с тем или иным кодом: в этом случае значение является литералом исходного кода Rust, переданного в макрокоманду. Шаблоны сравниваются со структурой этого исходного кода, а код, связанный с каждым паттерном, при совпадении заменяет код, переданный в макрокоманду. Все это происходит во время компиляции.

Для того чтобы определить макрокоманду, вы используете конструкцию macro_rules!. Давайте узнаем, как применять macro_rules!, глядя на определение макрокоманды vec!. Глава 8 посвящена тому, как использовать макрокоманду vec! для создания нового вектора с конкретными значениями. Например, следующая макрокоманда создает новый вектор, содержащий три целых числа:

let v: Vec<u32> = vec![1, 2, 3];

Мы могли бы также использовать макрокоманду vec! для создания вектора из двух целых чисел или вектора из пяти строковых срезов. Мы не сможем использовать функцию, чтобы сделать то же самое, потому что мы не будем знать заранее число или тип значений.

Листинг 19.28 показывает несколько упрощенное определение макрокоманды vec!.

Листинг 19.28. Упрощенная версия определения макрокоманды vec!

src/lib.rs

1 #[macro_export]
2 macro_rules! vec {
    3 ( $( $x:expr ),* ) => {
        {
            let mut temp_vec = Vec::new();
            4 $(
                5 temp_vec.push($x);
            )* 7 temp_vec
        }
    };
}

ПРИМЕЧАНИЕ
Фактическое определение макрокоманды vec! в стандартной библиотеке содержит код для предварительного выделения нужного объема памяти. Это код-оптимизация, он сюда не включен, чтобы упростить пример.