---
source_image: page_312.png
page_number: 312
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 36.64
tokens: 7573
characters: 2173
timestamp: 2025-12-24T10:54:04.957640
finish_reason: stop
---

создавать замыкание в одном месте, а затем вызвать его для оценки в другом контексте. В отличие от функций, замыкания могут захватывать значения из области видимости, в которой они определены. Мы продемонстрируем, как эти средства обеспечивают повторное использование кода и индивидуализацию поведения.

Создание абстракции поведения с помощью замыканий

Давайте поработаем над примером ситуации, в которой полезно хранить замыкание для последующего исполнения. Попутно мы поговорим о синтаксисе замыканий, логическом выводе типов и типажах.

Рассмотрим гипотетическую ситуацию: мы работаем в стартапе, где создается приложение для генерирования индивидуальных планов тренировок. Бэкенд написан на Rust, и алгоритм, который генерирует план тренировок, берет в расчет многие факторы, такие как возраст пользователя приложения, индекс массы тела, предпочтения в упражнениях, последние тренировки и интенсивность, задаваемую пользователем. Фактический алгоритм, используемый в примере, не важен. Важно то, что этот расчет занимает несколько секунд. Мы хотим вызывать этот алгоритм, только когда нужно и лишь один раз, чтобы не заставлять пользователя ждать больше, чем необходимо.

Мы смоделируем вызов этого гипотетического алгоритма с помощью функции simulated_expensive_calculation, показанной в листинге 13.1, которая будет выводить сообщение

вычисляется медленно...

ждать 2 секунды, а затем возвращать число, которое мы передали.

Листинг 13.1. Функция, замещающая гипотетическое вычисление, которое занимает около 2 секунд

src/main.rs
use std::thread;
use std::time::Duration;

fn simulated_expensive_calculation(intensity: u32) -> u32 {
    println!("вычисляется медленно...");
    thread::sleep(Duration::from_secs(2));
    intensity
}

Далее идет функция main, содержащая важные для данного примера части приложения плана тренировок. Эта функция представляет собой код, который приложение будет вызывать, когда пользователь запрашивает план тренировок. Поскольку взаимодействие с фронтэндом приложения не имеет отношения к использованию замыканий, мы будем жестко встраивать в код все значения, представляющие программе данные на входе, и выведем данные на выходе.