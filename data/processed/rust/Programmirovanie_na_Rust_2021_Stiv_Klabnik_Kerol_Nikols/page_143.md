---
source_image: page_143.png
page_number: 143
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 34.48
tokens: 7560
characters: 2053
timestamp: 2025-12-24T10:49:31.868187
finish_reason: stop
---

нет значения, то она должна возвращать значение None и не выполнять какие-либо операции.

Эта функция очень проста в написании благодаря match и будет выглядеть как в листинге 6.5.

Листинг 6.5. Функция, использующая выражение match для перечисления Option<i32>
```rust
fn plus_one(x: Option<i32>) -> Option<i32> {
    match x {
        None => None,
        Some(i) => Some(i + 1),
    }
}

let five = Some(5);
let six = plus_one(five); ③
let none = plus_one(None); ④
```

Давайте рассмотрим первое исполнение функции plus_one подробнее. Когда мы вызываем plus_one(five) ③, переменная x в теле plus_one имеет значение Some(5). Затем мы сравниваем его с каждым рукавом выражения match.

Значение Some(5) не совпадает с паттерном None ①, поэтому мы переходим к следующему рукаву. Совпадает ли Some(5) с Some(i) ②? Разумеется, да! У нас такой же вариант. Переменная i привязывается к значению, содержащемуся в Some, поэтому i принимает значение 5. Затем выполняется код в рукаве выражения match, мы прибавляем 1 к значению i и создаем новое значение Some с суммарным числом 6 внутри.

Теперь рассмотрим второй вызов plus_one в листинге 6.5, где x равно None ④. Мы входим в match и сравниваем с первым рукавом ①.

И оно совпадает! Там нет никакого прибавляемого значения, поэтому программа останавливается и возвращает значение None справа от =>. Поскольку первый рукав совпадает, никакие другие рукава не сравниваются.

Комбинирование выражения match и перечислений оказывается полезным во многих ситуациях. Вы будете встречать указанный паттерн в коде Rust очень часто: сопоставление с вариантами перечисления, привязка переменной к данным внутри, а затем исполнение кода на их основе. Поначалу все это немного сложновато, но как только вы привыкнете к этому паттерну, вы пожалеете, что его нет во всех языках. Он неизменно является излюбленным среди пользователей языка Rust.

Совпадения являются исчерпывающими

Нам нужно обсудить еще один аспект выражения match. Рассмотрим такую версию функции plus_one, в которой есть ошибка, и она не компилируется: