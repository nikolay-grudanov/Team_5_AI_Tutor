---
source_image: page_372.png
page_number: 372
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 28.57
tokens: 7449
characters: 1632
timestamp: 2025-12-24T10:55:32.337362
finish_reason: stop
---

2 fn new(x: T) -> MyBox<T> {
    3 MyBox(x)
}
}

Мы определяем структуру с именем MyBox и объявляем обобщенный параметр T 1, поскольку хотим, чтобы наш тип содержал значения любого типа. Тип MyBox представляет собой кортежную структуру с одним элементом типа T. Функция MyBox::new берет один параметр типа T 2 и возвращает экземпляр структуры MyBox, содержащий значение, переданное внутрь 3.

Давайте попробуем добавить функцию main из листинга 15.7 в листинг 15.8 и изменить ее на тип MyBox<T>, который мы определили вместо Box<T>. Код в листинге 15.9 не компилируется, потому что язык Rust не знает, как пройти по указателю MyBox к значению с помощью оператора разыменования.

Листинг 15.9. Попытка использовать MyBox<T> таким же образом, как ссылки и умный указатель Box<T>
src/main.rs
fn main() {
    let x = 5;
    let y = MyBox::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}

Ошибка в результате компиляции¹:

error[E0614]: type `MyBox<{integer}>` cannot be dereferenced
 --> src/main.rs:14:19
  |
14 |     assert_eq!(5, *y);
  |                   ^^

У нас не получается пройти по указателю MyBox<T> к значению с помощью оператора разыменования, потому что мы не реализовали эту способность в нашем типе. Чтобы иметь возможность пройти по указателю к значению с помощью оператора *, мы реализуем типаж Deref.

Трактовка типа как ссылки путем реализации типажа Deref

Как обсуждалось в главе 10, для того чтобы реализовать типаж, нужно предоставить реализации для обязательных методов типажа. Типаж Deref, предусмо-

¹ ошибка[E0614]: не получается пройти к существующему значению по указателю типа `MyBox<{integer}>`