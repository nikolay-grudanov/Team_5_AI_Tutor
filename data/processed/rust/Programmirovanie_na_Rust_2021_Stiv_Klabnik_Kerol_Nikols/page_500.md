---
source_image: page_500.png
page_number: 500
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 28.90
tokens: 7401
characters: 1632
timestamp: 2025-12-24T10:58:55.633944
finish_reason: stop
---

Листинг 19.18. Детализация того, метод fly какого типажа мы хотим вызвать

src/main.rs
```rust
fn main() {
    let person = Human;
    Pilot::fly(&person);
    Wizard::fly(&person);
    person.fly();
}
```

Указание имени типажа перед именем метода проясняет, какую реализацию метода fly мы хотим вызвать. Мы также могли бы написать Human::fly(&person), что эквивалентно person.fly(), использованному в листинге 19.18. Так выходит длиннее, но пригодится, если нам нужно устранить неоднозначность.

Выполнение этого кода выводит следующее:

    Говорит ваш капитан.
    Подъем!
    *яростно размахивает руками*

Поскольку метод fly берет параметр self, если бы у нас было два типа, которые реализуют один типаж, язык Rust мог бы узнавать, какую реализацию типажа использовать, основываясь на типе self.

Однако связанные функции, которые являются частью типажей, не имеют параметра self. Когда два типа в одинаковой области видимости реализуют этот типаж, компилятор не может выяснить, какой тип вы имеете в виду, если вы не используете полный синтаксис, наиболее специфичный для применения при вызове функции. Например, типаж Animal в листинге 19.19 имеет связанную функцию baby_name, реализацию Animal для структуры Dog и связанную функцию baby_name, определенную непосредственно для Dog.

Листинг 19.19. Типаж со связанной функцией и тип со связанной функцией с тем же именем, который также реализует этот типаж

src/main.rs
```rust
trait Animal {
    fn baby_name() -> String;
}

struct Dog;

impl Dog {
    fn baby_name() -> String {
        String::from("Спот")
    }
}

impl Animal for Dog {
    fn baby_name() -> String {
```