---
source_image: page_218.png
page_number: 218
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 30.71
tokens: 7445
characters: 1713
timestamp: 2025-12-24T10:51:25.882494
finish_reason: stop
---

Обратите внимание, что, поскольку для определения Point<T> мы использовали только один обобщенный тип, это определение говорит о том, что структура Point<T> является обобщением над неким типом T, а поля x и y имеют одинаковый тип, каким бы он ни был. Если мы создадим экземпляр Point<T>, который имеет значения разных типов, как в листинге 10.7, то код компилироваться не будет.

Листинг 10.7. Поля x и y должны быть одного типа, поскольку они имеют одинаковый обобщенный тип данных, T

src/main.rs
```rust
struct Point<T> {
    x: T,
    y: T,
}

fn main() {
    let wont_work = Point { x: 5, y: 4.0 };
}
```

В этом примере, когда мы передаем целочисленное значение 5 полю x, мы сообщаем компилятору, что обобщенный тип T для этого экземпляра Point<T> будет целочисленным. Затем, когда мы передаем 4.0 полю y, которое мы определили как имеющее тот же тип, что и у x, мы получим ошибку несовпадения типов, как здесь:

error[E0308]: mismatched types
 --> src/main.rs:7:38
  |
7 |     let wont_work = Point { x: 5, y: 4.0 };
    |                        ^^^ expected integral variable, found floating-point variable
  = note: expected type `{integer}`
         found type `{float}`

Для того чтобы определить структуру Point, где поля x и y являются обобщенными, но могут иметь разные типы, мы можем использовать несколько разных параметров обобщенного типа. Например, в листинге 10.8 можно изменить определение структуры Point так, чтобы оно стало обобщением над типами T и U, где поле x имеет тип T, а поле y — тип U.

Листинг 10.8. Point<T, U> является обобщением двух типов, в результате чего x и y могут быть значениями разных типов

src/main.rs
```rust
struct Point<T, U> {
    x: T,
    y: U,
}

fn main() {