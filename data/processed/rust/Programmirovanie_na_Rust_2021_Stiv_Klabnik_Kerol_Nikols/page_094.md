---
source_image: page_094.png
page_number: 94
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 32.65
tokens: 7572
characters: 2265
timestamp: 2025-12-24T10:48:14.070411
finish_reason: stop
---

имен с помощью модулей в разделе «Пути для ссылки на элемент в дереве модулей» (с. 151).

Этот вид строки может изменяться:

    let mut s = String::from("hello");

    s.push_str(", world!"); // push_str() добавляет литерал к экземпляру типа String

    println!("{}, {}", s);      // эта инструкция выводит `hello, world!`

Тогда в чем же разница? Почему тип String может изменяться, а литералы — нет? Разница заключается в том, как эти два типа работают с памятью.

Память и выделение пространства

В случае строкового литерала мы знаем его содержимое во время компиляции, поэтому текст жестко кодируется непосредственно в конечный исполняемый файл. Вот почему строковые литералы быстры и эффективны. Но эти свойства существуют только вследствие неизменяемости строкового литерала. К сожалению, мы не можем поместить большой объем памяти в двоичный файл для каждого фрагмента текста, размер которого неизвестен при компиляции и который может измениться во время выполнения программы.

В случае с типом String для поддержки изменяемого, наращиваемого фрагмента текста, нам нужно выделить объем памяти в куче, неизвестный во время компиляции, для хранения содержимого. Это означает, что:

○ Память должна быть запрошена из операционной системы во время выполнения.
○ Нам нужен способ вернуть эту память в операционную систему, когда мы закончим работу с экземпляром типа String.

Эта первая часть выполняется нами: когда мы вызываем функцию String::from, ее реализация запрашивает необходимую память. Так же происходит и в других языках программирования.

Однако вторая часть отличается от предыдущей. В языках со сборщиком мусора (GC от англ. garbage collector) он отслеживает и очищает память, которая больше не используется, и нам не нужно об этом думать. Без сборщика мусора мы сами должны узнать, когда память больше не используется, и вызвать код, который возвращает ее. Мы делали так, когда ее запрашивали. Правильное выполнение этой работы исторически являлось трудновыполнимой задачей программирования. Если мы забудем, то потеряем память. Если мы сделаем это слишком рано, то получим недействительную переменную. Если мы сделаем это дважды, то это тоже будет дефектом. Нам нужно связать в пару одно allocate («выделение») с одним free («высвобождением»).