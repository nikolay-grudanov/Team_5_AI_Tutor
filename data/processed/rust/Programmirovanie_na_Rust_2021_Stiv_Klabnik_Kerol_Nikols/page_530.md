---
source_image: page_530.png
page_number: 530
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 33.87
tokens: 7630
characters: 2376
timestamp: 2025-12-24T10:59:47.228299
finish_reason: stop
---

Теперь для начала введите код из листинга 20.1 в src/main.rs. Этот код будет слушать входящие TCP-потоки по адресу 127.0.0.1:7878. Получая входящий поток, он будет выводить:

Соединение установлено!

Листинг 20.1. Прослушивание входящих потоков и печать сообщения при получении потока

src/main.rs
use std::net::TcpListener;

fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
    for stream in listener.incoming() {
        let stream = stream.unwrap();
        println!("Соединение установлено!");
    }
}

Используя TcpListener, мы можем прослушивать TCP-соединения по адресу 127.0.0.1:7878 ①. В адресе секция перед двоеточием — это IP-адрес, представляющий ваш компьютер (этот адрес одинаков на каждом компьютере и не представляет компьютер определенного автора), а 7878 — это порт. Мы выбрали этот порт по двум причинам: на нем обычно принимается HTTP, а 7878 — это слово rust, набранное на телефоне.

Функция bind в этом сценарии работает как функция new в том, что она возвращает новый экземпляр типа TcpListener. Причина, по которой указанная функция называется bind (то есть «привязать»), заключается в том, что в сети подключение к порту для прослушивания называется привязкой к порту.

Функция bind возвращает экземпляр типа Result<T, E>, который говорит о том, что привязка может быть неуспешной. Например, для подключения к порту 80 требуются права администратора (неадминистраторы могут прослушивать только порты выше 1024), поэтому, если мы попытаемся подключиться к порту 80, не будучи администратором, то привязка не будет работать. Еще один пример, когда привязка не будет работать: если мы запускаем два экземпляра программы, и поэтому две программы прослушивают один и тот же порт. Поскольку мы пишем базовый сервер только для целей обучения, мы не будем беспокоиться об обработке таких ошибок. Мы используем метод unwrap, чтобы остановить программу в случае ошибок.

Метод incoming в типе TcpListener возвращает итератор, который дает последовательность потоков ② (более конкретно, потоков типа TcpStream). Один поток представляет собой открытое соединение между клиентом и сервером. Соединение — это имя для полного процесса запроса и ответа, в котором клиент подключается к серверу, сервер генерирует ответ и закрывает соединение. Таким образом, TcpStream будет читать из себя, чтобы увидеть, что отправил клиент, а затем будет