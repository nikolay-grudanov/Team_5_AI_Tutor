---
source_image: page_331.png
page_number: 331
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 34.56
tokens: 7537
characters: 2105
timestamp: 2025-12-24T10:54:28.314244
finish_reason: stop
---

Shoe { size: 10, style: String::from("кроссовки") },
Shoe { size: 13, style: String::from("сандалии") },
Shoe { size: 10, style: String::from("ботинки") },
];
let in_my_size = shoes_in_my_size(shoes, 10);
assert_eq!(
    in_my_size,
    vec![
        Shoe { size: 10, style: String::from("кроссовки") },
        Shoe { size: 10, style: String::from("ботинки") },
    ]
);

Функция shoes_in_my_size берет во владение вектор и размер обуви в качестве параметров ①. Она возвращает вектор, содержащий обувь только заданного размера.

В теле функции shoes_in_my_size мы вызываем метод into_iter для создания итератора, который берет вектор во владение ②. Затем мы вызываем метод filter, чтобы переделать этот итератор в новый, содержащий только те элементы, для которых замыкание возвращает true ③.

Замыкание захватывает параметр shoe_size из среды и сравнивает его значение с размером каждого вида обуви, сохраняя только обувь заданного размера. Наконец, вызов метода collect собирает значения, возвращенные переделанным итератором, в вектор, возвращаемый функцией ④.

Тест показывает, что, когда мы вызываем функцию shoes_in_my_size, мы получаем обратно только ту обувь, которая имеет тот же размер, что и заданное значение.

Создание собственных итераторов с помощью типажа Iterator

Мы показали, что вы можете создавать итератор, вызывая iter, into_iter или iter_mut для вектора. Итераторы можно создавать из других типов коллекций стандартной библиотеки, таких как хеш-отображение. Вы также можете создавать итераторы, которые делают все, что вы хотите, путем реализации типажа Iterator в собственных типах. Как уже упоминалось ранее, метод next — единственный, для которого требуется определение. После того как вы его предоставите, вы сможете использовать все другие методы с реализациями по умолчанию, предусмотренные типажом Iterator!

В качестве примера давайте создадим итератор, который будет всегда считать только от 1 до 5. Сначала мы сделаем структуру для хранения нескольких значений. Затем мы превратим ее в итератор, реализовав типаж Iterator и используя эти значения в указанной реализации.