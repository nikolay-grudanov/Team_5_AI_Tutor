---
source_image: page_488.png
page_number: 488
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 31.48
tokens: 7568
characters: 2005
timestamp: 2025-12-24T10:58:38.507849
finish_reason: stop
---

Вставляя блок unsafe в вызов функции dangerous, мы уверяем Rust, что прочитали документацию к указанной функции и понимаем, как правильно использовать ее свойства.

Тела небезопасных функций фактически являются блоками unsafe, поэтому для выполнения других небезопасных операций внутри небезопасной функции нам не нужно добавлять еще один блок unsafe.

Создание безопасной абстракции над небезопасным кодом

То, что функция содержит небезопасный код, не означает, что мы должны пометить всю функцию как небезопасную. На самом деле обертывание небезопасного кода в безопасную функцию — это часто встречающаяся абстракция. В качестве примера давайте изучим функцию из стандартной библиотеки split_at_mut, которая требует некоторого небезопасного кода, и узнаем, как ее можно реализовать. Этот безопасный метод определяется на изменяемых срезах: он берет один срез и делает из него два, разделяя срез по индексу, заданному в качестве аргумента. Листинг 19.4 показывает, как использовать split_at_mut.

Листинг 19.4. Использование безопасной функции split_at_mut

let mut v = vec![1, 2, 3, 4, 5, 6];

let r = &mut v[..];

let (a, b) = r.split_at_mut(3);

assert_eq!(a, &mut [1, 2, 3]);
assert_eq!(b, &mut [4, 5, 6]);

Мы не можем реализовать эту функцию, используя только безопасный Rust. Попытка выглядит примерно так, как код в листинге 19.5, который не компилируется. Для простоты мы реализуем split_at_mut как функцию, а не метод и только для срезов значений типа i32, а не для обобщенного типа T.

Листинг 19.5. Попытка реализовать функцию split_at_mut с использованием только безопасного языка Rust

fn split_at_mut(slice: &mut [i32], mid: usize) -> (&mut [i32], &mut [i32]) {
    let len = slice.len();

    assert!(mid <= len);

    (&mut slice[..mid],
     &mut slice[mid..])
}

Эта функция сначала получает суммарную длину среза. Затем она выполняет проверочное утверждение того, что индекс, заданный в качестве параметра, находится внутри среза, проверяя, что он меньше или равен длине. Проверочное