---
source_image: page_515.png
page_number: 515
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 33.82
tokens: 7523
characters: 1919
timestamp: 2025-12-24T10:59:21.778630
finish_reason: stop
---

можно использовать конкретный тип, реализующий типаж в качестве значения, возвращаемого из функции. Но вы не можете делать это с замыканиями, потому что у них нет конкретного типа, который можно вернуть. Например, вы не можете использовать указатель функции fn в качестве типа, возвращаемого из функции.

Код ниже пытается вернуть замыкание напрямую, но он не компилируется:

fn returns_closure() -> Fn(i32) -> i32 {
    |x| x + 1
}

Ошибка компилятора заключается в следующем:

error[E0277]: the trait bound `std::ops::Fn(i32) -> i32 + 'static: std::marker::Sized` is not satisfied
  --> 
  |
1 | fn returns_closure() -> Fn(i32) -> i32 {
      ^^^^^^^^^^^^^^^ `std::ops::Fn(i32) -> i32 + 'static` does not have a constant size known at compile-time
  |
  = help: the trait `std::marker::Sized` is not implemented for `std::ops::Fn(i32) -> i32 + 'static`
  = note: the return type of a function must have a statically known size

Ошибка снова ссылается на типаж Sized! Язык Rust не знает, сколько пространства ему понадобится для хранения замыкания. Ранее мы уже видели решение этой проблемы. Мы можем использовать типажный объект:

fn returns_closure() -> Box<dyn Fn(i32) -> i32> {
    Box::new(|x| x + 1)
}

Этот код будет компилироваться без проблем. Дополнительные сведения о типажных объектах смотрите в разделе «Использование типажных объектов, допускающих значения разных типов» (с. 435).

Далее давайте посмотрим на макрокоманды!

Макрокоманды

Мы использовали макрокоманды, такие как println!, на протяжении всей книги, но мы еще не полностью изучили сам термин «макрокоманда» и способ ее действия. Термин «макрокоманда» относится к семейству средств языка Rust: декларативным макрокомандам с помощью макрокоманды macro_rules! и трем видам процедурных макрокоманд:

О Настраиваемым макрокомандам #[derive], которые задают код, добавляемый при помощи атрибута derive, используемого в структурах и перечислениях.