---
source_image: page_408.png
page_number: 408
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 31.63
tokens: 7510
characters: 2004
timestamp: 2025-12-24T10:56:28.703411
finish_reason: stop
---

ная система планирует потоки. В этом прогоне главный поток исполнения выводится первым, даже если инструкция вывода из порожденного потока появляется в коде первой. И хотя перед порожденным потоком стояла задача выводиться до тех пор, пока переменная i равна 9, он добрался только до 5, прежде чем главный поток исполнения закрылся.

Если, выполняя этот код, вы видите данные только из главного потока или не видите никаких данных других потоков, попробуйте увеличить числа в интервалах, чтобы создать больше возможностей для переключения операционной системы между потоками.

Ожидание завершения работы всех потоков с использованием дескрипторов join

Код в листинге 16.1 не только чаще всего преждевременно останавливает порожденный поток из-за окончания работы главного потока, но и не может гарантировать, что порожденный поток вообще будет запущен. Причина в том, что нет гарантии, в каком порядке потоки будут выполняться!

Мы можем решить проблему незапуска или неполной работы порожденного потока исполнения, сохранив значение, возвращаемое из функции thread::spawn, в переменной. Функция thread::spawn возвращает тип JoinHandle. Тип JoinHandle — это обладаемое значение, которое, когда мы вызываем для него метод join, будет ждать до тех пор, пока его поток не завершится. Листинг 16.2 показывает, как использовать дескриптор JoinHandle потока, который мы создали в листинге 16.1, и как вызывать join, чтобы порожденный поток завершался до выхода main.

Листинг 16.2. Сохранение дескриптора JoinHandle из функции thread::spawn, чтобы поток завершился полностью

src/main.rs
use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!("привет, число {} из порожденного потока!", i);
            thread::sleep(Duration::from_millis(1));
        }
    });
    for i in 1..5 {
        println!("привет, число {} из главного потока!", i);
        thread::sleep(Duration::from_millis(1));
    }
    handle.join().unwrap();
}