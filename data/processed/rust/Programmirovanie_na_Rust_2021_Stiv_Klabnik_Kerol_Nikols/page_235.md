---
source_image: page_235.png
page_number: 235
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 32.70
tokens: 7494
characters: 1915
timestamp: 2025-12-24T10:51:58.626996
finish_reason: stop
---

Еще один вид обобщения, который мы уже использовали, называется «жизненный цикл». Он не отвечает за то, чтобы у типа были определенные свойства, но обеспечивает, чтобы ссылки были действительными до тех пор, пока они нам нужны. Давайте посмотрим, как жизненный цикл это делает.

Проверка ссылок с помощью жизненных циклов

В разделе «Ссылки и заимствование» (с. 102) мы не обсудили одну деталь, а именно: у каждой ссылки в Rust есть жизненный цикл, то есть протяженность, в течение которой эта ссылка действительно. В большинстве случаев жизненные циклы выводятся логически неявно, так же как и типы, которые чаще всего выводятся логически. Необходимо аннотировать типы, когда существует возможность нескольких типов. Мы должны аннотировать жизненный цикл схожим образом, когда жизненные циклы у ссылок могут быть взаимосвязаны разными способами. Язык Rust требует, чтобы мы аннотировали связи, применяя параметры обобщенных жизненных циклов, чтобы фактические ссылки, используемые во время выполнения, были безусловно действительными.

Понятие жизненного цикла несколько отличается от инструментов в других языках программирования, что, возможно, делает жизненный цикл в Rust наиболее характерным средством. Хотя в этой главе мы не охватим жизненный цикл в полном объеме, но обсудим часто встречающиеся случаи, когда вы, возможно, будете сталкиваться с синтаксисом жизненного цикла, что позволит вам освоиться с этим понятием.

Предотвращение висячих ссылок с помощью жизненного цикла

Главная цель жизненного цикла — предотвращать висячие ссылки, из-за которых программа ссылается на данные, отличные от тех, на которые она должна ссылаться. Рассмотрим программу из листинга 10.17, которая имеет внешнюю и внутреннюю область видимости.

Листинг 10.17. Попытка использовать ссылку, значение которой вышло из области видимости

{
    let r;
    {
        let x = 5;
        r = &x;
    }
    println!("r: {}", r);
}