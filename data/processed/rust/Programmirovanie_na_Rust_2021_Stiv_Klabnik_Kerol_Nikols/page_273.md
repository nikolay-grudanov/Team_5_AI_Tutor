---
source_image: page_273.png
page_number: 273
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 30.78
tokens: 7459
characters: 1757
timestamp: 2025-12-24T10:52:51.087479
finish_reason: stop
---

Листинг 11.12. Тестирование приватной функции

src/lib.rs
```rust
pub fn add_two(a: i32) -> i32 {
    internal_adder(a, 2)
}

fn internal_adder(a: i32, b: i32) -> i32 {
    a + b
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn internal() {
        assert_eq!(4, internal_adder(2, 2));
    }
}
```

Обратите внимание, что функция internal_adder не помечена как pub, но, поскольку тесты представляют собой простой код Rust, а модуль tests — просто еще один модуль, вы можете ввести internal_adder в область видимости теста и вызвать его. Если вы не считаете, что приватные функции должны тестироваться, ничто в Rust не заставит вас это сделать.

Интеграционные тесты

В Rust интеграционные тесты являются полностью внешними по отношению к библиотеке. Они используют библиотеку так же, как и любой другой код, то есть они вызывают только те функции, которые являются частью публичного API вашей библиотеки. Их цель — протестировать правильность работы многих частей библиотеки. Единицы кода, которые работают правильно в отдельности, могут иметь проблемы во время интеграции, поэтому тестовое покрытие интегрированного кода так же важно. Для создания интеграционных тестов сначала необходимо создать каталог tests.

Каталог tests

Мы создаем каталог tests на верхнем уровне каталога нашего проекта, рядом с src. Cargo знает, что нужно искать файлы интеграционных тестов в этом каталоге. Затем мы можем создать в этом каталоге столько тестовых файлов, сколько захотим, и каждый из них будет скомпилирован как отдельная упаковка.

Давайте создадим интеграционный тест. Если код из листинга 11.12 по-прежнему находится в файле src/lib.rs, то создайте каталог tests и новый файл с именем tests/integration_test.rs и введите код из листинга 11.13.