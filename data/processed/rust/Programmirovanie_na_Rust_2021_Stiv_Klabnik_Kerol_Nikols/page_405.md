---
source_image: page_405.png
page_number: 405
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 32.06
tokens: 7522
characters: 2220
timestamp: 2025-12-24T10:56:28.733811
finish_reason: stop
---

циональность для конкурентной передачи сообщений, но невнятные способы совместного использования состояния между потоками. Для языков высокого уровня поддерживать только подмножества возможных решений разумно, поскольку в таких языках можно получить преимущества, если отказаться от некоторого контроля в пользу абстракций. Однако предполагается, что языки низкого уровня должны обеспечивать решение с наилучшей производительностью в любой ситуации и иметь меньше абстракций по сравнению с аппаратным обеспечением. Следовательно, язык Rust предлагает разнообразие инструментов для моделирования задач любым способом, подходящим для вашей ситуации и технических требований.

Вот темы, которые мы рассмотрим в этой главе:

○ Как создавать потоки, которые выполняют многочисленные части кода одновременно.
○ Конкурентность передачи сообщений, при которой каналы посылают сообщения между потоками.
○ Конкурентность совместного состояния, когда несколько потоков исполнения имеют доступ к некоторой части данных.
○ Типажи Sync и Send, которые расширяют гарантии конкурентности языка Rust для типов, определяемых пользователем, а также типов, предусмотренных стандартной библиотекой.

Использование потоков исполнения для одновременного выполнения кода

В большинстве современных операционных систем код работающей программы исполняется в процессе, а операционная система управляет несколькими процессами сразу. Внутри программы вы также можете иметь независимые части, которые работают одновременно. Средства, которые управляют этими независимыми частями, называются потоками (thread).

Разделение вычислений в программе на несколько потоков исполнения повышает производительность, поскольку программа работает с несколькими задачами в одно и то же время, но это также добавляет сложности. Поскольку потоки работают одновременно, нет никакой гарантии порядка, в котором части кода будут выполняться в разных потоках. Это приводит к таким проблемам, как:

○ Состояние гонки, когда потоки обращаются к данным или ресурсам в несогласованном порядке.
○ Взаимоблокировки, при которых поток ждет, когда другой поток закончит использование ресурса, принадлежавшего первому. В итоге это препятствует продолжению работы обоих потоков.