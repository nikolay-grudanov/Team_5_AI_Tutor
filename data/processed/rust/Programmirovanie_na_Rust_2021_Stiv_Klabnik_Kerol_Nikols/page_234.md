---
source_image: page_234.png
page_number: 234
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 32.31
tokens: 7502
characters: 2056
timestamp: 2025-12-24T10:51:55.773711
finish_reason: stop
---

```rust
fn new(x: T, y: T) -> Self {
    Self {
        x,
        y,
    }
}

impl<T: Display + PartialOrd> Pair<T> {
    fn cmp_display(&self) {
        if self.x >= self.y {
            println!("Наибольший член x равен {}", self.x);
        } else {
            println!("Наибольший член y равен {}", self.y);
        }
    }
}
```

Мы также можем условно реализовать типаж для любого типа, который реализует еще один типаж. Реализации типажа в любом типе, удовлетворяющем границам типажа, называются полными реализациями и широко используются в стандартной библиотеке языка Rust. Например, стандартная библиотека реализует типаж ToString в любом типе, реализующем типаж Display. Блок impl в стандартной библиотеке выглядит аналогично коду, приведенному ниже:

```rust
impl<T: Display> ToString for T {
    // --пропуск--
}
```

Поскольку в стандартной библиотеке есть полная реализация, мы можем вызвать метод to_string, определенный типажом ToString, для любого типа, реализующего типаж Display. Например, можно превратить целые числа в соответствующие им значения типа String, потому что целые числа реализуют Display:

```rust
let s = 3.to_string();
```

Полные реализации описаны в документации о типажах в разделе «Разработчики».

Типажи и границы типажа позволяют писать код, который использует параметры обобщенного типа не только чтобы сократить повторы, но и чтобы у обобщенного типа были определенные свойства. Компилятор затем использует информацию о границе типажа и проверяет, что все используемые в коде конкретные типы обеспечивают правильное поведение. В динамически типизированных языках произошла бы ошибка времени выполнения, если бы мы вызвали метод для типа, который этот тип не реализовал. Но Rust смещает эти ошибки на время компиляции, поэтому мы вынуждены устранять проблемы еще до того, как код сможет работать. В дополнение к этому, нам не нужно писать код, который проверяет поведение во время выполнения, потому что мы уже это сделали во время компиляции. Это повышает производительность, и гибкость обобщений сохраняется.