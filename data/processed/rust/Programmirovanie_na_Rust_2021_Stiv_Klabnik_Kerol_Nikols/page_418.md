---
source_image: page_418.png
page_number: 418
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 25.77
tokens: 7417
characters: 1665
timestamp: 2025-12-24T10:56:42.902102
finish_reason: stop
---

```rust
let (tx, rx) = mpsc::channel();

thread::spawn(move || {
    let vals = vec![
        String::from("привет"),
        String::from("из"),
        String::from("потока"),
        String::from("исполнения"),
    ];

    for val in vals {
        tx.send(val).unwrap();
        thread::sleep(Duration::from_secs(1));
    }
});

for received in rx {
    println!("Получено: {}", received);
}
```

На этот раз порожденный поток имеет вектор строковых значений, которые мы хотим отправить в главный поток. Мы перебираем их, посылая каждое по отдельности, и делаем паузу между ними, вызывая функцию thread::sleep со значением Duration, равным 1 секунде.

В главном потоке исполнения мы больше не вызываем функцию recv явно: вместо этого мы трактуем rx как итератор. Мы выводим каждое полученное значение. Когда канал будет закрыт, итерация закончится.

При выполнении этого кода из листинга 16.10 вы должны увидеть следующие данные с секундной паузой между каждой строкой результата:

Получено: привет
Получено: из
Получено: потока
Получено: исполнения

Поскольку у нас нет кода, который приостанавливает или задерживает цикл for в главном потоке исполнения, можно сказать, что главный поток ожидает значения из порожденного потока.

Создание нескольких производителей путем клонирования передатчика

Ранее мы уже упоминали, что mpsc — это сокращение для обозначения нескольких производителей и одного потребителя. Давайте применим mpsc и расширим код из листинга 16.10 так, чтобы создать несколько потоков исполнения, которые посылают значения одному и тому же приемнику. Мы можем сделать это, клонировав передающую половину канала, как показано в листинге 16.11.