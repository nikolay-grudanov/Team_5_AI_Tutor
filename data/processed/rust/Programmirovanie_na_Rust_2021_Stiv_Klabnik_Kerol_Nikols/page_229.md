---
source_image: page_229.png
page_number: 229
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 32.65
tokens: 7561
characters: 2304
timestamp: 2025-12-24T10:51:46.839561
finish_reason: stop
---

```rust
pub fn notify<T: Summary>(item: T) {
    println!("Срочные новости! {}", item.summarize());
}
```

Эта более длинная форма эквивалентна примеру в предыдущем разделе, но в ней больше слов. Мы помещаем границы типажа с помощью объявления параметра обобщенного типа после двоеточия внутрь угловых скобок.

Синтаксис impl Trait удобен и способствует более сжатому коду в простых случаях. В других ситуациях синтаксис границы типажа выражает больше сложности. Например, у нас может быть два параметра, которые реализуют Summary. Использование синтаксиса impl Trait выглядит следующим образом:

```rust
pub fn notify(item1: impl Summary, item2: impl Summary) {
```

Если бы мы хотели, чтобы эта функция позволяла item1 и item2 иметь разные типы, то использование impl Trait было бы уместным (если оба типа реализуют Summary). Если нужно, чтобы у обоих параметров был один и тот же тип, то это можно выразить только с помощью границы типажа:

```rust
pub fn notify<T: Summary>(item1: T, item2: T) {
```

Обобщенный тип T, указанный в качестве типа параметров item1 и item2, ограничивает функцию таким образом, что конкретный тип значения, передаваемого в качестве аргумента для item1 и item2, должен быть одинаковым.

Указание нескольких границ типажа с помощью синтаксиса +

Мы также можем указывать несколько границ типажа. Скажем, мы хотим, чтобы функция notify использовала дисплейное форматирование для item, а также метод summarize. В определении notify мы указываем, что item должен реализовать как Display, так и Summary. Можно сделать это, используя синтаксис +:

```rust
pub fn notify(item: impl Summary + Display) {
```

Синтаксис + также допустим с границами типажа для обобщенных типов:

```rust
pub fn notify<T: Summary + Display>(item: T) {
```

С двумя указанными границами типажа тело notify может вызвать метод summarize и использовать {} для форматирования параметра item.

Более четкие границы типажа с условием where

Использование слишком большого числа границ типажа имеет свои недостатки. У каждого обобщенного типа есть свои границы типажа, поэтому функции с многочисленными параметрами обобщенного типа могут содержать много информации о границах типажа между именем функции и списком ее параметров, что затрудняет чтение сигнатуры функции. По этой причине в языке Rust имеется