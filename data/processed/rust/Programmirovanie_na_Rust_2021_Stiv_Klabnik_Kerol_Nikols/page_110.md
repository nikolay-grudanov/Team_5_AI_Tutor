---
source_image: page_110.png
page_number: 110
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 35.92
tokens: 7640
characters: 2444
timestamp: 2025-12-24T10:48:42.383307
finish_reason: stop
---

отдельного байта в кортеже ②. Поскольку мы получаем ссылку на элемент из .iter().enumerate(), мы используем в паттерне оператор &.

Внутри цикла for мы ищем байт, который представляет пробел, используя синтаксис байтового литерала ④. Если мы находим пробел, то возвращаем его позицию. В противном случае мы возвращаем длину строки с помощью s.len() ⑤.

Теперь у нас есть способ выяснить индекс конца первого слова в строке, но есть одна проблема. Мы возвращаем тип usize отдельно, но это число имеет значение только в контексте &String. Другими словами, поскольку это значение является отдельным от типа String, нет никакой гарантии, что оно будет по-прежнему действительным в будущем. Рассмотрим программу из листинга 4.8, которая использует функцию first_word из листинга 4.7.

Листинг 4.8. Сохранение результата, полученного после вызова функции first_word, и изменение содержимого экземпляра типа String

src/main.rs
```rust
fn main() {
    let mut s = String::from("hello world");

    let word = first_word(&s); // переменная word получит значение 5

    s.clear(); // это опустошает экземпляр типа String, делая его равным ""

    // здесь word по-прежнему имеет значение 5, но больше нет строки,
    // с которой мы могли бы осмысленно использовать значение 5.
    // переменная word теперь полностью недействительна!
}
```

Эта программа компилируется без каких-либо ошибок и также будет компилироваться, если мы используем переменную word после вызова s.clear(). Поскольку переменная word вообще не связана с состоянием переменной s, переменная word по-прежнему содержит значение 5. Мы могли бы использовать значение 5 с переменной s, чтобы попытаться извлечь первое слово, но это было бы ошибкой, потому что с тех пор, как мы сохранили 5 в word, содержимое s изменилось.

Беспокойство о том, что индекс в word выходит из синхронизации с данными в s, утомительно, и могут быть ошибки! Управление этими индексами становится еще более деликатным, если мы пишем функцию second_word. Ее сигнатура должна выглядеть вот так:

```rust
fn second_word(s: &String) -> (usize, usize) {
```

Теперь мы отслеживаем начальный и конечный индексы, и у нас еще больше значений, которые были рассчитаны из данных в отдельно взятом состоянии, но совсем не привязаны к этому состоянию Теперь у нас три свободные несвязанные переменные, которые нужно держать в синхронизированном состоянии.

К счастью, в Rust есть решение этой проблемы — строковые срезы.