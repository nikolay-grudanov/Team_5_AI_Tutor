---
source_image: page_502.png
page_number: 502
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 33.23
tokens: 7540
characters: 2056
timestamp: 2025-12-24T10:59:03.320879
finish_reason: stop
---

Для того чтобы устранить неоднозначность и сообщить языку Rust, что нужна реализация Animal в Dog, требуется полный синтаксис. В листинге 19.21 показано, как применять полный синтаксис.

Листинг 19.21. Использование полного синтаксиса для указания, что мы хотим вызвать функцию baby_name из типажа Animal, реализованного в Dog

src/main.rs
```rust
fn main() {
    println!("Детеныш собаки - это {}", <Dog as Animal>::baby_name());
}
```

Мы предоставляем языку Rust аннотацию типа внутри угловых скобок. Она конкретизирует, что мы хотим вызвать метод baby_name из типажа Animal, реализованного в Dog, говоря, что нужно трактовать тип Dog как Animal для данного вызова функции. Этот код теперь будет печатать то, что мы хотим:

Детеныш собаки - это щенок

В общем случае полный синтаксис определяется следующим образом:

<Tип as Типаж>::функция(приемник_в_случае_метода, следующий_арг, ...);

Для связанных функций не будет приемника, будет только список других аргументов. Вы можете использовать полный синтаксис везде, где вызываете функции или методы. Однако можно опустить любую часть этого синтаксиса, которую компилятор может выяснить в другом месте программы. Вы должны использовать такой подробный синтаксис только тогда, когда есть много реализаций, использующих одинаковое имя, и Rust нужно помочь выявить, какую реализацию вы хотите вызвать.

Использование супертипажей, требующих функциональности одного типажа внутри другого типажа

Иногда вам, возможно, понадобится, чтобы один типаж использовал функциональность другого типажа. В этом случае нужно полагаться на то, что зависимый типаж также реализуется. Типаж, на который вы полагаетесь, является супертипажом того типажа, который вы реализуете.

Предположим, мы хотим создать типаж OutlinePrint с помощью метода outline_print, который будет печатать значение, обрамленное звездочками. То есть если задана структура Point, реализующая типаж Display для результата в (x, y), то при вызове функции outline_print для экземпляра структуры Point с 1 для x и 3 для y она должна печатать следующее: