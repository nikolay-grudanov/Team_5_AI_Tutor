---
source_image: page_049.png
page_number: 49
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 42.96
tokens: 7667
characters: 2695
timestamp: 2025-12-24T10:47:13.736618
finish_reason: stop
---

Вы видите разные номера версий (но все они будут совместимы с кодом, благодаря SemVer!), причем выводимые на экран строки могут находиться в другом порядке.

Теперь, когда у нас есть внешняя зависимость, Cargo извлекает последние версии всего этого из реестра, то есть копии данных из https://crates.io/. Crates.io — это то место, где участники экосистемы языка Rust размещают свои проекты с открытым исходным кодом Rust для их использования другими разработчиками.

После обновления реестра пакетный менеджер Cargo проверяет раздел [dependencies] и скачивает все упаковки, которых у вас еще нет. В данном случае, несмотря на то что мы указали в качестве зависимости только rand, Cargo также захватил копию libc, потому что в своей работе rand зависит от libc. После скачивания упаковок язык Rust компилирует их, а затем компилирует проект с имеющимися зависимостями.

Если вы сразу же выполните команду cargo build снова, не внося никаких изменений, то на выходе вы не получите никакого результата, кроме строчки Finished. Cargo знает, что он уже скачал и скомпилировал зависимости и вы ничего не изменили в файле Cargo.toml. Cargo также знает, что вы ничего не изменили в коде, поэтому он не перекомпилирует и его. Он просто завершает работу, ничего не делая.

Если вы откроете файл src/main.rs, внесете незначительное изменение, а затем сохраните его и соберете снова, то увидите только две результирующие строчки:

$ cargo build
    Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 1.50 secs

Эти строчки показывают, что Cargo обновляет сборку, используя только крошечное изменение в файле src/main.rs. Ваши зависимости не изменились, поэтому Cargo знает, что он может использовать повторно те упаковки, которые он уже скачал и скомпилировал для них. Он просто перестраивает вашу часть кода.

Обеспечение воспроизводимых сборок с помощью файла Cargo.lock

Cargo имеет механизм, который дает возможность перестройки одного и того же артефакта всякий раз, когда вы или кто-либо другой выполняете сборку вашего кода: Cargo будет использовать только те версии зависимостей, которые вы указали, до тех пор, пока вы не укажете иное. Например, что произойдет, если на следующей неделе выйдет версия 0.3.15 упаковки rand, содержащая важное исправление ошибок, а также регрессию, которая нарушит работу вашего кода?

Ответом на этот вопрос является файл Cargo.lock, который был создан при первом выполнении команды cargo build и теперь находится в каталоге guessing_game. Когда вы создаете проект в первый раз, Cargo выясняет все версии зависимостей, которые соответствуют критериям, а затем записывает их в файл Cargo.lock. Ког-