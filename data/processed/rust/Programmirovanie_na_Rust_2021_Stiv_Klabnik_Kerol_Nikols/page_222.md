---
source_image: page_222.png
page_number: 222
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 30.74
tokens: 7519
characters: 2035
timestamp: 2025-12-24T10:51:35.652864
finish_reason: stop
---

Цель этого примера — продемонстрировать ситуацию, в которой одни обобщенные параметры объявляются с помощью ключевого слова impl, а другие — с помощью определения метода. Здесь обобщенные параметры T и U объявляются после impl①, поскольку они идут вместе с определением структуры. Обобщенные параметры V и W объявляются после fn mixup ②, поскольку они относятся только к методу.

Производительность кода с использованием обобщений

Вы, наверное, задаетесь вопросом, сказывается ли использование параметров обобщенного типа на времени выполнения. Хорошая новость — язык Rust реализует обобщенные типы таким образом, что, используя их, код не работает медленнее, чем при применении конкретных типов.

Rust достигает этого за счет мономорфизации кода, который использует обобщенные методы во время компиляции. Мономорфизация — это процесс превращения обобщенного кода в конкретный путем вставки конкретных типов, которые используются во время компиляции.

В этом процессе компилятор выполняет действия, противоположные шагам, которые мы предпринимали для создания обобщенной функции в листинге 10.5: компилятор просматривает все места, где вызывается обобщенный код, и генерирует код для конкретных типов, с которыми вызывается обобщенный код.

Давайте посмотрим, как это работает. Пример ниже использует перечисление Option<T> из стандартной библиотеки:

let integer = Some(5);
let float = Some(5.0);

Когда Rust компилирует этот код, он выполняет мономорфизацию. Во время этого процесса компилятор читает значения, которые были использованы в экземплярах типа Option<T>, и определяет два типа Option<T>: один — i32, а другой — f64. По этой причине он расширяет обобщенное определение типа Option<T> в Option_i32 и Option_f64, тем самым заменяя обобщенное определение конкретными определениями.

Мономорфизированная версия кода выглядит следующим образом. Обобщенный тип Option<T> заменяется конкретными определениями, создаваемыми компилятором:

src/main.rs
enum Option_i32 {
    Some(i32),
    None,
}

enum Option_f64 {
    Some(f64),