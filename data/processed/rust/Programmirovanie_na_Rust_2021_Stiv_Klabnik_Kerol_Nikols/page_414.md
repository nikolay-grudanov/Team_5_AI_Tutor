---
source_image: page_414.png
page_number: 414
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 42.60
tokens: 7665
characters: 2565
timestamp: 2025-12-24T10:56:51.420965
finish_reason: stop
---

пающих сообщений. Канал считается закрытым, если отброшена половина либо передатчика, либо приемника.

Здесь мы поработаем над программой, которая имеет один поток для генерирования значений и отправки их по каналу, а другой поток для получения значений и их вывода. Чтобы показать, как это работает, будем отправлять простые значения между потоками, используя канал. Как только вы ознакомитесь с этим техническим решением, то сможете использовать каналы для реализации чат-системы или системы, в которой много потоков исполнения выполняют части вычисления и отправляют их в один поток, который агрегирует результаты.

Сначала в листинге 16.6 мы создадим канал, но ничего с ним делать не будем. Обратите внимание, что этот код пока не компилируется, потому что компилятору не известно, какой тип значений мы хотим отправить по каналу.

Листинг 16.6. Создание канала и присвоение значений tx и rx его элементам
src/main.rs

```rust
use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();
}
```

Мы создаем новый канал, используя функцию mpsc::channel, mpsc расшифровывается как «много производителей, один потребитель» от англ. multiple producer, single consumer. Одним словом, то, как стандартная библиотека языка Rust реализует каналы, означает, что канал может иметь несколько отправляющих концов, которые производят значения, и только один принимающий конец, который потребляет эти значения. Представьте себе, что несколько потоков сливаются в одну большую реку: все, что отправлено вниз по любому из потоков, в конце концов окажется в одной реке. Сейчас мы начнем с одного производителя, но, когда этот пример будет работать, мы добавим несколько производителей.

Функция mpsc::channel возвращает кортеж, первый элемент которого является отправляющим, а второй — принимающим. Аббревиатуры tx и rx традиционно используются во многих областях для обозначения передатчика и приемника соответственно, поэтому мы и называем так переменные, чтобы указать каждый конец. Мы используем инструкцию let с паттерном, который деструктурирует кортежи. Мы обсудим использование паттернов в инструкциях let и деструктурирование в главе 18. Используя инструкцию let таким образом, вы можете легко извлекать части кортежа, возвращаемого функцией mpsc::channel.

Давайте переместим передающий конец в порожденный поток и дадим ему отправить одно строковое значение, чтобы порожденный поток общался с главным потоком, как показано в листинге 16.7. Все равно, что положить резиновую утку в реку в верхнем течении или отправить сообщение в чате из одной ветви в другую.