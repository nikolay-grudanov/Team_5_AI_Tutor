---
source_image: page_112.png
page_number: 112
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 28.30
tokens: 7392
characters: 1534
timestamp: 2025-12-24T10:48:39.551572
finish_reason: stop
---

Точно так же, если ваш срез содержит последний байт значения типа String, то вы можете удалить конечное число. Это означает, что следующие варианты равны:

let s = String::from("hello");

let len = s.len();

let slice = &s[3..len];
let slice = &s[3..];

Вы также можете отбросить оба значения, взяв срез всего значения типа String целиком. Поэтому следующие варианты равны:

let s = String::from("hello");

let len = s.len();

let slice = &s[0..len];
let slice = &s[..];

ПРИМЕЧАНИЕ

Индексы интервала строкового среза должны располагаться в допустимых границах символов UTF-8. Если вы попытаетесь создать строковый срез в середине многобайтового символа, то программа завершится с ошибкой. Для введения строковых срезов в этом разделе мы исходим из использования только символов ASCII. Более подробное описание работы с UTF-8 приведено в разделе «Хранение текста в кодировке UTF-8 с помощью строк» (с. 175).

Имея в виду всю эту информацию, давайте перепишем функцию first_word так, чтобы вернуть срез. Тип, обозначающий «строковый срез», записывается как &str:

src/main.rs
fn first_word(s: &String) -> &str {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }

    &s[..]
}

Мы получаем индекс конца слова таким же образом, как и в листинге 4.7, путем отыскания первого вхождения пробела. Когда мы отыскиваем пробел, мы возвращаем строковый срез, используя начало строки и индекс пробела в качестве начального и конечного индексов.