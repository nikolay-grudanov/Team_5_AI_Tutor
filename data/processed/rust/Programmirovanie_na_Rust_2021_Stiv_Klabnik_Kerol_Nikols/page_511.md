---
source_image: page_511.png
page_number: 511
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 43.93
tokens: 7698
characters: 2651
timestamp: 2025-12-24T10:59:28.306683
finish_reason: stop
---

строки до наступления выполнения, то есть мы не можем ни создать переменную типа str, ни взять аргумент типа str. Рассмотрим следующий фрагмент кода, который не работает:

    let s1: str = "Привет!";
    let s2: str = "Как дела?";

Rust должен знать, сколько памяти нужно выделить для любого значения некоторого типа, и все значения этого типа должны использовать одинаковый объем памяти. Если бы Rust позволял нам писать этот код, то оба значения str должны были бы занимать одинаковый объем пространства. Но они имеют разную длину: s1 требуется 12 байт памяти, а s2 — 15. Вот почему невозможно создать переменную, содержащую динамически изменяемый тип.

Тогда что же нам делать? В этом случае вы уже знаете ответ: мы создаем переменные s1 и s2 с типом &str вместо str. Напомним, в разделе «Строковые срезы» (с. 111) мы отметили, что срезовая структура данных хранит начальную позицию и длину среза.

Поэтому, в отличие от ссылки &T, представляющей собой одинарное значение, которое хранит адрес памяти, где находится T, ссылка &str состоит из двух значений: адреса str и его длины. По этой причине мы можем знать размер значения типа &str во время компиляции: он в два раза больше длины типа usize. То есть мы всегда знаем размер &str, независимо от того, насколько длинное строковое значение, на которое она ссылается. В общем случае именно таким образом динамически изменяемые типы используются в Rust: они имеют дополнительный кусок метаданных, который хранит размер динамической информации. Золотое правило динамически изменяемых типов состоит в том, что мы всегда должны помещать значения динамически изменяемых типов за какой-либо указатель.

Мы можем комбинировать str со всеми видами указателей: например, умными указателями Box<str> или Rc<str>. На самом деле вы уже встречали это раньше, но с другим динамически изменяемым типом — типажом. Каждый типаж является динамически изменяемым типом, на который мы можем ссылаться, используя имя типажа. В разделе «Использование типажных объектов, допускающих значения разных типов» (с. 435), мы упоминали, что для использования типажей в качестве типажных объектов мы должны их ставить за указатель, например, &dyn Trait или Box<dyn Trait> (Rc<dyn Trait> тоже будет работать).

Для работы с динамически изменяемыми типами в языке Rust имеется отдельный типаж под названием Sized, чтобы выяснить, известен ли размер типа во время компиляции. Указанный типаж автоматически реализуется для всего того, чей размер известен во время компиляции. В дополнение к этому, язык Rust неявно добавляет к типажу Sized границу в каждую обобщенную функцию. То есть определение обобщенной функции, подобное этому.