---
source_image: page_413.png
page_number: 413
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 39.94
tokens: 7629
characters: 2352
timestamp: 2025-12-24T10:56:48.595609
finish_reason: stop
---

error[E0382]: use of moved value: `v`
  --> src/main.rs:10:10
   |
6  |     let handle = thread::spawn(move || {
   |                        -------- value moved (into closure) here
...
10 |         drop(v); // о нет!
   |                ^ value used here after move
   |
= note: move occurs because `v` has type `std::vec::Vec<i32>`, which does not implement the `Copy` trait

Правила владения снова нас спасли! Мы получили ошибку из кода в листинге 16.3, потому что Rust был строг и позаимствовал переменную v только для этого потока, то есть главный поток исполнения теоретически мог аннулировать ссылку порожденного потока. Говоря компилятору переместить владение переменной v в порожденный поток, мы гарантируем, что главный поток больше не будет использовать v. Если мы изменяем листинг 16.4 таким же образом, то нарушаем правила владения, когда пытаемся использовать v в главном потоке. Ключевое слово move отменяет консервативное поведение заимствования, присущее языку Rust по умолчанию, поэтому мы не нарушаем правила владения.

Изучив основы потоков исполнения и их API, давайте посмотрим, что можно с ними делать.

Использование передачи сообщений для пересылки данных между потоками

Для безопасной конкурентности все популярнее становится передача сообщений, когда потоки или акторы общаются, отправляя друг другу сообщения, содержащие данные. Вот как эта идея выражена в слогане из документации языка Go (http://golang.org/doc/effective_go.html): «Не общайтесь, используя одну и ту же память. Делитесь памятью, общаясь».

Один из основных инструментов языка Rust, предназначенный для достижения параллелизма отправки сообщений, — это понятие под названием «канал», реализация которого предусматривается стандартной библиотекой. Вы можете представить себе канал в программировании как канал с водой, такой как ручей или река. Если вы положите что-то вроде резиновой утки или лодки в поток воды, то она будет двигаться вниз по течению до конца водного пути.

Канал в программировании состоит из двух элементов: передатчика и приемника. Передатчик — это место выше по течению, где вы кладете резиновых уток в реку, а приемник — это место, где резиновая утка заканчивает движение вниз по течению. Одна часть кода вызывает методы для передатчика с данными, которые вы хотите отправить, а другая — проверяет принимающий конец на наличие посту-