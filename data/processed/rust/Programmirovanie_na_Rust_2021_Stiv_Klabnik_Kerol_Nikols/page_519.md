---
source_image: page_519.png
page_number: 519
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 39.07
tokens: 7660
characters: 2424
timestamp: 2025-12-24T10:59:34.765427
finish_reason: stop
---

Мы определили макрокоманду, которая берет любое число аргументов любого типа и может генерировать код для создания вектора, содержащего указанные элементы.

У декларативной макрокоманды macro_rules! есть несколько странных пограничных случаев. В будущем в Rust появится второй вид декларативной макрокоманды, который будет работать схожим образом, но при этом пограничные случаи будут исправлены. После этого обновления макрокоманду macro_rules! практически объявят устаревшей. Имея это в виду, а также тот факт, что большинство программистов Rust будут больше использовать макрокоманды, чем писать их, мы не будем дальше обсуждать макрокоманду macro_rules!. Для того чтобы узнать больше о том, как писать макрокоманды, обратитесь к документации или другим ресурсам, таким как «Маленькая книга макрокоманд языка Rust» (The Little Book of Rust Macros) по адресу https://danielkeep.github.io/tlborm/book/index.html.

Процедурные макрокоманды для генерирования кода из атрибутов

Вторая форма макрокоманд — это процедурные макрокоманды, которые действуют больше как функции (и являются типом процедуры). Процедурные макрокоманды принимают некий код на входе, работают с этим кодом и производят некий код на выходе вместо сопоставления с паттернами и замены одного кода другим, как это делают декларативные макрокоманды.

Все три вида процедурных макрокоманд (настраиваемые с атрибутом derive, подобные атрибутам и подобные функциям) работают похожим образом.

При создании процедурных макрокоманд их определения должны находиться в собственной упаковке со специальным типом. Это происходит по техническим причинам, которые мы надеемся устранить в будущем. Использование процедурных макрокоманд выглядит как код в листинге 19.29, где some_attribute является заполнителем для использования конкретной макрокоманды.

Листинг 19.29. Пример использования процедурной макрокоманды src/lib.rs

use proc_macro;

#[some_attribute]
pub fn some_name(input: TokenStream) -> TokenStream {
}

Функция, которая определяет процедурную макрокоманду, берет TokenStream на входе и производит TokenStream на выходе. Тип TokenStream определяется упаковкой proc_macro. Он входит в состав языка Rust и представляет собой последовательность токенов. Это ядро макрокоманды: исходный код, с которым работает макрокоманда, образует входной TokenStream, а код, производящий макрокоманду, является выходным TokenStream. Функция также имеет атрибут, который