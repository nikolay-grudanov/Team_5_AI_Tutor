---
source_image: page_436.png
page_number: 436
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 45.33
tokens: 7757
characters: 2922
timestamp: 2025-12-24T10:57:28.368689
finish_reason: stop
---

Однако иногда мы хотим, чтобы пользователь библиотеки мог расширить набор типов, допустимых в конкретной ситуации. Чтобы показать, как это сделать, мы создадим пример графического пользовательского интерфейса (GUI), который перебирает элементы в списке, вызывая метод draw для отрисовки каждого из них на экране, — часто встречающийся технический прием для инструментов GUI. Мы создадим библиотечную упаковку под названием gui, которая содержит в себе структуру библиотеки GUI. Эта упаковка включает в себя несколько типов, таких как Button или TextField. В дополнение к этому пользователи gui смогут создавать собственные типы, которые можно нарисовать: например, один программист, возможно, добавит изображение (тип Image), а другой — поле выбора (тип SelectBox).

В данном примере мы не будем реализовывать полнофункциональную библиотеку GUI, но покажем, как ее части будут сочетаться друг с другом. На момент написания библиотеки мы не можем знать и определить все типы, которые другие программисты, возможно, захотят создать. Но мы знаем, что библиотека gui должна отслеживать большое число значений разных типов и вызывать метод draw для каждого из этих по-разному типизированных значений. Не нужно знать наверняка, что произойдет, когда мы вызовем метод draw; требуется знать только то, что этот метод будет иметься у значения для вызова.

Для того чтобы сделать это в языке с наследованием, мы, возможно, определили бы класс с именем Component с методом draw. Другие классы, такие как Button, Image и SelectBox, наследовали бы у класса Component и поэтому наследовали бы метод draw. Каждый из них мог бы переопределить метод draw, задав свое индивидуальное поведение, но интерфейсный каркас мог бы трактовать все типы, как если бы они были экземплярами класса Component, и вызывать метод draw для них. Но поскольку Rust не имеет наследования, нам нужен другой способ структурировать библиотеку gui, чтобы позволить пользователям расширять ее новыми типами.

Определение типажа для часто встречающегося поведения

Для того чтобы реализовать поведение, которого мы хотим добиться от gui, мы определим типаж с именем Draw с одним методом draw. Затем мы можем определить вектор, который берет типажный объект. Типажный объект указывает как на экземпляр типа, реализующего указанный нами типаж, так и на таблицу для поиска методов типажа в этом типе во время выполнения. Мы создаем типажный объект, описывая некоторый вид указателя, такой как ссылка & или умный указатель Box<T>, с последующим ключевым словом dyn, а затем указывая соответствующий типаж. (Мы поговорим, почему типажные объекты должны использовать указатель, в разделе «Динамически изменяемые типы и типаж Sized».) Мы можем использовать типажные объекты вместо обобщенного или конкретного типа. Везде, где мы используем типажный объект, система типов Rust во время компиляции сделает так, чтобы любое значение в этом контексте реализовывало типаж типаж-