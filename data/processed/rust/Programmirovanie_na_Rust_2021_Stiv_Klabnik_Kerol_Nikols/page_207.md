---
source_image: page_207.png
page_number: 207
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 38.57
tokens: 7744
characters: 2973
timestamp: 2025-12-24T10:51:18.012876
finish_reason: stop
---

О Хороший способ закодировать эту информацию в типах, которые вы используете, отсутствует.

Если кто-то вызывает ваш код и передает внутрь значения, которые не имеют смысла, то лучшим вариантом выбора, возможно, будет вызов panic! и оповещение человека, использующего вашу библиотеку, о дефекте в его коде. Благодаря этому он сможет устранить дефект во время разработки. Схожим образом макрокоманда panic! часто уместна, если вы вызываете внешний код, который находится вне вашего контроля, и он возвращает недопустимое состояние, которое вы не можете исправить.

Однако, когда сбой ожидаем, уместнее вернуть Result, чем устраивать вызов panic!. Примеры включают в себя парсер (синтаксический анализатор), которому передаются деформированные данные или HTTP-запрос, возвращающий статус, который указывает, что вы исчерпали число запросов. В этих случаях возвращение экземпляра Result указывает, что сбой является ожидаемой возможностью и вызывающий код должен решить, как его обработать.

Когда код выполняет операции над значениями, сначала он должен проверить, являются ли значения действительноими, и поднять панику, если значения недействительны. Это главным образом делается из соображений безопасности: попытка выполнять операции над недействительными данными приводит к уязвимостям кода. Это главная причина, по которой стандартная библиотека будет вызывать макрокоманду panic!, если вы попытаетесь обратиться к памяти за пределами границ. Попытка обратиться к памяти, которая не принадлежит текущей структуре данных, является распространенной проблемой нарушения безопасности. В функциях часто есть контракты: их поведение гарантируется только в том случае, если входные данные удовлетворяют определенным требованиям. Поднимать панику, когда контракт нарушается, имеет смысл по той причине, что нарушение контракта всегда указывает на дефект со стороны вызывающего кода. И это не та ошибка, которую вызывающий код был бы обязан явно обрабатывать. На самом деле нет никакого разумного способа восстановить вызывающий код — исправлять код должны вызывающие его программисты. Контракты для функции, в особенности когда нарушение будет причиной паники, должны объясняться в документации API для этой функции.

Однако большое количество проверок на наличие ошибок во всех функциях было бы избыточным и могло бы раздражать. К счастью, можно использовать систему типов языка Rust (отсюда и проверка типов, выполняемая компилятором) для проведения многих проверок за вас. Если у функции есть конкретный тип в качестве параметра, то вы можете продолжить логику кода, зная, что компилятор уже обеспечил действительное значение. Например, если вместо Option у вас есть тип, то программа ожидает получить что-то определенное. И тогда коду не придется обрабатывать два случая для вариантов Some и None: у него будет только один случай — точное наличие значения. Код, пытающийся передать ничто в функцию, даже не скомпилируется, поэтому функция не должна проверять этот случай во