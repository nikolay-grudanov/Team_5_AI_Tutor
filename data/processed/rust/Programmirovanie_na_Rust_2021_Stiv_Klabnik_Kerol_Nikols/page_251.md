---
source_image: page_251.png
page_number: 251
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 28.41
tokens: 7516
characters: 1996
timestamp: 2025-12-24T10:52:17.151638
finish_reason: stop
---

Как писать тесты

Тесты — это функции, которые проверяют, что не-тестовый код функционирует ожидаемым образом.

Тела тестовых функций обычно выполняют следующие действия:

1. Настраивают необходимые данные или состояние.
2. Выполняют код, который вы хотите протестировать.
3. Подтверждают, что результаты соответствуют ожиданиям.

Давайте рассмотрим специальные средства для написания тестов, выполняющих эти действия, включая атрибут test, несколько макрокоманд и атрибут should_panic.

Анатомия функции тестирования

В самом простом случае тест — это функция, которая аннотируется атрибутом test. Атрибуты — это метаданные о фрагментах кода на языке Rust; одним из примеров является атрибут derive, который мы использовали со структурами в главе 5. Для того чтобы превратить функцию в тестовую, добавьте #[test] в строке кода перед fn. Когда вы выполняете тесты с помощью команды cargo test, Rust создает двоичный исполнитель теста, который выполняет функции, помеченные атрибутом test, и сообщает результаты прохождения проверки каждой тестовой функцией.

Когда мы создаем новый библиотечный проект с помощью Cargo, автоматически генерируется тестовый модуль с тестовой функцией внутри. Этот модуль помогает писать тесты, благодаря чему вам не придется искать точную структуру и синтаксис тестовых функций всякий раз, когда вы приступаете к новому проекту. Вы можете добавить столько дополнительных тестовых функций и тестовых модулей, сколько захотите!

Мы познакомимся с несколькими аспектами процесса работы тестов, экспериментируя с образцом теста, сгенерированным без фактического тестирования какого-либо кода. Затем мы напишем несколько реальных тестов, которые вызовут некий написанный нами код и подтвердят, что он работает корректно.

Давайте создадим новый библиотечный проект под названием adder («сумматор»):

$ cargo new adder --lib
    Created library `adder` project
$ cd adder

Содержимое файла src/lib.rs в библиотеке adder должно выглядеть так, как показано в листинге 11.1.