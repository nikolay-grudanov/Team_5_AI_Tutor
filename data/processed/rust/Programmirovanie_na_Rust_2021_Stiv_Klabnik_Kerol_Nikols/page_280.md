---
source_image: page_280.png
page_number: 280
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 33.04
tokens: 7528
characters: 2167
timestamp: 2025-12-24T10:53:10.673768
finish_reason: stop
---

Листинг 12.1. Сборка аргументов командной строки в вектор и их печать

src/main.rs

use std::env;

fn main() {
    let args: Vec<String> = env::args().collect();
    println!("{:?}", args);
}

Сначала мы вводим модуль std::env в область видимости с помощью инструкции use, в результате чего можно использовать его функцию args.

Обратите внимание, что функция std::env::args вложена в два уровня модулей. Как мы уже говорили в главе 7, в тех случаях, когда желаемая функция вложена в несколько модулей, обычно в область видимости вводится родительский модуль, а не сама функция. Благодаря этому мы можем легко использовать другие функции из std::env. Это также менее двусмысленно, чем добавление use std::env::args, а затем вызов функции с указанием только args, потому что функцию args легко по ошибке принять за функцию, определенную в текущем модуле.

ФУНКЦИЯ ARGS И НЕДЕЙСТВИТЕЛЬНЫЙ ЮНИКОД

Обратите внимание, что std::env::args будет паниковать, если какой-либо аргумент содержит недействительный Юникод. Если программе нужно принимать аргументы, содержащие недействительный Юникод, используйте функцию std::env::args_os. Эта функция возвращает итератор, который вместо значений типа String создает значения типа OsString. Мы решили использовать std::env::args здесь для простоты, потому что значения типа OsString отличаются от платформы к платформе и сложнее для работы, чем значения типа String.

В первой строке функции main мы вызываем функцию env::args и сразу же применяем функцию collect, чтобы превратить итератор в вектор, содержащий все значения, полученные итератором. Можно использовать функцию collect для создания многих видов коллекций, поэтому мы аннотируем тип args, указав, что нам нужен вектор строк. Хотя в Rust аннотировать типы приходится очень редко, функция collect является одной из тех, которую часто нужно аннотировать, потому что компилятор не может определить тип требуемой коллекции.

Наконец, мы выводим вектор с помощью отладочного средства форматирования :?. Давайте попробуем выполнить этот код сначала без аргументов, а затем с двумя аргументами:

$ cargo run
--пропуск--
["target/debug/minigrep"]

$ cargo run needle haystack