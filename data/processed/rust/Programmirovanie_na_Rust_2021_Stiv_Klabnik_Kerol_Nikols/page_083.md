---
source_image: page_083.png
page_number: 83
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 27.19
tokens: 7377
characters: 1681
timestamp: 2025-12-24T10:47:48.174181
finish_reason: stop
---

значение булева типа в качестве условия. К примеру, если мы хотим, чтобы блок кода if выполнялся только тогда, когда число не равно 0, то мы можем изменить выражение if на следующее:

src/main.rs
    fn main() {
        let number = 3;
        if number != 0 {
            println!("число было отличным от нуля");
        }
    }

При выполнении этого кода будет выведено:

    число было отличным от нуля

Обработка нескольких условий с помощью else if

Вы можете иметь несколько условий, совместив if и else в выражение else if. Например:

src/main.rs
    fn main() {
        let number = 6;
        if number % 4 == 0 {
            println!("число делится на 4");
        } else if number % 3 == 0 {
            println!("число делится на 3");
        } else if number % 2 == 0 {
            println!("число делится на 2");
        } else {
            println!("число не делится на 4, 3 и 2");
        }
    }

У программы есть четыре варианта развития событий. После ее выполнения вы должны увидеть следующий результат:

    $ cargo run
        Compiling branches v0.1.0 (file:///projects/branches)
        Finished dev [unoptimized + debuginfo] target(s) in 1.50 secs
        Running `target/debug/branches`
    число делится на 3

Когда программа исполняется, она проверяет каждое выражение if по очереди и исполняет первое тело, для которого условие соблюдается. Обратите внимание, что даже если 6 делится на 2, мы не увидим результат число делится на 2, равно как и не будет текста число не делится на 4, 3 и 2 из блока else. Это обусловлено тем, что Rust исполняет блок только для первого истинного условия. Как только он его находит, язык не проверяет остальные условия.