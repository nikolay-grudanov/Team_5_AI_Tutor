---
source_image: page_138.png
page_number: 138
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 30.69
tokens: 7516
characters: 2050
timestamp: 2025-12-24T10:49:21.570601
finish_reason: stop
---

фикса Option::: Перечисление Option<T> по-прежнему является обычным перечислением, а Some(T) и None — по-прежнему варианты типа Option<T>.

Синтаксис <T> является средством языка Rust, о котором мы еще не говорили. Это параметр обобщенного типа, мы рассмотрим обобщения подробнее в главе 10. На данный момент вам нужно знать только одно: <T> означает, что вариант Some перечисления Option может содержать один фрагмент данных любого типа. Вот несколько примеров использования значений перечисления Option для числовых и строковых типов:

let some_number = Some(5);
let some_string = Some("строковый литерал");

let absent_number: Option<i32> = None;

Если вместо Some мы используем None, то нам нужно указать, какой тип Option<T> у нас есть, потому что компилятор не может логически вывести тип, который вариант Some будет содержать, только из значения None.

Когда есть значение Some (то есть какое-то значение), мы знаем, что оно присутствует и содержится внутри Some. Когда у нас есть значение None (то есть нет никакого значения), в некотором смысле это означает то же самое, что и null: у нас нет действительного значения. Тогда почему Option<T> лучше, чем null?

Если коротко, так как Option<T> и T (где T может быть любым типом) являются разными типами, компилятор не позволит использовать значение Option<T>, как если бы это значение было действительно. Например, этот код не компилируется, потому что он пытается прибавить значение типа i8 к значению типа Option<i8>:

let x: i8 = 5;
let y: Option<i8> = Some(5);

let sum = x + y;

Если мы выполним этот код, то получим сообщение об ошибке¹:

error[E0277]: the trait bound `i8: std::ops::Add<std::option::Option<i8>>` is not satisfied
  --> 
   |
5 |     let sum = x + y;
   |         ^ no implementation for `i8 + std::option::Option<i8>`

Круто! Это сообщение об ошибке означает, что компилятор не понимает, как сложить типы i8 и Option<i8>, потому что это разные типы. Когда у нас есть значение

¹ ошибка[E0277]: граница типажа`i8: std::ops::Add<std::option::Option<i8>>` не удовлетворена