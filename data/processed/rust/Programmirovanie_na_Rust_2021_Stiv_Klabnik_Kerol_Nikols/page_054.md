---
source_image: page_054.png
page_number: 54
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 32.54
tokens: 7488
characters: 2033
timestamp: 2025-12-24T10:47:09.925913
finish_reason: stop
---

Ошибку заключается в том, что типы не совпадают. В Rust имеется сильная статическая система типов. Однако в нем также есть логический вывод типов. Когда мы написали let mut guess = String::new(), Rust смог логически вывести, что переменная guess должна иметь тип String, и не заставил нас указать тип. С другой стороны, переменная secret_number имеет числовой тип. Значение от 1 до 100 могут иметь несколько числовых типов: i32, 32-битное число; u32, беззнаковое 32-битное число; i64, 64-битное число и другие. По умолчанию Rust использует тип i32, который является типом переменной secret_number, при условии, что вы не добавляете информацию о типе в другом месте, что заставит компилятор логически вывести другой числовой тип. Причина ошибки здесь заключается в том, что Rust не может сравнить строковый и числовой типы.

В итоге мы хотим конвертировать значение типа String, которое программа читает на входе, в числовой тип, чтобы численно сравнить его с секретным числом. Мы можем это сделать, добавив следующие две строки кода в тело функции main:

src/main.rs

```rust
// --пропуск--
let mut guess = String::new();

io::stdin().read_line(&mut guess)
    .expect("Не получилось прочитать строку");

let guess: u32 = guess.trim().parse()
    .expect("Пожалуйста, наберите число!");

println!("Вы загадали: {}", guess);

match guess.cmp(&secret_number) {
    Ordering::Less => println!("Слишком малое число!"),
    Ordering::Greater => println!("Слишком большое число!"),
    Ordering::Equal => println!("Вы выиграли!"),
}
```

Мы создаем переменную с именем guess. Но подождите, у программы ведь уже есть переменная с именем guess? Да, есть, но Rust позволяет нам затенить предыдущее значение переменной guess новым. Это языковое средство часто используется в ситуациях, когда требуется конвертировать значение из одного типа в другой. Затенение позволяет нам использовать имя переменной guess повторно, а не создавать две уникальные переменные, как, например, guess_str и guess. (В главе 3 затенение рассматривается подробнее.)