---
source_image: page_055.png
page_number: 55
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 42.76
tokens: 7677
characters: 2713
timestamp: 2025-12-24T10:47:20.620058
finish_reason: stop
---

Мы связываем переменную guess с выражением guess.trim().parse(). Переменная guess в указанном выражении относится к исходной переменной guess, которая была экземпляром типа String, содержащим в себе входные данные. Метод trim для типа String устраняет любые пробелы в начале и конце. Несмотря на то что тип u32 может содержать только числовые символы, пользователь должен нажать клавишу ENTER и тем самым выполнить метод read_line. Когда пользователь нажимает ENTER, символ новой строки добавляется в конец строкового значения. Например, если пользователь набирает 5 и нажимает ENTER, то переменная guess выглядит следующим образом: 5\n. \n обозначает «новую строку», то есть результат нажатия клавиши ENTER. Метод trim исключает \n, давая в результате только 5.

Метод parse, определенный для типа String, делает разбор строкового значения и преобразует его в какое-то число. Поскольку этот метод извлекает различные типы чисел, нужно указать точный тип числа, который мы хотим, используя let guess: u32. Двоеточие (:) после guess говорит о том, что мы аннотируем тип переменной. В Rust имеется несколько встроенных числовых типов: u32, который мы рассматриваем, является беззнаковым 32-битным целочисленным типом. Это хороший выбор по умолчанию для малого положительного числа. О других типах чисел вы узнаете в главе 3. Кроме того, аннотация u32 в этом примере программы и сравнение с переменной secret_number означают, что Rust логически выведет, что переменная secret_number тоже должна иметь тип u32. И, таким образом, теперь будут сравниваться два значения одного и того же типа!

Вызов метода parse легко может стать причиной ошибки. Если бы, например, строка содержала А0%, то было бы невозможно конвертировать ее в число. Поскольку метод parse может не сработать, он возвращает тип Result во многом также, как и метод read_line (тип Result обсуждался в разделе «Обработка потенциального сбоя с помощью типа Result»). Мы будем обращаться с этим типом точно так же, снова используя метод expect. Если parse возвращает вариант типа Result, равный Err, так как он не смог создать число из строки, то вызов метода expect завершит игру аварийно и выведет сообщение, заданное нами. Если метод parse выполнит успешную конвертацию строки в число, то он вернет вариант типа Result, равный Ok, а метод expect вернет число, которое мы хотим получить из значения Ok.

Давайте прямо сейчас выполним эту программу!

$ cargo run
    Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev[unoptimized + debuginfo] target(s) in 1.50 secs
    Running `target/debug/guessing_game`
Угадайте число!
Секретное число равно 58
Пожалуйста, введите свою догадку.
76
Вы загадали: 76
Слишком большое число!