---
source_image: page_151.png
page_number: 151
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 32.73
tokens: 7642
characters: 2322
timestamp: 2025-12-24T10:49:44.130147
finish_reason: stop
---

также могут содержать определения других элементов, таких как структуры, перечисления, константы, типажи или — как в листинге 7.1 — функции.

Используя модули, мы можем группировать взаимосвязанные определения вместе и называть причину, почему они связаны. Программистам, использующим этот код, будет легче отыскивать определения, которые они хотят использовать, потому что они смогут перемещаться по коду на основе групп, а не прочитывать все определения. Программисты, добавляющие новую функциональность в этот код, будут знать, где размещать код, поддерживая программу организованной.

Ранее мы упоминали, что src/main.rs и src/lib.rs называются корнями упаковки. Причина такого названия заключается в том, что содержимое любого из этих двух файлов формирует модуль с именем crate («упаковка») в корне модульной упаковочной структуры, именуемой деревом модулей.

В листинге 7.2 показано дерево модулей для организационной структуры в листинге 7.1.

Листинг 7.2. Дерево модулей для кода в листинге 7.1

crate
  └── front_of_house
      ├── hosting
      │   ├── add_to_waitlist
      │   └── seat_at_table
      └── serving
          ├── take_order
          ├── serve_order
          └── take_payment

Это дерево показывает, что некоторые модули вставлены друг в друга (например, hosting вложен внутрь front_of_house). Дерево также показывает, что некоторые модули являются одноуровневыми друг другу, имея в виду, что они определены в одном модуле (модули hosting и serving определяются в front_of_house). Продолжая метафору семьи, если модуль А содержится внутри модуля В, то мы говорим, что модуль А является дочерним к модулю В, а модуль В является родительским по отношению к модулю А. Обратите внимание, что все дерево модулей коренится в скрытом модуле с именем crate.

Дерево модулей, возможно, напомнит вам каталожное дерево файловой системы на вашем компьютере: такое сравнение является очень удачным! Как и каталоги в файловой системе, вы используете модули для организации кода. И точно также, как файлы в каталоге, нам нужен способ отыскивать модули.

Пути для ссылки на элемент в дереве модулей

Для того чтобы показать языку Rust, где в дереве модулей отыскать элемент, мы используем путь точно так же, как во время навигации по файловой системе. Если мы хотим вызвать функцию, то нам нужно знать ее путь.