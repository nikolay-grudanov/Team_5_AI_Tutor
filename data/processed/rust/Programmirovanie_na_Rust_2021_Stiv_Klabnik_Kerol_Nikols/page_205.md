---
source_image: page_205.png
page_number: 205
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 37.59
tokens: 7702
characters: 2636
timestamp: 2025-12-24T10:51:12.053241
finish_reason: stop
---

Тип Box<dyn Error> называется типажным объектом, о котором мы поговорим в разделе «Использование типажных объектов, допускающих значения разных типов». Пока же вы можете истолковать смысл выражения Box<dyn Error> как «любой вид ошибки». Применение оператора ? в функции main с этим типом возвращаемого значения допускается.

Теперь, когда мы обсудили детали вызова макрокоманды panic! и возврата экземпляра Result, давайте вернемся к вопросу о том, каким образом определить, что уместно использовать и в каких случаях.

Паниковать! Или не паниковать!

Итак, как же определить, когда следует вызывать макрокоманду panic!, а когда нужно возвращать Result? Когда код поднимает панику, нет никакого способа восстановить работу. Вы можете вызвать макрокоманду panic! при любой ошибочной ситуации, независимо от того, есть ли возможный способ ее устранения или нет, но тогда вы принимаете решение от имени кода, вызывающего ваш код, о том, что такая ситуация является неустранимой. Когда вы решаете вернуть значение типа Result, вы даете вызывающему коду варианты, а не принимаете решение за него. Вызывающий код мог бы попытаться устранить ситуацию способом, который является уместным, либо он мог бы принять решение о том, что значение Err в данном случае устранить невозможно, и поэтому он может вызвать макрокоманду panic! и превратить устранимую ошибку в неустранимую. Следовательно, возвращение экземпляра типа Result — это хороший выбор по умолчанию, когда вы определяете функцию, которая может завершиться сбоем.

В редких случаях целесообразнее писать код, который вместо возвращения экземпляра типа Result поднимает панику. Давайте разберемся в причинах, почему уместно поднимать панику в примерах, прототипном коде и тестах. Затем мы обсудим ситуации, в которых компилятор не способен распознать, что сбой невозможен, но вы, как человек, способны. Эта глава завершится несколькими общими принципами в отношении целесообразности паники в библиотечном коде.

Примеры, прототипный код и тесты

Когда вы пишете пример для иллюстрации какой-то идеи, наличие в этом примере еще и кода с надежной обработкой ошибок сделает этот пример менее ясным. В примерах понятно, что вызов метода, такого как unwrap, который мог бы поднять панику, задуман как заполнитель для способа обработки ошибок, который вы хотите внедрить в программу, а он может отличаться в зависимости от того, что делает остальная часть кода.

Точно так же методы unwrap и expect очень удобны во время прототипирования до того, как вы решите, как обрабатывать ошибки. Они оставляют в коде четкие маркеры для момента, когда вы будете готовы сделать программу более надежной.