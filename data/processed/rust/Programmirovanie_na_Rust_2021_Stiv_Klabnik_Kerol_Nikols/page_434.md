---
source_image: page_434.png
page_number: 434
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 40.84
tokens: 7668
characters: 2744
timestamp: 2025-12-24T10:57:23.590318
finish_reason: stop
---

Мы оставляем поля list и average приватными, чтобы внешний код не мог добавлять или удалять элементы непосредственно в поле list. В противном случае поле average может оказаться несинхронизированным при изменении list. Метод average возвращает значение в поле average, позволяя внешнему коду читать average, не изменяя его.

Поскольку мы инкапсулировали детали реализации структуры AveragedCollection, в будущем можно легко изменять такие аспекты, как структура данных. Например, мы могли бы использовать HashSet<i32> вместо Vec<i32> для поля list. До тех пор пока сигнатуры публичных методов add, remove и average остаются неизменными, код, использующий AveragedCollection, не нуждается в изменении. Если бы мы сделали поле list публичным, то это не обязательно было бы так: HashSet<i32> и Vec<i32> имеют разные методы добавления и удаления элементов, поэтому внешний код, вероятно, нужно было бы изменить, если бы он преобразовывал поле list напрямую.

Если инкапсуляция — это необходимый аспект для объектно-ориентированного языка, то Rust удовлетворяет этому требованию. Возможность выбирать, когда использовать ключевое слово pub для разных частей кода, а когда нет, позволяет инкапсулировать детали реализации.

Наследование как система типов и как совместное использование кода

Наследование — это механизм, посредством которого объект может наследовать определение другого объекта, получая таким образом данные и поведение родителя без необходимости их повторного определения.

Если наследование — это черта объектно-ориентированного языка, то тогда Rust нельзя отнести к этому типу. В нем невозможно определить структуру, которая наследует поля и реализации методов родительской структуры. Но если вы привыкли иметь наследование в своем инструментарии, то вы можете использовать другие решения Rust в зависимости от своих целей.

Вы выбираете наследование по двум главным причинам. Одна — ради повторного использования кода: вы можете реализовать некоторое поведение для одного типа, а наследование позволяет использовать эту реализацию повторно для другого. Вместо этого вы можете делиться кодом Rust с помощью реализаций по умолчанию для типажных методов, которые вы видели в листинге 10.14, когда мы добавили реализацию по умолчанию метода summarize для типажа Summary. Любой тип, реализующий типаж Summary, будет иметь метод summarize, доступный для него без какого-либо дополнительного кода. Это похоже на родительский класс с реализацией метода, наследующий классу потомка, также с реализацией этого метода. Кроме того, мы можем переопределить реализацию по умолчанию метода summarize во время реализации типажа Summary, что аналогично классу потомка, переопределяющему реализацию метода, унаследованного от родительского класса.