---
source_image: page_181.png
page_number: 181
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 36.70
tokens: 7626
characters: 2315
timestamp: 2025-12-24T10:50:34.016626
finish_reason: stop
---

смотрим на них как на графемные кластеры, мы получим то, что человек назвал бы четырьмя буквами, составляющими слово на хинди:

["न", "म", "स्", "ते"]

Rust предоставляет разные способы интерпретации сырых строковых данных, хранящихся в компьютерах. Благодаря этому каждая программа может выбирать необходимую ей интерпретацию, независимо от того, на каком человеческом языке хранятся данные.

Последняя причина, по которой Rust не позволяет нам индексировать значение типа String для получения символа, заключается в том, что от операций индексирования ожидается, что они всегда будут занимать постоянное время (O(1)). Но гарантировать такую производительность со значением типа String невозможно, поскольку для того, чтобы выяснить число допустимых символов, компилятору пришлось бы проверить его содержимое с самого начала до индекса.

Нарезка строк

Зачастую индексирование в строке — плохая идея, поскольку неясно, каким должен быть тип возвращаемого значения операции индексирования строки: байтовым значением, символом, графемным кластером или строковым срезом. Поэтому язык Rust просит вас быть точнее, если вам действительно нужно использовать индексы для создания строковых срезов. Для того чтобы быть точнее при индексировании и указать, что вам нужен строковый срез, а не индексирование с помощью [ ] с одним единственным числом, вы можете использовать [ ] с интервалом, создав строковый срез, содержащий отдельные байты:

let hello = "Здравствуйте";

let s = &hello[0..4];

Здесь переменная s будет строковым срезом &str, который содержит первые 4 байта строки. Ранее мы упоминали, что каждый из этих символов имеет размер в 2 байта, а это значит, что переменная s будет содержать зд.

Что бы произошло, если бы мы применили &hello[0..1]? Ответ: язык Rust поднял бы панику во время выполнения точно так же, как если бы в векторе произошло обращение к недопустимому индексу¹:

thread 'main' panicked at 'byte index 1 is not a char boundary; it is inside '3' (bytes 0..2) of `Здравствуйте`', src/libcore/str/mod.rs:2188:4

Использовать интервалы для создания строковых срезов следует с осторожностью, потому что это может привести к аварийному сбою программы.

¹ поток 'main' вызвал панику в точке 'байтовый индекс 1 не является границей char; он находится внутри '3' (байты 0..2) цепочки `Здравствуйте`'