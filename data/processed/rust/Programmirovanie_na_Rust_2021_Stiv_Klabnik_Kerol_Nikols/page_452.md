---
source_image: page_452.png
page_number: 452
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 38.62
tokens: 7624
characters: 2630
timestamp: 2025-12-24T10:57:48.885077
finish_reason: stop
---

Компромиссы паттерна переходов между состояниями

Мы показали, что язык Rust способен реализовывать объектно-ориентированный паттерн переходов между состояниями с инкапсуляцией разных видов поведения, которые статья должна иметь в каждом состоянии. Методы для структуры Post ничего не знают о различных поведениях. Принятый нами принцип организации кода позволяет обращаться только в одно место, чтобы узнать, каким может быть поведение публикуемой статьи: к реализации типажа State в структуре Published.

Если бы мы создали альтернативную реализацию без паттерна переходов между состояниями, то можно было бы использовать выражения match в методах для структур Post или даже в коде функции main, которые проверяют состояние статьи и изменяют поведение в этих местах. Таким образом нам пришлось бы обращаться к нескольким местам, чтобы понять, какие последствия возможны, когда статья находится в опубликованном состоянии! Это увеличило бы число добавленных состояний: каждому из выражений match потребовался бы еще один рукав.

С паттерном переходов между состояниями методы структуры Post и места, которые мы используем в Post, не нуждаются в выражениях match. Для добавления нового состояния нам нужно будет только добавить новую структуру и реализовать методы типажа для этой структуры.

Реализация с паттерном переходов между состояниями легко расширяется, что дает большую функциональность. Убедитесь в простоте технического сопровождения кода с паттерном переходов между состояниями, выполнив несколько рекомендаций:

○ Добавьте метод reject, который изменяет состояние статьи из PendingReview в Draft.
○ Внесите требование делать два вызова метода approve, прежде чем состояние может быть изменено на Published.
○ Разрешите пользователям добавлять текстовое содержимое только в том случае, если статья находится в состоянии Draft. Подсказка: дайте объекту состояния возможность отвечать за то, что может меняться в содержимом, но не отвечать за модификацию структуры Post.

Одним из недостатков модели состояний является то, что, поскольку состояния реализуют переходы между собой, некоторые из них связаны друг с другом. Если бы между состояниями PendingReview и Published мы добавили еще одно состояние, к примеру, Scheduled, то нам пришлось бы изменить код в PendingReview для перехода в Scheduled. Было бы проще, если бы структуре PendingReview не требовалось вносить изменения с добавлением нового состояния, но это означало бы переход к другому паттерну проектирования.

Еще один недостаток заключается в том, что мы дублировали алгоритм. Ради устранения некоторых повторов мы могли бы сделать реализации по умолча-