---
source_image: page_508.png
page_number: 508
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 37.33
tokens: 7582
characters: 2187
timestamp: 2025-12-24T10:59:15.926178
finish_reason: stop
---

Этот код намного легче читать и писать! Выбор осмысленного имени для псевдонима типа также помогает сообщать ваше намерение (thunk («заставка») — это слово для кода, который будет вычислен позже, поэтому данное имя уместно для сохраняемого замыкания).

Псевдонимы типов также обычно используются с типом Result<T, E> для уменьшения повторов. Рассмотрим модуль std::io в стандартной библиотеке. Операции ввода-вывода часто возвращают тип Result<T, E> для урегулирования ситуаций, когда операции не срабатывают. Эта библиотека имеет структуру std::io::Error, которая представляет все возможные ошибки ввода-вывода. Многие функции в std::io будут возвращать Result<T, E>, где E — это std::io::Error, такие как эти функции в типаже Write:

use std::io::Error;
use std::fmt;

pub trait Write {
    fn write(&mut self, buf: &[u8]) -> Result<usize, Error>;
    fn flush(&mut self) -> Result<(), Error>;

    fn write_all(&mut self, buf: &[u8]) -> Result<(), Error>;
    fn write_fmt(&mut self, fmt: fmt::Arguments) -> Result<(), Error>;
}

Фрагмент Result<..., Error> часто повторяется. По этой причине std::io имеет в объявлении псевдонима такой тип:

type Result<T> = Result<T, std::io::Error>;

Поскольку это объявление находится в модуле std::io, мы можем использовать полный псевдоним std::io::Result<T>, то есть Result<T, E>, в котором E заполнен как std::io::Error. Сигнатуры типажа Write в итоге выглядят так:

pub trait Write {
    fn write(&mut self, buf: &[u8]) -> Result<usize>;
    fn flush(&mut self) -> Result<()>;

    fn write_all(&mut self, buf: &[u8]) -> Result<()>;
    fn write_fmt(&mut self, fmt: Arguments) -> Result<()>;
}

Псевдоним типа помогает в двух отношениях: он облегчает написание кода и обеспечивает согласованный интерфейс для всех std::io. Поскольку он представляет собой псевдоним, то это просто еще один Result<T, E>, а значит, мы можем использовать любые методы, которые работают с типом Result<T, E>, а также специальный синтаксис, такой как оператор ?.

Тип never, который никогда не возвращается

В Rust есть особый тип под названием !, который известен как пустой тип, потому что не имеет значений. Мы предпочитаем называть его типом never, потому что