---
source_image: page_399.png
page_number: 399
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 34.48
tokens: 7549
characters: 2069
timestamp: 2025-12-24T10:56:17.085071
finish_reason: stop
---

с именем branch со значением 5 и с leaf в качестве одного из его дочерних узлов, как показано в листинге 15.27.

Листинг 15.27. Создание узла leaf без дочерних узлов и узла branch с leaf в качестве одного из его дочерних узлов

src/main.rs
```rust
fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        children: RefCell::new(vec![]),
    });
    let branch = Rc::new(Node {
        value: 5,
        children: RefCell::new(vec![Rc::clone(&leaf)]),
    });
}
```

Мы клонируем умный указатель Rc<Node> из узла leaf и сохраняем его в узле branch, то есть экземпляр структуры Node в узле leaf теперь имеет двух владельцев: leaf и branch. Мы можем добраться из branch в leaf через branch.children, но путь из leaf в branch отсутствует. Причина в том, что leaf не имеет ссылки на branch и не знает, что они связаны. Мы хотим, чтобы узел leaf знал, что узел branch — его родитель. Мы сделаем это далее.

Добавление ссылки из дочернего узла на родительский

Для того чтобы дочерний узел знал о своем родителе, нужно добавить поле parent в определение структуры Node. Трудно решить, каким должен быть тип поля parent. Мы знаем, что оно не может содержать умный указатель Rc<T>, потому что это создаст цикл в переходах по ссылкам, где leaf.parent будет указывать на branch, а branch.children будет указывать на leaf, поэтому значения их чисел strong_count никогда не будут равны 0.

Если рассмотреть связи с другой стороны, родительский узел должен владеть своими дочерними узлами: если родительский узел отброшен, то и его дочерние узлы тоже должны быть отброшены. Однако дочерний узел не должен владеть своим родителем: если мы отбросим дочерний узел, то родитель все равно должен существовать. Это как раз тот случай, который относится к слабым ссылкам!

Таким образом, вместо умного указателя Rc<T> мы сделаем так, чтобы тип родителя использовал тип Weak<T>, а точнее — умный указатель RefCell<Weak<Node>>. Теперь определение структуры Node выглядит следующим образом:

src/main.rs
```rust
use std::rc::{Rc, Weak};
use std::cell::RefCell;

#[derive(Debug)]
```