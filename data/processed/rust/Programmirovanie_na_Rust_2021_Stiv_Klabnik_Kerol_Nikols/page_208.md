---
source_image: page_208.png
page_number: 208
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 30.11
tokens: 7543
characters: 2144
timestamp: 2025-12-24T10:51:11.993582
finish_reason: stop
---

время выполнения. Еще один пример — использование беззнакового целочисленного типа, например u32, который обеспечивает нетрицательность параметра.

Создание настраиваемых типов для проверки допустимости

Давайте разовьем идею о том, что можно использовать систему типов языка Rust, чтобы у нас было действительное значение. Мы посмотрим, как создать настраиваемый тип для проверки. Вспомните игру на угадывание в главе 2, в которой код просил пользователя угадать число от 1 до 100. Мы так и не подтвердили, находится ли догадка пользователя в интервале между 1 и 100, перед тем как сверить его с секретным числом; мы только подтвердили, что догадка является положительным числом. В том случае последствия были не очень страшными: наш результат «Слишком большое» или «Слишком маленькое» все равно был бы правильным. Но все же было бы полезно усовершенствовать этот код, направляя пользователя к допустимым отгадкам и действуя по-разному, когда пользователь загадывает число, которое находится вне интервала, и когда вместо этого, к примеру, пользователь набирает на клавиатуре буквы.

Один из способов это сделать — выполнять разбор загаданного числа не только как тип u32, но и как тип i32, допустив потенциально отрицательные числа, а затем добавить проверку на предмет того, что число находится внутри интервала, например, вот так:

loop {
    // --пропуск--
    let guess: i32 = match guess.trim().parse() {
        Ok(num) => num,
        Err(_) => continue,
    };

    if guess < 1 || guess > 100 {
        println!("Секретное число будет между 1 и 100.");
        continue;
    }

    match guess.cmp(&secret_number) {
        // --пропуск--
    }
}

Выражение if проверяет, находится ли значение вне интервала, сообщает пользователю о проблеме и вызывает continue, начиная следующую итерацию цикла и запрашивая еще одно загаданное число. После выражения if мы можем продолжить сравнение загаданного числа guess с секретным числом, зная, что загаданное число находится между 1 и 100.

Однако это неидеальное решение: если бы было чрезвычайно важно, чтобы программа работала только со значениями от 1 до 100 и у нее было бы много функций