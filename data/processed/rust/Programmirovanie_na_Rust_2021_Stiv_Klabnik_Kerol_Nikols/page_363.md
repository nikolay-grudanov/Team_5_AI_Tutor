---
source_image: page_363.png
page_number: 363
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 33.09
tokens: 7596
characters: 2217
timestamp: 2025-12-24T10:55:21.355590
finish_reason: stop
---

указатели реализуют типажи Deref и Drop. Типаж Deref позволяет экземпляру структуры умного указателя вести себя как ссылка, поэтому вы можете писать код, который работает либо со ссылками, либо с умными указателями. Типаж Drop позволяет настраивать код, который выполняется, когда экземпляр умного указателя выходит из области видимости. В этой главе мы обсудим оба типажа и объясним, почему они важны для умных указателей.

С учетом того, что паттерн умного указателя — это общий паттерн проектирования, часто используемый в Rust, эта глава не охватит каждый существующий умный указатель. Многие библиотеки имеют свои умные указатели, и вы даже можете написать собственный указатель. Мы рассмотрим умные указатели, наиболее часто встречающиеся в стандартной библиотеке:

○ Умный указатель Box<T> для размещения значений в куче.
○ Умный указатель Rc<T> — тип подсчета числа ссылок, который обеспечивает множественное владение.
○ Умные указатели Ref<T> и RefMut<T> с доступом через RefCell<T> — тип, который обеспечивает соблюдение правил заимствования во время выполнения, а не во время компиляции.

Кроме того, мы рассмотрим паттерн внутренней изменяемости, в котором неизменяемый тип предоставляет API для изменения внутреннего значения. Мы также обсудим тему циклов в переходах по ссылкам: как они приводят к утечке памяти и как их предотвращать.

Давайте приступим!

Использование Box<T> для указания на данные в куче

Наиболее простым умным указателем является Box, тип которого записывается как Box<T>. Умные указатели Box позволяют хранить данные не в стеке, а в куче. В стеке же остается указатель на данные кучи. Обратитесь к главе 4, чтобы вспомнить разницу между стеком и кучей.

Помимо хранения своих данных в куче, а не в стеке, умные указатели Box не производят трудоемких операций, сказывающихся на производительности. Но у них, впрочем, не так много дополнительных способностей. Вы будете использовать их чаще всего в следующих ситуациях:

○ У вас есть тип, размер которого нельзя узнать во время компиляции, и вы хотите использовать значение этого типа в контексте, требующем точного размера.
○ У вас крупный объем данных, и вы хотите передать владение так, чтобы при этом данные не были скопированы.