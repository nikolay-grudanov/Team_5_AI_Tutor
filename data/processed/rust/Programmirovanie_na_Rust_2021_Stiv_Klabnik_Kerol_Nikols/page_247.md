---
source_image: page_247.png
page_number: 247
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 36.58
tokens: 7683
characters: 2449
timestamp: 2025-12-24T10:52:19.948365
finish_reason: stop
---

Теперь все ссылки в этой сигнатуре функции имеют жизненный цикл, и компилятор может продолжать анализ. Участие программиста, который аннотировал бы жизненный цикл в сигнатуре этой функции, не требуется.

Давайте посмотрим еще на один пример, на этот раз используя функцию longest, которая не имела никаких параметров жизненных циклов, когда мы начали работать с ней в листинге 10.21:

fn longest(x: &str, y: &str) -> &str {

Давайте применим первое правило: каждый параметр получает собственный жизненный цикл. На этот раз у нас два параметра вместо одного, поэтому имеется два жизненных цикла:

fn longest<'a, 'b>(x: &'a str, y: &'b str) -> &str {

Вы видите, что второе правило не применяется, потому что существует более одного входного жизненного цикла. Третье правило тоже неприменимо, потому что longest является функцией, а не методом, поэтому ни один из параметров не является параметром self. Поработав со всеми тремя правилами, мы все еще не выяснили продолжительность жизненного цикла возвращаемого типа. Вот почему мы получили ошибку, пытаясь скомпилировать код в листинге 10.21: компилятор работал с правилами исключения жизненного цикла, но так и не смог вычислить все жизненные циклы ссылок в сигнатуре.

Поскольку третье правило применяется только в сигна турах методов, далее мы рассмотрим жизненный цикл в данном контексте, чтобы увидеть, почему третье правило означает, что нам не нужно очень часто аннотировать жизненный цикл в сигна турах методов.

Аннотации жизненных циклов в определениях методов

Когда мы реализуем методы в структуре с жизненным циклом, то используем тот же синтаксис, что и для параметров обобщенного типа, показанный в листин ге 10.11. То, где мы объявляем и используем параметры жизненных циклов, зависит от того, связаны ли они с полями структуры либо с параметрами метода и возвращаемыми значениями.

Имена жизни для полей структуры всегда должны объявляться после ключевого слова impl и затем использоваться после имени структуры, потому что эти жизненные циклы являются частью типа структуры.

В сигна турах методов внутри блока impl ссылки могут быть привязаны к жизненному циклу ссылок в полях структуры, либо они могут быть независимыми. В дополнение к этому, правила исключения жизненного цикла приводят к тому, что аннотации жизненных циклов не нужны в сигна турах методов. Давайте посмотрим на несколько примеров использования структуры ImportantExcerpt, которую мы определили в листинге 10.25.