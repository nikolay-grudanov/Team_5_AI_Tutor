---
source_image: page_327.png
page_number: 327
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 35.14
tokens: 7554
characters: 2103
timestamp: 2025-12-24T10:54:26.634121
finish_reason: stop
---

В языках, в которых итераторы не предусмотрены стандартными библиотеками, вы, вероятно, пишете эту же функциональность, начав переменную в индексе 0, используя ее для доступа внутри вектора по индексу, чтобы получить значение, и увеличивая значение переменной в цикле до тех пор, пока оно не достигнет суммарного числа элементов в векторе.

Итераторы обрабатывают этот алгоритм за вас, сокращая повторяющийся код, который вы потенциально можете испортить. Итераторы дают больше гибкости при использовании одного и того же алгоритма с несколькими разными типами последовательностей, а не только с теми структурами данных, которые вы можете индексировать как векторы. Давайте посмотрим, как итераторы это делают.

Типаж Iterator и метод next

Все итераторы реализуют типаж Iterator, определенный в стандартной библиотеке. Определение этого типажа выглядит следующим образом:

```rust
pub trait Iterator {
    type Item;

    fn next(&mut self) -> Option<Self::Item>;

    // методы с реализациями по умолчанию опускаются
}
```

Обратите внимание, что в данном определении используется новый синтаксис: type Item и Self::Item, который определяет тип, связанный с этим типажом. Мы подробно поговорим о связанных типах в главе 19. А пока вам нужно знать лишь одно: этот код говорит о том, что реализация типажа Iterator требует, чтобы вы также определили тип Item, который используется в качестве типа, возвращаемого из метода next. Другими словами, Item будет типом, возвращаемым из итератора.

Типаж Iterator требует от разработчиков определения только одного метода — next, который возвращает по одному элементу итератора, завернутому в Some, за раз, а когда перебор завершается, он возвращает None.

Мы можем вызывать метод next непосредственно для итераторов. Листинг 13.15 демонстрирует, какие значения возвращаются при повторных вызовах метода next для итератора, созданного из вектора.

Листинг 13.15. Вызов метода next для итератора
src/lib.rs

```rust
#[test]
fn iterator_demonstration() {
    let v1 = vec![1, 2, 3];

    let mut v1_iter = v1.iter();

    assert_eq!(v1_iter.next(), Some(&1));
```