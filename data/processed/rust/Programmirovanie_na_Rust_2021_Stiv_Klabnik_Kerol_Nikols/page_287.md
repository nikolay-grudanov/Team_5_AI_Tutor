---
source_image: page_287.png
page_number: 287
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 30.98
tokens: 7539
characters: 2204
timestamp: 2025-12-24T10:53:19.572268
finish_reason: stop
---

}
⑤ struct Config {
    query: String,
    filename: String,
}

⑥ fn parse_config(args: &[String]) -> Config {
    ⑦ let query = args[1].clone();
    ⑧ let filename = args[2].clone();

    Config { query, filename }
}

Мы добавили структуру с именем Config, определенную для полей query и filename ⑤. Сигнатура parse_config теперь указывает на то, что она возвращает значение типа Config ⑥. В теле parse_config, где мы обычно возвращали строковые срезы, ссылающиеся на значения типа String в args, теперь мы определяем структуру Config, которая содержит обладаемые значения типа String. Переменная args в функции main является владельцем значений аргументов и позволяет функции parse_config их заимствовать. Это означает, что мы бы нарушили правила заимствования языка Rust, если бы структура Config попыталась взять значения в args во владение.

Мы могли бы управлять данными String несколькими разными способами, но самый простой маршрут, хотя и несколько неэффективный, — вызывать метод clone для значений ⑦⑧. В результате этого появится полная копия данных, дав возможность экземпляру Config владеть, что займет больше времени и памяти, чем хранение ссылки на строковые данные. Однако клонирование данных также делает код очень простым, потому что не нужно управлять жизненными циклами ссылок. В этих обстоятельствах отказ от небольшой производительности ради достижения простоты — ценный компромисс.

КОМПРОМИССЫ ИСПОЛЬЗОВАНИЯ МЕТОДА CLONE

Многие растягивате избегают метод clone для решения проблем владения в связи с затратностью времени его выполнения. В главе 13 вы узнаете, как в подобных ситуациях использовать более эффективные методы. Но сейчас можно скопировать несколько строк, чтобы продолжить, так как вы сделаете эти копии только один раз, а имя файла и строка запроса очень малы. Лучше иметь программу, которая работает, но при этом несколько неэффективна, чем пытаться улучшить код сверх меры на первом этапе. Когда вы наберетесь опыта, вам будет легче начать с самого эффективного решения, однако пока вполне приемлемо вызывать clone.

Мы обновили функцию main так, что она поместила экземпляр структуры Config, возвращаемый функцией parse_config, в переменную с именем config ①. Мы