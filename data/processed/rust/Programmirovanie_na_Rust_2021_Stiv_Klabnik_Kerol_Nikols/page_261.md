---
source_image: page_261.png
page_number: 261
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 32.88
tokens: 7523
characters: 2110
timestamp: 2025-12-24T10:52:41.266809
finish_reason: stop
---

---- tests::greeting_contains_name stdout ----
    thread 'tests::greeting_contains_name' panicked at 'assertion failed:
result.contains("Кэрол")', src/lib.rs:12:8
note: Run with `RUST_BACKTRACE=1` for a backtrace.

failures:
    tests::greeting_contains_name

Этот результат просто указывает, что проверочное утверждение не прошло и на какой строке оно находится. Более полезное сообщение об ошибке в этом случае будет печатать значение, которое мы получили из функции greeting. Давайте изменим тестовую функцию, дав ей сообщение об ошибке для пользователя, состоящее из форматной строки с заполнителем, имеющим фактическое значение, полученное из функции greeting:

#[test]
fn greeting_contains_name() {
    let result = greeting("Кэрол");
    assert!(
        result.contains("Кэрол"),
        "Приветствие не содержало имя, предоставлено значение `{}`", result
    );
}

Теперь, выполнив этот тест, мы получим более информативное сообщение об ошибке:

---- tests::greeting_contains_name stdout ----
    thread 'tests::greeting_contains_name' panicked at 'Приветствие не содержало имя, предоставлено значение `Здравствуй!`', src/lib.rs:12:8
note: Run with `RUST_BACKTRACE=1` for a backtrace.

В тестовых данных мы видим значение, полученное фактически, которое поможет отладить то, что произошло, а не то, что вероятно произойдет.

Проверка на панику с помощью атрибута should_panic

В дополнение к проверке правильности ожидаемых значений, возвращаемых кодом, также важно проверить, что код обрабатывает условия возникновения ошибки, как мы ожидаем. Например, рассмотрим тип Guess, который мы создали в листинге 9.10. Другой код, использующий тип Guess, зависит от гарантии того, что экземпляры типа Guess будут содержать значения в интервале только между 1 и 100. Мы можем написать тест, который обеспечивает, чтобы попытка создать экземпляр типа Guess со значением вне этого интервала поднимала панику.

Мы делаем это, добавляя еще один атрибут, should_panic, в тестовую функцию. Этот атрибут делает тест успешным, если код внутри функции паникует. Тест не сработает, если код внутри функции не паникует.