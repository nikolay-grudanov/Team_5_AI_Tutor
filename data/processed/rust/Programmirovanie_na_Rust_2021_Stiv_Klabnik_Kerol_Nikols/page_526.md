---
source_image: page_526.png
page_number: 526
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 33.89
tokens: 7619
characters: 2237
timestamp: 2025-12-24T10:59:42.693760
finish_reason: stop
---

ляют создавать новые атрибуты. Они также более гибкие: derive работает только для структур и перечислений, атрибуты могут применяться и к другим элементам, таким как функции. Вот пример использования макрокоманды, подобной атрибутам: допустим, у вас есть атрибут с именем route, который аннотирует функции при использовании каркаса веб-приложения:

    #[route(GET, "/")]
    fn index() {

Этот атрибут #[route] будет определен программным каркасом как процедурная макрокоманда. Сигнатура функции определения макрокоманд будет выглядеть следующим образом:

    #[proc_macro_attribute]
    pub fn route(attr: TokenStream, item: TokenStream) -> TokenStream {

Здесь мы имеем два параметра типа TokenStream. Первый — для содержимого атрибута: GET, часть «/». Второй — это тело элемента, к которому атрибут прикреплен: в данном случае FN index () {} и остальная часть тела функции.

Помимо этого, макрокоманды, подобные атрибутам, работают так же, как настраиваемые макрокоманды с атрибутом derived: вы создаете упаковку с типом упаковки proc-macro и реализуете функцию, которая генерирует нужный код.

Макрокоманды, подобные функциям

Макрокоманды, подобные функциям, определяют макрокоманды, которые выглядят как вызовы функций. Аналогично макрокомандам macro_rules! они более гибкие, чем функции: например, они могут брать неизвестное число аргументов. Однако макрокоманды macro_rules! могут быть определены только с помощью синтаксиса, похожего на выражение match, который мы обсуждали в разделе «Декларативные макрокоманды с помощью macro_rules! для общего метапрограммирования» (с. 516). Макрокоманды, подобные функциям, берут параметр TokenStream, а их определение манипулирует TokenStream, используя код Rust, как и другие два типа процедурных макрокоманд. Пример макрокоманды, подобной функциям, — макрокоманда sql!, которую можно вызвать так:

    let sql = sql!(SELECT * FROM posts WHERE id=1);

Эта макрокоманда выполнит разбор инструкции SQL внутри себя и проверит ее на синтаксическую правильность, что представляет собой намного более сложную обработку, чем способна сделать макрокоманда macro_rules!. Макрокоманда sql! будет определена следующим образом:

    #[proc_macro]
    pub fn sql(input: TokenStream) -> TokenStream {