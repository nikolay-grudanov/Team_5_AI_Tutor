---
source_image: page_333.png
page_number: 333
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 33.05
tokens: 7520
characters: 2036
timestamp: 2025-12-24T10:54:34.142190
finish_reason: stop
---

значение, завернутое в Some, но если count равен 6 или выше, то итератор будет возвращать None.

Использование метода next итератора структуры Counter

После того как мы реализовали типаж Iterator, у нас появился итератор! В листинге 13.22 показан тест, демонстрирующий, что мы можем использовать итераторную функциональность структуры Counter, напрямую вызывая метод next точно так же, как мы это делали с итератором, созданным из вектора в листинге 13.15.

Листинг 13.22. Тестирование функциональности реализации метода next
src/lib.rs
#[test]
fn calling_next_directly() {
    let mut counter = Counter::new();

    assert_eq!(counter.next(), Some(1));
    assert_eq!(counter.next(), Some(2));
    assert_eq!(counter.next(), Some(3));
    assert_eq!(counter.next(), Some(4));
    assert_eq!(counter.next(), Some(5));
    assert_eq!(counter.next(), None);
}

Этот тест создает в переменной counter новый экземпляр структуры Counter, а затем повторно вызывает метод next, проверяя, что мы реализовали нужное поведение итератора, а именно возвращение значений от 1 до 5.

Использование других методов типажа Iterator

Мы реализовали типаж Iterator путем определения метода next, поэтому теперь мы можем использовать реализации по умолчанию любого метода типажа Iterator, определенного в стандартной библиотеке, поскольку все они используют функциональность метода next.

Например, если по какой-то причине мы хотим взять значения, произведенные экземпляром структуры Counter, соединить их в пары со значениями, произведенными еще одним экземпляром структуры Counter после пропуска первого значения, перемножить пары между собой, сохранить только те результаты, которые делятся на 3, и сложить все полученные значения вместе, то мы можем сделать это, как показано в тесте из листинга 13.23.

Листинг 13.23. Использование различных методов типажа Iterator для итератора структуры Counter
src/lib.rs
#[test]
fn using_other_iterator_trait_methods() {
    let sum: u32 = Counter::new().zip(Counter::new().skip(1))
        .map(|(a, b)| a * b)