---
source_image: page_146.png
page_number: 146
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 21.17
tokens: 7333
characters: 1505
timestamp: 2025-12-24T10:49:21.673532
finish_reason: stop
---

Дим, и при этом называть штаты четвертаков, то мы могли бы сделать это с помощью такого выражения match:

let mut count = 0;
match coin {
    Coin::Quarter(state) => println!("Четвертак из штата {:?}!", state),
    _ => count += 1,
}

Или мы могли бы использовать выражения if let и else:

let mut count = 0;
if let Coin::Quarter(state) = coin {
    println!("Четвертак из штата {:?}!", state);
} else {
    count += 1;
}

В ситуации, когда логика программы слишком многословна, чтобы выразить ее с помощью match, помните, if let также находится в арсенале инструментов Rust.

Итоги

Выше мы показали, как использовать перечисления для создания настраиваемых типов, которые могут принимать одно из множества перечисляемых значений. Мы продемонстрировали, как тип Option<T> стандартной библиотеки помогает использовать систему типов для предотвращения ошибок. Когда значения перечисления содержат данные, вы можете использовать match или if let для извлечения и использования этих значений, в зависимости от того, сколько случаев вам нужно учитывать.

Ваши программы на Rust теперь могут выражать понятия в домене с помощью структур и перечислений. Создание настраиваемых типов для использования в API обеспечивает безопасность типов: компилятор сделает так, чтобы функции получали только те значения типа, которые ожидает каждая функция.

Для того чтобы дать вашим пользователям хорошо организованный API, простой в использовании и предоставляющий только то, что нужно, давайте теперь обратимся к модулям.