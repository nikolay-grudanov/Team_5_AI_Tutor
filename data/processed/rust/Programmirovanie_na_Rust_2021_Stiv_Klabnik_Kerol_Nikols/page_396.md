---
source_image: page_396.png
page_number: 396
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 37.60
tokens: 7602
characters: 2201
timestamp: 2025-12-24T10:56:20.010622
finish_reason: stop
---

```rust
if let Some(link) = a.tail() {
    *link.borrow_mut() = Rc::clone(&b);
}

println!("b число rc после изменения а = {}", Rc::strong_count(&b));
println!("a число rc после изменения а = {}", Rc::strong_count(&a));

// Раскомментируйте следующую строку кода, и вы увидите, что у нас цикл;
// он переполнит стек.
// println!("a следующий элемент = {:?}", a.tail());
}
```

Мы создаем экземпляр Rc<List>, содержащий значение типа List в переменной a с начальным списком, состоящим из 5, Nil ①. Затем мы создаем экземпляр Rc<List>, содержащий еще одно значение типа List в переменной b, которая содержит значение 10 и указывает на список в a ②.

Мы модифицируем переменную a так, чтобы она указывала на b вместо Nil, создавая цикл. Мы делаем это с помощью метода tail, получающего ссылку на RefCell<Rc<List>> в a, которую мы помещаем в переменную link ③. Затем мы применяем метод borrow_mut для RefCell<Rc<List>>, чтобы изменить значение внутри с Rc<List>, который содержит значение Nil, на Rc<List> в b ④.

Когда мы выполним этот код, оставив последнюю инструкцию println! закомментированной, мы получим такие данные:

a начальное число rc = 1
a следующий элемент = Some(RefCell { value: Nil })
a число rc после создания b = 2
b начальное число rc = 1
b следующий элемент = Some(RefCell { value: Cons(5, RefCell { value: Nil }) })
b число rc после изменения а = 2
a число rc после изменения а = 2

Число ссылок экземпляров умного указателя Rc<List> в a и b равно 2 после того, как мы изменим список в a, чтобы он указывал на b. В конце функции main компилятор попытается сначала удалить b, что уменьшит число экземпляров умного указателя Rc<List> в b на 1.

Однако, поскольку a по-прежнему ссылается на умный указатель Rc<List>, который был в b, этот Rc<List> имеет число 1, а не 0, поэтому память для умного указателя Rc<List> в куче удалена не будет. Память просто останется там навсегда с числом 1. Для визуализации этого цикла в переходах по ссылкам мы создали диаграмму на рис. 15.4.

Если вы раскомментируете последнюю инструкцию println! и выполните программу, Rust попытается напечатать этот цикл, в котором a указывает на b, который указывает на a, и так далее, пока он не переполнит стек.