---
source_image: page_567.png
page_number: 567
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 35.78
tokens: 7553
characters: 2282
timestamp: 2025-12-24T11:00:50.501741
finish_reason: stop
---

Теперь мы перебираем работников дважды: один раз для отправки одного сообщения Terminate для каждого работника ① и один раз для вызова join в поток каждого работника ②. Если бы мы попытались отправить сообщение и сразу же вызвать join в том же цикле, то мы бы не смогли гарантировать, что работник в текущей итерации будет именно тем, кто получит сообщение из канала.

Чтобы лучше понять, зачем нужно два отдельных цикла, представьте себе сценарий с двумя работниками. Если бы мы использовали один цикл для итерации по каждому работнику, то во время первой итерации сообщение о завершении было бы отправлено по каналу, а метод join был бы вызван для потока первого работника. Если первый работник был бы в этот момент занят обработкой запроса, то второй работник подобрав бы указанное сообщение из канала и отключился бы. Нам пришлось бы ждать, пока отключится первый работник, но это так не произойдет, потому что сообщение о завершении приняли второй поток. Взаимоблокировка!

Для того чтобы предотвратить этот сценарий, мы сначала помещаем все сообщения Terminate в канале в один цикл, затем выполняем join для всех потоков исполнения в еще одном цикле. Каждый работник прекратит получать запросы на канале, как только получит сообщение о завершении. Таким образом, мы можем быть уверены в том, что, если отправляем такое же число сообщений о завершении, что и число работников, каждый работник получит такое сообщение до вызова метода join для своего потока.

Для того чтобы увидеть этот код в действии, давайте модифицируем функцию main так, чтобы принимать только два запроса, прежде чем корректно завершить работу сервера, как показано в листинге 20.26.

Листинг 20.26. Выключение сервера после выполнения двух запросов путем выхода из цикла

src/bin/main.rs
```rust
fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();
    let pool = ThreadPool::new(4);

    for stream in listener.incoming().take(2) {
        let stream = stream.unwrap();

        pool.execute(|| {
            handle_connection(stream);
        });
    }

    println!("Выключение.");
}
```

Не хотелось, чтобы реальный веб-сервер выключался после обслуживания только двух запросов. Этот код просто демонстрирует, что корректное отключение и очистка находятся в рабочем состоянии.