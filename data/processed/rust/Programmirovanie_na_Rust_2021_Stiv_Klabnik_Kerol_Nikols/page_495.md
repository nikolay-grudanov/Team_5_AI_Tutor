---
source_image: page_495.png
page_number: 495
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 30.91
tokens: 7522
characters: 2011
timestamp: 2025-12-24T10:58:47.914282
finish_reason: stop
---

Один из примеров типажа со связанным типом — Iterator, предусмотренный стандартной библиотекой. Связанный тип называется Item и исполняет роль типа значений, которые перебирает тип, реализующий типаж Iterator. В разделе «Типаж Iterator и метод next» (с. 327) мы упомянули, что определение Iterator выглядит так, как показано в листинге 19.12.

Листинг 19.12. Определение типажа Iterator со связанным типом Item

```rust
pub trait Iterator {
    type Item;

    fn next(&mut self) -> Option<Self::Item>;
}
```

Тип Item заполнительный, определение метода next показывает, что он будет возвращать значения типа Option<Self::Item>. Средства типажа Iterator будут описывать конкретный тип для Item, а метод next будет возвращать тип Option, содержащий значение этого конкретного типа.

Может показаться, что связанные типы похожи на обобщения, поскольку последние позволяют определять функцию, не указывая, с какими типами она может работать. Тогда зачем использовать связанные типы?

Рассмотрим разницу между этими идеями на примере из главы 13, в котором реализован типаж Iterator в структуре Counter. В листинге 13.21 мы описали, что у Item был тип u32:

src/lib.rs
```rust
impl Iterator for Counter {
    type Item = u32;

    fn next(&mut self) -> Option<Self::Item> {
        // --пропуск--
    }
}
```

Кажется, что этот синтаксис сопоставим с синтаксисом обобщений. Тогда почему бы просто не определить типаж Iterator с помощью обобщений, как показано в листинге 19.13?

Листинг 19.13. Гипотетическое определение типажа Iterator с использованием обобщений

```rust
pub trait Iterator<T> {
    fn next(&mut self) -> Option<T>;
}
```

Разница заключается в том, что при использовании обобщенных типов, как в листинге 19.13, мы должны аннотировать типы в каждой реализации. Поскольку мы также можем реализовать Iterator<String> for Counter или сделать это с участием любого другого типа, у нас может быть несколько реализаций Iterator для Counter. Другими словами, когда у типажа обобщенный параметр, его можно