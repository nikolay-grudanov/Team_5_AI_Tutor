---
source_image: page_322.png
page_number: 322
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 31.41
tokens: 7537
characters: 2116
timestamp: 2025-12-24T10:54:12.336800
finish_reason: stop
---

Не сохраняя замыкание непосредственно в переменной, мы сохраняем новый экземпляр структуры Cacher, который содержит замыкание ①. Затем в каждом месте, где мы хотим получить результат ②③④, вызываем метод value для экземпляра Cacher. Можно вызывать метод value сколько угодно или не вызывать его вообще, и затратное вычисление будет исполнено максимум один раз.

Попробуйте выполнить эту программу с помощью функции main из листинга 13.2. Измените значения в переменных simulated_user_specified_value и simulated_random_number, чтобы проверить, что во всех случаях в различных блоках if и else сообщение вычисляется медленно... появляется только один раз и только при необходимости. Cacher отвечает за алгоритм, необходимый для того, чтобы не вызывать затратное вычисление чаще, чем нужно, благодаря чему функция generate_workout может сосредоточиться на логике функционирования.

Ограничения в реализации структуры Cacher

Кэширование значений в общем-то является полезным, его можно использовать в других частях кода с разными замыканиями. Однако в текущей реализации структуры Cacher есть две проблемы, которые затрудняют ее повторное использование в разных контекстах.

Первая проблема заключается в том, что для экземпляра структуры Cacher предполагается, что он всегда будет получать одно и то же значение для параметра arg в методе value. То есть этот тест структуры Cacher не сработает:

#[test]
fn call_with_different_values() {
    let mut c = Cacher::new(|a| a);

    let v1 = c.value(1);
    let v2 = c.value(2);

    assert_eq!(v2, 2);
}

Этот тест создает новый экземпляр структуры Cacher с замыканием, которое возвращает переданное в него значение. Мы вызываем метод value для этого экземпляра структуры Cacher со значением arg, равным 1, а затем значением arg, равным 2, и ожидаем, что вызов метода value со значением arg, равным 2, вернет 2.

Выполните этот тест, реализовав структуру Cacher из листингов 13.9 и 13.10, и тест не сработает на assert_eq! с таким сообщением:

thread 'call_with_different_values' panicked at 'assertion failed: `(left == right)`
    left: `1`,
    right: `2`, src/main.rs