---
source_image: page_564.png
page_number: 564
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 31.43
tokens: 7434
characters: 1830
timestamp: 2025-12-24T11:00:38.785748
finish_reason: stop
---

// --пропуск--

    Worker {
        id,
        thread: Some(thread),
    }
}

Первая ошибка находится в реализации типажа Drop. Ранее мы упоминали, что намеревались вызывать take для значения Option, чтобы перемещать thread из Worker. Следующие изменения нужны как раз для этого:

src/lib.rs

impl Drop for ThreadPool {
    fn drop(&mut self) {
        for worker in &mut self.workers {
            println!("Отключение работника {}", worker.id);

            if let Some(thread) = worker.thread.take() { // 1
                thread.join().unwrap(); // 2
            }
        }
    }
}

Как обсуждалось в главе 17, метод take для Option вынимает вариант Some и не трогает None. Мы используем if let для деструктурирования Some и получения потока 1; затем мы вызываем метод join для потока 2. Если поток Worker равен None, то мы знаем, что поток Worker уже был очищен, поэтому в таком случае ничего не происходит.

Подача потокам сигнала об остановке прослушивания заданий

Благодаря внесенным изменениям код компилируется без предупреждений. Но есть и плохая новость: этот код пока что не функционирует так, как мы хотим. Ключом является алгоритм в замыканиях, выполняемых нитями экземпляров типа Worker: в данный момент мы вызываем метод join, но из-за этого потоки не отключаются, потому что находятся в бесконечном цикле в поисках заданий. Если мы попытаемся отбросить ThreadPool с текущей реализацией drop, то главный поток исполнения навсегда заблокируется, ожидая завершения первого потока.

Для устранения этой проблемы мы выполним модификацию потоков исполнения так, чтобы они прослушивали либо подлежащее выполнению задание Job, либо сигнал о том, что они должны прекратить прослушивание и выйти из бесконечного цикла. Вместо экземпляров типа Job канал будет отправлять один из приведенных ниже вариантов перечисления.