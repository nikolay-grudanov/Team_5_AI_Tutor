---
source_image: page_328.png
page_number: 328
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 35.08
tokens: 7549
characters: 2126
timestamp: 2025-12-24T10:54:28.387678
finish_reason: stop
---

assert_eq!(v1_iter.next(), Some(&2));
    assert_eq!(v1_iter.next(), Some(&3));
    assert_eq!(v1_iter.next(), None);
}

Обратите внимание, что нам нужно было сделать v1_iter изменяемым: вызов метода next для итератора изменяет внутреннее состояние, которое итератор использует для отслеживания своей позиции в последовательности. Другими словами, этот код потребляет, или расходует, итератор. Каждый вызов метода next съедает элемент из итератора. Когда мы использовали цикл for, нам не нужно было делать v1_iter изменяемым, потому что указанный цикл брал v1_iter во владение и делал его изменяемым неявно.

Также обратите внимание на то, что значения, которые мы получаем от вызовов метода next, являются неизменяемыми ссылками на значения в векторе. Метод iter создает итератор для неизменяемых ссылок. Если мы хотим создать итератор, который берет v1 во владение и возвращает обладаемые значения, то мы вызываем into_iter вместо iter. Схожим образом, если мы хотим перебрать изменяемые ссылки, то мы вызываем iter_mut вместо iter.

Методы, которые потребляют итератор

В типаже Iterator имеется ряд разных методов с реализациями по умолчанию, предусмотренными стандартной библиотекой. Вы найдете сведения об этих методах, если заглянете в документацию API стандартной библиотеки о типаже Iterator. Некоторые из них вызывают метод next в своем определении, и именно поэтому требуется реализовать метод next во время реализации типажа Iterator.

Методы, которые вызывают next, называются «потребляющие адаптеры», потому что их вызов расходует итератор. Одним из примеров является метод sum, который берет итератор во владение и перебирает элементы, повторно вызывая next, тем самым потребляя итератор. По мере перебора он добавляет каждый элемент в промежуточную сумму и возвращает его по завершении итераций. В листинге 13.16 приводится тест, иллюстрирующий использование метода sum.

Листинг 13.16. Вызов метода sum для получения суммы всех элементов в итераторе
src/lib.rs
#[test]
fn iterator_sum() {
    let v1 = vec![1, 2, 3];
    let v1_iter = v1.iter();
    let total: i32 = v1_iter.sum();
    assert_eq!(total, 6);
}