---
source_image: page_249.png
page_number: 249
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 31.30
tokens: 7553
characters: 2161
timestamp: 2025-12-24T10:52:19.832553
finish_reason: stop
---

Параметры обобщенного типа, границы типажа и жизненный цикл вместе

Давайте вкратце рассмотрим синтаксис описания параметров обобщенного типа, границ типажа и жизненных циклов в одной функции.

use std::fmt::Display;

fn longest_with_an_announcement<'a, T>(x: &'a str, y: &'a str, ann: T) -> &'a str
    where T: Display
{
    println!("Объявление! {}", ann);
    if x.len() > y.len() {
        x
    } else {
        y
    }
}

Выше приведена функция longest из листинга 10.22, которая возвращает самый длинный строковый срез из двух. Но теперь у нее есть дополнительный параметр с именем ann обобщенного типа T, который может быть заполнен любым типом, реализующим типаж Display, как указано в условии where. Этот дополнительный параметр будет напечатан перед тем, как функция сравнит длины строковых срезов, и именно поэтому требуется граница типажа Display. Поскольку жизненный цикл является типом обобщения, объявления параметра жизненного цикла 'a и параметра обобщенного типа T помещаются в один и тот же список внутри угловых скобок после имени функции.

Итоги

В этой главе мы узнали много нового! Теперь, когда вам известны параметры обобщенного типа, типажи и границы типажа, а также параметры обобщенных жизненных циклов, вы готовы писать код без повторов, который работает в различных ситуациях. Параметры обобщенного типа позволяют применять код к разным типам. Типажи и границы типажа обеспечивают, чтобы, даже если типы являются обобщенными, они имели свойства, необходимые коду. Вы узнали, как использовать аннотации жизненных циклов, чтобы у гибкого кода не было висячих ссылок. И весь этот анализ происходит во время компиляции, что не влияет на производительность времени выполнения!

Вы не поверите, но нам предстоит еще многое узнать по темам, которые мы обсудили в этой главе: глава 17 посвящена типажным объектам, которые представляют собой еще один способ использования типажей. В главе 19 рассказывается о более сложных сценариях, сопряженных с аннотациями жизненных циклов, а также о нескольких расширенных языковых средствах системы типов. А в следующей главе вы научитесь писать тесты на Rust, чтобы ваш код работал должным образом.