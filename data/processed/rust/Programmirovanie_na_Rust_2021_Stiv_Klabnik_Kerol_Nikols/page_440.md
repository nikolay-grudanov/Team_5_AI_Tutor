---
source_image: page_440.png
page_number: 440
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 25.93
tokens: 7452
characters: 2006
timestamp: 2025-12-24T10:57:17.402087
finish_reason: stop
---

Листинг 17.9. Использование типажных объектов для хранения значений разных типов, реализующих один и тот же типаж

src/main.rs

use gui::{Screen, Button};

fn main() {
    let screen = Screen {
        components: vec![
            Box::new(SelectBox {
                width: 75,
                height: 10,
                options: vec![
                    String::from("Да"),
                    String::from("Может быть"),
                    String::from("Нет")
                ],
            }),
            Box::new(Button {
                width: 50,
                height: 10,
                label: String::from("ОК"),
            }),
        ],
    };

    screen.run();
}

Когда мы писали библиотеку, то не знали, что кто-то может добавить тип SelectBox. Но реализация типа Screen была способна работать с новым типом и рисовать его, потому что SelectBox реализует типаж Draw, то есть реализует метод draw.

Идея заниматься только сообщениями, на которые откликается значение, а не конкретным типом значения похожа на идею утиной типизации в динамически типизированных языках: если что-то ходит как утка и крякает как утка, то это точно утка! В реализации функции run в структуре Screen листинга 17.5 не требуется знать конкретный тип каждого компонента. Функция не проверяет, экземпляром какой структуры, Button или SelectBox, является компонент. Она просто вызывает метод draw для компонента. Указав Box<dyn Draw> в качестве типа значений в векторе components, мы определили, что структуре Screen нужны значения, для которых мы можем вызывать метод draw.

Преимущество типажных объектов и системы типов Rust для написания кода, похожего на код с утиной типизацией, заключается в том, что нам не нужно проверять во время выполнения, реализует ли значение тот или иной метод. Нам также не нужно беспокоиться о возможных ошибках, если значение не реализует метод, но мы все равно его вызываем. Rust не будет компилировать код, если значения не реализуют типажи, которые нужны типажным объектам.