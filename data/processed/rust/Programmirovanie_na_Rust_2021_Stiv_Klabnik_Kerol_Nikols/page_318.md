---
source_image: page_318.png
page_number: 318
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 36.00
tokens: 7615
characters: 2223
timestamp: 2025-12-24T10:54:12.795048
finish_reason: stop
---

С аннотациями типов синтаксис замыканий более похож на синтаксис функций. Ниже приводится вертикальное сравнение синтаксиса определения функции, прибавляющей 1 в свой параметр, и замыкание, которое имеет такое же поведение. Мы добавили несколько пробелов, чтобы выровнять соответствующие части. Этот пример иллюстрирует, что синтаксис замыкания похож на синтаксис функции, за исключением вертикальных черт и объема синтаксиса, который является необязательным:

fn add_one_v1 (x: u32) -> u32 { x + 1 }
let add_one_v2 = |x: u32| -> u32 { x + 1 };
let add_one_v3 = |x| { x + 1 };
let add_one_v4 = |x| x + 1 ;

В первой строке показано определение функции, а во второй — полностью аннотированное определение замыкания. Третья строка удаляет аннотации типов из определения замыкания, а четвертая — удаляет скобки, которые являются необязательными, поскольку тело замыкания имеет только одно выражение. Все это — допустимые определения, которые будут вести себя одинаково при вызове.

Определения замыканий будут иметь один конкретный тип, логически выводимый для каждого из параметров и возвращаемого значения. Например, в листинге 13.8 показано определение краткого замыкания, которое просто возвращает значение, полученное в качестве параметра. Это замыкание не очень полезно, если не считать целей данного примера. Обратите внимание, что мы не добавили никаких аннотаций типов в определение: если потом мы попытаемся вызвать замыкание дважды, используя тип String в качестве аргумента в первый раз, а тип u32 — во второй, то произойдет ошибка.

Листинг 13.8. Попытка вызвать замыкание, типы которого логически выводятся из двух разных типов

src/main.rs
    let example_closure = |x| x;
    let s = example_closure(String::from("Привет"));
    let n = example_closure(5);

Компилятор выдает такую ошибку:

error[E0308]: mismatched types
  --> src/main.rs
   |
   | let n = example_closure(5);
   |                        ^ expected struct `std::string::String`, found integral variable
   |
   = note: expected type `std::string::String`
           found type `{integer}`

В первый раз, когда мы вызываем example_closure со значением типа String, компилятор логически выводит тип параметра x и тип, возвращаемый из замыкания,