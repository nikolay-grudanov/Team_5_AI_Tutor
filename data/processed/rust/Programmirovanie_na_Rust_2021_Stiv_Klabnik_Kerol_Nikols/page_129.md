---
source_image: page_129.png
page_number: 129
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 31.92
tokens: 7547
characters: 2225
timestamp: 2025-12-24T10:49:07.182689
finish_reason: stop
---

println!("Может ли rect1 содержать в себе rect2? {}", rect1.can_hold(&rect2));
println!("Может ли rect1 содержать в себе rect3? {}", rect1.can_hold(&rect3));
}

И ожидаемый результат будет выглядеть следующим образом, потому что обе размерности переменной rect2 меньше, чем размерности переменной rect1, но переменная rect3 шире, чем переменная rect1:

    Может ли rect1 содержать в себе rect2? true
    Может ли rect1 содержать в себе rect3? false

Мы знаем, что хотим определить метод, поэтому он будет находиться внутри блока impl Rectangle. Имя метода can_hold, он будет брать неизменяемое заимствование еще одной структуры Rectangle в качестве параметра. Мы можем определить тип параметра, посмотрев на код, который вызывает метод: rect1.can_hold(&rect2) передает аргумент &rect2, который является неизменяемым заимствованием переменной rect2 экземпляра структуры Rectangle. Это имеет смысл, потому что нам нужно только читать rect2 (а не писать, что означало бы, что нам нужно было изменяемое заимствование). Также нужно, чтобы функция main сохранила владение переменной rect2, в результате чего мы сможем использовать его снова после вызова метода can_hold. Значение, возвращаемое из can_hold, будет булевым, и реализация проверит, являются ли ширина и высота параметра self соответственно больше ширины и высоты другой структуры Rectangle. Давайте добавим новый метод can_hold в блок impl из листинга 5.13, показанный в листинге 5.15.

Листинг 5.15. Реализация метода can_hold в структуре Rectangle, который берет еще один экземпляр структуры Rectangle в качестве параметра

src/main.rs
impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }

    fn can_hold(&self, other: &Rectangle) -> bool {
        self.width > other.width && self.height > other.height
    }
}

Когда мы выполним этот код с помощью функции main в листинге 5.14, то получим желаемый результат. Методы могут принимать многочисленные параметры, которые мы добавляем в сигнатуру после параметра self, и они работают так же, как параметры в функциях.

Связанные функции

Еще одним полезным свойством блоков impl является то, что нам разрешено определять функции в блоках impl, которые не берут self в качестве параметра.