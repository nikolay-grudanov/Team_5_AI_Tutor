---
source_image: page_180.png
page_number: 180
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 44.73
tokens: 7780
characters: 2478
timestamp: 2025-12-24T10:50:41.838129
finish_reason: stop
---

эта строка начинается с заглавной кириллической буквы З, а не с арабской цифры 3.)

let len = String::from("Здравствуйте").len();

На вопрос о том, какова длина строки, вы можете ответить: 12. Однако ответ языка Rust будет 24: это число байтов, необходимое для кодирования приветствия "Привет" в UTF-8, потому что каждое скалярное значение Юникода в данной строке занимает 2 байта памяти. Следовательно, индекс в байты строки не всегда будет коррелировать с допустимым скалярным значением Юникода. Для демонстрации рассмотрим недопустимый код Rust:

let hello = "Здравствуйте";
let answer = &hello[0];

Каким должно быть значение переменной answer? Должно ли оно равняться 3, первой букве? При кодировке в UTF-8 первый байт буквы З равен 208, а второй — 151, поэтому переменная answer должна равняться 208, но 208 само по себе не является допустимым символом. Число 208, скорее всего, не является тем, что пользователь хотел бы вернуть, если бы он запросил первую букву этой строки. Однако это единственные данные, которые есть у Rust в байтовом индексе 0. Пользователи вообще-то не хотят возвращать значение байта, даже если строка содержит только латинские буквы: если бы выражение &"hello"[0] было допустимым кодом, который возвращал бы значение байта, то он вернул бы 104, а не h. Во избежание возвращения неожиданного значения и возникновения ошибок, которые, возможно, будут обнаружены не сразу, язык Rust вообще не компилирует этот код и предотвращает недоразумения на ранних стадиях процесса разработки.

Байты, скалярные значения и графемные кластеры! О боже!

Еще один момент, связанный с UTF-8, заключается в том, что с точки зрения Rust есть три релевантных способа рассматривать строки: как байты, как скалярные значения и как графемные кластеры (наиболее близкие к тому, что мы называем буквами).

Если мы взглянем на слово «नमस्ते» на языке хинди, написанное слоговым письмом деванагари, то оно хранится в виде вектора значений типа u8, который выглядит следующим образом:

[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164, 224, 165, 135]

Это 18 байт, и именно так компьютеры хранят эти данные. Если мы посмотрим на них как на скалярные значения Юникод, то есть на то, что в языке Rust является типом char, то эти байты выглядят следующим образом:

['न', 'म', 'स', '.', 'त', 'े']

Здесь шесть значений char, но четвертое и шестое не являются буквами — это диакритические знаки, которые сами по себе не имеют смысла. Наконец, если мы по-