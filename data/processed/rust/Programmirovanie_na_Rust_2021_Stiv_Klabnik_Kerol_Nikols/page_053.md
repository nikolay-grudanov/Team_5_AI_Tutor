---
source_image: page_053.png
page_number: 53
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 43.20
tokens: 7679
characters: 2618
timestamp: 2025-12-24T10:47:20.546117
finish_reason: stop
---

Как и Result, Ordering («упорядочение») — это еще одно перечисление, но вариантами для перечисления Ordering являются Less («меньше»), Greater («больше») и Equal («равно»), являющиеся тремя возможными результатами, когда вы сравниваете два значения.

Затем мы добавляем внизу пять новых строк кода, которые используют тип Ordering. Метод cmp 3 сравнивает два значения и может быть вызван для всего, что можно сравнить. Он ссылается на то, с чем вы хотите сравнить. Здесь он сравнивает загаданное число guess с секретным числом secret_number. Затем он возвращает вариант перечисления Ordering, который мы ввели в область видимости с помощью инструкции use. Мы используем выражение match 2, чтобы решить, что делать дальше, основываясь на том, какой вариант упорядочения Ordering был возвращен из вызова метода cmp со значениями в guess и secret_number.

Выражение match состоит из ветвей. Рукав (arm) состоит из шаблона и кода, который должен быть исполнен, если значение, заданное в начале выражения match, совпадает с шаблоном ветви. Язык Rust берет значение, переданное в match, и по очереди просматривает шаблон каждого рукава. Конструкция match и шаблоны являются мощными средствами. Они позволяют выражать разнообразные ситуации, с которыми может столкнуться код, и гарантируют, что каждая ситуация будет обработана. Мы подробно разберем эти средства в главах 6 и 18 соответственно.

Давайте посмотрим, что произойдет с используемым здесь выражением match. Будем считать, что пользователь загадал 50, а случайно сгенерированное секретное число на этот раз равно 38. Когда код сравнивает 50 и 38, то метод cmp возвращает Ordering::Greater, потому что 50 больше 38. Выражение match получает значение Ordering::Greater и начинает проверять шаблон каждой ветви. Выражение смотрит на шаблон первой ветви Ordering::Less и видит, что значение Ordering::Greater не совпадает с Ordering::Less, поэтому оно игнорирует код в этом рукаве и переходит к следующему. Паттерн следующего рукава Ordering::Greater действительно совпадает с Ordering::Greater! Связанный код в ветви исполнится и выведет Слишком большое число!. Выражение match завершает свою работу, потому что нет необходимости проверять последнюю ветвь в этом сценарии.

Однако код в листинге 2.4 пока что не компилируется. Давайте попробуем это сделать¹:

$ cargo build
Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
error[E0308]: mismatched types
 --> src/main.rs:23:21
  |
23 |     match guess.cmp(&secret_number) {
      |     ^^^^^^^^^^^^^^^^ expected struct `std::string::String`,
found integral variable

¹ ошибка[E0308]: несовпадающие типы