---
source_image: page_077.png
page_number: 77
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 27.70
tokens: 7465
characters: 1771
timestamp: 2025-12-24T10:47:41.476494
finish_reason: stop
---

вращают значение. Выражение же оценивает результирующее значение. Давайте взглянем на несколько примеров.

Создание переменной и присвоение ей значения с помощью ключевого слова let — это инструкция. В листинге 3.1 let y = 6; является инструкцией.

Листинг 3.1. Объявление функции main, содержащее одну инструкцию
src/main.rs
```rust
fn main() {
    let y = 6;
}
```

Определения функций тоже являются инструкциями; весь приведенный выше пример является отдельной инструкцией.

Инструкции не возвращают значений. Следовательно, вы не можете назначить инструкцию let еще одной переменной, как это пытается сделать следующий код. Произойдет ошибка:

src/main.rs
```rust
fn main() {
    let x = (let y = 6);
}
```

Когда вы выполните эту программу, то полученная ошибка будет выглядеть следующим образом¹:

```sh
$ cargo run
Compiling functions v0.1.0 (file:///projects/functions)
error: expected expression, found statement (`let`)
 --> src/main.rs:2:14
  |
2 |     let x = (let y = 6);
  |     ^^^
= note: variable declaration using `let` is a statement
```

Инструкция let y = 6 не возвращает значения, поэтому переменную x не к чему привязать. Это отличается от того, что происходит в других языках, таких как C и Ruby, где инструкция присваивания возвращает значение присваивания. В этих языках вы можете написать x = y = 6, при этом как x, так и y будут содержать значение 6. В Rust дела обстоят иначе.

Выражения оцениваются и составляют большую часть остального кода, который вы будете писать на языке Rust. Возьмем простую математическую операцию 5 + 6, то есть выражение, которое в результате вычисления принимает значение 11. Выражения могут быть частью инструкций: в листинге 3.1 число 6 в инструкции

¹ ошибка: ожидалось выражение, обнаружена инструкция (`let`)