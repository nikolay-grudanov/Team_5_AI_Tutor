---
source_image: page_415.png
page_number: 415
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 24.07
tokens: 7367
characters: 1543
timestamp: 2025-12-24T10:56:36.619835
finish_reason: stop
---

Листинг 16.7. Перемещение переменной tx в порожденный поток и отправка сообщения «привет»

src/main.rs

use std::thread;
use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from("привет");
        tx.send(val).unwrap();
    });
}

Опять же мы используем функцию thread::spawn, чтобы создать новый поток, а затем применяем move для перемещения переменной tx в замыкание, чтобы порожденный поток стал владельцем переменной tx. Порожденный поток должен владеть передающим концом канала, чтобы иметь возможность отправлять сообщения.

Передающий конец имеет метод send, берущий значение, которое мы хотим отправить. Метод send возвращает тип Result<T, E>, поэтому, если принимающий конец уже отброшен и послать значение некуда, то операция send будет возвращать ошибку. В данном примере мы вызываем метод unwrap, чтобы поднимать панику в случае ошибки. Но в реальном приложении мы бы обрабатывали это надлежащим образом. Вернитесь к главе 9, чтобы освежить в памяти стратегии надлежащей обработки ошибок.

В листинге 16.8 мы получим значение от принимающего конца канала в главный поток исполнения.

Листинг 16.8. Получение значения «привет» в главном потоке исполнения и его вывод

src/main.rs

use std::thread;
use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from("привет");
        tx.send(val).unwrap();
    });

    let received = rx.recv().unwrap();
    println!("Получено: {}", received);
}