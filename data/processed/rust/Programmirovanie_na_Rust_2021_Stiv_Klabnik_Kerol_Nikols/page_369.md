---
source_image: page_369.png
page_number: 369
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 37.18
tokens: 7649
characters: 2428
timestamp: 2025-12-24T10:55:36.038026
finish_reason: stop
---

требуется меньше места, чем варианту Cons. Теперь мы знаем, что любое значение списка будет занимать размер типа i32 плюс размер данных указателя Box. Используя умный указатель Box, мы разорвали бесконечную рекурсивную цепочку, благодаря чему компилятор может вычислить размер, необходимый для хранения значения типа List. На рис. 15.2 показано, как теперь выглядит вариант Cons.

![Рис. 15.2. Список, размер которого не бесконечен, так как Cons содержит умный указатель Box](../images/15_2.png)

Рис. 15.2. Список, размер которого не бесконечен, так как Cons содержит умный указатель Box

Умные указатели Box обеспечивают только косвенную адресацию и выделение пространства в куче. У них нет специальных свойств, подобных тем, которые мы увидим у других типов умных указателей. На их производительности не сказываются никакие специальные свойства, поэтому они бывают полезными в таких случаях, как cons-список, где нам нужно только косвенное обращение. Мы также рассмотрим другие варианты использования умных указателей Box в главе 17.

Тип Box<T> является умным указателем, поскольку он реализует типаж Deref, который позволяет трактовать значения Box<T> как ссылки. Когда значение указателя Box<T> выходит из области видимости, данные кучи, на которые указывает Box, также очищаются по причине реализации типажа Drop. Давайте подробнее изучим эти типажи. Они будут важнее для функциональности, предусмотренной другими типами умных указателей, которые мы обсудим далее в этой главе.

Трактовка умных указателей как обыкновенных ссылок с помощью типажа Deref

Реализация типажа Deref позволяет настроить поведение оператора разыменования * индивидуально (в отличие от оператора умножения или оператора glob). Реализуя типаж Deref таким образом, что умный указатель можно трактовать как обыкновенную ссылку, вы можете писать код, который работает со ссылками, и использовать этот же код с умными указателями.

Давайте сначала посмотрим, как оператор разыменования работает с регулярными ссылками. Затем мы попытаемся определить настраиваемый тип, который ведет себя как Box<T>, и посмотрим, почему оператор разыменования не работает как ссылка в только что определенном типе. Мы узнаем, как благодаря реализации типажа Deref умные указатели работают по подобию ссылок. Затем мы рассмотрим средство языка Rust — принудительное приведение типа посредством deref и то, как оно позволяет работать со ссылками или умными указателями.