---
source_image: page_141.png
page_number: 141
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 34.54
tokens: 7550
characters: 2105
timestamp: 2025-12-24T10:49:28.955305
finish_reason: stop
---

код, связанный с этим паттерном, исполняется. Если этот паттерн не совпадает со значением, то исполнение продолжается и переходит к следующему рукаву, как в машине для сортировки монет. У нас может быть столько рукавов, сколько нам нужно: в листинге 6.3 у выражения match четыре рукава.

Код, связанный с каждым рукавом, является выражением, а результирующее значение выражения в совпадающем рукаве является значением, возвращаемым для всего выражения match.

В типичной ситуации фигурные скобки не используются, если код рукава выражения match короткий, как показано в листинге 6.3, где каждый рукав просто возвращает значение. Если вы хотите выполнить несколько строк кода в рукаве выражения match, то используете фигурные скобки. Например, следующий код будет выводить «Монетка на счастье!» всякий раз, когда метод вызывается с Coin::Penny, но все равно возвращать последнее значение блока, 1:

fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => {
            println!("Монетка на счастье!");
            1
        },
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter => 25,
    }
}

Паттерны, которые привязываются к значениям

Еще одним полезным свойством рукавов выражения match является то, что они могут привязываться к частям значений, которые совпадают с паттерном. Именно так мы можем извлекать значения из вариантов перечисления.

В качестве примера давайте изменим один из наших вариантов перечисления так, чтобы он содержал данные внутри себя. С 1999 по 2008 год США чеканили четвертаки с разными рисунками с одной стороны для каждого из 50 штатов. Ни одна другая монета не имеет рисунка, соответствующего своему штату, поэтому только у четвертаков есть эта дополнительная ценность. Мы можем добавить эту информацию в перечисление, изменяя вариант Quarter и включив в него значение UsState, хранящееся внутри него. Это мы сделали в листинге 6.4.

Листинг 6.4. Перечисление Coin, в котором вариант Quarter также имеет значение UsState
#[derive(Debug)] // чтобы проверить штат сразу
enum UsState {
    Alabama,
    Alaska,
    // --пропуск--