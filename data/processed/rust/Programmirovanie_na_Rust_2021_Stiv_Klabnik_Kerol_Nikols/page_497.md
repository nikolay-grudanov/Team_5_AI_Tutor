---
source_image: page_497.png
page_number: 497
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 29.94
tokens: 7469
characters: 1799
timestamp: 2025-12-24T10:58:51.661238
finish_reason: stop
---

Point {
    x: self.x + other.x,
    y: self.y + other.y,
}
}

fn main() {
    assert_eq!(Point { x: 1, y: 0 } + Point { x: 2, y: 3 },
        Point { x: 3, y: 3 });
}

Метод add складывает значения x двух экземпляров структуры Point и значения y двух экземпляров структуры Point, создавая новую структуру Point. Типаж Add имеет связанный тип с именем Output, который выясняет тип, возвращаемый методом add.

Обобщенный тип по умолчанию в этом коде находится внутри типажа Add. Вот его определение:

trait Add<RHS=Self> {
    type Output;

    fn add(self, rhs: RHS) -> Self::Output;
}

В целом этот код должен быть вам знаком: типаж с одним методом и связанным типом. Новым фрагментом является RHS=Self: этот синтаксис называется параметром типа по умолчанию. Параметр обобщенного типа RHS (сокращенно от right-hand side, то есть «правая сторона») определяет тип параметра rhs в методе add. Если мы не зададим конкретный тип для RHS при реализации типажа Add, то RHS по умолчанию примет Self, который будет типом, в котором реализуется Add.

Когда мы реализовывали Add для Point, мы использовали для RHS тип по умолчанию, потому что хотели складывать два экземпляра структуры Point. Давайте рассмотрим пример реализации типажа Add, где требуется настраивать тип RHS индивидуально, а не использовать тип по умолчанию.

У нас есть две структуры, Millimeters и Meters, которые содержат значения в разных единицах измерения. Мы хотим прибавлять значения в миллиметрах к значениям в метрах и реализовывать Add, которая делала бы конвертацию правильно. Мы можем реализовать Add для Millimeters, где Meters будут в качестве RHS, как показано в листинге 19.15.

Листинг 19.15. Реализация типажа Add в Millimeters для прибавления Millimeters к Meters

src/lib.rs
use std::ops::Add;

struct Millimeters(u32);