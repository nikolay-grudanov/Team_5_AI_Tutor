---
source_image: page_171.png
page_number: 171
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 44.46
tokens: 7701
characters: 2594
timestamp: 2025-12-24T10:50:28.268381
finish_reason: stop
---

с нуля. Во-вторых, два упомянутых способа получить третий элемент предусматривают использование & и [ ], в результате чего мы получаем ссылку, либо использование метода get с индексом, переданным в качестве аргумента, в результате чего мы получаем Option<&T>.

Rust может ссылаться на элемент двумя способами, благодаря чему можно выбирать, как программа себя ведет при попытке использовать значение индекса, для которого вектор не имеет элемента. В качестве примера давайте посмотрим, что программа будет делать, если она имеет вектор, содержащий пять элементов, а затем пытается обратиться к элементу с индексом 100, как показано в листинге 8.6.

Листинг 8.6. Попытка обратиться к элементу с индексом 100 в векторе, содержащем пять элементов

```rust
let v = vec![1, 2, 3, 4, 5];

let does_not_exist = &v[100];
let does_not_exist = v.get(100);
```

Когда мы выполним этот код, первый метод [ ] станет причиной того, что программа поднимет панику, потому что он ссылается на несуществующий элемент. Этот метод лучше всего использовать, когда вы хотите, чтобы программа завершила работу аварийно, если есть попытка обратиться к элементу после окончания вектора.

Когда метод get получает индекс, который находится вне вектора, он возвращает None без паники. Вы можете использовать этот метод, если обращение к элементу вне диапазона вектора происходит нерегулярно при нормальных обстоятельствах. Тогда код будет иметь логику для обработки, имея либо Some(&element), либо None, как описано в главе 6. Например, индекс может исходить от человека, вводящего число. Если он ненароком вводит слишком большое число и программа получает значение None, то вы можете сообщить пользователю о количестве элементов, находящихся в текущем векторе, и дать ему еще один шанс ввести допустимое значение. Это было бы для пользователя удобнее, чем аварийный сбой программы из-за опечатки!

Когда у программы есть действительная ссылка, контролер заимствования применяет правила владения и заимствования (описанные в главе 4) и обеспечивает, чтобы эта ссылка и любые другие ссылки на содержимое вектора оставались действительными. Вспомните правило, которое гласит, что вы не можете иметь изменяемые и неизменяемые ссылки в одной и той же области. Это правило применяется в листинге 8.7, где содержится неизменяемая ссылка на первый элемент вектора, а мы пытаемся добавить элемент в конец. Это не будет работать.

Листинг 8.7. Попытка добавить элемент в вектор при сохранении ссылки на элемент

```rust
let mut v = vec![1, 2, 3, 4, 5];
let first = &v[0];
v.push(6);
println!("Первый элемент равен {}", first);
```