---
source_image: page_133.png
page_number: 133
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 28.74
tokens: 7396
characters: 1481
timestamp: 2025-12-24T10:49:11.350093
finish_reason: stop
---

Мы можем выразить эту идею в коде, определив перечисление IpAddrKind и перечислив возможные варианты видов IP-адреса, V4 и V6. Они называются вариантами перечисления:

enum IpAddrKind {
    V4,
    V6,
}

Теперь IpAddrKind является настраиваемым типом данных, который можно использовать в любом месте кода.

Значения перечисления

Мы можем создавать экземпляры каждого из двух вариантов перечисления IpAddrKind следующим образом:

let four = IpAddrKind::V4;
let six = IpAddrKind::V6;

Обратите внимание, что варианты перечисления находятся в пространстве имен под его идентификатором, и чтобы их отделить, мы используем двойное двоеточие. Это полезно потому, что теперь оба значения, IpAddrKind::V4 и IpAddrKind::V6, имеют один и тот же тип: IpAddrKind. Затем мы можем, к примеру, определить функцию, которая принимает любой вариант IpAddrKind:

fn route(ip_kind: IpAddrKind) { }

Можно вызвать эту функцию с любым вариантом:

route(IpAddrKind::V4);
route(IpAddrKind::V6);

Использование перечислений имеет еще больше преимуществ. Если вновь обратиться к типу IP-адреса, на данный момент у нас нет способа хранить фактические данные IP-адреса; нам лишь известен его вид. Учитывая, что вы узнали о структурах в главе 5, можно решить эту задачу, как показано в листинге 6.1.

Листинг 6.1. Хранение данных и варианта IpAddrKind IP-адреса с использованием структуры

enum IpAddrKind {
    V4,
    V6,
}

struct IpAddr {
    kind: IpAddrKind,
    address: String,
}

let home = IpAddr {