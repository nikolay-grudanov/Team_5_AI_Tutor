---
source_image: page_382.png
page_number: 382
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 37.56
tokens: 7673
characters: 2370
timestamp: 2025-12-24T10:55:56.601699
finish_reason: stop
---

Варианты Cons владеют данными, которые они содержат, поэтому, когда мы создаем список b ①, список a перемещается в b, и b владеет a. Затем, когда мы пытаемся использовать список a снова при создании списка с ②, это не разрешается, потому что a был перемещен.

Мы могли бы изменить определение Cons так, чтобы содержались ссылки, но тогда пришлось бы задавать параметры жизненных циклов. Задавая параметры жизненных циклов, мы бы описывали, что каждый элемент в списке будет жить по крайней мере столько же, сколько и весь список. Например, контролер заимствования не позволит нам скомпилировать инструкцию let a = Cons(10, &Nil);, потому что временное значение Nil будет отброшено до того, как a сможет взять ссылку на него.

Мы изменим определение типа List так, чтобы использовать умный указатель Rc<T> вместо умного указателя Box<T>, как показано в листинге 15.18. Каждый вариант Cons теперь будет содержать значение и умный указатель Rc<T>, указывающий на List. Когда мы создаем b, вместо того чтобы брать a во владение, мы будем клонировать умный указатель Rc<List>, который содержит a, тем самым увеличивая число ссылок с одной до двух и позволяя a и b совместно владеть данными в этом умном указателе Rc<List>. Мы также будем клонировать a при создании c, увеличивая число ссылок с двух до трех. Каждый раз, когда мы вызываем Rc::clone, число ссылок на данные в умном указателе Rc<List> увеличивается, и данные не очищаются, если только на них нет ни одной ссылки.

Листинг 15.18. Определение типа List, который использует умный указатель Rc<T>
src/main.rs

enum List {
    Cons(i32, Rc<List>),
    Nil,
}
use crate::List::{Cons, Nil};
① use std::rc::Rc;

fn main() {
    ② let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil))))));
    ③ let b = Cons(3, Rc::clone(&a));
    ④ let c = Cons(4, Rc::clone(&a));
}

Нужно добавить инструкцию use для введения Rc<T> в область видимости ①, потому что его нет в прелюдии. В функции main мы создаем список, содержащий 5 и 10, и сохраняем его в новом умном указателе Rc<List> в a ②. Затем, создавая b ③ и с ④, мы вызываем функцию Rc::clone и передаем внутрь ссылку на Rc<List> в качестве аргумента.

Вместо функции Rc::clone(&a) мы могли бы вызвать метод a.clone(), но исходя из принятых соглашений в данном случае используется функция Rc::clone. Реализация функции Rc::clone не делает глубокую копию всех данных, как это