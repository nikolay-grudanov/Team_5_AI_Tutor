---
source_image: page_505.png
page_number: 505
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 31.54
tokens: 7514
characters: 2082
timestamp: 2025-12-24T10:59:06.174202
finish_reason: stop
---

щую экземпляр типа Vec<T>, затем реализовать типаж Display для типа Wrapper и использовать значение типа Vec<T>, как показано в листинге 19.23.

Листинг 19.23. Создание типа Wrapper вокруг типа Vec<String> для реализации типажа Display

src/main.rs
use std::fmt;

struct Wrapper(Vec<String>);

impl fmt::Display for Wrapper {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "[{}]", self.0.join(", "))
    }
}

fn main() {
    let w = Wrapper(vec![String::from("hello"), String::from("world")]);
    println!("w = {}", w);
}

Реализация типажа Display использует self.0 для доступа к внутреннему значению типа Vec<T>, потому что Wrapper — это кортежная структура, а значение типа Vec<T> — элемент с индексом 0 в кортеже. Тогда мы можем использовать функциональность типажа Display в типе Wrapper.

Недостаток использования этого технического приема в том, что Wrapper — это новый тип, поэтому у него нет методов для значения, которое он содержит. Мы должны были бы реализовать все методы типа Vec<T> непосредственно в типе Wrapper таким образом, чтобы методы делегировали полномочия self.0, — это позволило бы нам рассматривать Wrapper точно так же, как Vec<T>. Если бы мы хотели, чтобы новый тип имел все методы, которые есть у внутреннего типа, то решение состояло бы в реализации типажа Deref (обсуждается в разделе «Трактовка умных указателей как обыкновенных ссылок с помощью типажа Deref» (с. 364)) в типе Wrapper для того, чтобы возвращать внутренний тип. Если мы не хотим, чтобы тип Wrapper имел все методы внутреннего типа, например, чтобы ограничить поведение Wrapper, то нам нужно реализовывать те методы, которые мы действительно хотим, вручную.

Теперь вы знаете, как паттерн newtype используется применительно к типажам. Этот паттерн полезен, даже когда типажи не задействуются. Давайте займемся некоторыми эффективными способами взаимодействия с системой типов Rust.

Продвинутые типы

В системе типов Rust есть некоторые средства, о которых мы упоминали, но еще не обсуждали. Мы начнем с типов newtype в целом, поскольку мы исследуем, по-