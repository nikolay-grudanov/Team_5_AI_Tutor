---
source_image: page_136.png
page_number: 136
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 31.32
tokens: 7507
characters: 2088
timestamp: 2025-12-24T10:49:17.637494
finish_reason: stop
---

○ Write включает в себя одно значение String.
○ ChangeColor включает в себя три значения i32.

Определение перечисления с вариантами, подобными приведенным в листинге 6.2, похоже на определение структур разных видов. Однако различие состоит в том, что перечисление не использует ключевое слово struct, и все варианты сгруппированы вместе, в соответствии с типом Message. Следующие структуры могли бы содержать те же данные, что и варианты предыдущего перечисления:

struct QuitMessage;   // пустая структура
struct MoveMessage {
    x: i32,
    y: i32,
}
struct WriteMessage(String);           // кортежная структура
struct ChangeColorMessage(i32, i32, i32); // кортежная структура

Но если бы мы использовали разные структуры, у каждой из которых был бы собственный тип, то мы бы не смогли так же легко определить функцию для приема любого из этих типов сообщений, как можно было бы сделать с перечислением Message, определенным в листинге 6.2, которое является единым типом.

Между перечислениями и структурами существует еще одно сходство: для перечислений можно определять методы с помощью ключевого слова impl точно так же, как для структур. Вот метод с именем call, который мы можем определить в перечислении Message:

impl Message {
    fn call(&self) {
        // здесь будет определено тело метода
    }
}

let m = Message::Write(String::from("hello"));
m.call();

Тело метода будет использовать параметр self, чтобы получить значение, для которого мы вызвали этот метод. В этом примере мы создали переменную m ② со значением Message::Write(String::from("hello")), и это то, как будет выглядеть параметр self в теле метода call ①, когда выполняется m.call().

Давайте рассмотрим еще одно полезное перечисление из стандартной библиотеки, которое встречается очень часто, — Option.

Перечисление Option и его преимущества по сравнению со значениями null

В предыдущем разделе мы видели, как перечисление IpAddr позволяет использовать систему типов языка Rust, чтобы кодировать в программу больше информации, чем просто данные. В этом разделе проводится тематический анализ перечис-