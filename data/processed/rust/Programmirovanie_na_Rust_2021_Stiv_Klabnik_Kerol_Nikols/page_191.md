---
source_image: page_191.png
page_number: 191
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 37.89
tokens: 7668
characters: 2348
timestamp: 2025-12-24T10:50:53.261163
finish_reason: stop
---

РАЗМАТЫВАНИЕ СТЕКА, ИЛИ ПРЕРЫВАНИЕ РАБОТЫ В ОТВЕТ НА ПАНИКУ

По умолчанию, когда возникает паника, программа начинает разматываться, то есть язык Rust отступает назад в стеке и очищает данные в каждой функции, с которой он сталкивается. Но этот процесс сопряжен с большой работой. Альтернативой является немедленное прерывание, которое завершает программу без очистки. Память, которую программа использовала, затем должна быть очищена операционной системой. Если в проекте нужно сделать результирующий двоичный файл как можно меньше, то при возникновении паники вы можете переключиться с разматывания на прерывание, добавив panic = 'abort' в соответствующие разделы [profile] в файле Cargo.toml. Например, если вы хотите прервать работу при возникновении паники в релизном режиме, добавьте:

[profile.release]
panic = 'abort'

Давайте попробуем вызвать panic! в простой программе:

src/main.rs
fn main() {
    panic!("полное фиаско");
}

Когда вы выполните указанную программу, то увидите что-то вроде этого¹:

$ cargo run
Compiling panic v0.1.0 (file:///projects/panic)
Finished dev [unoptimized + debuginfo] target(s) in 0.25 secs
Running 'target/debug/panic'
thread 'main' panicked at 'полное фиаско', src/main.rs:2:5
note: Run with 'RUST_BACKTRACE=1' for a backtrace.

Вызов макрокоманды panic! приводит к появлению сообщения об ошибке, содержащегося в последних двух строках кода. Первая строка кода показывает сообщение о панике и место в исходном коде, где произошла паника: src/main.rs:2:5 указывает на то, что это вторая строка, пятый символ файла src/main.rs.

В данном случае указанная строка является частью кода, и если мы перейдем к этой строке, то увидим вызов макрокоманды panic!. В других случаях вызов макрокоманды panic! может быть в коде, который вызывается нашим кодом, а имя файла и номер строки в сообщении об ошибке будут чужим кодом, где макрокоманда panic! была вызвана, а не той строкой нашего кода, которая в конечном итоге привела к вызову макрокоманды. Мы можем использовать обратную трассировку функций, откуда пришел вызов макрокоманды panic!, чтобы выяснить, какая часть кода служит причиной этой проблемы. Далее мы подробнее обсудим понятие обратной трассировки.

¹ поток 'main' вызвал панику при 'полном фиаско', src/main.rs:2:5
примечание: выполните с опцией 'RUST_BACKTRACE=1' для получения обратной трассировки