---
source_image: page_265.png
page_number: 265
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 30.32
tokens: 7506
characters: 2041
timestamp: 2025-12-24T10:52:44.798210
finish_reason: stop
---

Сообщение об ошибке указывает на то, что этот тест действительно поднял панику, как мы и предполагали, но в сообщении о панике не было ожидаемой строки 'Значение догадки должно быть меньше или равно 100'. Сообщение о панике, которое мы получили в этом случае, было Значение догадки должно быть больше или равно 1, получено 200. Теперь мы можем заняться вопросом, где находится дефект!

Использование типа Result<T, E> в тестах

До сих пор мы писали тесты, которые паникуют, когда не срабатывают. Мы также можем писать тесты, которые используют тип Result<T, E>! Вот тест из листинга 11.1, переписанный так, чтобы использовать тип Result<T, E> и возвращать Err вместо вызова паники:

#[cfg(test)]
mod tests {
    #[test]
    fn it_works() -> Result<(), String> {
        if 2 + 2 == 4 {
            Ok(())
        } else {
            Err(String::from("два плюс два не равно четырем"))
        }
    }
}

Функция it_works теперь возвращает тип Result<(), String>. В теле функции вместо того, чтобы вызывать макрокоманду assert_eq!, мы возвращаем Ok(()), когда тест успешно, и Err с экземпляром типа String внутри, когда тест не срабатывает.

Написание тестов так, чтобы они возвращали тип Result<T, E>, позволяет использовать оператор вопросительного знака в теле тестов, что бывает удобно в написании тестов, которые должны закончиться неуспешно, если какая-либо операция в них возвращает вариант Err.

Вы не можете применять аннотацию #[should_panic] для тестов, использующих тип Result<T, E>. Вместо этого вы должны возвращать значение Err непосредственно, когда тест должен не сработать.

Теперь, когда вы знаете несколько способов написания тестов, давайте посмотрим, что происходит, когда мы выполняем тесты, и изучим разные варианты, которые можно использовать с командой cargo test.

Контроль выполнения тестов

Подобно тому как команда cargo run компилирует код, а затем выполняет результирующий двоичный файл, команда cargo test компилирует код в тестовом режиме и выполняет результирующий двоичный тест. Вы можете указать аргументы