---
source_image: page_466.png
page_number: 466
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 25.43
tokens: 7450
characters: 1697
timestamp: 2025-12-24T10:57:57.574471
finish_reason: stop
---

error[E0162]: irrefutable if-let pattern
  --> <anon>:2:8
   |
2 | if let x = 5 {
   |         ^ irrefutable pattern

По этой причине рукава выражения match должны использовать опровержимые паттерны, за исключением последнего рукава, который должен сопоставлять любые оставшиеся значения с неопровержимым паттерном. Rust позволяет использовать неопровержимый паттерн в выражении match только с одним рукавом, но этот синтаксис не особо полезен, и его можно заменить более простой инструкцией let.

Теперь, когда вы знаете, где используются паттерны и чем отличаются опровержимые и неопровержимые паттерны, давайте познакомимся с синтаксисом, который мы можем использовать для создания паттернов.

Синтаксис паттернов

В процессе чтения книги вы видели примеры многих видов паттернов. В этом разделе мы соберем весь синтаксис, допустимый в паттернах, и обсудим, почему вы можете использовать каждый из них.

Сопоставление литералов

В главе 6 вы видели, что можно напрямую сопоставлять паттерны с литералами. В следующем коде приводится несколько примеров:

let x = 1;

match x {
    1 => println!("один"),
    2 => println!("два"),
    3 => println!("три"),
    _ => println!("что угодно"),
}

Этот код выводит один, потому что значение в x равно 1. Данный синтаксис полезен, когда вы хотите, чтобы код выполнял действие, если он получает то или иное конкретное значение.

Сопоставление именованных переменных

Именованные переменные — это неопровержимые паттерны, которые совпадают с любым значением, мы применяли их в этой книге неоднократно. Однако при использовании именованных переменных в выражениях match возникают сложности. Поскольку ключевое слово match начинает новую область видимости,