---
source_image: page_109.png
page_number: 109
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 30.59
tokens: 7509
characters: 2031
timestamp: 2025-12-24T10:48:35.209163
finish_reason: stop
---

Срезовый тип

Еще один тип данных, в котором не предусмотрено владение, — это срез (или отрезок). Срезы позволяют ссылаться не на всю коллекцию, а на сплошную последовательность элементов в коллекции.

Вот небольшая задача по программированию: нужно написать функцию, которая берет строку и возвращает первое слово, которое она находит в этой строке. Если функция не находит пробел в строке, то вся строка является одним словом, поэтому ее нужно возвратить целиком.

Давайте подумаем о сигнатуре этой функции:

fn first_word(s: &String) -> ?

Указанная функция first_word имеет в качестве параметра &String. Владение не требуется, так что все в порядке. Но что мы должны вернуть? На самом деле мы не можем говорить о части строки. Однако мы могли бы вернуть индекс конца слова. Давайте попробуем это сделать, как показано в листинге 4.7.

Листинг 4.7. Функция first_word, которая возвращает значение байтового индекса в параметр типа String
src/main.rs

fn first_word(s: &String) -> usize {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return i;
        }
    }

    s.len()
}

Поскольку нужно проверить экземпляр типа String поэлементно и посмотреть, что текущее значение является пробелом, мы выполним конвертирование нашего экземпляра в массив байт с помощью метода as_bytes 1. Далее мы создадим итератор по массиву байт, используя метод iter 3.

Подробнее об итераторах мы поговорим в главе 13. Пока же знайте, что iter — это метод, который возвращает каждый элемент в коллекции, а метод enumerate обертыает результат метода iter и возвращает каждый элемент как часть кортежа. Первый элемент кортежа, возвращаемого из enumerate, является индексом, а второй — ссылкой на элемент. Это немного удобнее, чем вычислять индекс самим.

Поскольку метод enumerate возвращает кортеж, мы можем использовать паттерны для деструктурирования этого кортежа, как и везде в Rust. Поэтому в цикле for мы указываем паттерн, который имеет i для индекса в кортеже и &item для