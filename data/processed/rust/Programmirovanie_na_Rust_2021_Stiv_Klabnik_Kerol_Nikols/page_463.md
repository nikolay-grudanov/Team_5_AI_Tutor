---
source_image: page_463.png
page_number: 463
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 29.15
tokens: 7490
characters: 1667
timestamp: 2025-12-24T10:57:57.207207
finish_reason: stop
---

мер, листинг 18.5 показывает попытку деструктурирования кортежа из трех элементов в две переменные, которая не будет работать.

Листинг 18.5. Неправильное построение паттерна, переменные которого не совпадают с числом элементов в кортеже

let (x, y) = (1, 2, 3);

Попытка компиляции этого кода приводит к ошибке типа:

error[E0308]: mismatched types
 --> src/main.rs:2:9
  |
2 |     let (x, y) = (1, 2, 3);
  |     ^^^^^ expected a tuple with 3 elements, found one with 2 elements
  = note: expected type `({integer}, {integer}, {integer})`
         found type `(_, _)`

Если бы мы хотели проигнорировать одно или несколько значений в кортеже, то могли бы использовать _ или .., как вы увидите в разделе «Игнорирование значений в паттерне». Если проблема состоит в том, что в паттерне слишком много переменных, то нужно сделать так, чтобы типы совпадали, удалив переменные, чтобы число переменных равнялось числу элементов в кортеже.

Параметры функций

Параметры функций также могут быть паттернами. Код в листинге 18.6, объявляющий функцию foo, которая берет один параметр x типа i32, теперь вам знаком.

Листинг 18.6. Сигнатура функции использует паттерны в параметрах

fn foo(x: i32) {
    // здесь будет код
}

Часть x — это паттерн! Как и в случае с let, мы можем сопоставить кортеж в аргументах функции с паттерном. Листинг 18.7 разбивает значения в кортеже в момент, когда мы передаем его внутрь функции.

Листинг 18.7. Функция с параметрами, которые деструктурируют кортеж
src/main.rs

fn print_coordinates(&(x, y): &(i32, i32)) {
    println!("Текущее местоположение: ({}, {})", x, y);
}

fn main() {
    let point = (3, 5);
    print_coordinates(&point);
}