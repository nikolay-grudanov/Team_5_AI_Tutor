---
source_image: page_334.png
page_number: 334
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 28.10
tokens: 7413
characters: 1686
timestamp: 2025-12-24T10:54:31.078225
finish_reason: stop
---

Обратите внимание, что метод zip производит только четыре пары. Теоретически возможная пятая пара (5, None) никогда не производится, потому что zip возвращает None, когда любой из его входных итераторов возвращает None.

Вызовы всех этих методов становятся возможными благодаря тому, что мы прописали, как работает метод next, а стандартная библиотека предоставляет реализации по умолчанию для других методов, которые вызывают next.

Улучшение проекта ввода-вывода

С учетом новых знаний об итераторах мы можем улучшить проект ввода-вывода из главы 12 путем применения итераторов, сделав места в коде более четкими и лаконичными. Давайте посмотрим, как итераторы улучшат реализацию функций Config::new и search.

Удаление метода clone с помощью Iterator

В листинг 12.6 мы добавили код, который брал срез значений типа String и создавал экземпляр структуры Config путем индексирования внутри этого среза и клонирования значений, позволяя структуре Config владеть этими значениями. В листинге 13.24 мы воспроизвели реализацию функции Config::new, как это было в листинге 12.23.

Листинг 13.24. Воспроизведение функции Config::new из листинга 12.23
src/lib.rs

impl Config {
    pub fn new(args: &[String]) -> Result<Config, &'static str> {
        if args.len() < 3 {
            return Err("недостаточно аргументов");
        }

        let query = args[1].clone();
        let filename = args[2].clone();

        let case_sensitive = env::var("CASE_INSENSITIVE").is_err();

        Ok(Config { query, filename, case_sensitive })
    }
}

В то время мы отметили, что не стоит беспокоиться о неэффективных вызовах метода clone, потому что мы удалим их в будущем. Ну что ж, время пришло!