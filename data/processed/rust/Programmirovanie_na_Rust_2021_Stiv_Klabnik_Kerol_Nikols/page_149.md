---
source_image: page_149.png
page_number: 149
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 36.73
tokens: 7718
characters: 2566
timestamp: 2025-12-24T10:49:43.958269
finish_reason: stop
---

src
$ ls my-project/src
main.rs

Когда мы ввели команду, пакетный менеджер Cargo создал файл Cargo.toml, обеспечив нас пакетом. Глядя на содержимое файла Cargo.toml, мы видим, что там нет упоминания о src/main.rs, потому что Cargo следует соглашению о том, что src/main.rs является упаковочным корнем двоичной упаковки с тем же именем, что и пакет. Кроме того, Cargo знает, что если каталог пакета содержит src/lib.rs, то указанный пакет содержит библиотечную упаковку с тем же именем, что и пакет, а src/lib.rs является его упаковочным корнем. Cargo передает файлы корня упаковки в rustc для построения библиотеки или двоичного файла.

Здесь мы имеем дело с пакетом, который содержит только src/main.rs, то есть только двоичную упаковку с именем my-project. Если в пакете есть src/main.rs и src/lib.rs, то он имеет две упаковки: библиотечную и двоичную — обе с тем же именем, что и пакет. Пакет может иметь несколько двоичных упаковок, помещая файлы в каталог src/bin: каждый файл будет отдельной двоичной упаковкой.

Упаковка будет группировать связанную функциональность в область видимости, вследствие чего эту функциональность можно легко использовать совместно в нескольких проектах. Например, упаковка rand, которую мы использовали в разделе «Генерирование секретного числа», предоставляет функциональность, генерирующую случайные числа. Мы можем использовать эту функциональность в собственных проектах, введя упаковку rand внутрь области видимости своего проекта. Вся функциональность, предусмотренная упаковкой rand, доступна благодаря ее имени, rand.

Функциональность упаковки в ее собственной области видимости проясняет, где определяется та или иная функциональность — в нашей упаковке либо в упаковке rand, и предотвращает потенциальные конфликты. Например, упаковка rand предоставляет типаж с именем Rng. Мы также можем определить структуру с именем Rng в нашей упаковке. Поскольку функциональность упаковки организуется в пространстве имен в ее собственной области видимости, когда мы добавляем rand в качестве зависимости, компилятор не путает смысл имени Rng. В нашей упаковке это относится к определенной нами структуре Rng. Можно получить доступ к типажу rand из упаковки rand как rand::Rnd.

Теперь давайте поговорим о модульной системе!

Определение модулей для управления областью видимости и конфиденциальностью

В этом разделе мы поговорим о модулях и других частях модульной системы, а именно о путях, позволяющих называть элементы, ключевом слове use, которое вводит путь в область видимости, и ключевом слове pub, которое делает элементы