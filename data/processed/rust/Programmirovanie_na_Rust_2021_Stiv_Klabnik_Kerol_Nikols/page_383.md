---
source_image: page_383.png
page_number: 383
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 33.53
tokens: 7591
characters: 2171
timestamp: 2025-12-24T10:55:54.550451
finish_reason: stop
---

делают реализации метода clone в большинстве типов. Вызов функции Rc::clone только наращивает число ссылок, это недолгий процесс. Глубокое копирование данных занимает много времени. Используя функцию Rc::clone для подсчета ссылок, мы можем видеть различие между видами клонирования с глубоким копированием и с увеличением числа ссылок. При поиске проблем с производительностью в коде мы должны учитывать только клонирования с глубоким копированием и не обращать внимания на вызовы функции Rc::clone.

Клонирование Rc<T> увеличивает число ссылок

Давайте изменим пример из листинга 15.18 и посмотрим, как изменяется число ссылок, когда мы создаем и отбрасываем ссылки на Rc<List> в а.

В листинге 15.19 мы изменим функцию main, чтобы у нее была внутренняя область вокруг списка с. Тогда мы сможем увидеть, как изменяется число ссылок, когда с выходит из указанной области.

Листинг 15.19. Вывод числа ссылок
src/main.rs

```rust
fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    println!("число после создания a = {}", Rc::strong_count(&a));
    let b = Cons(3, Rc::clone(&a));
    println!("число после создания b = {}", Rc::strong_count(&a));
    {
        let c = Cons(4, Rc::clone(&a));
        println!("число после создания c = {}", Rc::strong_count(&a));
    }
    println!("число после выхода с из области видимости = {}",
             Rc::strong_count(&a));
}
```

В каждой точке программы, где число ссылок изменяется, мы печатаем число ссылок, которое можно получить путем вызова функции Rc::strong_count. Эта функция названа strong_count («подсчет числа сильных ссылок») вместо count, потому что тип Rc<T> также имеет функцию weak_count («подсчет числа слабых ссылок»). Мы увидим, для чего используется функция weak_count, в разделе «Предотвращение циклов в переходах по ссылкам: превращение Rc<T> в Weak<T>» (с. 397).

Этот код выводит следующее:

число после создания a = 1
число после создания b = 2
число после создания c = 3
число после выхода с из области видимости = 2

Мы видим, что изначально Rc<List> имеет в а число ссылок, равное 1. Затем каждый раз, когда мы вызываем clone, это число увеличивается на 1. Когда с выхо-