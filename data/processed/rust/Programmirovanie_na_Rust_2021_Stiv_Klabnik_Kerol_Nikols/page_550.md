---
source_image: page_550.png
page_number: 550
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 41.15
tokens: 7623
characters: 2372
timestamp: 2025-12-24T11:00:28.428094
finish_reason: stop
---

дания потоков исполнения, а функция thread::spawn предусматривает получение некоторого программного кода, который поток должен исполнить после того, как она будет создана. Однако в нашем случае мы хотим создавать потоки — они будут ожидать программный код, который мы отправим позже. В реализации потоков исполнения стандартной библиотекой нет способов сделать это, мы должны реализовать такое поведение вручную.

Мы реализуем это поведение путем введения новой структуры данных между ThreadPool и потоками, которые будут управлять новым поведением. Мы обозначим эту структуру данных Worker («работник»), термином, часто встречающимся в реализациях операций с пулом. Представьте себе людей, работающих на кухне в ресторане: работники ждут заказов от клиентов, а затем отвечают за принятие этих заказов и их исполнение.

Вместо того чтобы хранить вектор экземпляров JoinHandle<>() в пуле потоков исполнения, мы будем хранить экземпляры структуры Worker. Каждый Worker будет хранить один экземпляр JoinHandle<()>. Затем мы реализуем метод для структуры Worker, который будет брать замыкание выполняемого кода и отправлять его в уже работающий поток для выполнения. Мы также дадим каждому работнику id, чтобы различать разных работников в пуле во время журналирования или отладки.

Давайте внесем следующие изменения в то, что происходит при создании пула потоков исполнения. Мы реализуем код, который отправляет замыкание потока после того, как Worker был настроен, следующим образом:

1. Определить структуру Worker, содержащую id и JoinHandle<()>.
2. Изменить ThreadPool так, чтобы он содержал вектор экземпляров структуры Worker.
3. Определить функцию Worker::new, которая берет id и возвращает экземпляр структуры Worker, содержащий id и поток, порожденный с пустым замыканием.
4. В функции ThreadPool::new использовать счетчик цикла for для генерирования id, создать новый экземпляр структуры Worker с этим id и сохранить его в векторе.

Если вы готовы принять вызов, то попробуйте реализовать эти изменения самостоятельно, прежде чем взглянуть на код в листинге 20.15.

Готовы? Вот листинг 20.15 с одним из способов внесения приведенных модификаций.

Листинг 20.15. Модифицирование структуры ThreadPool для хранения экземпляров структуры Worker вместо хранения потоков исполнения напрямую

src/lib.rs
use std::thread;

pub struct ThreadPool {
    workers: Vec<Worker>,