---
source_image: page_142.png
page_number: 142
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 27.70
tokens: 7467
characters: 1886
timestamp: 2025-12-24T10:49:24.865410
finish_reason: stop
---

Давайте представим, что у нас есть друг, который пытается собрать четвертаки всех 50 штатов. Пока мы сортируем разменную монету по типам, мы также будем называть штат, связанный с каждым четвертаком. Таким образом, в случае, если у друга нет такой монеты, он сможет добавить ее в свою коллекцию.

В выражении match для этого кода мы добавляем переменную state в паттерн, который сопоставляется со значениями варианта Coin::Quarter. Если Coin::Quarter совпадет, переменная state будет привязана к значению штата этого четвертака. Затем можно использовать state в коде для этого рукава:

```rust
fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter(state) => {
            println!("Четвертак из штата {:?}!", state);
            25
        },
    }
}
```

Если бы нужно было вызвать value_in_cents(Coin::Quarter(UsState::Alaska)), то переменная coin была бы Coin::Quarter(UsState::Alaska). Когда мы сравниваем это значение с каждым рукавом выражения match, ни один из них не совпадет до тех пор, пока мы не достигнем Coin::Quarter(state). В этом месте привязкой для state будет значение UsState::Alaska. Затем можно использовать эту привязку в выражении println!, получив таким образом внутреннее значение штата из варианта перечисления Coin для Quarter.

Сопоставление с Option<T>

В предыдущем разделе мы хотели получить внутреннее значение T из случая Some при использовании перечисления Option<T>. Можно обрабатывать Option<T>, используя выражение match, так же как это было с перечислением Coin! Вместо сравнения монет мы будем сравнивать варианты перечисления Option<T>, но характер работы выражения match останется тем же.

Допустим, мы хотим написать функцию, которая берет перечисление Option<i32> и, если внутри есть значение, то эта функция прибавляет к нему 1. Если внутри