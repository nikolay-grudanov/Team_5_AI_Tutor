---
source_image: page_084.png
page_number: 84
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 28.97
tokens: 7401
characters: 1710
timestamp: 2025-12-24T10:47:54.090719
finish_reason: stop
---

Использование слишком большого числа выражений else if загромождает код, поэтому, если у вас более одного выражения, вам, возможно, потребуется рефакторизовать код. В главе 6 описывается мощная конструкция ветвления в Rust под названием match, предназначенная для таких случаев.

Использование выражения if в инструкции let

Поскольку if является выражением, мы можем использовать его в правой части инструкции let, как в листинге 3.2.

Листинг 3.2. Назначение переменной результата выражения if
src/main.rs
```rust
fn main() {
    let condition = true;
    let number = if condition {
        5
    } else {
        6
    };

    println!("Значение числа равно {}", number);
}
```

Переменная number будет привязана к значению на основе результата выражения if. Выполните этот код и посмотрите, что произойдет:

```
$ cargo run
Compiling branches v0.1.0 (file:///projects/branches)
Finished dev [unoptimized + debuginfo] target(s) in 1.50 secs
    Running `target/debug/branches`
Значение числа равно 5
```

Помните, что блоки кода в результате вычисления принимают значение последнего выражения в них, и сами числа тоже являются выражениями. В данном случае значение всего выражения if зависит от того, какой блок кода исполняется. Это означает, что значения, которые потенциально будут результатами из каждого ветвления if, должны иметь одинаковый тип. В листинге 3.2 результаты как ветвления if, так и ветвления else были целыми числами i32. Если типы не совпадают, как в следующем примере, то мы получим ошибку:

src/main.rs
```rust
fn main() {
    let condition = true;

    let number = if condition {
        5
    } else {
        "шесть"
    };

    println!("Значение числа равно {}", number);
}
```