---
source_image: page_337.png
page_number: 337
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 30.71
tokens: 7442
characters: 1806
timestamp: 2025-12-24T10:54:35.902429
finish_reason: stop
---

let case_sensitive = env::var("CASE_INSENSITIVE").is_err();

Ok(Config { query, filename, case_sensitive })
}

Как вы помните, первым значением в возвращаемом значении env::args является имя программы. Мы хотим его проигнорировать и перейти к следующему значению, поэтому сначала мы вызываем next и ничего с возвращенным значением не делаем. Далее мы вызываем next и получаем значение, которое хотим поместить в поле query структуры Config. Если next возвращает значение Some, то мы используем выражение match для извлечения значения. Если он возвращает None, то это означает, что было дано недостаточно аргументов, и мы возвращаемся досрочно со значением Err. Мы делаем то же самое для значения filename.

Написание более ясного кода с помощью итераторных адаптеров

Мы можем воспользоваться преимуществами итераторов и в функции search проекта ввода-вывода, которая воспроизводится в листинге 13.28 так, как это было в листинге 12.19.

Листинг 13.28. Реализация функции search из листинга 12.19
src/lib.rs

pub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.contains(query) {
            results.push(line);
        }
    }

    results
}

Мы можем написать этот код в более сжатом виде, используя методы итераторных адаптеров. Они также позволяют избежать изменяемого вектора промежуточных результатов results. Функциональный стиль программирования предпочитает минимизировать объем изменяемых состояний, чтобы сделать код понятнее. Удаление изменяемого состояния может обеспечить возможность для будущих улучшений, которые позволят выполнять процедуру поиска в параллельном режиме, поскольку нам не придется управлять конкурентным доступом к вектору results. Это изменение показано в листинге 13.29.