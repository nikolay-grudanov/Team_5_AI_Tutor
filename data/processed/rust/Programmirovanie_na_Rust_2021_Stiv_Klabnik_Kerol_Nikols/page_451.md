---
source_image: page_451.png
page_number: 451
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 34.03
tokens: 7517
characters: 2027
timestamp: 2025-12-24T10:57:44.184146
finish_reason: stop
---

Затем мы вызываем метод unwrap, который, как известно, никогда не будет паниковать. Мы знаем, что благодаря методам для структуры Post поле state всегда содержит значение Some, когда эти методы заканчивают работу. Это один из случаев, о которых мы говорили в разделе «Случаи, когда у вас больше информации, чем у компилятора» (с. 206), когда известно, что значение None невозможно, даже если компилятор не в состоянии понять это.

В момент, когда мы вызываем метод content для &Box<Dyn State>, вступит в силу принудительное приведение типа посредством deref для & и Box, и поэтому метод content в конечном счете будет вызван для типа, который реализует типаж State. Таким образом, нам нужно добавить content в определение типажа State. Именно там мы разместим алгоритм для возврата содержимого в зависимости от имеющегося состояния, как показано в листинге 17.18.

Листинг 17.18. Добавление метода content в типаж State

src/lib.rs

trait State {
    // --пропуск--
    fn content<'a>(&self, post: &'a Post) -> &'a str {
        ① ""
    }
}

// --пропуск--

struct Published {}

impl State for Published {
    // --пропуск--
    fn content<'a>(&self, post: &'a Post) -> &'a str {
        ② &post.content
    }
}

Мы добавляем реализацию по умолчанию для метода content, которая возвращает пустой строковый срез ①. То есть нам не нужно реализовывать content в структурах Draft и PendingReview. Структура Published будет переопределять метод content и возвращать значение в post.content ②.

Обратите внимание, что для этого метода нужны аннотации жизненных циклов, как обсуждалось в главе 10. Мы берем ссылку на post в качестве аргумента и возвращаем ссылку на часть этого аргумента post, поэтому жизненный цикл возвращаемой ссылки связан с жизненным циклом аргумента post.

И дело сделано — теперь весь листинг 17.11 работает! Мы применили паттерн переходов между состояниями к процессу создания статьи для блога. Алгоритм, связанный с указанными правилами, размещен в объектах состояния, а не разбросан по всей структуре Post.