---
source_image: page_427.png
page_number: 427
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 28.49
tokens: 7455
characters: 1911
timestamp: 2025-12-24T10:56:57.289056
finish_reason: stop
---

Атомарный подсчет ссылок с помощью Arc<T>

К счастью, тип Arc<T> подобен Rc<T> и безопасен для использования в конкурентных ситуациях. Буква «а» в имени типа расшифровывается как «атомарный», то есть это тип с атомарным подсчетом ссылок. Атомики (atomics) — это дополнительный вид конкурентных примитивов, который здесь не будет рассматриваться подробно: для получения дополнительной информации обратитесь к документации стандартной библиотеки по std::sync::atomic. Пока же вам просто нужно знать, что атомики работают как примитивные типы, но ими можно безопасно делиться между несколькими потоками.

Тогда вы можете задаться вопросом, почему все примитивные типы не атомарны и почему типы стандартной библиотеки не реализованы с Arc<T> по умолчанию. Причина заключается в том, что безопасность потоков затратна для производительности и применяется только когда это необходимо. Если вы выполняете операции лишь со значениями в одном потоке, то код будет работать быстрее, если ему не нужно соблюдать гарантии, предусмотренные атомиками.

Давайте вернемся к нашему примеру: типы Arc<T> и Rc<T> имеют один и тот же API, поэтому мы исправляем программу, изменяя строки use, вызова функции new и вызова метода clone. Код в листинге 16.15 будет окончательно скомпилирован и выполнен.

Листинг 16.15. Использование типа Arc<T> для обертывания типа Mutex<T>, чтобы делиться владением между несколькими потоками

src/main.rs

use std::sync::{Mutex, Arc};
use std::thread;

fn main() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Результат: {}", *counter.lock().unwrap());
}