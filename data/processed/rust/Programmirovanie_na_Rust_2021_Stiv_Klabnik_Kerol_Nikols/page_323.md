---
source_image: page_323.png
page_number: 323
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 34.63
tokens: 7598
characters: 2233
timestamp: 2025-12-24T10:54:19.752144
finish_reason: stop
---

Проблема состоит в том, что в первый раз, когда мы вызвали с.value с 1, экземпляр структуры Cacher сохранил Some(1) в self.value. После этого, независимо от того, что мы передаем в метод value, он всегда будет возвращать 1.

Попробуйте модифицировать структуру Cacher так, чтобы она содержала не одно значение, а хеш-отображение. Ключами хеш-отображения будут передаваемые значения arg, а значения хеш-отображения будут результатом вызова замыкания по этому ключу. Вместо того чтобы смотреть, есть ли в self.value напрямую значение Some или None, функция value будет искать arg в хеш-отображении и возвращать значение, если оно присутствует. Если его нет, то Cacher вызовет замыкание и сохранит полученное значение в хеш-отображении, связанном со значением его arg.

Вторая проблема в текущей реализации структуры Cacher заключается в том, что она принимает только те замыкания, которые берут один параметр типа u32 и возвращают тип u32. Например, мы могли бы кэшировать результаты замыканий, которые принимают строковый срез и возвращают значения типа usize. В целях устранения этой проблемы попробуйте ввести более обобщенные параметры для повышения гибкости в функциональности структуры Cacher.

Захватывание среды с помощью замыканий

В примере генератора тренировок мы использовали замыкания только как встроенные анонимные функции. Однако у замыканий есть дополнительная возможность, которой нет у функций: они могут захватывать свою среду и обращаться к переменным из области видимости, в которой они определены.

В листинге 13.12 приведен пример замыкания, хранящегося в переменной equal_to_x, которая использует переменную x из среды замыкания.

Листинг 13.12. Пример замыкания, ссылающегося на переменную в окаймляющей ее области видимости
src/main.rs
```rust
fn main() {
    let x = 4;

    let equal_to_x = |z| z == x;

    let y = 4;

    assert!(equal_to_x(y));
}
```

Здесь, даже если x не является одним из параметров замыкания equal_to_x, указанному замыканию разрешено использовать переменную x, которая определена в той же области видимости, в которой определено замыкание equal_to_x.

Мы не можем сделать то же самое с функциями. Если мы попробуем это сделать в следующем примере, то код компилироваться не будет: