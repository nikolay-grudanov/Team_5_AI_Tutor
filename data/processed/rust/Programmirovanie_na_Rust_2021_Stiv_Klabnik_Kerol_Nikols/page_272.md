---
source_image: page_272.png
page_number: 272
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 38.23
tokens: 7576
characters: 2194
timestamp: 2025-12-24T10:52:58.230106
finish_reason: stop
---

тает, а где не работает как должно. Вы будете размещать модульные тесты в каталоге src в каждом файле вместе с кодом, который они тестируют. В каждом файле принято создавать модуль с именем tests, содержащим тестовые функции, и аннотировать модуль с помощью cfg(test).

Модуль tests и #[cfg(test)]

Аннотация #[cfg(test)] для модуля tests говорит компилятору выполнить тестовый код, только при запуске команды cargo test, а не при запуске cargo build. Это экономит время компиляции, когда вы хотите только собрать библиотеку и сэкономить место в итоговом скомпилированном артефакте, так как тесты не включены. Вы увидите, что, поскольку интеграционные тесты располагаются в другом каталоге, они не нуждаются в аннотации #[cfg(test)]. Но поскольку модульные тесты находятся в тех же файлах, что и код, вы будете использовать #[cfg(test)], чтобы указать, что их не следует включать в скомпилированный результат.

Напомним, что, когда мы создавали новый проект adder в первом разделе этой главы, Cargo генерировал код ниже за нас:

src/lib.rs
    #[cfg(test)]
    mod tests {
        #[test]
        fn it_works() {
            assert_eq!(2 + 2, 4);
        }
    }

Этот код автоматически генерируется тестовым модулем. Атрибут cfg расшифровывается как конфигурация и сообщает компилятору, что следующий элемент должен быть включен только при заданном варианте конфигурации. В данном случае вариантом конфигурации является test, предусмотренный языком для компиляирования и выполнения тестов. Используя атрибут cfg, Cargo компилирует тестовый код только в том случае, если мы активно выполняем тесты с помощью команды cargo test. Сюда входят любые вспомогательные функции, которые могут быть в этом модуле, в дополнение к функциям, аннотированным атрибутом #[test].

Тестирование приватных функций

В сообществе тестирования ведутся споры о том, следует ли тестировать приватные функции напрямую, тогда как другие языки затрудняют или делают невозможным тестирование приватных функций. Независимо от того, какой идеологии тестирования вы придерживаетесь, правила конфиденциальности Rust позволяют тестировать приватные функции. Рассмотрим код в листинге 11.12 с приватной функцией internal_adder.