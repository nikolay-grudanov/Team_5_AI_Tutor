---
source_image: page_139.png
page_number: 139
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 33.99
tokens: 7605
characters: 2743
timestamp: 2025-12-24T10:49:25.272428
finish_reason: stop
---

типа i8, компилятор обеспечит, чтобы значение всегда было действительно. Мы можем действовать уверенно, не проводя проверок на null перед использованием этого значения. Нам приходится беспокоиться о возможном отсутствии значения, только когда у нас есть Option<i8> (или любой другой тип значения, с которым мы работаем), а компилятор сделает так, чтобы мы справились с задачей, прежде чем использовать это значение.

Другими словами, вы должны конвертировать тип Option<T> в T, прежде чем сможете выполнять операции с t. Как правило, это помогает выявлять одну из самых распространенных проблем с null: допущение, что нечто не является null, когда в действительности оно является таковым.

Если вам не нужно беспокоиться о том, как избежать ошибок при работе со значениями, которые не являются null, то вы можете быть уверены в своем коде. Для того чтобы иметь значение, которое может быть null, вы должны сделать тип этого значения типом Option<T>. Когда вы используете это значение, вам следует проанализировать ситуацию, при которой значение равно null. Если значение имеет тип, который не является Option<T>, можно с уверенностью допустить, что значение не является null. Решение разработчиков языка Rust ограничить всеобъемлющее свойство null и повысить безопасность кода Rust было сознательным.

Как получить значение типа T из некоторого варианта и использовать его, когда есть значение типа Option<T>? Перечисление Option<T> имеет большое число методов, которые полезны в различных ситуациях. Вы можете обратиться к ним в документации. Знакомство с методами, относящимися к Option<T>, будет чрезвычайно полезным в процессе изучения Rust.

В общем, для того чтобы использовать значение перечисления Option<T>, нужен код, который будет обрабатывать каждый вариант. Требуется некоторый код, который будет выполняться только в случае, когда у вас есть значение Some(T), и этому коду разрешается использовать внутренний T. Нужно, чтобы выполнялся какой-то другой код, если у вас есть значение None, а у этого кода нет значения T. Выражение match является той конструкцией управления потоком, которая делает именно это при использовании с перечислениями: она будет выполнять разный код в зависимости от того, какой вариант перечисления у нее есть, а этот код будет использовать данные внутри совпадающего значения.

Выражение match как оператор управления потоком

В языке Rust есть чрезвычайно мощное выражение, выступающее как оператор управления потоком, под названием match. Оно позволяет сравнивать значение с серией паттернов, а затем исполнять код, основываясь на том, какой паттерн совпадает. Паттерны могут состоять из буквенных значений, имен переменных, подстановочных знаков и других элементов. В главе 18 рассказывается о разных