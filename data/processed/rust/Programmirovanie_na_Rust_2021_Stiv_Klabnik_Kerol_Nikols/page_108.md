---
source_image: page_108.png
page_number: 108
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 28.17
tokens: 7428
characters: 1779
timestamp: 2025-12-24T10:48:30.142351
finish_reason: stop
---

Это сообщение об ошибке относится к языковому средству, которое мы еще не рассмотрели, — жизненным циклам. Мы подробно обсудим жизненный цикл в главе 10. Но если вы пропустите часть, посвященную жизненным циклам, то указанное сообщение действительно содержит ключ к тому, почему этот код является проблемным¹:

this function's return type contains a borrowed value, but there is no value for it to be borrowed from.

Давайте посмотрим, что именно происходит на каждом этапе кода функции dangle:

src/main.rs
fn dangle() -> &String { // dangle возвращает ссылку на String
    let s = String::from("hello"); // s — это новый экземпляр типа String
    &s // мы возвращаем ссылку на String, s
} // Здесь s выходит из области видимости и отбрасывается. Ее память уходит.
    // Поберегись!

Так как переменная s создана внутри функции dangle, когда код функции dangle завершен, место для указанной переменной освобождается. Но мы попытались вернуть ссылку на нее. Это означает, что ссылка будет указывать на недействительный экземпляр типа String. Это никуда не годится! Rust не позволит нам это сделать.

Решение заключается в том, чтобы вернуть экземпляр типа String напрямую:

src/main.rs
fn no_dangle() -> String {
    let s = String::from("hello");
    s
}

Этот код работает без проблем. Владение перемещено наружу, и ничто не высвобождается.

Правила ссылок

Давайте повторим пройденный материал про ссылки:

○ В любой момент времени у вас может быть один из двух вариантов, но не оба: одна изменяемая ссылка либо любое число неизменяемых ссылок.

○ Ссылки всегда должны быть действительными.

Далее мы рассмотрим совсем другой вид ссылок — срезы.

¹ Тип возвращения из этой функции содержит заимствованное значение, но значение, которое она могла бы заимствовать, отсутствует.