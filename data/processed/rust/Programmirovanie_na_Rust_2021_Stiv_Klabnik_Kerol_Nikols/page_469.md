---
source_image: page_469.png
page_number: 469
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 25.85
tokens: 7419
characters: 1611
timestamp: 2025-12-24T10:58:03.126102
finish_reason: stop
---

Вот пример использования интервалов значений char:

    let x = 'c';

    match x {
        'a' ... 'j' => println!("буква вверху ASCII"),
        'k' ... 'z' => println!("буква внизу ASCII"),
        _ => println!("что-то еще"),
    }

Язык Rust может различить, что с находится внутри интервала первого паттерна, и выводит буква вверху ASCII.

Деструктурирование для выделения значений

Мы также можем использовать паттерны для деструктурирования структур, перечислений, кортежей и ссылок, чтобы использовать разные части этих значений. Давайте разберем каждое значение.

Деструктурирование

Листинг 18.12 показывает структуру Point с двумя полями x и y, которую можно разбить с помощью паттерна с инструкцией let.

Листинг 18.12. Деструктурирование полей структуры на отдельные переменные
src/main.rs

    struct Point {
        x: i32,
        y: i32,
    }

    fn main() {
        let p = Point { x: 0, y: 7 };

        let Point { x: a, y: b } = p;
        assert_eq!(0, a);
        assert_eq!(7, b);
    }

Приведенный код создает переменные a и b, которые совпадают со значениями полей x и y структуры p. Этот пример показывает, что имена переменных в паттерне не обязательно должны совпадать с именами полей структуры. Но обычно требуется, чтобы имена переменных совпадали с именами полей. Это нужно для того, чтобы было легче запомнить, какие переменные пришли из каких полей.

Поскольку сопоставление имен переменных с полями встречается часто и написание let Point { x: x, y: y } = p; содержит много повторов, для паттернов, которые сочетаются с полями структур, существует сокращенная форма. Нужно