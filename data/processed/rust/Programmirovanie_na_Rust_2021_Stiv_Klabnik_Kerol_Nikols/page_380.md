---
source_image: page_380.png
page_number: 380
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 35.22
tokens: 7620
characters: 2451
timestamp: 2025-12-24T10:55:49.226260
finish_reason: stop
---

Вам также не нужно беспокоиться о проблемах, возникающих в результате нечаянной очистки используемых значений: благодаря системе владения ссылки всегда действительно, а метод drop вызывается только один раз, когда значение больше не используется.

Теперь, рассмотрев Box<T> и некоторые характеристики умных указателей, давайте обратимся к другим умным указателям из стандартной библиотеки.

Rc<T> — умный указатель подсчета ссылок

В большинстве случаев владение понятно: вы точно знаете, какая переменная владеет тем или иным значением. Однако бывают случаи, когда у одного значения может быть несколько владельцев. Например, в графовых структурах данных несколько ребер могут указывать на один и тот же узел, и этот узел концептуально находится во владении всех ребер, которые на него указывают. Узел не должен очищаться, если только на него не указывает ни одно ребро.

Для множественного владения в языке Rust имеется тип с именем Rc<T> — это аббревиатура словосочетания reference counting, то есть «подсчет ссылок». Тип Rc<T> отслеживает число ссылок на значение и позволяет выяснить, используется ли значение по-прежнему. Если имеется ноль ссылок на значение, то это значение можно очистить, при этом ссылки не становятся недействительными.

Представьте себе Rc<T> как телевизор в гостиной. Когда один человек приходит посмотреть телевизор, он его включает. Другие тоже могут прийти в комнату посмотреть телевизор. Когда последний человек выходит из комнаты, он выключает телевизор, потому что его больше никто не смотрит. Если кто-то выключит телевизор, когда другие его смотрят, то оставшиеся телезрители будут недовольны!

Мы используем тип Rc<T>, когда хотим разместить некоторые данные в куче, чтобы их читали несколько частей программы, и мы не можем выяснить во время компиляции, какая часть последней завершит использование данных. Если бы мы знали, какая часть будет последней, то мы бы просто могли сделать указанную часть владельцем этих данных, и в силу вступили бы обычные правила владения, применяемые во время компиляции.

Обратите внимание, что тип Rc<T> предназначен только для использования в однопоточных сценариях. При рассмотрении конкурентности в главе 16 мы изучим, как считать ссылки в многопоточных программах.

Применение Rc<T> для совместного использования данных

Давайте вернемся к примеру с cons-списком в листинге 15.5. Напомним, что мы определили его с помощью умного указателя Box<T>. На этот раз мы создадим два