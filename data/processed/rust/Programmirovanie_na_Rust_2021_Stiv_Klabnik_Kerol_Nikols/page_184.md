---
source_image: page_184.png
page_number: 184
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 36.76
tokens: 7623
characters: 2361
timestamp: 2025-12-24T10:50:39.390687
finish_reason: stop
---

Обратите внимание, что сначала нужно использовать тип HashMap из раздела коллекций стандартной библиотеки. Из трех часто встречающихся коллекций эта используется реже всего, поэтому она не входит в состав средств, включенных в прелюдию автоматически. Хеш-отображения также имеют меньшую поддержку со стороны стандартной библиотеки: например, для их проектирования нет встроенной макрокоманды.

Как и векторы, хеш-отображения хранят данные в куче. Этот экземпляр типа HashMap имеет ключи типа String и значения типа i32. Как и векторы, хеш-отображения однородны: у всех ключей должен быть один и тот же тип, и у всех значений тоже должен быть один и тот же тип.

Еще один способ построения хеш-отображения предусматривает использование метода collect в векторе кортежей, где каждый кортеж состоит из ключа и его значения. Метод collect собирает данные в несколько коллекционных типов, включая HashMap. Например, если бы у нас были названия команд и начальные баллы в двух отдельных векторах, то мы бы могли применить метод zip для создания вектора кортежей, где название «Синяя» связано с 10, и так далее. Затем можно было бы применить метод collect, чтобы превратить этот вектор кортежей в хеш-отображение, как показано в листинге 8.21.

Листинг 8.21. Создание хеш-отображения из списка команд и списка баллов

use std::collections::HashMap;

let teams = vec![String::from("Синяя"), String::from("Желтая")];
let initial_scores = vec![10, 50];

let scores: HashMap<_, _> = teams.iter().zip(initial_scores.iter()).collect();

Аннотация типа HashMap<_, _> здесь необходима, потому что метод collect может производить сборку в целый ряд разных структур данных, и язык Rust не знает, чего вы хотите, если ее не укажете. Однако для параметров типов ключей и значений мы используем подчеркивания, и язык Rust может логически вывести типы, которые содержит хеш-отображение, основываясь на типах данных в векторах.

Хеш-отображения и владение

Для типов, реализующих типаж Сору, таких как i32, значения копируются внутрь хеш-отображения. Для обладаемых значений, таких как String, значения будут перемещены, а хеш-отображение будет владельцем этих значений, как показано в листинге 8.22.

Листинг 8.22. Показывает, что ключи и значения находятся во владении хеш-отображения после их вставки

use std::collections::HashMap;

let field_name = String::from("Любимый цвет");