---
source_image: page_393.png
page_number: 393
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 32.27
tokens: 7564
characters: 1973
timestamp: 2025-12-24T10:56:08.612188
finish_reason: stop
---

гим списком. Поскольку умный указатель Rc<T> содержит только неизменяемые значения, создав значения, мы не можем изменить ни одно из них. Давайте добавим умный указатель RefCell<T>, чтобы изменять значения в списках. Листинг 15.24 показывает, что при использовании умного указателя RefCell<T> в определении Cons мы можем модифицировать значение, хранящееся во всех списках.

Листинг 15.24. Использование умного указателя Rc<RefCell<i32>> для создания экземпляра перечисления List, который мы можем изменять

src/main.rs
```rust
#[derive(Debug)]
enum List {
    Cons(Rc<RefCell<i32>>, Rc<List>),
    Nil,
}
use crate::List::{Cons, Nil};
use std::rc::Rc;
use std::cell::RefCell;

fn main() {
    let value = Rc::new(RefCell::new(5));
    let a = Rc::new(Cons(Rc::clone(&value), Rc::new(Nil)));
    let b = Cons(Rc::new(RefCell::new(6)), Rc::clone(&a));
    let c = Cons(Rc::new(RefCell::new(10)), Rc::clone(&a));

    *value.borrow_mut() += 10;
    println!("a после = {:?}", a);
    println!("b после = {:?}", b);
    println!("c после = {:?}", c);
}
```

Мы создаем значение, которое является экземпляром Rc<RefCell<i32>>, и сохраняем его в переменной с именем value ①, чтобы впоследствии обращаться к нему напрямую. Затем мы создаем List в а с вариантом Cons, который содержит value ②. Нам нужно клонировать value так, чтобы и a, и value были владельцами внутреннего значения 5, а не передавали владение от value к a или заимствовали у value.

Мы обертываем список a в умный указатель Rc<T>, чтобы при создании списков b и c они оба могли ссылаться на a, что мы и сделали в листинге 15.18.

После того как мы создали списки в a, b и c, мы прибавляем 10 к значению в value ③. Мы делаем это, вызывая функцию loan_mut для value, которая использует средство автоматической разыменования, описанное в главе 5 (см. врезку на с. 128 «Где оператор ->?») для того, чтобы проследовать по указателю Rc<T> к внутреннему значению RefCell<T>. Метод borrow_mut возвращает умный указатель