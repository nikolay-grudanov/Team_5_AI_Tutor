---
source_image: page_093.png
page_number: 93
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 33.64
tokens: 7589
characters: 2426
timestamp: 2025-12-24T10:48:11.412940
finish_reason: stop
---

Листинг 4.1. Переменная и область, в которой эта переменная действует

{
    let s = "hello "; // s здесь не действует; она еще не объявлена
    // s действует с этого момента и далее
    // что-то сделать с s
    // эта область закончилась, и s больше не действует
}

Другими словами, здесь имеется два важных момента во времени:

○ когда переменная s входит в область видимости, она становится действительной;
○ она остается действительной до тех пор, пока не выйдет из области видимости.

В этой точке связь между областями видимости и действительноми переменными аналогична той, что существует в других языках программирования. Теперь мы будем опираться на это понимание, представив тип String.

Строковый тип

В целях иллюстрации правил владения нам нужен более сложный тип данных, чем те, о которых мы говорили в разделе «Типы данных». Все описанные ранее типы хранятся в стеке и выталкиваются из него, когда их область видимости заканчивается. Но мы хотим посмотреть на данные, хранящиеся в куче, и понять, каким образом Rust знает, когда нужно очищать эти данные.

В качестве примера мы будем использовать тип String и сосредоточимся на тех частях указанного типа, которые относятся к владению. Эти аспекты также применимы к другим сложным типам данных, предусмотренным стандартной библиотекой, а также к тем, которые вы создаете. О типе String мы поговорим подробнее в главе 8.

Мы уже встречали строковые литералы, где значение строки жестко кодируется в программу. Указанные литералы удобны, но они не подходят для каждой ситуации, в которой мы используем текст. Одна из причин заключается в том, что они неизменяемы. Вторая причина — не каждое строковое значение может быть известно, когда мы пишем код. Например, что делать, если мы хотим взять у пользователя данные и сохранить их? Для этих ситуаций в Rust есть второй строковый тип — string. Пространство для этого типа выделяется в куче, и по этой причине он способен хранить объем текста, который нам не известен во время компиляции. Вы можете создать экземпляр типа String из строкового литерала с помощью функции from, например:

let s = String::from("hello");

Двойное двоеточие (::) — это оператор, который позволяет использовать пространство имен конкретной функции from под типом String вместо имени наподобие string_from. Мы обсудим этот синтаксис подробнее в разделе «Синтаксическое оформление метода», а также при рассмотрении организации пространств