---
source_image: page_453.png
page_number: 453
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 37.98
tokens: 7629
characters: 2443
timestamp: 2025-12-24T10:57:51.387828
finish_reason: stop
---

нию для методов request_review и approve для типажа State, которые возвращают self. Однако это нарушило бы объектную безопасность, потому что этот типаж не знает, каким конкретно будет self. Мы хотим использовать типаж State как типажный объект, поэтому его методы должны быть безопасными для объектов.

Другой повтор включает в себя схожие реализации методов request_review и approve в структуре Post. Оба метода делегируют полномочия одинакового метода, определенного для значения поля state экземпляра типа Option, и устанавливают новое значение поля state равным результату. Если бы для структуры Post было много методов, которые следовали бы этому паттерну, то мы бы могли подумать об определении макрокоманды для устранения повтора (см. раздел «Макрокоманды» в главе 19).

Применяя паттерн переходов между состояниями в точности как он определен для объектно-ориентированных языков, мы не используем сильные стороны Rust в полной мере. Давайте взглянем на некоторые изменения упаковки blog, из-за которых недопустимые состояния и переходы могут превратиться в ошибки времени компиляции.

Кодирование состояний и поведения как типов

Мы покажем вам, как переосмыслить паттерн переходов между состояниями, чтобы получить другую совокупность преимуществ. Вместо полной инкапсуляции состояний и переходов, чтобы внешний код о них не знал, мы будем кодировать состояния в разные типы. Следовательно, система проверки типов Rust будет предотвращать попытки использовать черновики там, где разрешены только опубликованные статьи, выдавая ошибку компилятора.

Давайте рассмотрим первую часть функции main в листинге 17.11:

src/main.rs
```rust
fn main() {
    let mut post = Post::new();

    post.add_text("Сегодня на обед я ел салат");
    assert_eq!("", post.content());
}
```

Мы по-прежнему можем создавать новые статьи в черновом состоянии с помощью функции Post::new, а также добавлять текст в пост. Но у черновика-поста не будет метода content, который возвращает пустую строку. Вместо этого мы сделаем так, чтобы черновые статьи вообще не имели метода content. Благодаря этому, если мы попытаемся получить содержимое черновой статьи, то получим ошибку компилятора, сообщающую о том, что данный метод не существует. В результате мы не сможем случайно показать содержимое черновой статьи, потому что этот код даже не будет компилироваться. В листинге 17.19 показано определение структур Post и DraftPost, а также методы для каждой из них.