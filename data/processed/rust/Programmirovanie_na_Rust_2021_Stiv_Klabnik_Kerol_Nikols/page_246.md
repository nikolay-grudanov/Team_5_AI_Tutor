---
source_image: page_246.png
page_number: 246
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 36.46
tokens: 7674
characters: 2434
timestamp: 2025-12-24T10:52:19.773743
finish_reason: stop
---

вив аннотации жизненных циклов, которые описывают то, как ссылки соотносятся друг с другом.

Жизненный цикл для параметров функций или методов называется входным жизненным циклом, а жизненный цикл для возвращаемых значений — выходным жизненным циклом.

Чтобы выяснить, какие жизненные циклы есть у ссылок, когда нет явно заданных аннотаций, компилятор использует три правила. Первое правило применяется к входным жизненным циклам, а второе и третье — к выходным. Если компилятор дойдет до конца этих трех правил и все еще останутся ссылки, для которых он не может выяснить жизненный цикл, то компилятор остановится с ошибкой. Эти правила применимы к определениям fn, а также к блокам impl.

Первое правило состоит в том, что каждый параметр, являющийся ссылкой, получает собственный параметр жизненного цикла. Другими словами, функция с одним параметром получает один параметр жизненного цикла: fn foo<'a>(x: &'a i32); функция с двумя параметрами получает два отдельных параметра жизненного цикла: fn foo<'a, 'b>(x: &'a i32, y: &'b i32) и так далее.

Второе правило состоит в том, что, если имеется ровно один параметр входного жизненного цикла, то этот параметр жизненного цикла назначается всем параметрам выходных жизненных циклов: fn foo<'a>(x: &'a i32) -> &'a i32.

Третье правило заключается в том, что, если имеется несколько параметров входных жизненных циклов, но один из них является &self или &mut self, так как это метод, то жизненный цикл параметра self назначается всем параметрам выходных жизненных циклов. Это третье правило делает методы гораздо удобнее для чтения и записи, поскольку требуется меньше символов.

Давайте представим, что мы — компилятор. Мы применим эти правила, чтобы выяснить продолжительность жизненного цикла ссылок в сигнатура функции first_word в листинге 10.26. Сигнатура начинается без каких-либо жизненных циклов, связанных со ссылками:

fn first_word(s: &str) -> &str {

Затем компилятор применяет первое правило, которое описывает, что каждый параметр получает свой собственный жизненный цикл. Как обычно, мы назовем его 'a, поэтому теперь сигнатура будет такой:

fn first_word<'a>(s: &'a str) -> &str {

Второе правило применяется потому, что существует ровно один входной жизненный цикл. Второе правило описывает, что жизненный цикл одного входного параметра назначается выходному жизненному циклу, поэтому сигнатура теперь будет выглядеть так:

fn first_word<'a>(s: &'a str) -> &'a str {