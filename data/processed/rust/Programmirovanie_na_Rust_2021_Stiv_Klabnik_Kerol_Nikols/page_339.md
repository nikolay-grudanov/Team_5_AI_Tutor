---
source_image: page_339.png
page_number: 339
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 42.17
tokens: 7682
characters: 2480
timestamp: 2025-12-24T10:54:52.736774
finish_reason: stop
---

Итераторная версия оказалась чуть-чуть быстрее! Мы не будем здесь объяснять исходный код, потому что речь не о том, чтобы доказать, что эти две версии эквивалентны, а о том, чтобы получить общее представление, как эти реализации соотносятся с точки зрения производительности.

В целях всестороннего сравнительного тестирования вы должны провести проверку, используя тексты разных размеров в качестве содержимого и слова разной длины в качестве запросов, а также другие всевозможные вариации. Суть в следующем: итераторы, хотя и являются высокоуровневой абстракцией, компилируются примерно до такого же кода, как если бы вы сами написали код более низкого уровня. Итераторы в языке Rust представляют собой одну из абстракций с нулевой стоимостью, под которой мы подразумеваем, что использование абстракции не накладывает никакого расхода времени выполнения. Это аналогично тому, как Бьерн Страуструп, первый дизайнер и разработчик C++, определяет нулевые накладные расходы в «Основах C++» (2012):

В общем, реализации C++ подчиняются принципу нулевых накладных расходов: вы не платите за то, что не используете. И далее: а с тем, что вы применяете, лучшего кода вручную вы и написать не сможете.

В качестве еще одного примера можно привести следующий код, взятый из аудиодекодера. Алгоритм декодирования использует математическую операцию линейного предсказания, чтобы оценивать будущие значения на основе линейной функции предыдущих выборок. Этот код использует итераторную цепочку для выполнения математических вычислений с тремя переменными в области видимости: со срезом данных buffer, массивом coefficients из 12 коэффициентов и суммой, на которую данные должны быть сдвинуты в qlp_shift. В этом примере мы объявили переменные, но не дали им никаких значений. Хотя этот код не очень важен вне своего контекста, это все равно краткий, реальный пример того, как язык Rust транслирует высокоуровневые идеи в низкоуровневый код.

let buffer: &mut [i32];
let coefficients: [i64; 12];
let qlp_shift: i16;

for i in 12..buffer.len() {
    let prediction = coefficients.iter()
        .zip(&buffer[i - 12..i])
        .map(|(&c, &s)| c * s as i64)
        .sum::<i64>() >> qlp_shift;
    let delta = buffer[i];
    buffer[i] = prediction as i32 + delta;
}

Для того чтобы рассчитать значение переменной prediction, этот код перебирает каждое из 12 значений в coefficients и использует метод zip для соединения значений коэффициентов в пары с предыдущими 12 значениями в buffer. Затем