---
source_image: page_376.png
page_number: 376
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 35.57
tokens: 7638
characters: 2463
timestamp: 2025-12-24T10:55:42.553845
finish_reason: stop
---

О Из &T в &U, когда T: Deref<Target=U>.
О Из &mut T в &mut U, когда T: DerefMut<Target=U>.
О Из &mut T в &U, когда T: Deref<Target=U>.

Первые два случая одинаковы, за исключением изменяемости. Первый случай констатирует, что если у вас есть ссылка &T, а тип T реализует типаж Deref для некоторого типа U, то вы можете получить ссылку &U прозрачно. Второй случай констатирует, что то же самое принудительное приведение типа посредством deref происходит для изменяемых ссылок.

Третий случай хитрее: Rust также выполняет приведение изменяемой ссылки к неизменяемой. Но обратное невозможно: неизменяемые ссылки никогда не будут приводиться к изменяемым ссылкам. По причине правил заимствования, если у вас есть изменяемая ссылка, то эта изменяемая ссылка должна быть единственной ссылкой на эти данные (в противном случае программа не компилируется). Конвертирование одной изменяемой ссылки в одну неизменяемую ссылку никогда не нарушит правила заимствования. Конвертирование неизменяемой ссылки в изменяемую ссылку потребует наличия только одной неизменяемой ссылки на эти данные, а правила заимствования этого не гарантируют. Следовательно, в Rust нельзя предположить, что конвертирование неизменяемой ссылки в изменяемую возможно.

Выполнение кода при очистке с помощью типажа Drop

Второй типаж, важный для паттерна умного указателя, — это Drop, который позволяет индивидуально настраивать то, что происходит, когда значение вот-вот выйдет из области видимости. Вы можете реализовать типаж Drop для любого типа, а указанный код может использоваться для высвобождения ресурсов, таких как файлы или сетевые подключения. Мы вводим Drop в контексте умных указателей, потому что функциональность типажа Drop почти всегда используется во время реализации умного указателя. Например, умный указатель Box<T> настраивает типаж Drop индивидуально для отмены выделения пространства в куче, на которую указывает тип Box.

В некоторых языках программист должен вызывать код для высвобождения памяти или ресурсов всякий раз, когда он заканчивает использовать экземпляр умного указателя. Если он об этом забудет, то система может оказаться перегруженной и рухнуть. В Rust вы можете указать, что некоторая часть кода будет выполняться всякий раз, когда значение выходит из области видимости, и компилятор вставит этот код автоматически. В результате вам не нужно размещать код очистки в программе там, где завершался экземпляр некоторого типа, — у вас не будет утечки ресурсов!