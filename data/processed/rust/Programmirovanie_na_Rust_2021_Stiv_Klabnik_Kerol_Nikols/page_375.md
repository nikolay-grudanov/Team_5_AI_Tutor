---
source_image: page_375.png
page_number: 375
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 35.62
tokens: 7629
characters: 2304
timestamp: 2025-12-24T10:55:42.364430
finish_reason: stop
---

Здесь мы вызываем функцию hello с аргументом &m, то есть ссылкой на значение MyBox<String>. Поскольку в листинге 15.10 мы реализовали типаж Deref в типе MyBox<T>, компилятор может превратить &MyBox<String> в &String путем вызова deref. Стандартная библиотека предоставляет реализацию типажа Deref в типе String, которая возвращает строковый срез, и эта информация есть в документации API о типаже Deref. Язык Rust снова вызывает deref, превращая &String в &str, что совпадает с определением функции hello.

Если бы принудительное приведение типа посредством deref не было реализовано в Rust, то для вызова функции hello со значением типа &MyBox<String> вместо кода из листинга 15.12 нам пришлось бы писать код из листинга 15.13.

Листинг 15.13. Код, который мы должны были бы написать, если бы принудительного приведения типа посредством deref не было

src/main.rs

```rust
fn main() {
    let m = MyBox::new(String::from("Rust"));
    hello(&(*m)[..]);
}
```

Выражение (*m) дереференцирует¹ тип MyBox<String> в тип String. Затем & и [ .. ] берут строковый срез экземпляра типа String, который равен всему строковому значению, чтобы совпасть с сигнатурой функции hello. Код без принудительного приведения типа посредством deref труднее читать, писать и понимать со всеми этими символами. Принудительное приведение типа посредством deref позволяет компилятору обрабатывать эти конверсии автоматически.

Когда типаж Deref будет определен для участвующих типов, язык Rust будет анализировать типы и использовать метод Deref::deref столько раз, сколько необходимо, чтобы получить ссылку, совпадающую с типом параметра. Число раз, когда нужно вставить вызов метода Deref::deref, определяется во время компиляции, поэтому время выполнения не увеличивается из-за принудительного приведения типа посредством deref!

Как принудительное приведение типа посредством deref взаимодействует с изменяемостью

Вы можете использовать типаж DerefMut для переопределения оператора * на изменяемых ссылках подобно тому, как вы используете типаж Deref для переопределения оператора * на неизменяемых ссылках.

Язык Rust выполняет принудительное приведение типа посредством deref, когда он находит типы и реализации типажей в трех случаях:

¹ То есть переходит по указателю MyBox к значению типа String с помощью оператора *.