---
source_image: page_088.png
page_number: 88
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 33.03
tokens: 7453
characters: 1659
timestamp: 2025-12-24T10:48:06.415343
finish_reason: stop
---

Листинг 3.4. Осуществление цикла в элементах коллекции с помощью while

src/main.rs

fn main() {
    let a = [10, 20, 30, 40, 50];
    let mut index = 0;

    while index < 5 {
        println!("Значение равно {}", a[index]);

        index = index + 1;
    }
}

Здесь код подсчитывает число элементов в массиве. Он начинается с индекса 0, а затем повторяется до тех пор, пока не достигнет конечного индекса в массиве (то есть когда выражение index < 5 больше не является истинным). Выполнение этого кода выведет каждый элемент массива:

$ cargo run
Compiling loops v0.1.0 (file:///projects/loops)
Finished dev [unoptimized + debuginfo] target(s) in 1.50 secs
    Running `target/debug/loops`
Значение равно 10
Значение равно 20
Значение равно 30
Значение равно 40
Значение равно 50

Все пять значений массива, как и предполагалось, появляются в терминале. Даже если индекс в какой-то момент достигнет значения 5, цикл остановится перед попыткой извлечь шестое значение из массива.

Но при таком подходе возможны ошибки. В программе может начаться паника, если длина индекса будет неправильной. Работа при этом подходе осуществляется медленно, потому что компилятор добавляет код времени выполнения для проверки условия каждого элемента во время каждой итерации цикла.

В качестве более короткой альтернативы можно использовать цикл for и исполнять код для каждого элемента в коллекции. Цикл for выглядит, как показано в коде из листинга 3.5.

Листинг 3.5. Осуществление цикла в элементах коллекции с помощью for

src/main.rs

fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a.iter() {
        println!("Значение равно {}", element);
    }
}