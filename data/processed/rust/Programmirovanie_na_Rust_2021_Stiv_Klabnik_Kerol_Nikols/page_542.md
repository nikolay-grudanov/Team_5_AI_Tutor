---
source_image: page_542.png
page_number: 542
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 32.00
tokens: 7606
characters: 2272
timestamp: 2025-12-24T11:00:04.685676
finish_reason: stop
---

нения (fork/join) и однопоточная модель асинхронного ввода-вывода. Если вас интересует эта тема, вы можете почитать о других решениях и реализовать их на языке Rust. Поскольку Rust является низкоуровневым языком, все эти варианты возможны.

Прежде чем приступить к реализации пула потоков исполнения, давайте поговорим о том, как должно выглядеть использование пула. При разработке кода, если сначала написать клиентский интерфейс, это поможет развить проект. Пишите API этого кода так, чтобы его структура соответствовала тому, как вы хотите его вызывать. Затем реализуйте свойства в рамках этой структуры вместо того, чтобы реализовывать свойства, а затем планировать публичный API.

Аналогично тому, как мы использовали разработку на основе тестов в проекте главы 12, здесь мы применим разработку на основе компилятора. Мы напишем код, который вызывает нужные функции, а затем посмотрим на ошибки компилятора и выясним, что требуется изменить, чтобы привести код в рабочее состояние.

Структура кода при возможности порождения потока исполнения для каждого запроса

Сначала давайте узнаем, как бы выглядел код, если бы он создавал новый поток для каждого соединения. Как упоминалось ранее, этот план не окончательный из-за проблем с потенциальным порождением неограниченного числа потоков исполнения, но это отправная точка. В листинге 20.11 показаны изменения, вносимые в функцию main, чтобы создавать новый поток для обработки каждого потока внутри цикла for.

Листинг 20.11. Создание нового потока исполнения для каждого потока
src/main.rs

```rust
fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        thread::spawn(|| {
            handle_connection(stream);
        });
    }
}
```

Как вы узнали из главы 16, функция thread::spawn будет создавать новый поток, а затем выполнять код внутри замыкания в новом потоке. Если вы выполните этот код и загрузите ресурс /sleep в браузер, а затем ресурс / в двух других вкладках браузера, то увидите, что запросам ресурса / не придется ждать завершения запроса /sleep. Но, как мы уже упоминали, это в итоге приводит к переполнению системы, потому что вы будете создавать новые потоки без каких-либо ограничений.