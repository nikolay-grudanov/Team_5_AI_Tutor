---
source_image: page_561.png
page_number: 561
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 38.15
tokens: 7564
characters: 2298
timestamp: 2025-12-24T11:00:42.887922
finish_reason: stop
---

fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Job>>> ) -> Worker {
    let thread = thread::spawn(move || {
        while let Ok(job) = receiver.lock().unwrap().recv() {
            println!("Работник {} получил задание; исполняется.", id);
            job.call_box();
        }
    });
    Worker {
        id,
        thread,
    }
}

Этот код компилируется и выполняется, но не приводит к желаемому поведению потоков исполнения: из-за медленного запроса другие запросы все равно будут ждать своей обработки. Причина этого неочевидна: структура Mutex не имеет публичного метода unlock, поскольку владение замком основано на жизненном цикле MutexGuard<T> в LockResult<MutexGuard<T>>, который возвращается методом lock. Во время компиляции контролер заимствования может обеспечить соблюдение правила о том, что ресурс, охраняемый мьютексом, не может быть доступен, если мы не удерживаем замок. Но эта реализация также может привести к тому, что замок будет удерживаться дольше, чем предполагалось, если мы плохо продумаем жизненный цикл MutexGuard<T>. Поскольку значения в выражении while остаются в области видимости на протяжении всего блока, замок удерживается на протяжении всего вызова метода job.call_box(), то есть другие работники не могут получать задания.

Используя вместо этого цикл loop и приобретая замок и задание внутри блока, а не вне его, MutexGuard, возвращаемый из метода lock, отбрасывается, как только инструкция let job заканчивается. Таким образом, замок удерживается во время вызова метода recv, но освобождается перед вызовом job.call_box(), что позволяет обслуживать несколько запросов одновременно.

Корректное отключение и очистка

Код в листинге 20.21 откликается на запросы асинхронно с помощью пула потоков исполнения, как мы и предполагали. Мы получаем несколько предупреждений о полях workers, id и thread, которые не используются непосредственно, в качестве напоминания о том, что мы ничего не подчищаем. Когда мы применяем менее элегантный способ Ctrl-C для остановки главного потока исполнения, все остальные потоки также немедленно останавливаются, даже если находятся в процессе обслуживания запроса.

Теперь мы реализуем типаж Drop, который будет вызывать join для каждого потока в пуле, чтобы они могли завершить запросы, над которыми работают, перед