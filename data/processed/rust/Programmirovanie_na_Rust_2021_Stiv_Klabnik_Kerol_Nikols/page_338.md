---
source_image: page_338.png
page_number: 338
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 35.91
tokens: 7634
characters: 2320
timestamp: 2025-12-24T10:54:44.642665
finish_reason: stop
---

Листинг 13.29. Использование методов итераторных адаптеров в реализации функции search

src/lib.rs

pub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {
    contents.lines()
        .filter(|line| line.contains(query))
        .collect()
}

Напомним, что функция search предназначена для возвращения в contents всех строк текста, которые содержат запрос query. Как и в примере с filter из листинга 13.19, этот код использует адаптер filter, который оставляет только те строки, для которых line.contains(query) возвращает true. Затем мы собираем совпадающие строки текста в еще один вектор с помощью метода collect. Гораздо проще! Вы можете свободно внести такое же изменение с использованием итераторных методов и в функцию search_case_insensitive.

Следующий логический вопрос заключается в том, какой стиль вы должны выбрать в коде и почему: исходную реализацию в листинге 13.28 или версию с использованием итераторов в листинге 13.29. Большинство программистов Rust предпочитают использовать итераторный стиль. Поначалу к нему трудновато привыкнуть, но после того, как вы опробуете различные итераторные адаптеры и их действия, итераторы станут понятными. Вместо того чтобы возиться с различными частями цикла и собирать новые векторы, код сосредоточен на высокоуровневой цели цикла. Он абстрагируется от обыкновенного кода, и поэтому становится легче увидеть уникальные для этого кода понятия, такие как условие фильтрации, которое каждый элемент итератора должен пройти.

Но действительно ли эти две реализации эквивалентны? Интуитивно можно допустить, что более низкоуровневый цикл будет быстрее. Давайте поговорим о производительности.

Сравнение производительности: циклы против итераторов

Для того чтобы определиться с тем, что использовать — циклы или итераторы, — необходимо знать, какая версия функции search работает быстрее: версия с явно выраженным циклом for или версия с итераторами.

Мы провели сравнительный анализ, загрузив все содержимое «Приключений Шерлока Холмса» сэра Артура Конан Дойла в экземпляр типа String и проведя поиск слова the в содержимом. Вот результаты сравнительного тестирования версии функции search с циклом for и с итераторами:

test bench_search_for ... bench: 19,620,300 ns/iter (+/- 915,700)
test bench_search_iter ... bench: 19,234,900 ns/iter (+/- 657,200)