---
source_image: page_554.png
page_number: 554
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 28.81
tokens: 7465
characters: 1939
timestamp: 2025-12-24T11:00:21.422635
finish_reason: stop
---

// --пропуск--

impl Worker {
    fn new(id: usize, receiver: mpsc::Receiver<Job>) -> Worker {
        let thread = thread::spawn(|| {
            ② receiver;
        });

        Worker {
            id,
            thread,
        }
    }
}

Мы внесли несколько небольших и простых изменений: передаем принимающий конец канала в функцию Worker::new ①, а затем используем его внутри замыкания ②.

Когда мы пытаемся проверить этот код, то получаем такую ошибку:

$ cargo check
Compiling hello v0.1.0 (file:///projects/hello)
error[E0382]: use of moved value: `receiver`
 --> src/lib.rs:27:42
  |
27 |     workers.push(Worker::new(id, receiver));
      ^^^^^^^^ value moved here in previous iteration of loop
  |
  = note: move occurs because `receiver` has type `std::sync::mpsc::Receiver<Job>`, which does not implement the `Copy` trait

Код пытается передать receiver нескольким экземплярам структуры Worker. Как вы помните из главы 16, это работать не будет: реализация канала, которую предоставляет Rust, именуется как «несколько производителей, один потребитель». А значит, для исправления этого кода мы не можем просто клонировать потребляющий конец канала. Даже если бы мы могли, это нежелательное техническое решение. Вместо этого мы хотим распределять задания между потоками путем совместного использования одного приемника receiver всеми работниками.

Вдобавок, удаление задания из очереди каналов предусматривает изменение приемника receiver, поэтому нитям исполнения нужен безопасный способ совместного использования и модификации приемника. В противном случае мы могли бы получить гоночные состояния (как описано в главе 16).

Вспомните про умные указатели, безопасные для потоков, о которых мы говорили в главе 16: чтобы делиться владением между несколькими потоками и позволить потокам исполнения изменять значение, нужен умный указатель Arc<Mutex<T>>. Тип Arc будет позволять нескольким работникам владеть приемником, а тип