---
source_image: page_518.png
page_number: 518
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 45.21
tokens: 7801
characters: 2570
timestamp: 2025-12-24T10:59:37.335886
finish_reason: stop
---

Аннотация #[macro_export] ① указывает, что эта макрокоманда должна быть доступна всякий раз, когда упаковка, в которой макрокоманда определена, вводится в область видимости. Без этой аннотации макрокоманда не может быть введена в область видимости.

Затем мы начинаем определение макрокоманды с помощью макрокоманды macro_rules! и приводим имя макрокоманды, которую определяем, без восклицательного знака ②. Имя, в данном случае vec, сопровождается фигурными скобками, обозначающими тело определения макрокоманды.

Структура кода в теле vec! похожа на структуру выражения match. Здесь мы имеем один рукав с паттерном ( $( $x:expr ),* ), за которым следует => и блок кода, связанный с этим паттерном ③. Если паттерн совпадает, то будет создан связанный блок кода. Учитывая, что это единственный паттерн в этой макрокоманде, существует только один допустимый способ совпадения, любой другой паттерн приведет к ошибке. У более сложных макрокоманд будет более одного рукава.

Допустимый синтаксис паттернов в определениях макрокоманд отличается от синтаксиса паттернов, описанного в главе 18, поскольку паттерны макрокоманд сопоставляются со структурой, а не со значениями кода Rust. Давайте изучим, что означают фрагменты паттерна в листинге 19.28. Полный синтаксис паттернов макрокоманд смотрите по адресу https://doc.rust-lang.org/stable/reference/macros.html.

Сначала весь паттерн охватывается набором скобок. Далее следует знак доллара ($), за которым идет набор скобок, захватывающий значения, совпадающие с паттерном внутри скобок, для использования в заменяющем коде. Внутри $() находится выражение $x:expr, которое совпадает с любым выражением языка Rust и дает выражению имя $x.

Запятая, следующая за $(), указывает, что символ-разделитель литерала запятой, как вариант, мог бы появиться после кода, совпадающего с кодом в $(). Символ * указывает на то, что паттерн совпадает с нулем или более из того, что предшествует *.

Когда мы вызываем эту макрокоманду с помощью vec![1, 2, 3];, паттерн $x трижды совпадает с тремя выражениями — 1, 2 и 3.

Теперь давайте посмотрим на паттерн в теле кода, связанного с этим рукавом: temp_vec.push() ⑤ внутри $()* ④ ⑦ генерируется для каждой части, которая совпадает с $() в паттерне ноль или более раз в зависимости от того, сколько раз совпадает паттерн. Имя $x ⑥ заменяется при каждом совпавшем выражении. Когда мы вызовем эту макрокоманду с vec![1, 2, 3];, генерируемый код, который заменяет этот макровызов, будет следующим:

let mut temp_vec = Vec::new();
temp_vec.push(1);
temp_vec.push(2);
temp_vec.push(3);
temp_vec