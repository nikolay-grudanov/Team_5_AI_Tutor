---
source_image: page_532.png
page_number: 532
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 29.47
tokens: 7547
characters: 2107
timestamp: 2025-12-24T10:59:47.333543
finish_reason: stop
---

функцию обработки соединений. В этой новой функции handle_connection мы будем читать данные из TCP-потока и печатать их, чтобы видеть данные, отправляемые из браузера. Измените код так, чтобы он выглядел как в листинге 20.2.

Листинг 20.2. Чтение из потока TcpStream и печать данных

src/main.rs

1 use std::io::prelude::*;
use std::net::TcpStream;
use std::net::TcpListener;

fn main() {
    let listener = TcpListener::bind("127.0.0.1:7878").unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        2 handle_connection(stream);
    }
}

fn handle_connection(3mut stream: TcpStream) {
    4 let mut buffer = [0; 512];

    5 stream.read(&mut buffer).unwrap();

    6 println!("Запрос: {}", String::from_utf8_lossy(&buffer[..]));
}

Мы вводим std::io::prelude в область видимости, чтобы получить доступ к некоторым типажам, позволяющим читать и писать в поток 1. В цикле for в функции main, вместо того, чтобы печатать сообщение о том, что у нас есть соединение, мы теперь вызываем новую функцию handle_connection и передаем ей переменную stream 2.

В функции handle_connection мы сделали параметр stream изменяемым 3. Причина в том, что внутренне экземпляр типа TcpStream отслеживает то, какие данные он нам возвращает. Он может прочитать данные в объеме, превышающем тот, который мы запрашивали, и сохранить их для следующего запроса. Следовательно, ему нужно ключевое слово mut, потому что его внутреннее состояние может измениться. Обычно мы думаем, что «чтение» не нуждается в изменении, но в данном случае указанное ключевое слово необходимо.

Далее нам фактически нужно читать из потока. Мы делаем это в два этапа: во-первых, объявляем переменную buffer в стеке для хранения считываемых данных 4. Мы создали буфер размером 512 байт, которого будет достаточно для хранения данных базового запроса и для других целей этой главы. Если бы мы хотели обрабатывать запросы произвольного размера, то управление буфером было бы сложнее. Мы пока оставим его простым. Мы передаем буфер методу stream.read, который будет читать байты из TcpStream и помещать их в буфер 5.