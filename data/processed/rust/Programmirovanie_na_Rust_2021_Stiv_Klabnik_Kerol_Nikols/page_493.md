---
source_image: page_493.png
page_number: 493
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 25.01
tokens: 7438
characters: 1681
timestamp: 2025-12-24T10:58:38.539156
finish_reason: stop
---

Листинг 19.10. Небезопасно читать изменяемую статическую переменную или записывать в нее

src/main.rs
```rust
static mut COUNTER: u32 = 0;

fn add_to_count(inc: u32) {
    unsafe {
        COUNTER += inc;
    }
}

fn main() {
    add_to_count(3);

    unsafe {
        println!("COUNTER: {}", COUNTER);
    }
}
```

Как и в случае с регулярными переменными, мы задаем изменяемость с помощью ключевого слова mut. Любой код, читающий или пишущий данные из COUNTER, должен находиться в блоке unsafe. Этот код ожидаемо компилирует и выводит COUNTER: 3, потому что это однопоточной код. Ситуация, когда к COUNTER обращается несколько потоков исполнения, скорее всего, приведет к гонкам данных.

Когда данные изменяемые и глобально доступные, трудно обойтись без гонок данных, поэтому Rust считает изменяемые статические переменные небезопасными. Там, где это возможно, предпочтительнее использовать параллельные технические приемы и безопасные для потоков умные указатели из главы 16, благодаря которым компилятор проверяет, что обращение к данным из разных потоков исполнения выполняется безопасным образом.

Реализация небезопасного типажа

Последнее действие, которое работает только с unsafe, — это реализация небезопасного типажа. Типаж небезопасен, если хотя бы один из его методов имеет некий инвариант, который компилятор не может проверить. Мы можем объявить типаж небезопасным, добавив ключевое слово unsafe перед ним и отметив реализацию типажа как unsafe, как показано в листинге 19.11.

Листинг 19.11. Определение и реализация небезопасного типажа
```rust
unsafe trait Foo {
    // здесь будут методы
}

unsafe impl Foo for i32 {
    // здесь будут реализации методов
}
```