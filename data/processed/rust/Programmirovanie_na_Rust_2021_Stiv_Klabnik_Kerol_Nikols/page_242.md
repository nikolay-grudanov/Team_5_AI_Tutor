---
source_image: page_242.png
page_number: 242
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 29.75
tokens: 7538
characters: 2188
timestamp: 2025-12-24T10:52:05.457073
finish_reason: stop
---

Когда мы попытаемся скомпилировать этот код, произойдет ошибка:

error[E0597]: `string2` does not live long enough
  --> src/main.rs:15:5
   |
14 |         result = longest(string1.as_str(), string2.as_str());
   |                        -------- borrow occurs here
15 |     }
16 |     ^ `string2` dropped here while still borrowed
17 |     println!("The longest string is {}", result);
18 | }
   | - borrowed value needs to live until here

Ошибка показывает, что для того, чтобы переменная result была действительно для инструкции println!, переменная string2 должна быть действительно вплоть до конца внешней области видимости. Rust знает это, потому что мы аннотировали жизненный цикл параметров функции и возвращаемых значений, используя один и тот же параметр жизненного цикла 'a.

Глядя на этот код, мы видим, что переменная string1 длиннее переменной string2, и поэтому результат будет содержать ссылку на string1. Поскольку string1 еще не вышла из области видимости, ссылка на string1 по-прежнему будет действительно для инструкции println!. Однако компилятор не способен видеть, что в данном случае ссылка является действительно. Мы уже сообщили Rust, что жизненный цикл ссылки, возвращаемой функцией longest, совпадает с меньшим жизненным циклом переданных ссылок. Следовательно, контролер заимствования запрещает код в листинге 10.24, поскольку в нем, возможно, есть недействительная ссылка.

Попробуйте разработать дополнительные эксперименты, в которых изменяются значения и жизненный цикл ссылок, передаваемых в функцию longest, а также характер использования возвращаемой ссылки. Выдвиньте предположения о том, смогут ли эти эксперименты пройти проверку контролера заимствования, перед компиляцией; затем проверьте, правы ли вы.

Мышление в терминах жизненных циклов

То, как вам нужно описывать параметры жизненных циклов, зависит от того, что делает функция. Например, если бы мы изменили реализацию функции longest так, чтобы она вместо самого длинного строкового среза всегда возвращала первый параметр, нам не нужно было бы указывать жизненный цикл для параметра y. Код ниже будет компилироваться:

src/main.rs
fn longest<'a>(x: &'a str, y: &str) -> &'a str {
    x
}