---
source_image: page_487.png
page_number: 487
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 31.41
tokens: 7574
characters: 2175
timestamp: 2025-12-24T10:58:34.584075
finish_reason: stop
---

Заметим также, что в листингах 19.1 и 19.3 мы создали сырые указатели *const i32 и *mut i32, указывающие на одну и ту же ячейку памяти, где хранится num. Если бы мы попытались создать неизменяемую и изменяемую ссылку на num, то этот код не компилировался бы, потому что правила владения языком Rust не допускают изменяемую ссылку одновременно с любыми неизменяемыми ссылками. С помощью сырых указателей мы можем создавать изменяемый и неизменяемый указатели на одно и то же место и изменять данные через изменяемый указатель, потенциально создавая гонку данных. Будьте осторожны!

С учетом всего этого зачем вообще применять сырые указатели? Один из основных вариантов использования — это взаимодействие с кодом на языке C, как вы увидите в следующем разделе. Еще один вариант — создание безопасных абстракций, которые контролер заимствований не понимает. Мы представим небезопасные функции, а затем рассмотрим пример безопасной абстракции, использующей небезопасный код.

Вызов небезопасной функции или метода

Второй тип операций, требующих небезопасный блок, — это вызовы небезопасных функций. Небезопасные функции и методы выглядят так же, как и регулярные функции и методы, но у них есть дополнительное ключевое слово unsafe перед остальной частью определения. Ключевое слово unsafe в этом контексте указывает, что данная функция имеет требования, которые нужно поддерживать при вызове этой функции, потому что язык Rust не может гарантировать, что эти требования удовлетворены. Вызывая небезопасную функцию в блоке unsafe, мы говорим о том, что прочитали документацию к этой функции и берем на себя ответственность за соблюдение обязательств функции.

Вот небезопасная функция с именем dangerous, которая ничего не делает в своем теле:

unsafe fn dangerous() {}

unsafe {
    dangerous();
}

Нужно вызвать функцию dangerous внутри отдельного блока unsafe. Если мы попытаемся вызвать dangerous без блока unsafe, то получим ошибку¹:

error[E0133]: call to unsafe function requires unsafe function or block
 --> 
  |
4 |     dangerous();
  |     ^^^^^^^^^^^^ call to unsafe function

¹ ошибка[E0133]: вызов небезопасной функции требует функции или блока с префиксом unsafe