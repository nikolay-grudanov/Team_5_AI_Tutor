---
source_image: page_421.png
page_number: 421
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 28.68
tokens: 7448
characters: 1802
timestamp: 2025-12-24T10:56:48.771039
finish_reason: stop
---

доступ к данным. Следовательно, мьютекс охраняет данные, которые он содержит, посредством системы замков.

Считается, что мьютексы трудно использовать, поэтому важно помнить два правила:

○ Вы должны получить замок перед использованием данных.

○ Когда вы закончите работу с данными, которые мьютекс охраняет, вы должны снять замок с данных, чтобы другие потоки могли получить этот замок.

В качестве реального примера мьютекса представьте себе коллективное обсуждение на конференции с одним микрофоном. Прежде чем кто-либо из участников дискуссии начнет свое выступление, он должен попросить или подать сигнал, что хочет воспользоваться микрофоном. Когда он получает микрофон, то может говорить сколько угодно, а затем передать микрофон следующему участнику, который просит слова. Если участник дискуссии забудет отдать микрофон, когда закончит свою речь, то никто больше не сможет выступить. Если работа с совместным микрофоном не заладится, то коллективное обсуждение пройдет не так, как планировалось!

Разобраться в управлении мьютексами бывает невероятно сложно, именно поэтому так много людей с энтузиазмом относятся к каналам. Тем не менее благодаря системе типов и правилам владения Rust вы точно разберетесь с установкой и снятием замков.

API Mutex<T>

В качестве примера давайте начнем с использования мьютекса в однопоточном контексте, как показано в листинге 16.12.

Листинг 16.12. Знакомство с API Mutex<T> в однопоточном контексте в качестве простого примера

src/main.rs

use std::sync::Mutex;

fn main() {
    let m = Mutex::new(5);
    {
        let mut num = m.lock().unwrap();
        *num = 6;
    }
    println!("m = {:?}", m);
}

Как и во многих других типах, мы создаем экземпляр типа Mutex<T>, используя связанную с ним функцию new ①. Для того чтобы обратиться к данным внутри