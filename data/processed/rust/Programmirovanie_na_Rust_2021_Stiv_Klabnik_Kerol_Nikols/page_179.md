---
source_image: page_179.png
page_number: 179
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 29.03
tokens: 7477
characters: 1800
timestamp: 2025-12-24T10:50:19.718640
finish_reason: stop
---

тата на экран она возвращает экземпляр типа String с его содержимым. Версия кода с использованием макрокоманды format! гораздо легче читается и не берет во владение ни один из своих параметров.

Индексирование в строках

Во многих других языках программирования доступ к отдельным символам в строке со ссылкой на них по индексу является допустимой и часто встречающейся операцией. Однако если вы попытаетесь обратиться к частям значения типа String с помощью синтаксиса индексирования в языке Rust, то получите ошибку. Рассмотрим недопустимый код в листинге 8.19.

Листинг 8.19. Попытка использовать синтаксис индексирования со значением типа String
let s1 = String::from("hello");
let h = s1[0];

Этот код приведет к следующей ошибке¹:

error[E0277]: the trait bound `std::string::String: std::ops::Index<{integer}>` is not satisfied
--> 
| 
3 |     let h = s1[0];
|        ^^^^^ the type `std::string::String` cannot be indexed by `{integer}`
| 
= help: the trait `std::ops::Index<{integer}>` is not implemented for `std::string::String`

Указанная ошибка и примечание говорят сами за себя: строки Rust не поддерживают индексирование. Но почему? Для того чтобы ответить на этот вопрос, нам нужно узнать, как Rust хранит строки в памяти.

Внутреннее представление

Тип String представляет собой обертку для Vec<u8>. Давайте посмотрим на некоторые примеры строк из листинга 8.14, надлежаще кодированные в UTF-8. Прежде всего, на эту:

let len = String::from("Hola").len();

В данном случае переменная len будет равна 4, то есть вектор, хранящий приветствие "Hola", имеет длину 4 байта. Каждая из этих букв занимает 1 байт при кодировке в UTF-8. Но как насчет следующей строки? (Обратите внимание, что

¹ ошибка[E0277]: граница типажа `std::string::String: std::ops::Index<{integer}>` не удовлетворена