---
source_image: page_128.png
page_number: 128
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 38.82
tokens: 7687
characters: 2594
timestamp: 2025-12-24T10:49:13.649912
finish_reason: stop
---

ГДЕ ОПЕРАТОР ->?

В языках C и C++ для вызова методов используются два разных оператора: вы пользуетесь оператором ., если вызываете метод непосредственно для объекта, и оператором ->, если вызываете метод для указателя на объект и сначала должны проследовать по указателю к значению с помощью оператора разыменования (говоря технически, дереференцировать указатель). Другими словами, если объект является указателем, то выражение object->something() аналогично (*object).something().

В языке Rust нет эквивалента оператору ->. Вместо него есть языковое средство, которое называется автоматической референцией (создание указателя на существующее значение) и дереференция (следование по указателю к существующему значению)1. Вызов методов — это одна из немногих характеристик языка Rust, которая так себя ведет.

Вот как это работает: когда вы вызываете метод с помощью object.something(), язык Rust автоматически добавляет &, &mut или *, благодаря чему объект совпадает с сигнатурой метода. Другими словами, варианты ниже одинаковы:

p1.distance(&p2);
(&p1).distance(&p2);

Первый выглядит гораздо яснее. Автоматическое создание ссылки работает, потому что методы имеют четкого получателя — тип параметра self. С учетом получателя и имени метода язык Rust точно знает, что делает метод: читает (&self), изменяет (&mut self) или потребляет (self). Тот факт, что язык Rust делает заимствование неявным для получателей метода, очень важен и делает владение эргономичным на практике.

Методы с большим числом параметров

Давайте позанимаемся применением методов путем реализации второго метода для структуры Rectangle. На этот раз мы хотим, чтобы экземпляр структуры Rectangle брал еще один экземпляр структуры Rectangle и возвращал true, если второй прямоугольник Rectangle полностью помещается внутрь параметра self. В противном случае он должен вернуть false. То есть мы хотим написать программу, показанную в листинге 5.14, как только определим метод can_hold.

Листинг 5.14. Использование пока еще не написанного метода can_hold

src/main.rs
fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };
    let rect2 = Rectangle { width: 10, height: 40 };
    let rect3 = Rectangle { width: 60, height: 45 };

1 Референция (referencing) — это операция косвенного обращения, которая заключается в создании указателя на существующее значение путем получения его адреса в памяти (с помощью оператора референции &). Разыменование (dereferencing) — это операция косвенного обращения, которая заключается в следовании по указателю к существующему значению (с помощью оператора разыменования *).