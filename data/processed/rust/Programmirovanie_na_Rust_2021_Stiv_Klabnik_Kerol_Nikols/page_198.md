---
source_image: page_198.png
page_number: 198
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 28.82
tokens: 7540
characters: 2231
timestamp: 2025-12-24T10:50:55.004451
finish_reason: stop
---

возникают в результате операции io. Вариантом, который мы хотим использовать, является ErrorKind::NotFound. Он указывает на то, что файл, который мы пытаемся открыть, пока еще не существует. Поэтому мы применяем match для f, но у нас также есть внутреннее выражение match для error.kind().

Во внутреннем выражении match мы хотим проверить условие о том, является ли значение, возвращаемое из error.kind(), вариантом NotFound перечисления ErrorKind. Если это так, то мы попытаемся создать файл с помощью функции File::create.

Однако, поскольку File::create тоже может не сработать, то внутреннему выражению match нужен второй рукав. Когда создать файл не получается, выводится другое сообщение об ошибке. Второй рукав внешнего выражения match остается неизменным, поэтому программа поднимает панику при любой ошибке, помимо ошибки отсутствующего файла.

Уж очень много выражений match! Выражение match очень полезно, но и во многом примитивно. В главе 13 вы узнаете о замыканиях. В типе Result<T, E> имеется много методов, которые принимают замыкание и реализуются с помощью выражений match. Использование этих методов сделает код лаконичнее. Более опытный растианин, возможно, написал бы вместо листинга 9.5 такой код:

src/main.rs
use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let f = File::open("hello.txt").unwrap_or_else(|error| {
        if error.kind() == ErrorKind::NotFound {
            File::create("hello.txt").unwrap_or_else(|error| {
                panic!("Проблема с созданием файла: {:?}", error);
            })
        } else {
            panic!("Проблема с открытием файла: {:?}", error);
        }
    });
}

Несмотря на то что этот код ведет себя так же, как и в листинге 9.5, он не содержит никаких выражений match и более понятен для чтения. Вернитесь к этому примеру после изучения главы 13 и найдите метод unwrap_or_else в документации стандартной библиотеки. Есть еще много методов, которые могут очищать огромные вложенные выражения match, когда вы работаете над ошибками.

Краткие формы для паники в случае ошибки: unwrap и expect

Выражение match работает неплохо, но оно бывает несколько многословным и не всегда хорошо передает намерение. Для типа Result<T, E> определено много вспо-