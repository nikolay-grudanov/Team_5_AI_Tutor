---
source_image: page_314.png
page_number: 314
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 36.52
tokens: 7564
characters: 2298
timestamp: 2025-12-24T10:54:04.928469
finish_reason: stop
---

    println!("Сделайте сегодня перерыв! Пейте больше воды!");
    } else {
        println!(
            "Сегодня пробежка {} минут!",
            simulated_expensive_calculation(intensity)
        );
    }
}

Код в листинге 13.3 несколько раз вызывает функцию медленного вычисления. Первый блок if ① вызывает функцию simulated_expensive_calculation дважды, if внутри внешнего else ② не вызывает ее вообще, а код внутри второго else case ③ вызывает ее один раз.

Желаемое поведение функции generate_workout состоит в том, чтобы сначала проверить, с какой интенсивностью пользователь хочет тренироваться — с низкой (обозначается числом меньше 25) или с высокой (число 25 или больше).

Планы тренировок с низкой интенсивностью будут рекомендовать ряд отжиманий и приседаний, основанных на сложном алгоритме, который мы моделируем.

Если пользователь хочет тренироваться с высокой интенсивностью, то существует дополнительный алгоритм: если значение случайного числа, генерируемого приложением, равно 3, то приложение посоветует передохнуть и попить воды. Если нет, то пользователь получит несколько минут пробежки на основе сложного алгоритма.

Этот код работает так, как этого хочет бизнес сейчас, но допустим, что команда исследователей данных решит, что в будущем нужно будет внести некоторые изменения в способ вызова функции simulated_expensive_calculation. Чтобы упростить обновления, когда эти изменения наступят, мы хотим провести рефакторинг этого кода так, чтобы он вызывал функцию simulated_expensive_calculation только один раз. Мы также хотим устранить то место, где сейчас без необходимости вызываем функцию дважды, в процессе не добавляя других вызовов этой функции. То есть мы не хотим вызывать ее, если результат не нужен, и все же хотим вызывать функцию только один раз.

Рефакторинг с использованием функций

Мы можем реструктурировать программу тренировок по-разному. Сначала мы попытаемся извлечь повторный вызов функции simulated_expensive_calculation в переменную, как показано в листинге 13.4.

Листинг 13.4. Извлечение вызовов функции simulated_expensive_calculation в одно место и сохранение результата в переменной expensive_result

src/main.rs
fn generate_workout(intensity: u32, random_number: u32) {
    let expensive_result = simulated_expensive_calculation(intensity);