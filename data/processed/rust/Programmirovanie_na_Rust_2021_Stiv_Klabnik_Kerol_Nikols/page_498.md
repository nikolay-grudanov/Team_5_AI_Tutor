---
source_image: page_498.png
page_number: 498
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 33.85
tokens: 7508
characters: 1984
timestamp: 2025-12-24T10:58:55.634312
finish_reason: stop
---

```rust
struct Meters(u32);

impl Add<Meters> for Millimeters {
    type Output = Millimeters;

    fn add(self, other: Meters) -> Millimeters {
        Millimeters(self.0 + (other.0 * 1000))
    }
}

Для сложения Millimeters и Meters мы указываем impl Add<Meters>, устанавливая значение параметра RHS типа вместо использования Self по умолчанию.

Мы будем использовать параметры типа по умолчанию двумя главными способами:

О Для расширения типа без нарушения существующего кода.
О Для разрешения индивидуальной настройки в специфических случаях, кото-
    рая большинству пользователей не понадобится.

Типаж Add стандартной библиотеки — это пример второго предназначения: обычно вы добавляете два подобных типа, но типаж Add обеспечивает возможность индивидуальной настройки помимо этого. Использование параметра типа по умолчанию в определении типажа Add означает, что большую часть времени вам не нужно указывать дополнительный параметр. Другими словами, большая часть стереотипного кода не требуется в реализации, что облегчает использование типажа.

Первое предназначение похоже на второе, но в обратном порядке: если вы хотите добавить параметр типа в существующий типаж, то можно дать ему тип по умол-
чанию, чтобы разрешить расширение функциональности типажа, не нарушая код существующей реализации.

Полный синтаксис для устранения неоднозначности: вызов методов с одинаковым именем

В Rust у типажа может быть метод с тем же именем, что и у метода другого типажа, а компилятор не мешает реализовывать оба типажа в одном типе. Также можно реализовывать метод непосредственно в типе с тем же именем, что и у метода из типажа.

При вызове методов с одинаковым именем нужно указывать, какой из них вы хотите использовать. Рассмотрим код в листинге 19.16, где мы определили два типажа, Pilot и Wizard, которые имеют метод с именем fly. Затем мы реализуем оба типажа в типе Human, у которого уже есть метод с именем fly, реализованный в нем. Каждый метод fly делает что-то свое.