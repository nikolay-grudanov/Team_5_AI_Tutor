---
source_image: page_074.png
page_number: 74
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 31.64
tokens: 7503
characters: 2033
timestamp: 2025-12-24T10:47:41.371254
finish_reason: stop
---

is 10', src/main.rs:6
note: Run with `RUST_BACKTRACE=1` for a backtrace.

При компиляции не произошло ошибок, но программа вызвала ошибку времени выполнения и не завершилась успешно. Когда вы попытаетесь обратиться к элементу по индексу, язык Rust проверит, чтобы указанный индекс был меньше длины массива. Если индекс больше или равен длине массива, то Rust поднимет панику.

Это первый пример, иллюстрирующий принципы безопасности Rust в действии. Во многих низкоуровневых языках подобная проверка не выполняется, и когда вы указываете неправильный индекс, то можно получить доступ к недействительной памяти. Rust защищает от таких ошибок, немедленно выходя из программы, вместо того чтобы разрешить доступ к памяти и продолжить работу. В главе 9 обработка ошибок в языке Rust обсуждается подробнее.

Функции

У функций в коде Rust всеобъемлющий характер. Вы уже видели одну из самых важных функций языка — функцию main, которая является точкой входа многих программ. Вы также встречались с ключевым словом fn, которое позволяет объявлять новые функции.

Часто используется змеиный регистр написания имен функций и переменных. В змеином регистре все буквы находятся в нижнем регистре, а отдельные слова соединяются символом подчеркивания. Вот программа, которая содержит пример определения функции:

src/main.rs
fn main() {
    println!("Hello, World!");
    another_function();
}
fn another_function() {
    println!("Еще одна функция.");
}

Определения функций начинаются с ключевого слова fn и имеют набор скобок после имени функции. Фигурные скобки сообщают компилятору место, где начинается и заканчивается тело функции.

Мы можем вызвать любую функцию, введя ее имя с последующим набором скобок. Поскольку функция another_function определена в программе, ее можно вызвать изнутри функции main. Обратите внимание, что в исходном коде мы определили функцию another_function после функции main. Мы могли бы определить ее и раньше. Языку Rust все равно, где вы определяете свои функции; главное, чтобы они были где-то определены.