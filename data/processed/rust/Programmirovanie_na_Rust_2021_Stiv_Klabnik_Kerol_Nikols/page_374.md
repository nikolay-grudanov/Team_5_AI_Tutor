---
source_image: page_374.png
page_number: 374
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 36.28
tokens: 7660
characters: 2355
timestamp: 2025-12-24T10:55:42.817224
finish_reason: stop
---

Обратите внимание, что оператор * заменяется вызовом метода deref, а затем вызовом оператора * всего один раз, когда мы используем * в коде. Поскольку замена оператора * не входит в бесконечную рекурсию, мы в итоге имеем данные типа i32, которые совпадают с 5 в инструкции assert_eq! из листинга 15.9.

Скрытые принудительные приведения типов посредством deref с функциями и методами

Принудительное приведение типа посредством deref — это вспомогательная операция, которую Rust выполняет с аргументами функций и методов. Указанная операция преобразует ссылку на тип, который реализует типаж Deref, в ссылку на тип, в который типаж Deref может преобразовать исходный тип. Принудительное приведение типа посредством deref происходит автоматически, когда мы передаем ссылку на значение некоторого типа в качестве аргумента функции или метода, который не совпадает с типом параметра в определении функции или метода. Последовательность вызовов метода deref преобразует предоставленный нами тип в тип, необходимый параметру.

Принудительное приведение типа посредством deref было добавлено в Rust, чтобы программистам, пишущим вызовы функций и методов, не приходилось добавлять так много явных операций референции и разыменования с использованием & и *. Средство принудительного приведения типа посредством deref также позволяет писать код, который может работать как для ссылок, так и для умных указателей.

Для того чтобы увидеть принудительное приведение типа посредством deref в действии, давайте применим тип MyBox<T>, который мы определили в листинге 15.8, а также реализацию Deref, добавленную в листинг 15.10. В листинге 15.11 показано определение функции, имеющей параметр с типом строкового среза.

Листинг 15.11. Функция hello, которая имеет параметр name типа &str
src/main.rs
```rust
fn hello(name: &str) {
    println!("Здравствуй, {}!", name);
}
```

Мы можем вызвать функцию hello со строковым срезом в качестве аргумента, к примеру, hello("Rust");. Принудительное приведение типа посредством deref позволяет вызывать hello со ссылкой на значение типа MyBox<String>, как показано в листинге 15.12.

Листинг 15.12. Вызов функции hello со ссылкой на значение MyBox<String>, которое работает из-за принудительного приведения типа посредством deref
src/main.rs
```rust
fn main() {
    let m = MyBox::new(String::from("Rust"));
    hello(&m);
}
```