---
source_image: page_430.png
page_number: 430
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 33.99
tokens: 7584
characters: 2277
timestamp: 2025-12-24T10:57:10.217594
finish_reason: stop
---

использоваться для совместного доступа с несколькими потоками, как вы видели в разделе «Совместное использование Mutex<T> несколькими потоками» (с. 422).

Реализовывать Send и Sync вручную небезопасно

Поскольку типы, состоящие из типажей Send и Sync, также автоматически маркируются как Send и Sync, нам не нужно реализовывать их вручную. Как маркерные типажи, они даже не имеют никаких методов, подлежащих реализации. Они просто полезны для соблюдения инвариантов, связанных с конкурентностью.

Ручная реализация этих типажей предусматривает реализацию небезопасного кода Rust. Мы поговорим об использовании небезопасного кода Rust в главе 19. А пока важно знать, что нужно тщательно обдумать новые конкурентные типы, не состоящие из Send и Sync, чтобы обеспечить безопасность. В «Растономиконе» (https://doc.rust-lang.org/stable/nomicon/) есть дополнительная информация о гарантиях безопасности.

Итоги

В этой книге вы еще столкнетесь с конкурентностью. В главе 20 при работе над проектом будут использованы идеи из этой главы в более реалистичной ситуации, чем те небольшие примеры, которые мы рассмотрели здесь.

Как уже упоминалось ранее, в самом языке мало инструментов конкурентности, поэтому многие решения для задач конкурентности реализованы в качестве упаковок. Они развиваются быстрее, чем стандартная библиотека, поэтому обязательно поищите в интернете актуальные современные упаковки для многопоточных ситуаций.

Стандартная библиотека Rust предоставляет каналы для передачи сообщений и типы умных указателей, такие как Mutex<T> и Arc<T>, безопасные для использования в конкурентных контекстах. Благодаря системе типов и проверке заимствования в коде, использующем эти решения, в итоге нет гонки данных и недействительных ссылок. Как только ваш код будет компилироваться, будьте уверены, что он будет работать в нескольких потоках без едва заметных ошибок, часто встречающихся в других языках. Больше не следует опасаться конкурентного программирования: смело делайте свои программы конкурентными!

Далее мы поговорим об идиоматических способах моделирования задач и структурирования решений по мере увеличения ваших программ. Кроме того, обсудим, как идиомы Rust соотносятся с теми, которые, возможно, знакомы вам по объектно-ориентированному программированию.