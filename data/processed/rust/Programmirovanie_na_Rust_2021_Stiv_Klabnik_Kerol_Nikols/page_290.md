---
source_image: page_290.png
page_number: 290
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 33.18
tokens: 7561
characters: 2262
timestamp: 2025-12-24T10:53:24.356317
finish_reason: stop
---

$ cargo run
    Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
    Running `target/debug/minigrep`
thread 'main' panicked at 'недостаточно аргументов', src/main.rs:26:13
note: Run with `RUST_BACKTRACE=1` for a backtrace.

Эти данные смотрятся лучше: теперь у нас есть разумное сообщение об ошибке. Однако у нас также есть посторонняя информация, которую мы не хотим сообщать пользователям. Пожалуй, использование здесь приема из листинга 9.10 не является наилучшим вариантом: вызов макрокоманды panic! больше подходит для задач по программированию, чем для прикладных задач, как описано в главе 9. Вместо этого можно применить другой прием, о котором вы узнали в главе 9, — возвращение типа Result, который указывает либо на успех, либо на ошибку.

Возвращение типа Result из функции new вместо вызова макрокоманды panic!

Вместо этого мы можем возвращать значение типа Result, которое в случае успеха будет содержать экземпляр структуры Config, а в случае ошибки опишет проблему. Когда функция Config::new сообщает что-либо функции main, мы можем использовать тип Result, сигнализируя о том, что возникла проблема. Затем можно изменить функцию main так, чтобы она конвертировала вариант Err в более практичную для пользователей ошибку без окружающего текста о потоке 'main' (thread 'main') и обратной трассировке (RUST_BACKTRACE), поводом для которых является вызов panic!.

Листинг 12.9 показывает изменения, которые нужно внести в значение, возвращаемое из Config::new, и тело функции, необходимые для того, чтобы возвращать Result. Обратите внимание, что этот код не будет компилироваться до тех пор, пока мы не обновим функцию main, что мы и сделаем в следующем листинге.

Листинг 12.9. Возвращение типа Result из Config::new
src/main.rs

impl Config {
    fn new(args: &[String]) -> Result<Config, &'static str> {
        if args.len() < 3 {
            return Err("недостаточно аргументов");
        }

        let query = args[1].clone();
        let filename = args[2].clone();

        Ok(Config { query, filename })
    }
}

Функция new теперь возвращает Result с экземпляром структуры Config в случае успеха и &'static str в случае ошибки. Вспомните из раздела «Статический жиз-