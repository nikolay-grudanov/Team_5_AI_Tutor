---
source_image: page_549.png
page_number: 549
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 27.58
tokens: 7385
characters: 1669
timestamp: 2025-12-24T11:00:14.754740
finish_reason: stop
---

Листинг 20.14. Создание вектора для типа ThreadPool, который будет хранить потоки

src/lib.rs

1 use std::thread;

pub struct ThreadPool {
    threads: Vec<thread::JoinHandle<()>>,
}

impl ThreadPool {
    // --пропуск--
    pub fn new(size: usize) -> ThreadPool {
        assert!(size > 0);

        let mut threads = Vec::with_capacity(size);

        for _ in 0..size {
            // создать несколько потоков исполнения и сохранить их в векторе
        }

        ThreadPool {
            threads
        }
    }
    // --пропуск--
}

Мы ввели std::thread в область видимости в библиотечной упаковке 1, потому что используем thread::JoinHandle в качестве типа элементов вектора в структуре ThreadPool 2.

После получения допустимого размера структура ThreadPool создает новый вектор, который может содержать size элементов 3. В этой книге мы еще не использовали функцию with_capacity, которая выполняет ту же задачу, что и функция Vec::new, но с важным отличием: она предварительно выделяет пространство в векторе. Поскольку мы знаем, что нужно хранить size элементов в векторе, выполнение операции выделения заблаговременно несколько эффективнее, чем использование функции Vec::new, размер которой изменяется по мере вставки элементов.

Когда вы снова выполните команду cargo check, вы получите еще несколько предупреждений, но она должна быть успешной.

Структура Worker, ответственная за отправку кода из структуры ThreadPool в поток

Мы оставили комментарий в цикле for из листинга 20.14, касающийся создания потоков исполнения. Здесь мы рассмотрим, как на самом деле создаются потоки. Стандартная библиотека предоставляет функцию thread::spawn как способ соз-