---
source_image: page_259.png
page_number: 259
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 43.03
tokens: 7675
characters: 2493
timestamp: 2025-12-24T10:52:48.541607
finish_reason: stop
---

Тест зафиксировал ошибку! Тест it_adds_two не сработал, показав сообщение assertion failed: `(left == right)` ① и указав, что left было равно 4 ②, а right было равно 5 ③. Это полезное сообщение, оно помогает начать отладку: сообщение означает, что левый аргумент макрокоманды assert_eq! был равен 4, а правый аргумент, где у нас было add_two(2), был равен 5.

Обратите внимание, что в некоторых языках и тестовых каркасах параметры функций, которые утверждают, что два значения равны, называются «ожидаемыми» (expected) и «фактическими» (actual), и порядок, в котором мы указываем аргументы, имеет значение. Однако в Rust они называются «левыми» (left) и «правыми» (right), и порядок, в котором мы описываем ожидаемое значение и значение, которое производит тестируемый код, не важен. Мы могли бы написать проверочное утверждение в этом тесте как assert_eq!(add_two(2), 4), что приведет к выводу сообщения assertion failed: `(left == right)` и к указанию, что левый аргумент был равен 5, а правый аргумент был равен 4.

Макрокоманда assert_ne! завершится успешно, если два значения, которые мы ей передаем, не равны, и не сработает, если они равны. Указанная макрокоманда наиболее полезна в тех случаях, когда мы не уверены, каким будет значение, но знаем, каким значение точно не будет, если код функционирует так, как мы предполагаем. Например, если мы тестируем функцию, которая гарантированно каким-либо образом изменит свои данные на входе, но способ их изменения зависит от дня недели, когда выполняются тесты, то лучше всего удостовериться, что выход из функции не равен входу.

Неявно обе макрокоманды — assert_eq! и assert_ne! — используют операторы == и != соответственно. Когда проверочные утверждения не срабатывают, эти макрокоманды печатают аргументы с помощью отладочного форматирования — это означает, что сравниваемые значения должны реализовать типажи PartialEq и Debug. Все примитивные типы и большинство типов стандартной библиотеки реализуют эти типажи. Для определяемых вами структур и перечислений нужно будет реализовать PartialEq, что позволит сравнить, равны или не равны значения этих типов. Для того чтобы печатать значения, когда проверочное утверждение проходит неуспешно, нужно будет реализовать Debug. Поскольку оба типажа генерируемы, как указано в листинге 5.12, обычно необходимо добавить простую аннотацию #[derive(PartialEq, Debug)] в определение структуры или перечисления. Дополнительные сведения об этих и других генерируемых типажах см. в приложении Б.