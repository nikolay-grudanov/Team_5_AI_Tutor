---
source_image: page_248.png
page_number: 248
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 29.95
tokens: 7540
characters: 2197
timestamp: 2025-12-24T10:52:16.840152
finish_reason: stop
---

Сначала мы будем использовать метод с именем level, единственным параметром которого является ссылка на self, а его возвращаемое значение — значение типа i32, которое не является ссылкой на что-либо:

```rust
impl<'a> ImportantExcerpt<'a> {
    fn level(&self) -> i32 {
        3
    }
}
```

Объявление параметра жизненного цикла после impl и использование после имени типа является обязательным, но от нас не требуется аннотировать жизненный цикл ссылки на параметр self из-за первого правила элизии.

Вот пример, где применяется третье правило пропуска жизненного цикла:

```rust
impl<'a> ImportantExcerpt<'a> {
    fn announce_and_return_part(&self, announcement: &str) -> &str {
        println!("Пожалуйста, внимание: {}", announcement);
        self.part
    }
}
```

Здесь имеется два входных жизненных цикла, поэтому компилятор применяет первое правило пропуска жизненного цикла и дает как &self, так и announcement их собственные жизненные циклы. Затем, поскольку одним из параметров является &self, возвращаемый тип получает жизненный цикл &self, и все жизненные циклы будут вычислены.

Статический жизненный цикл

Мы должны обсудить один особый жизненный цикл — 'static, который обозначает всю продолжительность программы. Все строковые литералы имеют жизненный цикл 'static, который мы обозначаем следующим образом:

```rust
let s: &'static str = "У меня статический жизненный цикл.";
```

Текст этого строкового значения хранится непосредственно в двоичном файле программы, который всегда доступен. Следовательно, жизненным циклом всех строковых литералов является 'static.

Вы, возможно, увидите рекомендации использовать жизненный цикл 'static в сообщениях об ошибках. Но прежде чем указать 'static в качестве жизненного цикла для ссылки, подумайте о том, живет ли ваша ссылка в действительно жизни всех жизненные циклы программы или нет. Вы, возможно, задумаетесь над тем, хотите ли вы, чтобы она жила так долго, даже если бы смогла. В большинстве случаев проблема возникает из-за попытки создать висячую ссылку или из-за несовпадения имеющихся жизненных циклов. В таких случаях решение заключается в устранении этих проблем, а не в указании статического жизненного цикла 'static.