---
source_image: page_068.png
page_number: 68
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 55.74
tokens: 7925
characters: 2750
timestamp: 2025-12-24T10:47:56.284220
finish_reason: stop
---

ЦЕЛОЧИСЛЕННОЕ ПЕРЕПОЛНЕНИЕ

Допустим, у вас есть переменная типа u8, которая может содержать значения от 0 до 255. Если вы попытаетесь изменить значение переменной на значение, выходящее за пределы этого интервала, такое как 256, то произойдет целочисленное переполнение. В Rust есть несколько интересных правил, связанных с этим поведением. Во время компиляции в отладочном режиме Rust делает проверки на предмет целочисленного переполнения, которые побуждают программу поднимать панику во время работы, если так происходит. В Rust используется термин «паника», когда работа программы завершается с ошибкой. Мы обсудим панику подробнее в разделе «Неустранимые ошибки с помощью макрокоманды panic!».

Когда вы компилируете в режиме с флагом --release, Rust не делает проверки на целочисленное переполнение, которые вызывают панику. Вместо этого, если происходит переполнение, то Rust выполняет циклический перенос на основе двоичного дополнения. Короче говоря, значения, превышающие возможный максимум, «сбрасываются» до минимума значений, которые тип может содержать. В случае u8, 256 становится 0, 257 становится 1 и так далее. Программа не будет поднимать панику, но у переменной будет значение, которое, вероятно, не будет соответствовать вашим ожиданиям. Опора на поведение с циклическим переносом при целочисленном переполнении считается ошибкой. Если вы хотите выполнить циклический перенос, то можете воспользоваться типом Wrapping стандартной библиотеки.

Каждый знаковый вариант может хранить числа от \(-(2^{n-1})\) до \(2^{n-1} - 1\) включительно, где \(n\) — это число бит, используемых вариантом. Таким образом, i8 может хранить числа от \(-(2^7)\) до \(2^7 - 1\), что равно интервалу от \(-128\) до \(127\). Беззнаковые варианты могут хранить числа от 0 до \(2^n - 1\), поэтому u8 может хранить числа от 0 до \(2^8 - 1\), что равно интервалу от 0 до 255.

Кроме того, типы isize и usize зависят от типа компьютера, на котором выполняется программа: 64 бита, если вы используете 64-битную архитектуру, и 32 бита, если у вас 32-битная архитектура.

Вы можете писать целочисленные литералы в любой из форм, приведенных в табл. 3.2. Обратите внимание, что все числовые литералы, кроме байтового литерала, допускают суффикс типа, например 57u8, и _ в качестве визуального разделителя, например 1_000.

Таблица 3.2. Целочисленные литералы в Rust

<table>
  <tr>
    <th>Числовые литералы</th>
    <th>Пример</th>
  </tr>
  <tr>
    <td>Десятичные</td>
    <td>98_222</td>
  </tr>
  <tr>
    <td>Шестнадцатеричные</td>
    <td>0xff</td>
  </tr>
  <tr>
    <td>Восьмеричные</td>
    <td>0o77</td>
  </tr>
  <tr>
    <td>Двоичные</td>
    <td>0b1111_0000</td>
  </tr>
  <tr>
    <td>Байтовый (только u8)</td>
    <td>b 'A'</td>
  </tr>
</table>