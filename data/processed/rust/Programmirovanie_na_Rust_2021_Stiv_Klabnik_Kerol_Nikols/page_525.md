---
source_image: page_525.png
page_number: 525
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 40.81
tokens: 7710
characters: 2665
timestamp: 2025-12-24T10:59:47.124969
finish_reason: stop
---

Макрокоманда quote! также предоставляет очень интересную механику паттернов: мы можем ввести #name, и quote! заменит его значением в имени переменной. Вы даже можете выполнять повторение, подобно тому, как работают обычные макрокоманды. Для получения обширных сведений обратитесь к документации упаковки quote по адресу https://docs.rs/quote.

Мы хотим, чтобы процедурная макрокоманда генерировала реализацию типажа HelloMacro для аннотированного пользователем типа, который можно получить, используя #name. У реализации типажа есть одна функция, hello_macro, тело которой содержит нужную функциональность: печать Здравствуй, Марко! Меня зовут, а затем имени аннотированного типа.

Используемая здесь макрокоманда stringify! встроена в Rust. Она берет выражение Rust, такое как 1 + 2, и во время компиляции преобразовывает его в строковый литерал "1 + 2". Это отличается от макрокоманд format! или println!, которые вычисляют выражение и затем преобразовывают результат в экземпляр типа String. Существует возможность, что #name на входе может быть выражением для печати в буквальной форме, поэтому мы используем stringify!. Использование stringify!, кроме того, сохраняет выделенное пространство путем конвертирования #name в строковый литерал во время компиляции.

В этой точке команда cargo build должна успешно завершиться как в hello_macro, так и в hello_macro_derive. Давайте подключим эти упаковки к коду в листинге 19.30, чтобы увидеть процедурную макрокоманду в действии! Создайте новый бинарный проект в каталоге projects, используя cargo new pancakes. Нужно добавить hello_macro и hello_macro_derive в качестве зависимостей в файл Cargo.toml упаковки pancakes. Если вы публикуете свои версии hello_macro и hello_macro_derive в https://crates.io/, то они будут регулярными зависимостями; если нет, то можете указать их в качестве зависимостей от пути следующим образом:

[dependencies]
hello_macro = { path = "../hello_macro" }
hello_macro_derive = { path = "../hello_macro/hello_macro_derive" }

Поместите код из листинга 19.30 в src/main.rs и выполните команду cargo run: она должна вывести Здравствуй, Марко! Меня зовут Pancakes!. Реализация типажа HelloMacro из процедурной макрокоманды была включена так, чтобы упаковке pancakes не требовалось его выполнять. Реализация указанного типажа была добавлена за счет аннотации #[derive (HelloMacro)].

Далее мы узнаем, чем отличаются другие виды процедурных макрокоманд от настраиваемых макрокоманд с атрибутом derive.

Макрокоманды, подобные атрибутам

Макрокоманды, подобные атрибутам, похожи на настраиваемые макрокоманды с атрибутом derive, но вместо того, чтобы генерировать код для derive, они позво-