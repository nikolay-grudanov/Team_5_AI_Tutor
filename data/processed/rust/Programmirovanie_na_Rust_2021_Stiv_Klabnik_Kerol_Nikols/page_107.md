---
source_image: page_107.png
page_number: 107
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 28.73
tokens: 7452
characters: 1768
timestamp: 2025-12-24T10:48:30.550741
finish_reason: stop
---

Вот те на! Мы также не можем иметь изменяемую ссылку, пока у нас есть неизменяемая. Пользователи неизменяемой ссылки не ожидают, что значения внезапно изменятся! Тем не менее, если имеется более одной неизменяемой ссылки, то все в порядке, потому что если кто-то просто читает данные, у него нет возможности повлиять на чтение данных кем-либо другим.

Даже если эти ошибки иногда расстраивают, помните, что компилятор Rust указывает на потенциальный дефект заблаговременно (во время компиляции, а не во время выполнения) и сообщает, где именно находится проблема. Благодаря этому вам не приходится отслеживать причину, почему данные не такие, как вы думали.

**Висячие ссылки**

В языках с указателями легко можно по ошибке создать висячий указатель, то есть указатель, ссылающийся на место в памяти, которое, возможно, было отдано кому-то другому, за счет освобождения некоторой памяти с сохранением указателя на нее. В Rust, напротив, компилятор гарантирует, что ссылки никогда не будут висячими. Если у вас есть ссылка на данные, то компилятор обеспечит, чтобы данные не вышли из области видимости до того, как это сделает ссылка на данные.

Давайте попробуем создать висячую ссылку, которую Rust предотвратит с ошибкой времени компиляции:

**src/main.rs**
```rust
fn main() {
    let reference_to_nothing = dangle();
}

fn dangle() -> &String {
    let s = String::from("hello");

    &s
}
```

Вот ошибка¹:

```
error[E0106]: missing lifetime specifier
 --> main.rs:5:16
  |
5 | fn dangle() -> &String {
  | ^expected lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from
  = help: consider giving it a 'static lifetime
```

¹ ошибка[E0106]: пропущен спецификатор жизненного цикла