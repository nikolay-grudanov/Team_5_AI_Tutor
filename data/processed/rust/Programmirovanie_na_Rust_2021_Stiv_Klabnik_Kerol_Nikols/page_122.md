---
source_image: page_122.png
page_number: 122
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 31.39
tokens: 7493
characters: 1775
timestamp: 2025-12-24T10:48:57.336804
finish_reason: stop
---

```
);
}

fn area(width: u32, height: u32) -> u32 {
    width * height
}

Теперь выполните эту программу с помощью команды cargo run:

Площадь прямоугольника равна 1500 квадратным пикселам.

Хотя листинг 5.8 работает и рассчитывает площадь прямоугольника, вызывая функцию area для каждой размерности, мы можем сделать ее лучше. Ширина и высота связаны друг с другом, потому что вместе описывают один прямоугольник.

Трудность с этим кодом проявляется в сигнатуре функции area:

fn area(width: u32, height: u32) -> u32 {

Функция area должна рассчитывать площадь одного прямоугольника, но у функции, которую мы написали, два параметра. Параметры являются связанными, но в программе это нигде не выражено. Она будет более читаемой и управляемой, если сгруппировать ширину и высоту. Мы уже обсуждали один из способов сделать это в разделе «Кортежный тип» путем использования кортежей.

Рефакторинг с использованием кортежей

Листинг 5.9 показывает еще одну версию программы, теперь с использованием кортежей.

Листинг 5.9. Указание ширины и высоты прямоугольника с помощью кортежа src/main.rs

fn main() {
    let rect1 = (30, 50);

    println!(
        "Площадь прямоугольника равна {} квадратным пикселам.",
        ① area(rect1)
    );
}

fn area(dimensions: (u32, u32)) -> u32 {
    ② dimensions.0 * dimensions.1
}

С одной стороны, эта программа — лучше. Кортежи позволяют добавить структуру, и теперь мы передаем всего один аргумент ①. Но, с другой стороны, эта версия менее ясная: кортежи не именуют свои элементы, и в результате вычисление становится запутаннее, потому что нужно индексировать части кортежа ②.

Вовсе не имеет значения, если при расчете площади мы перепутаем ширину и высоту, но если надо нарисовать прямоугольник на экране, то это будет иметь зна-
```