---
source_image: page_490.png
page_number: 490
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 42.23
tokens: 7711
characters: 2592
timestamp: 2025-12-24T10:58:52.072551
finish_reason: stop
---

Вспомните из раздела «Срезовый тип» (с. 109), что срез — это указатель на некие данные и длина среза. Мы используем метод len для получения длины среза ①, а метод as_mut_ptr — для обращения к сырому указателю среза ②. В данном случае, поскольку у нас изменяемый срез значений типа i32, метод as_mut_ptr возвращает сырой указатель с типом *mut i32, который мы сохранили в переменной ptr.

У нас есть проверочное утверждение того, что индекс mid находится внутри среза ③. Затем мы переходим к небезопасному коду ④: функция slice::from_raw_parts_mut берет сырой указатель и длину и создает срез. Мы используем эту функцию для создания среза, который начинается с ptr и является mid элементов в длину ⑤. Затем мы вызываем метод offset для ptr с mid в качестве аргумента и получаем сырой указатель, который начинается в mid. Далее мы создаем срез, используя этот указатель и число оставшихся элементов после mid в качестве длины ⑥.

Функция slice::from_raw_parts_mut небезопасна, поскольку она берет сырой указатель и должна принять на веру, что этот указатель действителен. Метод offset для сырых указателей также небезопасен, поскольку он должен принять на веру, что расположение смещения тоже является действительным указателем. Следовательно, для вызова функций slice::from_raw_parts_mut и offset мы должны окружить их блоком unsafe. Посмотрев на код и добавив проверочное утверждение, что mid должен быть меньше или равен len, мы можем сказать, что все сырые указатели, используемые в блоке unsafe, будут действительно указателями на данные внутри этого среза. Приемлемо и уместно так использовать блок unsafe.

Обратите внимание, не нужно помечать результирующую функцию split_at_mut как unsafe, можно вызывать эту функцию из безопасного Rust. Мы создали безопасную абстракцию для небезопасного кода, реализовав функцию, которая использует unsafe безопасным образом, потому что она создает только действительно указатели из данных, к которым эта функция обращается.

Напротив, slice::from_raw_parts_mut в листинге 19.7, скорее всего, приведет к аварийному сбою при использовании среза. Этот код берет произвольное место в памяти и создает срез длиной 10 000 элементов.

Листинг 19.7. Создание среза из произвольного места в памяти

use std::slice;

let address = 0x012345usize;
let r = address as *mut i32;

let slice: & [i32] = unsafe {
    slice::from_raw_parts_mut(r, 10000)
};

Мы не владеем памятью в этом произвольном месте, и нет гарантии, что срез, созданный кодом, содержит допустимые значения типа i32. Попытка использовать срез как допустимый приводит к неопределенному поведению.