---
source_image: page_319.png
page_number: 319
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 38.90
tokens: 7668
characters: 2466
timestamp: 2025-12-24T10:54:15.851427
finish_reason: stop
---

как String. Эти типы затем запираются внутри замыкания в example_closure, и мы получаем ошибку типа, если пытаемся использовать другой тип с тем же замыканием.

Хранение замыканий с использованием обобщенных параметров и типажей Fn

Давайте вернемся к приложению, генерирующему тренировки. В листинге 13.6 код все так же вызывал замыкание затратного вычисления чаще, чем это было необходимо. Один из вариантов решения этой проблемы — сохранение результата затратного замыкания в переменной для повторного использования и применение переменной в каждом месте, где нужен результат, вместо повторного вызова замыкания. Однако этот метод приводит к большому объему повторяющегося кода.

К счастью, есть еще одно решение. Мы можем создать структуру, которая будет содержать замыкание и результирующее значение вызова замыкания. Структура будет исполнять замыкание только в том случае, если понадобится результирующее значение. Она будет кэшировать результирующее значение, благодаря чему остальной части кода не придется отвечать за сохранение и повторное использование результата. Вы, возможно, знаете этот паттерн как мемоизацию, или ленивое вычисление.

Для того чтобы собрать структуру, содержащую замыкание, необходимо указать для замыкания его тип, поскольку определение структуры требует типы для каждого поля. У каждого экземпляра замыкания есть уникальный анонимный тип: то есть, даже если два замыкания имеют одинаковую сигнатуру, их типы все равно считаются разными. Для определения структур, перечислений или параметров функций, использующих замыкания, мы используем обобщения и границы типа-жа, как мы обсуждали в главе 10.

Типажи Fn предусмотрены стандартной библиотекой. Все замыкания реализуют по крайней мере один из трех типажей: Fn, FnMut или FnOnce. Мы обсудим разницу между ними в разделе «Захватывание среды с помощью замыканий». В данном примере можно использовать типаж Fn.

Мы добавляем типы в границу типажа Fn, указывая типы параметров и возвращаемых значений, которые замыкания должны иметь, чтобы совпасть с этой границей типажа. В данном случае замыкание имеет параметр типа u32 и возвращает тип u32, поэтому описываемая граница типажа равна Fn(u32) -> u32.

Листинг 13.9 показывает определение структуры Cacher, содержащей замыкание и необходимое значение результата.

Листинг 13.9. Определение структуры Cacher, содержащей замыкание в calculation и необходимый результат в value

src/main.rs
struct Cacher<T>
    where T: Fn(u32) -> u32
{