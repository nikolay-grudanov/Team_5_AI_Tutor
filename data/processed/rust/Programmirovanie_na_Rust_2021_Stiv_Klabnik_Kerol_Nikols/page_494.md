---
source_image: page_494.png
page_number: 494
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 34.99
tokens: 7577
characters: 2273
timestamp: 2025-12-24T10:58:51.927188
finish_reason: stop
---

Используя unsafe impl, мы обещаем, что будем поддерживать инварианты, которые компилятор не может проверить.

В качестве примера вспомним маркерные типажи Sync и Send, которые обсуждались в разделе «Расширяемая конкурентность с типажами Sync и Send» (с. 428): компилятор реализует эти типажи автоматически, если типы полностью состоят из Send и Sync. Если мы реализуем тип, содержащий тип, который не является Send и Sync, такой как сырые указатели, и хотим промаркировать этот тип как Send и Sync, нужно использовать unsafe. Rust не может проверить, что тип безопасен и его можно отправлять между потоками или получить к нему доступ из нескольких потоков. Следовательно, нужно делать проверки вручную и помечать их как unsafe.

Когда использовать небезопасный код

Использование ключевого слова unsafe для выполнения одного из четырех только что рассмотренных действий (сверхспособностей) не считают неправильным и не порицают. Но труднее получить небезопасный код в правильном виде, потому что компилятор не может поддержать безопасность памяти. Если по какой-то причине вам нужно использовать небезопасный код, вы можете это сделать. Если у вас есть явная аннотация unsafe, вам будет легче найти источник проблем, если они возникнут.

Продвинутые типажи

Мы впервые затронули типажи в разделе «Типажи: определение совместного поведения» (с. 223), но, как и в случае с жизненным циклом, не обсуждали эффективные элементы. Теперь, когда вы знаете о Rust больше, можно перейти к мелочам.

Детализация заполнительных типов в определениях типажей с помощью связанных типов

Связанные типы соединяют заполнитель типа с типажом таким образом, что определения типажных методов могут использовать эти заполнительные типы в своих сигнатурах. Реализация типажа укажет конкретный тип, который будет использоваться на месте этого типа в определенном случае. Благодаря этому мы можем определить типаж, который использует некоторые типы, и нам не нужно точно знать, что это за типы, пока типаж не будет реализован.

Мы говорили, что большинство продвинутых языковых средств из этой главе применяются редко. Связанные типы находятся где-то посередине: они используются реже, чем средства, описанные в остальной части книги, но чаще, чем многие другие средства, обсуждаемые в этой главе.