---
source_image: page_524.png
page_number: 524
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 36.26
tokens: 7628
characters: 2419
timestamp: 2025-12-24T10:59:42.485706
finish_reason: stop
---

Вскоре мы определим функцию impl_hello_macro, где построим новый код Rust, который мы хотим включить. Но прежде чем мы это сделаем, обратите внимание, выход из макрокоманды derive также является TokenStream. Возвращаемый TokenStream добавляется в код, который пишут пользователи упаковки. Поэтому при компиляции упаковки они получат добавленную функциональность, которую мы предоставляем в модифицированном TokenStream.

Вы, возможно, заметили, что мы вызываем метод unwrap, чтобы побудить функцию hello_macro_derive поднять панику, если вызов функции syn::parse здесь не срабатывает. Процедурной макрокоманде необходимо паниковать при ошибках, потому что функции proc_macro_derive должны возвращать TokenStream, а не Result, чтобы соответствовать API процедурных макрокоманд. Мы упростили этот пример за счет метода unwrap. В рабочем коде вы должны предоставить более конкретные сообщения об ошибках с помощью макрокоманды panic! или метода expect.

Теперь, когда у нас есть код для преобразования аннотированного кода Rust из TokenStream в экземпляр DeriveInput, давайте сгенерируем код, реализующий типаж HelloMacro в аннотированном типе, как показано в листинге 19.33.

Листинг 19.33. Реализация типажа HelloMacro с использованием разобранного кода Rust

hello_macro_derive/src/lib.rs

```rust
fn impl_hello_macro(ast: &syn::DeriveInput) -> TokenStream {
    let name = &ast.ident;
    let gen = quote! {
        impl HelloMacro for #name {
            fn hello_macro() {
                println!("Здравствуй, Макро! Меня зовут {}", stringify!(#name));
            }
        }
    };
    gen.into()
}
```

Мы получаем экземпляр структуры Ident, содержащий имя (идентификатор) аннотированного типа с ast.ident. Структура в листинге 19.32 показывает, что, когда мы выполняем функцию impl_hello_macro в коде листинга 19.30, ident, который мы получаем, будет иметь поле ident со значением "Pancakes". Таким образом, переменная name в листинге 19.33 будет содержать экземпляр структуры Ident, который при печати будет строкой "Pancakes", именем структуры в листинге 19.30.

Макрокоманда quote! позволяет определять Rust, который мы хотим возвращать. Компилятор ожидает чего-то отличного от прямого результата исполнения макрокоманды quote!, поэтому нужно преобразовать его в TokenStream. Мы делаем это, вызывая метод into, который использует промежуточное представление и возвращает значение требуемого типа TokenStream.