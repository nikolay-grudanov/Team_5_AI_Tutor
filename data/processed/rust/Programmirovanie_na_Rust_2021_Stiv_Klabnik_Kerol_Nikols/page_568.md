---
source_image: page_568.png
page_number: 568
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 38.08
tokens: 7630
characters: 2414
timestamp: 2025-12-24T11:00:52.878586
finish_reason: stop
---

Метод take определен в типаже Iterator и ограничивает итерацию максимум двумя первыми элементами. ThreadPool выйдет из области видимости в конце функции main, а затем заработает реализация типажа Drop.

Запустите сервер с помощью команды cargo run и сделайте три запроса. Третий запрос должен выдавать ошибку, а в терминале вы должны увидеть данные, как показано ниже:

$ cargo run
Compiling hello v0.1.0 (file:///projects/hello)
Finished dev [unoptimized + debuginfo] target(s) in 1.0 secs
    Running `target/debug/hello`
Работник 0 получил задание; исполняется.
Работник 3 получил задание; исполняется.
Выключение.
Всем работникам отправляется сообщение о завершении.
Все работники выключаются.
Выключается работник 0
Работнику 1 сказано завершить работу.
Работнику 2 сказано завершить работу.
Работнику 0 сказано завершить работу.
Работнику 3 сказано завершить работу.
Выключается работник 1
Выключается работник 2
Выключается работник 3

Вы, возможно, увидите, что работники и сообщения выведены в другом порядке.

Мы видим работу этого кода из сообщений: работники 0 и 3 получили первые два запроса, а затем на третьем запросе сервер перестал принимать соединения. Когда ThreadPool выходит из области видимости в конце функции main, запускается его реализация типажа Drop и пул сообщает всем работникам о завершении работы. Каждый работник выводит сообщение, когда видит сообщение о завершении, а затем пул потоков исполнения вызывает метод join, чтобы выключить поток у каждого работника.

Обратите внимание на один интересный аспект этого исполнения: ThreadPool отправлял сообщения о завершении по каналу, а перед тем, как какой-либо работник получал сообщения, мы пытались применить метод join к работнику 0. Работник 0 еще не получил сообщение о завершении, а потому главный поток исполнения заблокировался в ожидании завершения работника 0. Тем временем каждый работник получал сообщение о завершении. Когда работник 0 закончил, главный поток исполнения ждал до тех пор, пока закончат остальные. В этот момент все они получили сообщение о завершении и смогли выключиться.

Поздравляем! Мы завершили проект, теперь у нас есть базовый веб-сервер, который использует пул потоков исполнения для асинхронного ответа. Мы можем выполнять корректное выключение сервера, которое очищает все потоки в пуле. Зайдите на https://www.nostarch.com/Rust2018/, откуда вы можете скачать полный код этой главы для справки.