---
source_image: page_178.png
page_number: 178
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 43.55
tokens: 7701
characters: 2479
timestamp: 2025-12-24T10:50:34.107256
finish_reason: stop
---

трим на сигнатуру add, в которой конкретные типы заменены на обобщения, что как раз и происходит, когда мы вызываем этот метод со значениями типа String. Мы обсудим обобщения в главе 10. Эта сигнатура дает нам подсказки, которые нужны, чтобы понять хитрости оператора +.

Во-первых, переменная s2 содержит &, имея в виду, что в первую строку мы добавляем ссылку на вторую строку из-за параметра s в методе add: в значение типа String мы можем добавить только &str. Мы не можем сложить два значения типа String. Но постойте, типом &s2 является &String, а не &str, как указано во втором параметре метода add. Тогда почему листинг 8.18 компилируется?

Причина, по которой мы можем использовать &s2 в вызове метода add, заключается в том, что компилятор неявно приводит аргументный тип &String к типу &str. Когда мы вызываем метод add, Rust использует принудительное приведение типа посредством deref, которое здесь неявно превращает &s2 в &s2[..]. Мы обсудим это приведение типов подробнее в главе 15. Поскольку метод add не берет параметр s во владение, переменная s2 по-прежнему будет действительным экземпляром типа String после этой операции.

Во-вторых, по сигнатуре мы видим, что метод add берет параметр self во владение, потому что self не имеет &. Это означает, что s1 в листинге 8.18 будет перемещен в вызов метода add и после этого больше не будет действителен. Таким образом, хотя инструкция let s3 = s1 + &s2; выглядит так, как будто она копирует обе строки и создает новую, она фактически берет s1 во владение, добавляет в конец копию содержимого s2, а затем возвращает владение результата. Другими словами, внешне выглядит, будто она делает много копий, но на самом деле это не так. Ее реализация эффективнее, чем простое копирование.

Если нам нужно конкатенировать несколько строк, то результат работы с оператором + становится громоздким:

let s1 = String::from("tic");
let s2 = String::from("tac");
let s3 = String::from("toe");

let s = s1 + "-" + &s2 + "-" + &s3;

В этой точке переменная s будет равняться tic-tac-toe. Со всеми этими символами + и " становится трудно понять, что происходит. Для более сложного комбинирования строк мы можем применить макрокоманду format!:

let s1 = String::from("tic");
let s2 = String::from("tac");
let s3 = String::from("toe");

let s = format!("{}-{}-{}", s1, s2, s3);

Этот код также устанавливает переменную s равной tic-tac-toe. Макрокоманда format! работает так же, как и макрокоманда println!, но вместо печати резуль-