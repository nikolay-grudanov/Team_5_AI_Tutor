---
source_image: page_245.png
page_number: 245
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 34.06
tokens: 7627
characters: 2232
timestamp: 2025-12-24T10:52:14.427810
finish_reason: stop
---

ссылки. Однако в листинге 4.9 у нас была функция, снова изображенная в листинге 10.26, которая компилировалась без аннотаций жизненных циклов.

Листинг 10.26. Функция, определенная в листинге 4.9, которая компилировалась без аннотаций жизненных циклов, даже если параметр и возвращаемый тип являются ссылками

src/lib.rs
```rust
fn first_word(s: &str) -> &str {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }

    &s[..]
}
```

Причина, по которой эта функция компилируется без аннотаций жизненных циклов, имеет свою историю: в ранних версиях (до 1.0) этот код не компилировался, потому что каждая ссылка требовала явно выраженного жизненного цикла. В то время сигнатура функции была бы записана следующим образом:

```rust
fn first_word<'a>(s: &'a str) -> &'a str {
```

Написав большой объем кода, команда разработчиков обнаружила, что в некоторых ситуациях программисты снова и снова вводят одни и те же аннотации жизненных циклов. Эти ситуации были предсказуемы и подчинялись нескольким детерминированным паттернам. Разработчики запрограммировали эти паттерны в код компилятора, чтобы контролер заимствования мог логически выводить жизненный цикл в этих ситуациях и не нуждался в явных аннотациях.

Эта часть истории языка Rust имеет актуальное значение, потому что существует возможность, что появятся более детерминированные паттерны, которые добавят в компилятор. Возможно, в будущем еще меньше аннотаций жизненных циклов будут обязательными.

Паттерны, запрограммированные в анализ ссылок языка Rust, называются «правила пропуска жизненного цикла». Это не те правила, которым должны следовать программисты. Это набор частных случаев, которые рассмотрит компилятор, и если код укладывается в эти случаи, то не нужно явно прописывать жизненный цикл.

Правила пропуска не обеспечивают полного логического вывода. Если Rust детерминированно применяет эти правила, но все еще существует неопределенность относительно того, какой жизненный цикл есть у ссылок, то компилятор не догадается, каким должен быть жизненный цикл у остальных ссылок. В этом случае, не строя догадок, компилятор выдаст ошибку. Ее можно устранить, доба-