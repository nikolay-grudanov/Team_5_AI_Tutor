---
source_image: page_065.png
page_number: 65
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 31.67
tokens: 7479
characters: 2002
timestamp: 2025-12-24T10:47:26.364170
finish_reason: stop
---

src/main.rs

fn main() {
    let x = 5;

    let x = x + 1;

    let x = x * 2;

    println!("Значение x равно {}", x);
}

Эта программа сначала привязывает x к значению 5. Затем она затеняет x путем повтора инструкции let x =, беря исходное значение и прибавляя 1, после чего значение x становится 6. Третья инструкция let также затеняет x, умножая предыдущее значение на 2, давая x конечное значение 12. Когда мы выполним эту программу, она выведет следующее:

$ cargo run
Compiling variables v0.1.0 (file:///projects/variables)
Finished dev [unoptimized + debuginfo] target(s) in 1.50 secs
Running `target/debug/variables`
Значение x равно 12

Затенение отличается от маркировки переменной как mut, потому что мы получим ошибку времени компиляции, если нечаянно попытаемся передать этой переменной новое значение без использования ключевого слова let. Используя let, мы можем выполнить несколько трансформаций значения, но при этом после завершения трансформаций переменная будет неизменяемой.

Другое различие между mut и затенением заключается в том, что, поскольку во время использования ключевого слова let еще раз мы практически создаем новую переменную, мы можем изменить тип значения, используя то же самое имя повторно. Например, программа просит пользователя показать, сколько пробелов должно быть между неким текстом, путем ввода знаков пробела, но на самом деле мы хотим сохранить этот ввод данных в виде числа:

let spaces = " ";
let spaces = spaces.len();

Эта конструкция разрешена, поскольку первая переменная spaces имеет строковый тип, а вторая переменная spaces, то есть совершенно новая переменная с тем же именем, имеет числовой тип. Таким образом, затенение избавляет нас от необходимости придумывать разные имена, такие как spaces_str и spaces_num. Вместо этого мы можем использовать более простое имя spaces повторно. Однако если для этого мы попытаемся использовать mut, как показано здесь, то получим ошибку времени компиляции:

let mut spaces = " ";
spaces = spaces.len();