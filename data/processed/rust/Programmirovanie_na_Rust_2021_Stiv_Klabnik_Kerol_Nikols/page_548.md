---
source_image: page_548.png
page_number: 548
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 40.28
tokens: 7634
characters: 2278
timestamp: 2025-12-24T11:00:25.700601
finish_reason: stop
---

1 /// # Паники
2 ///
3 /// Функция `new` поднимет панику, если размер будет равен нулю.
4 pub fn new(size: usize) -> ThreadPool {
5   assert!(size > 0);
6
7   ThreadPool
8 }
9
10 // --пропуск--
11 }

Мы добавили документацию для структуры ThreadPool, используя документационные комментарии. Обратите внимание, с точки зрения документирования мы поступили правильно, добавив секцию, озвучивающую ситуации, в которых функция может поднимать панику ①, как описано в главе 14. Выполните команду cargo doc --open и щелкните на структуре ThreadPool — вы увидите, как выглядит сгенерированная документация для функции new!

Вместо добавления макрокоманды assert!, как мы сделали здесь ②, можно было бы переделать функцию new так, чтобы она возвращала тип Result, как мы поступили с функцией Config::new в проекте ввода-вывода в листинге 12.9. Но в данном случае мы решили, что попытка создать пул потоков исполнения без потоков должна быть неустранимой ошибкой. Если вы амбициозны, то попробуйте написать версию функции new со следующей сигнатурой, чтобы сравнить обе версии:

pub fn new(size: usize) -> Result<ThreadPool, PoolCreationError> {

Создание пространства для хранения потоков исполнения

Теперь, имея способ узнать, что у нас есть допустимое число потоков исполнения для хранения в пуле, мы можем создать эти потоки и сохранить их в структуре ThreadPool перед ее возвращением. Но как мы будем «хранить» потоки? Давайте еще раз взглянем на сигнатуру функции thread::spawn:

pub fn spawn<F, T>(f: F) -> JoinHandle<T>
    where
        F: FnOnce() -> T + Send + 'static,
        T: Send + 'static

Функция spawn возвращает JoinHandle<T>, где T — это тип, возвращаемый замыканием. Попробуем использовать JoinHandle и посмотрим, что получится. В нашем случае замыкания, которые мы передаем в пул потоков исполнения, будут обрабатывать соединение и ничего не возвращать, поэтому T будет пустым типом ().

Код в листинге 20.14 компилируется, но пока что не создает никаких потоков исполнения. Мы изменили определение структуры ThreadPool в части хранения вектора экземпляров thread::JoinHandle<()>, инициализировали вектор емкостью size, настроили цикл for, который будет выполнять некий код для создания потоков исполнения, и вернули содержащий их экземпляр структуры ThreadPool.