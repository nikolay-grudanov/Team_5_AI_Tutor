---
source_image: page_330.png
page_number: 330
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 30.25
tokens: 7471
characters: 1781
timestamp: 2025-12-24T10:54:24.018858
finish_reason: stop
---

Листинг 13.18. Вызов метода map для создания нового итератора и последующий вызов метода collect для потребления нового итератора и создания вектора

src/main.rs
```rust
let v1: Vec<i32> = vec![1, 2, 3];
let v2: Vec<_> = v1.iter().map(|x| x + 1).collect();
assert_eq!(v2, vec![2, 3, 4]);
```

Поскольку метод map берет замыкание, мы можем указать любую операцию, которую хотим выполнять с каждым элементом. Это отличный пример того, как замыкания позволяют настраивать поведение под свои нужды, при этом повторно используя итерационное поведение, которое обеспечивается типажом Iterator.

Использование замыканий, которые захватывают свою среду

Теперь, когда мы познакомились с итераторами, можно продемонстрировать часто встречающееся использование замыканий, которые захватывают свою среду, применяя итераторный адаптер filter. Метод filter для итератора берет замыкание, которое в свою очередь берет каждый элемент из итератора и возвращает булево значение. Если замыкание возвращает true, то значение будет включено в результирующий итератор, созданный методом filter. Если замыкание возвращает false, то значение в этот итератор включено не будет.

В листинге 13.19 мы используем метод filter с замыканием, захватывающим переменную shoe_size из своей среды, чтобы выполнить перебор коллекции экземпляров структуры Shoe. Он вернет только ту обувь, которая имеет заданный размер.

Листинг 13.19. Использование метода filter с замыканием, которое захватывает shoe_size

src/lib.rs
```rust
#[derive(PartialEq, Debug)]
struct Shoe {
    size: u32,
    style: String,
}

fn shoes_in_my_size(shoes: Vec<Shoe>, shoe_size: u32) -> Vec<Shoe> {
    shoes.into_iter()
        .filter(|s| s.size == shoe_size)
        .collect()
}

#[test]
fn filters_by_size() {
    let shoes = vec![
```