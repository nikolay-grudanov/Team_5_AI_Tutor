---
source_image: page_096.png
page_number: 96
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 48.93
tokens: 7836
characters: 2686
timestamp: 2025-12-24T10:48:30.551442
finish_reason: stop
---

Теперь давайте посмотрим на версию с экземпляром типа String:

    let s1 = String::from("hello");
    let s2 = s1;

Этот код очень похож на предыдущий. Поэтому мы будем исходить из того, что характер его работы будет таким же, то есть вторая строка кода сделает копию значения в s1 и связает ее с s2. Но это не совсем верно.

Взгляните на рис. 4.1, и вы увидите, что на самом деле происходит с экземпляром типа String. Экземпляр типа String состоит из трех частей, показанных слева: указателя на память, в которой находится содержимое строки, ее длины и емкости. Эта группа данных хранится в стеке. Справа находится память в куче, в которой расположено ее содержимое.

Длина — это объем памяти в байтах, который использует содержимое экземпляра типа String в настоящее время. Емкость — это общий объем памяти в байтах, который экземпляр типа String получил от операционной системы. Разница между длиной и емкостью имеет значение, но не в этом случае, поэтому на данный момент емкость можно проигнорировать.

<table>
  <tr>
    <th>имя</th>
    <th>значение</th>
    <th>указатель</th>
    <th>значение</th>
  </tr>
  <tr>
    <td>ptr</td>
    <td></td>
    <td>0</td>
    <td>h</td>
  </tr>
  <tr>
    <td>длина</td>
    <td>5</td>
    <td>1</td>
    <td>e</td>
  </tr>
  <tr>
    <td>емкость</td>
    <td>5</td>
    <td>2</td>
    <td>l</td>
  </tr>
  <tr>
    <td></td>
    <td></td>
    <td>3</td>
    <td>l</td>
  </tr>
  <tr>
    <td></td>
    <td></td>
    <td>4</td>
    <td>o</td>
  </tr>
</table>

Рис. 4.1. Представление в памяти экземпляра типа String, содержащего значение «hello», привязанное к переменной s1

Когда мы присваиваем переменную s1 переменной s2, данные экземпляра типа String копируются, то есть указатель, длина и емкость, которые находятся в стеке. Мы не копируем данные в куче, на которую ссылается указатель. Другими словами, представление данных в памяти выглядит так, как показано на рис. 4.2.

Это представление не похоже на рис. 4.3, а именно так выглядела бы память, если бы вместо этого Rust копировал данные кучи. Если бы язык сделал это, то операция s2 = s1 могла бы быть очень затратной с точки зрения производительности времени выполнения, если бы данные в куче были объемными.

Ранее мы говорили, что, когда переменная выходит из области видимости, Rust автоматически вызывает функцию drop и очищает память кучи для этой переменной. Но на рис. 4.2 показано, как оба указателя данных показывают одно и то же место. В этом как раз и проблема: когда s2 и s1 выходят из области видимости, они обе будут пытаться высвободить одну и ту же память. Такая ситуация называется ошибкой двойного освобождения (double free error) и является одной из ошибок