---
source_image: page_206.png
page_number: 206
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 33.79
tokens: 7597
characters: 2356
timestamp: 2025-12-24T10:51:08.273185
finish_reason: stop
---

Если вызов метода не срабатывает в тесте, то вы хотели бы, чтобы не срабатывал весь тест, даже если тестируется функциональность вовсе не этого метода. Поскольку именно вызов макрокоманды panic! маркирует тест как несработавший, должен произойти именно вызов методов unwrap или expect.

Случаи, когда у вас больше информации, чем у компилятора

Также уместно вызывать метод unwrap, когда у вас есть какой-то алгоритм, который обеспечивает, чтобы экземпляр типа Result имел значение Ok. Но компилятор не понимает этот алгоритм. У вас по-прежнему будет экземпляр типа Result, который нужно обработать: любая операция, которую вы вызываете, по-прежнему может завершиться сбоем в целом, даже если в конкретной ситуации это логически невозможно. Если вы можете добиться, проверяя код вручную, чтобы у вас никогда не было варианта Err, то вполне допустимо вызывать метод unwrap. Вот пример:

use std::net::IpAddr;

let home: IpAddr = "127.0.0.1".parse().unwrap();

Мы создаем экземпляр IpAddr, разбирая жестко кодированное значение типа String. Мы видим, что значение 127.0.0.1 является допустимым IP-адресом, поэтому здесь можно использовать метод unwrap. Однако наличие жестко кодированного допустимого значения типа String не изменяет тип, возвращаемый из метода parse: мы все равно получаем значение типа Result, и компилятор заставит нас обрабатывать Result, как если бы вариант Err был возможен. Это произойдет потому, что компилятор недостаточно умен, чтобы увидеть, что это значение типа String всегда является допустимым IP-адресом. Если бы значение типа String с IP-адресом не было жестко закодировано в программе, а исходило от пользователя и поэтому была бы вероятность сбоя, то мы определенно хотели бы обрабатывать значение типа Result более надежным способом.

Принципы обработки ошибок

Рекомендуется, чтобы код поднимал панику, когда существует возможность, что код в итоге окажется в плохом состоянии. В данном контексте плохое состояние подразумевает нарушение какого-либо предположения, гарантии, контракта или инварианта, например, когда в код передаются недействительные, противоречивые либо пропущенные значения — плюс один или несколько из следующих пунктов:

○ Плохое состояние — то, от чего не ожидают, что это будет происходить время от времени.
○ Код после этого момента должен опираться на то, что он не находится в плохом состоянии.