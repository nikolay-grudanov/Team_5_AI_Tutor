---
source_image: page_398.png
page_number: 398
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 37.47
tokens: 7588
characters: 2241
timestamp: 2025-12-24T10:56:20.003044
finish_reason: stop
---

пользует число weak_count в целях отслеживания числа ссылок Weak<T>, подобно числу strong_count. Разница в том, что число weak_count не должно равняться 0, чтобы экземпляр тира Rc<T> был очищен.

Сильные ссылки — это то, как вы делитесь владением экземпляром Rc<T>. Слабые ссылки не выражают связи владения. Они не станут причиной цикла в переходах по ссылкам, потому что любой цикл с участием слабых ссылок будет разрушен, как только число участвующих сильных ссылок будет равно 0.

Так как значение, на которое ссылается Weak<T>, возможно, было отброшено, чтобы сделать что-либо со значением, на которое Weak<T> продолжает указывать, вы должны убедиться, что значение все еще существует. Делайте это, вызывая метод upgrade для экземпляра Weak<T>, который будет возвращать Option<Rc<T>>. Вы будете получать результат Some, если значение Rc<T> еще не отброшено, и результат None, если значение Rc<T> отброшено. Поскольку метод upgrade возвращает Option<T>, язык Rust сделает так, чтобы обрабатывались случаи Some и None и не было недействительного указателя.

В качестве примера вместо списка, элементы которого знают только о следующем элементе, мы создадим дерево, элементы которого знают о своих дочерних и родительских элементах.

Создание древовидной структуры данных: узел с дочерними узлами

Для начала мы построим дерево с узлами, которые знают о своих дочерних узлах. Мы создадим структуру с именем Node («узел»), которая содержит собственное значение типа i32, а также ссылки на значения своих дочерних структур Node:

src/main.rs
use std::rc::Rc;
use std::cell::RefCell;

#[derive(Debug)]
struct Node {
    value: i32,
    children: RefCell<Vec<Rc<Node>>>,
}

Мы хотим, чтобы структура Node владела своими дочерними структурами Node, и хотим делиться этим владением с переменными, чтобы можно было обращаться к каждому узлу Node в дереве напрямую. Для этого мы определяем элементы типа Vec<T> как значения типа Rc<Node>. Мы также хотим изменить то, какие узлы являются дочерними другому узлу, поэтому в поле children свойство Vec<Rc<Node>> оборачивается в умный указатель RefCell<T>.

Далее мы воспользуемся определением и создадим один экземпляр структуры Node с именем leaf со значением 3 без дочерних узлов и еще один экземпляр