---
source_image: page_473.png
page_number: 473
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 25.83
tokens: 7402
characters: 1628
timestamp: 2025-12-24T10:58:09.790639
finish_reason: stop
---

Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(Color),
}

fn main() {
    let msg = Message::ChangeColor(Color::Hsv(0, 160, 255));

    match msg {
        Message::ChangeColor(Color::Rgb(r, g, b)) => {
            println!(
                "Поменять цвет на красный {}, зеленый {} и синий {}",
                r,
                g,
                b
            )
        },
        Message::ChangeColor(Color::Hsv(h, s, v)) => {
            println!(
                "Поменять цвет на тон {}, насыщенность {} и яркость {}",
                h,
                s,
                v
            )
        }
        _ => ()
    }
}

Паттерн первого рукава в выражении match совпадает с вариантом Message::ChangeColor перечисления, содержащим вариант Color::Rgb. Затем паттерн привязывается к трем внутренним значениям типа i32. Паттерн второго рукава также совпадает с вариантом Message::ChangeColor перечисления, но внутреннее перечисление совпадает с вариантом Color::Hsv. Мы можем указать эти сложные условия в одном выражении match, хотя здесь задействованы только два перечисления.

Деструктурирование структур и кортежей

Мы можем смешивать, сопоставлять и вкладывать деструктурирующие паттерны еще более сложными способами. Следующий пример показывает сложное деструктурирование, в котором мы вкладываем структуры и кортежи внутрь кортежа и деструктурируем все примитивные значения:

let ((feet, inches), Point {x, y}) = ((3, 10), Point { x: 3, y: -10 });

Этот код позволяет разбивать сложные типы на составные части, в результате чего мы можем использовать интересующие нас значения по отдельности.