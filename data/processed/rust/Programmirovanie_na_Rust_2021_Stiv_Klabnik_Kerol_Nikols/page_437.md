---
source_image: page_437.png
page_number: 437
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 27.29
tokens: 7496
characters: 1908
timestamp: 2025-12-24T10:57:13.356477
finish_reason: stop
---

ногого объекта. Следовательно, во время компиляции нам не нужно знать все возможные типы.

Мы уже упоминали, что в Rust не принято называть структуры и перечисления объектами, чтобы отличать их от объектов других языков. В структуре либо в перечислении данные в полях структуры и поведение в блоках impl отделены, тогда как в других языках данные и поведение объединены в одно понятие, которое часто обозначается термином «объект». Однако типажные объекты больше похожи на объекты в других языках в том смысле, что они объединяют данные и поведение. Но при этом типажные объекты отличаются от традиционных объектов тем, что в типажный объект нельзя добавлять данные. Типажные объекты не так полезны, как объекты в других языках. Их специфическая цель — сделать возможной абстракцию в часто встречающемся поведении.

Листинг 17.3 показывает, как определять типаж с именем Draw с одним методом draw.

Листинг 17.3. Определение типажа Draw
src/lib.rs
```rust
pub trait Draw {
    fn draw(&self);
}
```

Вам знаком этот синтаксис из темы определения типажей в главе 10. Далее следует новый синтаксис: листинг 17.4 определяет структуру Screen, которая содержит вектор components. Этот вектор имеет тип Box<Dyn Draw>, который является типажным объектом. Он замещает любой тип внутри Box, реализующий типаж Draw.

Листинг 17.4. Определение структуры Screen с полем components, содержащим вектор типажных объектов, реализующих типаж Draw
src/lib.rs
```rust
pub struct Screen {
    pub components: Vec<Box<dyn Draw>>,
}
```

В структуре Screen мы определим метод run, который будет вызывать метод draw для каждого своего компонента, как показано в листинге 17.5.

Листинг 17.5. Метод run в структуре Screen, который вызывает метод draw для каждого компонента
src/lib.rs
```rust
impl Screen {
    pub fn run(&self) {
        for component in self.components.iter() {
            component.draw();
        }
    }
}
```