---
source_image: page_293.png
page_number: 293
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 30.89
tokens: 7527
characters: 2011
timestamp: 2025-12-24T10:53:28.920999
finish_reason: stop
---

    println!("С текстом:\n{}", contents);
}
// --пропуск--
Функция run теперь содержит остальной алгоритм функции main, начиная с чтения файла. Функция run принимает экземпляр структуры Config в качестве аргумента.

Возвращение ошибок из функции run

Теперь, когда остальной алгоритм программы выделен в функцию run, мы можем улучшить обработку ошибок, как это было сделано с функцией Config::new в листинге 12.9. Вместо того чтобы давать программе паниковать, вызывая метод expect, функция run будет возвращать Result<T, E>, когда что-то пойдет не так. Это позволит еще больше консолидировать алгоритм вокруг обработки ошибок в функции main в удобном для пользователя виде. В листинге 12.12 показаны изменения, которые мы должны внести в сигнатуру и тело функции run.

Листинг 12.12. Изменение функции run в части возвращения экземпляра типа Result
src/main.rs
① use std::error::Error;
    // --пропуск--
② fn run(config: Config) -> Result<(), Box<dyn Error>> {
    let contents = fs::read_to_string(config.filename)?③;
    println!("С текстом:\n{}", contents);
    ④ Ok(())
}

Мы внесли три существенных изменения. Во-первых, мы изменили тип значения, возвращаемого из функции run, на Result<(), Box<dyn Error>> ②. Эта функция ранее возвращала пустой тип (); мы оставляем его как значение, возвращаемое в случае Ok.

Для типа ошибки мы использовали типажный объект Box<dyn Error> (мы ввели std::error::Error в область видимости с помощью инструкции use вверху ①). Мы рассмотрим типажные объекты в главе 17. А пока просто знайте, Box<dyn Error> означает, что функция будет возвращать тип, который реализует типаж Error, но нам не нужно уточнять, каким именно типом будет возвращаемое значение. Это дает возможность гибко возвращать значения ошибок, которые могут иметь разные типы в разных случаях. Ключевое слово dyn расшифровывается как «динамический».

Во-вторых, мы удалили вызов метода expect в пользу оператора ? ③, как мы уже говорили в главе 9. Вместо того чтобы вызывать panic! в случае ошибки, опера-