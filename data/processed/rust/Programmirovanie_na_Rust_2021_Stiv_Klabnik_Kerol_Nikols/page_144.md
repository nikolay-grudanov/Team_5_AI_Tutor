---
source_image: page_144.png
page_number: 144
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 33.25
tokens: 7534
characters: 2024
timestamp: 2025-12-24T10:49:33.486241
finish_reason: stop
---

fn plus_one(x: Option<i32>) -> Option<i32> {
    match x {
        Some(i) => Some(i + 1),
    }
}

Мы не учитываем случай None, поэтому указанный код вызовет ошибку. К счастью, Rust умеет выявлять эту ошибку. Если мы попытаемся скомпилировать код, то получим такую ошибку¹:

error[E0004]: non-exhaustive patterns: `None` not covered
  --> 
   |
6 |     match x {
   |         ^ pattern `None` not covered

Rust знает, что мы не учли все возможные случаи, и даже знает, какой мы забыли паттерн! Совпадения в Rust являются исчерпывающими: для того чтобы код был допустимым, мы должны исчерпать все до последней возможности. Особенно в случае с Option<T>, когда Rust не дает нам забыть про обработку None. Язык защищает от ошибочного предположения о наличии значения, когда вместо него может быть null, то есть от упомянутой ранее ошибки на миллиард долларов.

Заполнитель _

В Rust также имеется паттерн, который можно использовать, когда мы не хотим перечислять все возможные значения. Например, u8 имеет допустимые значения в интервале от 0 до 255. Если нас интересуют только значения 1, 3, 5 и 7, то нам не придется перечислять 0, 2, 4, 6, 8, 9 вплоть до 255. К счастью, мы не обязаны это делать: вместо этого мы можем использовать специальный паттерн _:

let some_u8_value = 0u8;
match some_u8_value {
    1 => println!("один"),
    3 => println!("три"),
    5 => println!("пять"),
    7 => println!("семь"),
    _ => (),
}

Паттерн _ будет соответствовать любому значению. Если поставить его после других рукавов, _ будет совпадать со всеми возможными случаями, которые не указаны до него. () является всего лишь пустым значением, поэтому в случае _ ничего не произойдет. В результате можно сказать, что ничего не нужно делать со всеми возможными значениями, которые мы не перечисляем до заполнителя _.

Однако выражение match бывает несколько избыточным в ситуации, когда нас интересует только один из случаев. Для этого в Rust есть конструкция if let.

¹ ошибка[E0004]: неисчерпывающие паттерны: не учтен случай `None`