---
source_image: page_255.png
page_number: 255
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 32.30
tokens: 7497
characters: 1921
timestamp: 2025-12-24T10:52:28.217132
finish_reason: stop
---

Теперь, когда вы увидели, как выглядят результаты теста в разных сценариях, давайте посмотрим на несколько макрокоманд, помимо panic!, которые широко используются в тестах.

Проверка результатов с помощью макрокоманды assert!

Макрокоманда assert!, предусмотренная стандартной библиотекой, полезна, когда вы хотите убедиться, что какое-то условие в тесте принимает значение true. Мы даем макрокоманде assert! аргумент, который вычисляется как булев. Если значение является истинным, то макрокоманда assert! ничего не делает, и тест успешно. Если значение является ложным, то макрокоманда assert! вызывает макрокоманду panic!, которая приводит к провалу теста. Использование макрокоманды assert! помогает нам проверить, что код функционирует именно так, как мы предполагаем.

В листинге 5.15 мы использовали структуру Rectangle и метод can_hold, которые приводятся повторно в листинге 11.5. Давайте поместим этот код в файл src/lib.rs и напишем для него несколько тестов с использованием макрокоманды assert!.

Листинг 11.5. Использование структуры Rectangle и ее метода can_hold из главы 5 src/lib.rs

```rust
#[derive(Debug)]
pub struct Rectangle {
    length: u32,
    width: u32,
}

impl Rectangle {
    pub fn can_hold(&self, other: &Rectangle) -> bool {
        self.length > other.length && self.width > other.width
    }
}
```

Метод can_hold возвращает булев тип — это значит, что такой вариант использования идеален для макрокоманды assert!. В листинге 11.6 мы пишем тест, который использует метод can_hold путем создания экземпляра структуры Rectangle с длиной 8 и шириной 7 и утверждения, что он может содержать другой экземпляр структуры Rectangle с длиной 5 и шириной 1.

Листинг 11.6. Тест для метода can_hold, который проверяет, может ли больший прямоугольник вместить меньший прямоугольник

src/lib.rs

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn larger_can_hold_smaller() {
```