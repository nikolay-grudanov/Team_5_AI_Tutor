---
source_image: page_402.png
page_number: 402
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 33.89
tokens: 7581
characters: 2137
timestamp: 2025-12-24T10:56:25.769728
finish_reason: stop
---

*leaf.parent.borrow_mut() = Rc::downgrade(&branch);

    println!(
        "сильные ссылки branch = {}, слабые ссылки = {}",
        Rc::strong_count(&branch),
        Rc::weak_count(&branch),
    );

    println!(
        "сильные ссылки leaf = {}, слабые ссылки = {}",
        Rc::strong_count(&leaf),
        Rc::weak_count(&leaf),
    );
}

println!("родительский узел leaf = {:?}}", leaf.parent.borrow().upgrade());
println!(
    "сильные ссылки leaf = {}, слабые ссылки = {}",
    Rc::strong_count(&leaf),
    Rc::weak_count(&leaf),
);

После того как узел leaf создан, его умный указатель Rc<Node> имеет сильное число 1 и слабое число 0 ①. Во внутренней области ② мы создаем узел branch и связываем его с узлом leaf, и в момент, когда мы выведем числа ③, умный указатель Rc<Node> в узле branch будет иметь сильное число 1 и слабое число 1 (для leaf.parent, указывающей на branch с Weak<Node>). Когда мы выведем числа в узле leaf ④, мы увидим, что у него будет сильное число 2, потому что узел branch теперь имеет клон умного указателя Rc<Node> узла leaf, хранящегося в branch.children, но по-прежнему будет иметь слабое число 0.

Когда внутренняя область видимости заканчивается ⑤, узел branch выходит из области и сильное число умного указателя Rc<Node> уменьшается до 0, поэтому его экземпляр структуры Node отбрасывается. Слабое число 1 из leaf.parent не имеет отношения к тому, будет ли этот Node отброшен, поэтому нет никаких утечек памяти!

Если мы попытаемся обратиться к родительскому узлу leaf после окончания области видимости, то мы снова получим None ⑥. В конце программы ⑦ умный указатель Rc<Node> в узле leaf имеет сильное число 1 и слабое число 0, потому что узел leaf теперь снова является единственной ссылкой на Rc<Node>.

Весь алгоритм, управляющий подсчетами и отбрасыванием значений, встроен в указатели Rc<T> и Weak<T>, а также в их реализации типажа Drop. Описав в определении структуры Node, что связь между дочерним узлом и его родителем должна быть ссылкой Weak<T>, вы можете сделать так, чтобы родительские узлы указывали на дочерние и наоборот, не создавая цикла в переходах по ссылкам и утечек памяти.