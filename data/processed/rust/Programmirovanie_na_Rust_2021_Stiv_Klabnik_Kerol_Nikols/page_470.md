---
source_image: page_470.png
page_number: 470
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 33.86
tokens: 7506
characters: 1720
timestamp: 2025-12-24T10:58:13.391007
finish_reason: stop
---

задать только имена полей структуры, а переменные, создаваемые из паттерна, будут иметь те же имена. Листинг 18.13 показывает код, который ведет себя точно так же, как и код в листинге 18.12, но переменными, создаваемыми в паттерне let, являются x и y вместо a и b.

Листинг 18.13. Деструктурирование полей структуры с помощью сокращенной формы записи полей структуры

src/main.rs
```rust
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x, y } = p;
    assert_eq!(0, x);
    assert_eq!(7, y);
}
```

Этот код создает переменные x и y, которые совпадают с полями x и y переменной p. В результате переменные x и y содержат значения из структуры p.

Мы также можем выполнять деструктурирование с литеральными значениями в рамках структурного паттерна, а не создавать переменные для всех полей. Это позволяет проверять некоторые поля на наличие определенных значений при создании переменных для деструктурирования других полей.

Листинг 18.14 показывает выражение match, которое делит значения структуры Point на три случая: точки, лежащие непосредственно на оси x (что верно при y = 0), на оси y (x = 0) или ни на одной из них.

Листинг 18.14. Деструктурирование и сопоставление литературных значений в одном паттерне

src/main.rs
```rust
fn main() {
    let p = Point { x: 0, y: 7 };

    match p {
        Point { x, y: 0 } => println!("На оси x в точке {}", x),
        Point { x: 0, y } => println!("На оси y в точке {}", y),
        Point { x, y } => println!("Ни на одной оси: ({}, {})", x, y),
    }
}
```

Первый рукав будет совпадать с любой точкой, лежащей на оси x, с указанием, что поле y совпадает, если его значение совпадает с литералом 0. Паттерн по-