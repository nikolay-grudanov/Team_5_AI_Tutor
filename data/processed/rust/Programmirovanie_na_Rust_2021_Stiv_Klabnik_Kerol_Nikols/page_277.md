---
source_image: page_277.png
page_number: 277
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 27.59
tokens: 7534
characters: 2044
timestamp: 2025-12-24T10:52:58.455741
finish_reason: stop
---

tests/integration_test.rs

use adder;

mod common;

#[test]
fn it_adds_two() {
    common::setup();
    assert_eq!(4, adder::add_two(2));
}

Обратите внимание, что объявление mod common; совпадает с объявлениями модулей из листинга 7.21. Затем в тестовой функции можно вызвать функцию common::setup().

Интеграционные тесты для двоичных упаковок

Если проект представляет собой двоичную упаковку, содержащую только файл src/main.rs, и в нем нет файла src/lib.rs, то мы не можем создавать интеграционные тесты в каталоге tests и вводить функции, определенные в файле src/main.rs, в область видимости с помощью инструкции use. Только в библиотечных упаковках имеются функции, которые могут использоваться другими упаковками; двоичные упаковки задуманы для того, чтобы они выполнялись самостоятельно.

Это одна из причин, по которой в проектах Rust, предоставляющих двоичный файл, есть простой файл src/main.rs, который вызывает алгоритм, расположенный в файле src/lib.rs. Используя эту структуру, интеграционные тесты могут проверять библиотечную упаковку с помощью use, испытывая важное свойство. Если это свойство работает, то небольшой объем кода в файле src/main.rs тоже будет работать, и его не нужно тестировать.

Итоги

Средства тестирования Rust дают возможность уточнить, как должен функционировать код, чтобы бесперебойная работа продолжалась даже при внесении изменений. В модульных тестах испытываются разные части библиотеки по отдельности, а также приватные детали реализации. В интеграционных тестах выполняется проверка правильности совместной работы многочисленных частей библиотеки и используется публичный API библиотеки, чтобы протестировать код таким же образом, каким его будет использовать внешний код. Несмотря на то что система типов и правила владения в языке Rust помогают предотвращать некоторые виды ошибок, тесты по-прежнему важны для уменьшения числа логических ошибок, связанных с ожидаемым поведением кода.

Давайте объединим знания, которые вы получили в этой главе и в предыдущих, чтобы поработать над проектом!