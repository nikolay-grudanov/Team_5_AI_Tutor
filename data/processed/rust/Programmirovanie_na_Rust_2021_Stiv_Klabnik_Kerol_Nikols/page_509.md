---
source_image: page_509.png
page_number: 509
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 29.96
tokens: 7483
characters: 1976
timestamp: 2025-12-24T10:59:08.752275
finish_reason: stop
---

он выступает вместо возвращаемого типа, когда функция никогда ничего не возвращает. Вот его пример:

fn bar() -> ! {
    // --пропуск--
}

Этот код читается как «эта функция никогда ничего не возвращает». Функции, которые никогда ничего не возвращают, называются отклоняющимися функциями. Мы не можем создавать значения типа !, и поэтому bar никогда не сможет ничего вернуть.

Но какая польза от типа, для которого вы никогда не сможете создавать значения? Вспомните код из листинга 2.5, мы воспроизвели его часть ниже, в листинге 19.26.

Листинг 19.26. Выражение match с рукавом, который заканчивается в continue

let guess: u32 = match guess.trim().parse() {
    Ok(num) => num,
    Err(_) => continue,
};

В то время мы пропустили некоторые детали в этом коде. В разделе «Выражение match как оператор управления потоком» (с. 139) мы отметили, что все рукава выражения match должны возвращать один и тот же тип. Поэтому, например, следующий код не работает:

let guess = match guess.trim().parse() {
    Ok(_) => 5,
    Err(_) => "здравствуй",
}

Тип переменной guess в этом коде должен быть целым числом и строкой, а компилятор требует, чтобы переменная guess имела только один тип. Тогда что возвращает continue? Как же нам разрешили вернуть тип u32 из одного рукава и иметь другой рукав, который заканчивается на инструкции continue в листинге 19.26?

Как вы могли догадаться, инструкция continue имеет значение типа !. То есть когда Rust вычисляет тип переменной guess, он смотрит на оба рукава выражения match, первое со значением типа u32, а второе со значением типа !. Так как тип ! никогда не может иметь значения, Rust решает, что типом переменной guess является u32.

Формальным способом описания такого поведения является то, что выражения типа ! могут принудительно приводиться к любому другому типу. Нам разрешено завершить этот рукав выражения match инструкцией continue, потому что continue не возвращает значение; вместо этого он перемещает управление обрат-