---
source_image: page_165.png
page_number: 165
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 35.53
tokens: 7555
characters: 2173
timestamp: 2025-12-24T10:50:09.064198
finish_reason: stop
---

В более крупных программах введение в область видимости большого числа элементов из одного пакета или модуля с помощью вложенных путей значительно сокращает число необходимых для этого отдельных инструкций use.

Мы можем использовать вложенный путь на любом уровне пути, что полезно при объединении двух инструкций use, совместно использующих вложенный путь. Например, листинг 7.19 показывает две инструкции: одна вводит в область видимости std::io, а другая вводит в область видимости std::io::Write.

Листинг 7.19. Две инструкции, где одна является подпутем другой

src/lib.rs
    use std::io;
    use std::io::Write;

Общей частью обоих путей является путь std::io, он представляет собой полный первый путь. Для объединения этих двух путей в одну инструкцию use мы можем использовать self во вложенном пути, как показано в листинге 7.20.

Листинг 7.20. Объединение путей в листинге 7.19 в одну инструкцию use

src/lib.rs
    use std::io::{self, Write};

Эта строка вводит в область видимости std::io и std::io::Write.

Оператор glob

Если мы хотим ввести в область видимости все публичные элементы, определенные в пути, то можно указать этот путь с последующим оператором glob*:

    use std::collections::*;

Эта инструкция use вводит в текущую область видимости все публичные элементы, определенные в std::collections. При использовании оператора glob будьте осторожны! Он может затруднить определение того, какие имена находятся в области видимости и где было определено имя, используемое в программе.

Оператор glob часто используется при тестировании с целью введения всего, что тестируется, в модуль tests. Мы поговорим об этом в разделе «Как писать тесты». Оператор glob также иногда используется как часть паттерна прелюдии. Для получения дополнительной информации об этом паттерне обратитесь к документации стандартной библиотеки по адресу https://doc.rust-lang.org/stable/std/prelude/index.html#other-preludes.

Разделение модулей на разные файлы

До сих пор все примеры в этой главе определяли несколько модулей в одном файле. Когда модули станут крупными, вы, возможно, захотите переместить их определения в отдельный файл, чтобы облегчить навигацию по коду.