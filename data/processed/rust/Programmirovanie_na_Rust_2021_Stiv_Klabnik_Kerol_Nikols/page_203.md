---
source_image: page_203.png
page_number: 203
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 26.63
tokens: 7475
characters: 1963
timestamp: 2025-12-24T10:51:00.699121
finish_reason: stop
---

Листинг 9.8. Выстраивание вызовов методов в цепочку после оператора ?

src/main.rs

use std::io;
use std::io::Read;
use std::fs::File;

fn read_username_from_file() -> Result<String, io::Error> {
    let mut s = String::new();

    File::open("hello.txt")?.read_to_string(&mut s)?;

    Ok(s)
}

Мы перенесли создание нового экземпляра типа String в переменной s в начало функции; эта часть не изменилась. Вместо того чтобы создавать переменную f, мы сцепили вызов read_to_string непосредственно с результатом File::open("hello.txt")?. У нас по-прежнему есть оператор ? в конце вызова read_to_string, и мы все так же возвращаем значение Ok, содержащее в s имя пользователя, когда и File::open, и read_to_string срабатывают успешно, а не возвращают ошибки. Функциональность снова та же, что и в листингах 9.6 и 9.7, просто этот способ написания более эргономичен.

Говоря о разных способах написания этой функции, листинг 9.9 показывает, что имеется способ сделать это еще короче.

Листинг 9.9. Использование fs::read_to_string вместо открытия и последующего чтения файла

src/main.rs

use std::io;
use std::fs;

fn read_username_from_file() -> Result<String, io::Error> {
    fs::read_to_string("hello.txt")
}

Операция чтения файла в строковую переменную встречается довольно часто, поэтому язык Rust предоставляет удобную функцию fs::read_to_string, которая открывает файл, создает новый экземпляр типа String, считывает содержимое файла, помещает его содержимое в этот экземпляр и возвращает его. Разумеется, использование fs::read_to_string не дает нам возможности объяснить весь процесс обработки ошибок, поэтому сначала мы сделали это более длинным способом.

Оператор ? может использоваться только в функциях, возвращающих Result

Оператор ? может использоваться только в функциях, которые имеют возвращаемый тип Result, поскольку он определен для работы таким же образом, как и выражение match, которое мы определили в листинге 9.6. Часть выражения match,