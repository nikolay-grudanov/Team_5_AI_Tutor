---
source_image: page_237.png
page_number: 237
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 28.33
tokens: 7454
characters: 1707
timestamp: 2025-12-24T10:51:55.862543
finish_reason: stop
---

Листинг 10.18. Аннотации жизненных циклов r и x, именуемые соответственно 'a и 'b

{
    let r;                // ----------+-- 'a
    {
        let x = 5;        // -+-- 'b
        r = &x;
    }
    println!("r: {}", r);  // ----------+
}

Здесь мы аннотировали жизненный цикл r как 'a, а жизненный цикл x как 'b. Как вы видите, внутренний блок 'b намного меньше внешнего блока 'a. Компилятор сравнивает размер двух жизненных циклов и видит, что переменная r имеет жизненный цикл 'a, но ссылается на память с жизненным циклом 'b. Программа отклоняется, потому что 'b короче 'a: предмет ссылки не живет так же долго, как ссылка.

В листинге 10.19 этот код исправлен таким образом, что у него нет висячей ссылки и он компилируется без ошибок.

Листинг 10.19. Действительная ссылка, поскольку у данных более продолжительный жизненный цикл, чем у ссылки

{
    let x = 5;            // ----------+-- 'b
    let r = &x;           // --+-- 'a
    println!("r: {}", r);  // --+
}                        // ----------+

Здесь переменная x имеет жизненный цикл 'b, который в данном случае больше 'a. Это означает, что переменная r может ссылаться на переменную x, потому что компилятор знает, что ссылка в r всегда будет действительной, пока переменная x является действительной.

Теперь, когда вы знаете, где находится жизненный цикл ссылок и как Rust анализирует жизненный цикл, чтобы ссылки всегда оставались действительными, давайте изучим обобщенные жизненные циклы параметров и возвращаемых значений в контексте функций.

Обобщенные жизненные циклы в функциях

Давайте напишем функцию, которая возвращает более длинный строковый срез из двух. Эта функция будет принимать два строковых среза и возвращать стро-