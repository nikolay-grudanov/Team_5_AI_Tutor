---
source_image: page_409.png
page_number: 409
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 26.74
tokens: 7470
characters: 1766
timestamp: 2025-12-24T10:56:28.883798
finish_reason: stop
---

Вызов join для дескриптора блокирует поток, работающий в настоящее время, до тех пор, пока поток дескриптора не завершится. Блокирование потока означает, что поток не может выполнять работу или выходить. Поскольку мы поместили вызов join после цикла for главного потока, выполнение листинга 16.2 должно привести к результату, аналогичному тому, который приведен ниже:

привет, число 1 из главного потока!
привет, число 2 из главного потока!
привет, число 1 из порожденного потока!
привет, число 3 из главного потока!
привет, число 2 из порожденного потока!
привет, число 4 из главного потока!
привет, число 3 из порожденного потока!
привет, число 4 из порожденного потока!
привет, число 5 из порожденного потока!
привет, число 6 из порожденного потока!
привет, число 7 из порожденного потока!
привет, число 8 из порожденного потока!
привет, число 9 из порожденного потока!

Оба потока продолжают чередоваться, но главный поток ждет из-за вызова handle.join() и не завершается до тех пор, пока не завершен порожденный поток.

Но давайте посмотрим, что произойдет, когда мы переместим вызов handle.join() и поставим его перед циклом for в функции main, как показано ниже:

src/main.rs

use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!("привет, число {} из порожденного потока!", i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    handle.join().unwrap();

    for i in 1..5 {
        println!("привет, число {} из главного потока!", i);
        thread::sleep(Duration::from_millis(1));
    }
}

Главный поток будет ждать завершения порожденного потока, а затем выполнит свой цикл for, поэтому результаты больше не будут чередоваться, как показано ниже: