---
source_image: page_103.png
page_number: 103
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 40.63
tokens: 7733
characters: 2319
timestamp: 2025-12-24T10:48:34.772239
finish_reason: stop
---

    println!("Длина '{}' равна {}.", s1, len);
}
fn calculate_length(s: &String) -> usize {
    s.len()
}

Во-первых, обратите внимание, что исчезли кортежный код в объявлении переменной и возвращаемое значение функции. Во-вторых, заметьте, что в функцию calculate_length мы передаем &s1 и для ее определения берем не String, а &String.

Амперсанды являются ссылками, они позволяют ссылаться на некое значение, не бея его во владение. На рис. 4.5 показана схема.

<table>
  <tr>
    <th>имя</th>
    <th>значение</th>
  </tr>
  <tr>
    <td>s</td>
    <td></td>
  </tr>
  <tr>
    <td>s1</td>
    <td></td>
  </tr>
  <tr>
    <td>имя</td>
    <td>значение</td>
  </tr>
  <tr>
    <td>ptr</td>
    <td></td>
  </tr>
  <tr>
    <td>длина</td>
    <td>5</td>
  </tr>
  <tr>
    <td>емкость</td>
    <td>5</td>
  </tr>
  <tr>
    <td>указатель</td>
    <td>значение</td>
  </tr>
  <tr>
    <td>0</td>
    <td>h</td>
  </tr>
  <tr>
    <td>1</td>
    <td>e</td>
  </tr>
  <tr>
    <td>2</td>
    <td>l</td>
  </tr>
  <tr>
    <td>3</td>
    <td>l</td>
  </tr>
  <tr>
    <td>4</td>
    <td>o</td>
  </tr>
</table>

Рис. 4.5. Схема, демонстрирующая, как &String s указывает на String s1

ПРИМЕЧАНИЕ

Противоположностью процедуре референции, то есть созданию указателя на существующее значение с использованием оператора референции &, является процедура разыменования, то есть следование по указателю к существующему значению с использованием оператора разыменования *. Мы рассмотрим некоторые виды использования оператора разыменования в главе 8 и обсудим детали разыменования в главе 15.

Давайте подробнее рассмотрим вызов функции:

let s1 = String::from("hello");
let len = calculate_length(&s1);

Синтаксис &s1 позволяет создать ссылку, которая ссылается на значение переменной s1, но не владеет им. Поскольку она не является ее владельцем, значение, на которое ссылка указывает, не будет отброшено, когда ссылка выйдет из области видимости.

Схожим образом в сигнатуре функции используется &, говоря о том, что тип параметра s является ссылкой. Давайте добавим несколько пояснительных аннотаций:

fn calculate_length(s: &String) -> usize { // s — это ссылка на экземпляр // типа String
    s.len()
} // Здесь s выходит из области видимости. Но поскольку она не владеет тем, // на что она ссылается, ничего не происходит.