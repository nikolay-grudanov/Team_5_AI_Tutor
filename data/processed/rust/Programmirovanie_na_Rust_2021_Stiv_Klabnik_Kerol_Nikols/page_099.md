---
source_image: page_099.png
page_number: 99
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 32.74
tokens: 7571
characters: 2123
timestamp: 2025-12-24T10:48:20.965131
finish_reason: stop
---

Пути взаимодействия переменных и данных: Clone

Если мы все-таки хотим сделать глубокую копию данных String из кучи, а не только данных из стека, то можно использовать часто встречающийся метод clone. Мы обсудим синтаксис методов в главе 5, но так как методы являются языковым средством, часто встречающимся во многих языках программирования, вы, вероятно, видели их раньше.

Вот пример метода clone в действии:

let s1 = String::from("hello");
let s2 = s1.clone();

println!("s1 = {}, s2 = {}", s1, s2);

Он хорошо работает и ведет себя так, как показано на рис. 4.3, где данные кучи действительно копируются.

Когда вы видите вызов метода clone, вы знаете, что исполняется произвольный код, который может быть затратным. Указанный метод является визуальным индикатором того, что происходит что-то другое.

Данные только из стека: Copy

Есть еще одна загвоздка, о которой мы пока не говорили. Приведенный ниже код с целыми числами, часть которого была показана в листинге 4.2, работает и является допустимым:

let x = 5;
let y = x;

println!("x = {}, y = {}", x, y);

Но этот код, похоже, противоречит тому, о чем мы только что узнали: у нас нет вызова метода clone, но переменная x по-прежнему действует и не была перемещена в y.

Причина заключается в том, что такие типы, как целые числа, размер которых во время компиляции известен, хранятся полностью в стеке, и поэтому копии фактических значений создаются быстро. Это означает, что нет причин, по которым следовало бы запретить переменной x быть действительно после того, как мы создадим переменную y. Другими словами, здесь нет разницы между глубоким и мелким копированием, поэтому вызов метода clone будет делать то, что бывает при обычном мелком копировании, и мы можем его исключить.

В Rust имеется специальная аннотация, именуемая типажом Copy, которую можно размещать в типах, таких как целые числа, хранящихся в стеке (подробнее о типажах мы поговорим в главе 10). Если у типа есть типаж Copy, то более старая переменная по-прежнему пригодна для использования после ее присвоения другой переменной. Язык Rust не позволит нам аннотировать тип с помощью типажа