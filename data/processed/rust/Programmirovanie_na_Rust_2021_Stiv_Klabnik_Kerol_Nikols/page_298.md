---
source_image: page_298.png
page_number: 298
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 32.63
tokens: 7581
characters: 2242
timestamp: 2025-12-24T10:53:37.160267
finish_reason: stop
---

search(query, contents)
    );
}
}

Этот тест выполняет поиск строкового значения "duct" («провод»). Текст, в котором мы производим поиск, состоит из трех строк, и только одна из них содержит слово "duct". Мы подтверждаем (с помощью assert_eq!), что значение, возвращаемое функцией search, содержит только ту строку текста, которую мы ожидаем.

Мы не можем выполнить этот тест, потому что тест даже не компилируется: функции search еще не существует! Поэтому теперь добавим объем кода, достаточный для того, чтобы тест можно было скомпилировать и выполнить, добавив определение функции search, которое всегда возвращает пустой вектор, как показано в листинге 12.16. Тогда тест должен скомпилироваться и не сработать, потому что пустой вектор не совпадает с вектором, содержащим строку текста "safe, fast, productive" («безопасно, быстро, продуктивно»).

Листинг 12.16. Определение функции search в объеме, достаточном для компиляции кода

src/lib.rs
pub fn search<'a>(query: &str, contents: &'a str) -> Vec<&'a str> {
    vec![]
}

Обратите внимание, что требуется явно выраженный жизненный цикл 'a, определенный в сигнатуре функции search и используемый с аргументом contents и возвращаемым из функции значением. Вспомните, что в главе 10 параметры жизненных циклов описывают то, какой аргумент жизненного цикла соединен с жизненным циклом возвращаемого значения. В этом случае мы указываем, что возвращаемый вектор должен содержать строковые срезы, которые ссылаются на срезы аргумента contents (а не аргумента query).

Другими словами, мы говорим компилятору, что данные, возвращаемые функцией search, будут жить столько же, сколько данные, передаваемые в функцию search в аргументе contents. Это очень важно! Чтобы ссылка была действительно, данные, на которые ссылается срез, должны быть действительно; если компилятор допускает, что мы делаем строковые срезы аргумента query, а не аргумента contents, то он будет выполнять проверку безопасности неправильно.

Если мы забудем об аннотациях жизненных циклов и попытаемся скомпилировать эту функцию, то получим такую ошибку:

error[E0106]: missing lifetime specifier
 --> src/lib.rs:5:51
  |
5 | pub fn search(query: &str, contents: &str) -> Vec<&str> {
      ^ expected lifetime parameter