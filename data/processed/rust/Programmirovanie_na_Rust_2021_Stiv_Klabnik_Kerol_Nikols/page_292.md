---
source_image: page_292.png
page_number: 292
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 32.24
tokens: 7549
characters: 2066
timestamp: 2025-12-24T10:53:28.285721
finish_reason: stop
---

в замыкании в аргументе err, расположенном между вертикальными чертами ④. Код в замыкании может затем использовать значение err во время работы.

Мы добавили новую строку кода use, введя process из стандартной библиотеки в область видимости ①. Код в замыкании, который будет выполняться в случае ошибки, состоит всего из двух строк: мы печатаем значение err ⑤, а затем вызываем process::exit ⑥. Функция process::exit немедленно остановит программу и вернет число, которое было передано в качестве кода завершения работы. Это похоже на panic!-ориентированную обработку, которую мы использовали в листинге 12.8, но мы больше не получаем лишних данных. Давайте попробуем это сделать:

    $ cargo run
        Compiling minigrep v0.1.0 (file:///projects/minigrep)
        Finished dev [unoptimized + debuginfo] target(s) in 0.48 secs
        Running `target/debug/minigrep`
    Проблема с разбором аргументов: недостаточно аргументов

Великолепно! Пользоваться этими данными гораздо удобнее.

Извлечение алгоритма из функции main

Теперь, когда мы закончили рефакторинг конфигурационного разбора, давайте обратимся к алгоритму программы. Как мы уже говорили в разделе «Разделение обязанностей в двоичных проектах», мы извлекаем функцию с именем run, которая будет содержать весь алгоритм, пока что находящийся в функции main, которая не связана с настройкой конфигурации или обработкой ошибок. Когда мы закончим, функция main будет краткой, ее легко будет проверить и мы сможем писать тесты для остального алгоритма.

Листинг 12.11 показывает извлеченную функцию run. Пока мы делаем лишь небольшое, поступательное улучшение процедуры извлечения функции. Мы по-прежнему определяем указанную функцию в src/main.rs.

Листинг 12.11. Извлечение функции run, содержащей остальной алгоритм
src/main.rs

fn main() {
    // --пропуск--

    println!("Поиск {}", config.query);
    println!("В файле {}", config.filename);

    run(config);
}

fn run(config: Config) {
    let contents = fs::read_to_string(config.filename)
        .expect("Что-то пошло не так при чтении файла");