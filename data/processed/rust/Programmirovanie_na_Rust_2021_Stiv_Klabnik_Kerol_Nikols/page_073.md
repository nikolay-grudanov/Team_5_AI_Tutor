---
source_image: page_073.png
page_number: 73
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 28.29
tokens: 7448
characters: 1703
timestamp: 2025-12-24T10:47:33.335428
finish_reason: stop
---

Такая запись типа массива похожа на альтернативный синтаксис инициализации массива: если вы хотите создать массив, содержащий одинаковое значение для каждого элемента, то вы можете указать в квадратных скобках начальное значение с последующей точкой с запятой, а затем написать длину массива, как показано здесь:

let a = [3; 5];

Массив с именем a будет содержать 5 элементов, для всех элементов которого изначально будет задано значение 3. Это то же самое, что написать let a = [3, 3, 3, 3, 3];, но в более сжатом виде.

Доступ к элементам массива

Массив представляет собой отдельную часть памяти, выделенную в стеке. К элементам массива можно обращаться по индексу, например:

src/main.rs
fn main() {
    let a = [1, 2, 3, 4, 5];
    let first = a[0];
    let second = a[1];
}

В этом примере переменная с именем first получит значение 1, потому что это значение находится в массиве в индексе [0]. Переменная с именем second получит значение 2 из индекса [1] в массиве.

Недействительный доступ к элементу массива

Что произойдет, если вы попытаетесь обратиться к элементу массива, который находится за его пределами? Допустим, вы меняете пример на следующий код, который будет компилироваться, но завершится с ошибкой при выполнении:

src/main.rs
fn main() {
    let a = [1, 2, 3, 4, 5];
    let index = 10;
    let element = a[index];
    println!("Значение элемента равно {}", element);
}

Выполнение этого кода с командой cargo run произведет следующий результат:

$ cargo run
Compiling arrays v0.1.0 (file:///projects/arrays)
Finished dev [unoptimized + debuginfo] target(s) in 1.50 secs
Running `target/debug/arrays`
thread '<main>' panicked at 'index out of bounds: the len is 5 but the index