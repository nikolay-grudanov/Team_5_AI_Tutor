---
source_image: page_156.png
page_number: 156
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 32.33
tokens: 7577
characters: 2314
timestamp: 2025-12-24T10:49:50.387747
finish_reason: stop
---

Теперь код будет компилироваться! Давайте посмотрим на абсолютный и относительный путь и перепроверим, почему добавление ключевого слова pub позволяет использовать эти пути в add_to_waitlist в соответствии с правилами конфиденциальности.

В абсолютном пути мы начинаем с crate, корня дерева модулей упаковки. Затем в корне упаковки определяется модуль front_of_house. Модуль front_of_house не является публичным, но так как функция eat_at_restaurant определена в том же модуле, что и модуль front_of_house (то есть eat_at_restaurant и front_of_house являются одноуровневыми), мы можем ссылаться на модуль front_of_house из функции eat_at_restaurant. Далее идет модуль hosting, помеченный ключевым словом pub. Мы можем обратиться к родительскому модулю hosting, поэтому можно обратиться и к модулю hosting. Наконец, функция add_to_waitlist помечена ключевым словом pub, и можно получить доступ к ее родительскому модулю, поэтому вызов функции работает!

В относительном пути логика такая же, как и в абсолютном, за исключением первого шага: вместо того, чтобы начинать с корня упаковки, путь начинается с модуля front_of_house. Модуль front_of_house определяется в том же модуле, что и функция eat_at_restaurant, поэтому относительный путь, начинающийся с модуля, в котором определена функция eat_at_restaurant, работает. Тогда, поскольку модуль hosting и функция add_to_waitlist помечены ключевым словом pub, остальная часть пути работает и вызов функции является допустимым!

Начало относительных путей с помощью super

Мы также можем конструировать относительные пути, которые начинаются в родительском модуле, используя в начале пути ключевое слово super. Это похоже на начало пути файловой системы с помощью синтаксиса ... Почему нам хотелось бы это делать?

Рассмотрим код в листинге 7.8, моделирующий ситуацию, в которой шеф-повар исправляет неправильный заказ и лично выносит его клиенту. Функция fix_incorrect_order («исправить неправильный заказ») вызывает функцию serve_order («обслужить заказ»), указав путь к serve_order, начинающийся с ключевого слова super.

Листинг 7.8. Вызов функции с использованием относительного пути, начинающегося с super
src/lib.rs
    fn serve_order() {}

    mod back_of_house {
        fn fix_incorrect_order() {
            cook_order();
            super::serve_order();