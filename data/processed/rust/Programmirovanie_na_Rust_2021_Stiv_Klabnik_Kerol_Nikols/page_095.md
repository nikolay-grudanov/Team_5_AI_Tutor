---
source_image: page_095.png
page_number: 95
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 33.04
tokens: 7602
characters: 2259
timestamp: 2025-12-24T10:48:14.562812
finish_reason: stop
---

Язык Rust выбирает другой путь: память возвращается автоматически, как только переменная, которой она принадлежит, выходит из области видимости. Вот версия примера области видимости из листинга 4.1 с использованием экземпляра типа String вместо строкового литерала:

{
    let s = String::from("hello"); // s действительно с этого момента и далее
    // что-то сделать с s
} // эта область закончилась, и
    // s больше не действует

Существует естественная точка, в которой мы можем вернуть память, необходимую экземпляру типа String, в операционную систему — когда переменная s выходит из области видимости. Когда переменная выходит из области видимости, Rust вызывает специальную функцию. Эта функция называется drop («отбросить»), и именно туда автор экземпляра типа String может поместить код для возврата памяти. Rust вызывает функцию drop автоматически в месте, где расположена закрывающая фигурная скобка.

ПРИМЕЧАНИЕ

В языке C++ паттерн высвобождения ресурсов в конце жизненного цикла элемента иногда называется «Получение ресурса — это инициализация» (то есть получение ресурса совмещается с инициализацией, а высвобождение — с уничтожением объекта, от англ. Resource Acquisition Is Initialization, RAII). Функция drop в языке Rust, вероятно, вам знакома, если вы использовали паттерны RAII.

Этот паттерн оказывает глубокое влияние на то, как код пишется на Rust. Сейчас все кажется простым, но поведение кода окажется неожиданным в более сложных ситуациях, когда нужно, чтобы данные, для которых мы выделили пространство в куче, использовались более одной переменной. Давайте рассмотрим некоторые ситуации.

Способы взаимодействия переменных и данных: перемещение

В Rust многочисленные переменные взаимодействуют с одними и теми же данными по-разному. Рассмотрим пример использования целого числа в листинге 4.2.

Листинг 4.2. Передача целочисленного значения от переменной x переменной y
let x = 5;
let y = x;

Мы догадываемся, что здесь происходит: «связать значение 5 с x; затем сделать копию значения в x и связать его с y». Теперь у нас есть две переменные, x и y, и обе равны 5. Это действительно то, что происходит, потому что целые числа — это простые значения с известным фиксированным размером, и эти два значения 5 помещаются в стек.