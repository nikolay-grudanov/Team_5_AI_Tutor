---
source_image: page_442.png
page_number: 442
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 34.43
tokens: 7569
characters: 2340
timestamp: 2025-12-24T10:57:28.011263
finish_reason: stop
---

тор порождает код, который во время выполнения будет выяснять, какой метод вызывать.

Когда мы используем типажные объекты, Rust должен применять динамическую диспетчеризацию. Компилятор не знает все типы, которые могли бы использоваться с кодом, в котором есть типажные объекты, поэтому ему неизвестно, ни какой метод реализован, ни для какого типа его вызывать. Вместо этого во время выполнения Rust использует указатели внутри типажного объекта, чтобы знать, какой метод вызывать. Когда есть уточняющий запрос, несколько увеличивается время выполнения, чего не происходит со статической диспетчеризацией. Динамическая диспетчеризация также не дает компилятору внедрять код метода, поэтому, в свою очередь, не выполняются некоторые оптимизации. Тем не менее мы получили дополнительную гибкость в коде из листинга 17.5 и смогли поддержать эту гибкость в листинге 17.9, так что стоит это учитывать.

Объектная безопасность необходима для типажных объектов

Можно переделывать в типажные объекты только объектно-безопасные типажи. Несколько сложных правил управляют всеми свойствами, которые делают типажный объект безопасным, но на практике важны только два правила. Типаж объектно-безопасен, если все методы, определенные в нем, имеют следующие свойства:

○ Возвращаемый тип не является Self.
○ Параметры обобщенных типов отсутствуют.

Ключевое слово Self — это псевдоним типа, в котором мы реализуем типажи или методы. Типажные объекты должны быть объектно-безопасными, потому что после использования типажного объекта Rust больше не знает конкретный тип, реализующий этот типаж. Если типажный метод возвращает конкретный тип Self, а типажный объект забывает точный тип, который Self имеет, то нет ни единого способа, которым данный метод сможет использовать оригинальный конкретный тип. То же самое верно и для параметров обобщенного типа, которые заполняются параметрами конкретного типа при использовании типажа: конкретные типы становятся частью типа, реализующего типаж. Когда тип забывается в результате использования типажного объекта, никак нельзя узнать, какими типами заполнять параметры обобщенного типа.

Примером типажа, методы которого не являются объектно-безопасными, является Clone стандартной библиотеки. Сигнатура метода clone в типаже Clone выглядит следующим образом:

pub trait Clone {
    fn clone(&self) -> Self;
}