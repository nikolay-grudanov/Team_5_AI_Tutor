---
source_image: page_385.png
page_number: 385
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 40.55
tokens: 7732
characters: 2795
timestamp: 2025-12-24T10:56:04.474706
finish_reason: stop
---

О В любой момент у вас может быть одно из следующих значений, но не оба: одна изменяемая ссылка или любое число неизменяемых ссылок.

О Ссылки всегда должны быть действительными.

В случае со ссылками и умным указателем Box<T> инварианты правил заимствования соблюдаются во время компиляции. В случае с умным указателем RefCell<T> эти инварианты соблюдаются во время выполнения. В случае со ссылками, если вы нарушите эти правила, то произойдет ошибка компилятора. В случае с RefCell<T>, если вы их нарушите, то программа поднимет панику и завершится.

Преимущества проверки правил заимствования во время компиляции заключаются в том, что ошибки выявляются на раннем этапе в процессе разработки, и ни-что не влияет на производительность времени выполнения, поскольку весь анализ выполняется заранее. Поэтому проверка правил заимствования во время компиляции — чаще всего лучший вариант и выполняется в Rust по умолчанию.

Преимущество проверки правил заимствования во время выполнения заключается в том, что в этом случае разрешаются некоторые безопасные для памяти сценарии, тогда как они запрещаются проверками во время компиляции. Статический анализ, как и компилятор, по своей сути является консервативным. Некоторые свойства кода невозможно обнаружить путем анализа: самый известный пример — это проблема остановки, рассмотрение которой выходит за рамки темы данной книги, но это интересный вопрос для исследования.

Поскольку анализ невозможен, если компилятор не способен проверить, что код согласуется с правилами владения, он может отклонить правильную программу. В этом смысле он консервативен. Если бы Rust принял неправильную программу, то пользователи не смогли бы доверять возможностям этого языка. Но если Rust будет отклонять правильную программу, то программисту будет не очень удобно работать, но ничего страшного не произойдет. Тип RefCell<T> полезен, когда вы уверены, что код следует правилам заимствования, но компилятор не может понять и гарантировать это.

Как и Rc<T>, тип RefCell<T> предназначен для использования только в однопоточных сценариях и будет выдавать ошибку времени компиляции, если вы попытаетесь применить его в многопоточном контексте. О том, как получить функциональность типа RefCell<T> в многопоточной программе, мы поговорим в главе 16.

Кратко скажем, почему нужно выбирать типы Box<T>, Rc<T> или RefCell<T>:

О Тип Rc<T> дает возможность иметь более одного владельца одних и тех же данных. У типов Box<T> и RefCell<T> единственный владелец.

О Тип Box<T> допускает, чтобы неизменяемые или изменяемые заимствования проверялись во время компиляции. Тип Rc<T> допускает, чтобы только неизменяемые заимствования проверялись во время компиляции. Тип RefCell<T> допускает, чтобы неизменяемые либо изменяемые заимствования проверялись во время выполнения.