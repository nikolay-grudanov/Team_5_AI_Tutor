---
source_image: page_170.png
page_number: 170
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 35.55
tokens: 7553
characters: 1935
timestamp: 2025-12-24T10:50:19.298748
finish_reason: stop
---

Как и в случае с любой переменной, если мы хотим иметь возможность изменять его значение, нам нужно сделать его изменяемым с помощью ключевого слова mut, как описано в главе 3. Все числа, которые мы помещаем внутрь, относятся к типу i32, а язык Rust выводит это логически из данных, поэтому аннотация Vec<i32> не нужна.

Отбрасывание вектора отбрасывает его элементы

Как и любая другая структура, вектор высвобождается, когда он выходит из области видимости, как указано в листинге 8.4.

Листинг 8.4. Показывает точку, где вектор и его элементы отбрасываются

```rust
{
    let v = vec![1, 2, 3, 4];
    // что-то сделать с v
} // <- здесь v выходит из области видимости и высвобождается
```

Когда вектор отбрасывается, все его содержимое тоже отбрасывается, то есть те целые числа, которые он содержит, будут очищены. Этот момент, возможно, покажется простым, но он окажется немного сложнее, когда вы начнете вводить ссылки на элементы вектора. Давайте разберемся с этим вопросом далее.

Чтение элементов вектора

Теперь, когда вы знаете, как векторы создаются, обновляются и уничтожаются, пора познакомиться с тем, как читать их содержимое. Существует два способа ссылаться на значение, хранящееся в векторе. В примерах мы ради большей ясности аннотировали типы значений, возвращаемых этими функциями.

Листинг 8.5 показывает оба метода доступа к значению в векторе, с помощью синтаксиса индексирования либо с помощью метода get.

Листинг 8.5. Использование синтаксиса индексирования либо метода get для доступа к элементу в векторе

```rust
let v = vec![1, 2, 3, 4, 5];
let third: &i32 = &v[2];
println!("Третий элемент равен {}", third);

match v.get(2) {
    Some(third) => println!("Третий элемент равен {}", third),
    None => println!("Третий элемент отсутствует."),
}
```

Обратите внимание на две детали. Во-первых, мы используем индексное значение 2, чтобы получить третий элемент: векторы индексируются по числу, начиная