---
source_image: page_315.png
page_number: 315
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 25.25
tokens: 7366
characters: 1696
timestamp: 2025-12-24T10:53:53.705102
finish_reason: stop
---

if intensity < 25 {
    println!(
        "Сегодня сделайте {} отжиманий!",
        expensive_result
    );
    println!(
        "Далее, сделайте {} приседаний!",
        expensive_result
    );
} else {
    if random_number == 3 {
        println!("Сделайте сегодня перерыв! Пейте больше воды!");
    } else {
        println!(
            "Сегодня пробежка {} минут!",
            expensive_result
        );
    }
}
}

Это изменение унифицирует все вызовы функции simulated_expensive_calculation и решает проблему, когда первый блок if без необходимости вызывает функцию дважды. Но, к сожалению, теперь мы вызываем эту функцию и ждем результата во всех случаях, включая внутренний блок if, который вообще не использует значение результата.

Мы хотим определить код в одном месте программы, но выполнить его только там, где действительно нужен результат. Этот случай хорошо подходит для использования замыканий!

Рефакторинг с замыканиями для сохранения кода в переменной

Вместо того чтобы всегда вызывать функцию simulated_expensive_calculation перед блоками if, мы можем определить замыкание и сохранить его в переменной, а не сохранять результат вызова функции, как показано в листинге 13.5. На самом деле, можно переместить все тело функции simulated_expensive_calculation внутрь замыкания, которое мы вводим ниже.

Листинг 13.5. Определение замыкания и сохранение его в переменной expensive_closure

src/main.rs
let expensive_closure = |num| {
    println!("вычисляется медленно...");
    thread::sleep(Duration::from_secs(2));
    num
};

Определение замыкания следует за оператором =, который назначает его переменной expensive_closure. Для того чтобы определить замыкание, мы начинаем