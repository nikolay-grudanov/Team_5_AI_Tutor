---
source_image: page_439.png
page_number: 439
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 24.63
tokens: 7419
characters: 1707
timestamp: 2025-12-24T10:57:13.446225
finish_reason: stop
---

```rust
pub height: u32,
    pub label: String,
}

impl Draw for Button {
    fn draw(&self) {
        // код для фактической отрисовки кнопки
    }
}

Поля width, height и label в структуре Button будут отличаться от полей в других компонентах, таких как тип TextField, которые вместо этого могли бы иметь эти же поля плюс поле placeholder. Каждый тип, который мы хотим нарисовать на экране, будет реализовывать типаж Draw, но использовать другой код в методе draw с определением способа отрисовки этого конкретного типа, как здесь у типа Button (без фактического кода GUI, который выходит за рамки темы этой главы). Тип Button, например, мог бы иметь дополнительный блок impl, содержащий методы, связанные с тем, что происходит, когда пользователь нажимает кнопку. Эти методы не будут применимы к таким типам, как TextField.

Если пользователь библиотеки решит реализовать структуру SelectBox, содержащую поля width, height и options, то он также реализует типаж Draw для типа SelectBox, как показано в листинге 17.8.

Листинг 17.8. Еще одна упаковка, использующая gui и реализующая типаж Draw в структуре SelectBox

src/main.rs
use gui::Draw;

struct SelectBox {
    width: u32,
    height: u32,
    options: Vec<String>,
}

impl Draw for SelectBox {
    fn draw(&self) {
        // код для фактической отрисовки кнопки
    }
}

Теперь пользователь библиотеки может написать свою функцию main с экземпляром структуры Screen. В этот экземпляр он может добавить структуры SelectBox и Button, поместив каждую в Box<T>, которые станут типажным объектом. Затем он может вызвать метод run для экземпляра Screen, который будет вызывать метод draw для каждого компонента. Эта реализация показана в листинге 17.9.