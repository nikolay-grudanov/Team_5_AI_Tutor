---
source_image: page_097.png
page_number: 97
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 19.96
tokens: 7275
characters: 1106
timestamp: 2025-12-24T10:48:01.774954
finish_reason: stop
---

обеспечения безопасности доступа к памяти, о которых мы упоминали ранее. Высвобождение памяти дважды приводит к ее повреждению, что потенциально может вызвать уязвимость в системе безопасности.

![Представление в памяти переменной s2, имеющей копию указателя, длины и емкости s1](../images/chapter4/fig4_2.png)

Рис. 4.2. Представление в памяти переменной s2, имеющей копию указателя, длины и емкости s1

![Еще один вариант, что выражение s2 = s1 могло бы сделать, если бы язык Rust копировал данные кучи](../images/chapter4/fig4_3.png)

Рис. 4.3. Еще один вариант, что выражение s2 = s1 могло бы сделать, если бы язык Rust копировал данные кучи

Чтобы обеспечить безопасность памяти в Rust в этой ситуации, происходит еще одна вещь. Язык не пытается скопировать выделенную память, а считает, что переменная s1 больше не является действительной. Поэтому Rust не нужно ничего высвобождать, когда s1 выходит из области видимости. Убедитесь сами, что произойдет, когда вы пытаетесь использовать s1 после создания s2. Ничего не выйдет:

let s1 = String::from("hello");
let s2 = s1;

println!("{}, world!", s1);