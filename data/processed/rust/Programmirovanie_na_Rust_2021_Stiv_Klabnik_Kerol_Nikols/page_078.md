---
source_image: page_078.png
page_number: 78
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 23.82
tokens: 7428
characters: 1780
timestamp: 2025-12-24T10:47:37.707551
finish_reason: stop
---

let y = 6; является выражением, которое в результате вычисления принимает значение 6. Вызов функции является выражением. Вызов макрокоманды является выражением. Блок, который мы используем для создания новых областей, { }, является выражением, например:

src/main.rs
    fn main() {
        let x = 5;
        let y = {
            let x = 3;
            x + 1
        };
        println!("Значение у равно {}", y);
    }

Выражение ② — это блок, который в данном случае в результате вычисления принимает значение 4. Его значение привязывается к переменной y как часть инструкции let ①. Обратите внимание на строку кода без точки с запятой в конце ③ — она не похожа на большинство строк кода, которые вы видели до сих пор. Выражения не включают конечные точки с запятой. Если вы добавляете точку с запятой в конец выражения, то превращаете его в инструкцию, которая в таком случае не возвращает значение. Имейте это в виду при дальнейшем анализе значений и выражений, возвращаемых из функций.

Функции с возвращаемыми значениями

Функции могут возвращать значения в вызывающий их код. Мы не даем возвращаемым значениям имена, но объявляем их тип после стрелки (->). В Rust возвращаемое функцией значение является синонимом значения конечного выражения в блоке тела функции. Вы можете вернуться из функции досрочно, используя ключевое слово return и указав значение, но большинство функций неявным образом возвращают последнее выражение. Вот пример функции, которая возвращает значение:

src/main.rs
    fn five() -> i32 {
        5
    }
    fn main() {
        let x = five();
        println!("Значение x равно {}", x);
    }

В функции five нет вызовов функций, макрокоманд или даже инструкций let — только одно число 5. В Rust такая функция совершенно допустима. Обратите вни-