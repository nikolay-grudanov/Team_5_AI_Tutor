---
source_image: page_384.png
page_number: 384
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 35.63
tokens: 7645
characters: 2547
timestamp: 2025-12-24T10:55:57.030772
finish_reason: stop
---

дит из области видимости, число уменьшается на 1. Нам не приходится вызывать функцию, чтобы уменьшить число ссылок, в отличие от ситуации, когда нужно вызывать функцию Rc::clone, чтобы увеличить число ссылок. Реализация типа-жа Drop уменьшает число ссылок автоматически, когда значение Rc<T> выходит из области видимости.

Чего мы не увидим в этом примере, так это то, что когда b и затем a выходят из области видимости в конце функции main, то число становится равным 0, и в этот момент Rc<List> полностью очищается. Использование Rc<T> позволяет одному значению иметь несколько владельцев, а подсчет ссылок обеспечивает, чтобы значение оставалось действительно до тех пор, пока любой из владельцев существует.

Посредством неизменяемых ссылок умный указатель Rc<T> позволяет делиться данными только для чтения между несколькими частями программы. Если бы помимо этого умный указатель Rc<T> разрешил иметь несколько изменяемых ссылок, то вы бы могли нарушить одно из правил заимствования, описанных в главе 4: несколько изменяемых заимствований в одном и том же месте могут стать причиной гонки данных и несогласованности. Но изменять данные — очень полезная возможность! В следующем разделе мы обсудим паттерн внутренней изменяемости и тип RefCell<T>, который вы можете использовать в сочетании с умным указателем Rc<T> для работы с ограничением неизменяемости.

RefCell<T> и паттерн внутренней изменяемости

Внутренняя изменяемость — это паттерн проектирования, который позволяет изменять данные, даже когда есть неизменяемые ссылки на эти данные. Обычно это действие запрещено правилами заимствования. Для того чтобы изменить данные, указанный паттерн использует небезопасный (unsafe) код внутри структуры данных, чтобы обойти обычные правила Rust, которые управляют изменением и заимствованием. Мы рассмотрим небезопасный код в главе 19. Можно использовать типы, использующие паттерн внутренней изменяемости, когда мы можем обеспечить, чтобы правила заимствования соблюдались во время выполнения, даже если компилятор этого не гарантирует. В этом случае небезопасный код обертывается в безопасный API, и внешний тип остается неизменяемым.

Давайте узнаем, как это работает, обратившись к типу RefCell<T>, который подчиняется паттерну внутренней изменяемости.

Соблюдение правил заимствования во время выполнения с помощью RefCell<T>

В отличие от Rc<T>, тип RefCell<T> представляет одинарное владение данными, которые он содержит. Что отличает RefCell<T> от типа Box<T>? Вспомните правила заимствования, с которыми вы познакомились в главе 4: