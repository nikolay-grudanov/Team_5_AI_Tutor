---
source_image: page_173.png
page_number: 173
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 32.88
tokens: 7508
characters: 1962
timestamp: 2025-12-24T10:50:17.084805
finish_reason: stop
---

Мы также можем перебирать изменяемые ссылки на каждый элемент в изменяемом векторе для того, чтобы внести изменения во все элементы. Цикл for в листинге 8.9 прибавит по 50 в каждый элемент.

Листинг 8.9. Перебор изменяемых ссылок, указывающих на элементы в векторе
let mut v = vec![100, 32, 57];
for i in &mut v {
    *i += 50;
}

Для того чтобы изменить значение, на которое ссылается изменяемая ссылка, приходится использовать оператор разыменования (*), чтобы получить значение в i перед тем, как использовать оператор +=. Подробнее об операторе разыменования мы поговорим в разделе «Следование по указателю к значению с помощью оператора разыменования» (с. 370).

Использование перечисления для хранения нескольких типов

В начале этой главы мы говорили, что векторы хранят значения только одного типа. Это бывает неудобно. Безусловно, существуют варианты использования, в которых требуется хранить список элементов разных типов. К счастью, варианты перечисления определяются под одним и тем же типом enum, поэтому, когда нам нужно сохранить элементы другого типа в векторе, мы можем определить и использовать перечисление.

Предположим, что мы хотим получить значения из строки электронной таблицы, в которой одни столбцы в строке таблицы содержат целые числа, другие — числа с плавающей точкой, а третьи — строковые значения. Мы можем определить перечисление, варианты которого будут содержать разные типы значений, и тогда все варианты перечисления будут считаться одним и тем же типом — типом enum. Затем мы можем создать вектор, который содержит это перечисление и поэтому, в конечном счете, включает разные типы. Мы продемонстрировали это в листинге 8.10.

Листинг 8.10. Определение перечисления для хранения значений разных типов в одном векторе
enum SpreadsheetCell {
    Int(i32),
    Float(f64),
    Text(String),
}
let row = vec![
    SpreadsheetCell::Int(3),
    SpreadsheetCell::Text(String::from("синий")),
    SpreadsheetCell::Float(10.12),
];