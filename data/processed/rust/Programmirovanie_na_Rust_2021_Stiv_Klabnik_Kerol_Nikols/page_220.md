---
source_image: page_220.png
page_number: 220
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 29.99
tokens: 7481
characters: 1719
timestamp: 2025-12-24T10:51:30.740055
finish_reason: stop
---

Когда вы замечаете, что в коде несколько определений структур или перечислений отличаются только типами значений, которые они содержат, вы можете избежать повторов, используя обобщенные типы.

В определениях методов

Мы можем реализовать методы в структурах и перечислениях (как мы делали в главе 5), а также использовать обобщенные типы в их определениях. Листинг 10.9 показывает структуру Point<T>, которую мы ранее определили в листинге 10.6, с реализованным в ней методом x.

Листинг 10.9. Реализация метода х в структуре Point<T>, который будет возвращать ссылку на поле х типа Т
src/main.rs
```rust
struct Point<T> {
    x: T,
    y: T,
}

impl<T> Point<T> {
    fn x(&self) -> &T {
        &self.x
    }
}

fn main() {
    let p = Point { x: 5, y: 10 };

    println!("p.x = {}", p.x());
}
```

Здесь мы определили метод x для структуры Point<T>, который возвращает ссылку на данные в поле x.

Обратите внимание, что сразу после ключевого слова impl приходится объявлять T, в результате чего можно использовать его для уточнения, что мы реализуем методы в типе Point<T>. Благодаря объявлению T как обобщенного типа после impl, Rust будет отождествлять тип в угловых скобках в Point как обобщенный, а не конкретный. Например, мы могли бы реализовать методы только в экземплярах типа Point<f32>, а не в экземплярах типа Point<T> с любым обобщенным типом. В листинге 10.10 мы используем конкретный тип f32, то есть не объявляем никаких типов после impl.

Листинг 10.10. Блок impl, который применим только к структуре с отдельно взятым конкретным типом для параметра обобщенного типа T
```rust
impl Point<f32> {
    fn distance_from_origin(&self) -> f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}
```