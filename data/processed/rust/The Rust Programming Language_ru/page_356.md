---
source_image: page_356.png
page_number: 356
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 66.39
tokens: 11849
characters: 2337
timestamp: 2025-12-24T10:33:47.999493
finish_reason: stop
---

быть вызваны. Замыкание, которое перемещает захваченные значения из своего тела, реализует только FnOnce и ни один из других признаков Fn, потому что оно может быть вызвано только один раз.
2. FnMut применяется к замыканиям, которые не перемещают захваченные значения из своего тела, но могут изменять захваченные значения. Эти закрытия могут вызываться более одного раза.
3. Fn применяется к замыканиям, которые не перемещают захваченные значения из своего тела и не изменяют захваченные значения, а также к замыканиям, которые ничего не захватывают из своего окружения. Эти замыкания можно вызывать более одного раза без изменения окружения, что важно в таких случаях, как одновременный вызов замыкания несколько раз.

Давайте рассмотрим определение метода unwrap_or_else на Option<T>, который мы использовали в листинге 13-1:

```rust
impl<T> Option<T> {
    pub fn unwrap_or_else<F>(self, f: F) -> T
    where
        F: FnOnce() -> T
    {
        match self {
            Some(x) => x,
            None => f(),
        }
    }
}
```

Напомним, что T - это общий тип, отображающий тип значения в Some варианте Option. Этот тип T также является возвращаемым типом функции unwrap_or_else: код, вызывающий unwrap_or_else на Option<String>, например, получит String.

Далее, обратите внимание, что функция unwrap_or_else имеет дополнительный параметр общего типа F. Тип F - это тип параметра f, который является замыканием, которое мы задаём при вызове unwrap_or_else.

Ограничение, заданное для общего типа F, - это FnOnce() -> T, что означает, что F должен вызываться один раз, не принимать аргументов и возвращать T. Использование FnOnce в ограничении трейта выражает ограничение того, что unwrap_or_else будет вызывать f не более одного раза. В теле unwrap_or_else мы видим, что если Option равно Some, то f вызываться не будет. Если Option будет равен None, f будет вызван один раз. Поскольку все замыкания реализуют FnOnce, unwrap_or_else принимает самые разные виды замыканий и является настолько гибким, насколько это возможно.

Примечание: Функции также могут реализовывать все три признака Fn. Если то, что мы хотим сделать, не требует захвата значения из среды, мы можем использовать имя функции, а не замыкания, когда нам нужно что-то, реализующее один из признаков Fn. Например, для значения Option<Vec<T>> мы можем вызвать