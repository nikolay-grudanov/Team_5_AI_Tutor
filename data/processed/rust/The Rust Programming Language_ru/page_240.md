---
source_image: page_240.png
page_number: 240
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 55.25
tokens: 11655
characters: 1470
timestamp: 2025-12-24T10:28:43.888631
finish_reason: stop
---

enum Result<T, E> {
    Ok(T),
    Err(E),
}

Перечисление Result имеет два обобщённых типа T и E и два варианта: Ok, которое содержит тип T, и Err, которое содержит тип E. Такое определение позволяет использовать перечисление Result везде, где операции могут быть выполнены успешно (возвращая значение типа данных T) или неуспешно (возвращая значение типа данных E). Это то что мы делали в коде листинга 9-2, где при открытии файла заполнялись данные типа T, в примере тип std::fs::File или E тип std::io::Error при ошибке, при каких-либо проблемах открытия файла.

Когда вы в коде распознаете ситуации с несколькими структурами или определениями перечислений, которые отличаются только типами содержащих значений, вы можете избежать дублирования, используя обобщённые типы.

В определении методов

Также, как и в Главе 5, можно реализовать методы структур и перечислений с помощью обобщённых типов и их объявлений. Код листинга 10-9 демонстрирует пример добавления метода с названием x в структуру Point<T>, которую мы ранее описали в листинге 10-6.

Файл: src/main.rs

struct Point<T> {
    x: T,
    y: T,
}

impl<T> Point<T> {
    fn x(&self) -> &T {
        &self.x
    }
}

fn main() {
    let p = Point { x: 5, y: 10 };

    println!("p.x = {}", p.x());
}

Листинг 10-9. Реализация метода с именем x у структуры Point, которая будет возвращать ссылку на поле x типа T

Здесь мы определили метод с именем x у Point<T> который возвращает ссылку на данные в поле x.