---
source_image: page_140.png
page_number: 140
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 42.57
tokens: 11599
characters: 1466
timestamp: 2025-12-24T10:24:21.509018
finish_reason: stop
---

Проблема не в самой концепции, а в конкретной реализации. Таким образом, в Rust нет null-значений, но есть перечисление, которое может закодировать концепцию наличия или отсутствия значения. Это перечисление Option<T> и оно определено в стандартной библиотеке следующим образом:

```rust
let some_number = Some(5);
let some_char = Some('e');
let absent_number: Option<i32> = None;
```

Тип some_number - Option<i32>. Тип some_string - Option<&str>, это другой тип. Rust может вывести эти типы, потому что мы указали значение внутри варианта Some. Для absent_number Rust требует, чтобы мы аннотировали общий тип для Option: компилятор не может вывести тип, который будет в Some, глядя только на значение None. Здесь мы сообщаем Rust, что absent_number должен иметь тип Option<i32>.

Когда есть значение Some, мы знаем, что значение присутствует и содержится внутри Some. Когда есть значение None, это означает то же самое, что и null в некотором смысле: у нас нет действительного значения. Так почему наличие Option<T> лучше, чем null?

Вкратце, поскольку Option<T> и T (где T может быть любым типом) относятся к разным типам, компилятор не позволит нам использовать значение Option<T> даже если бы оно было определённо допустимым вариантом Some. Например, этот код не будет компилироваться, потому что он пытается добавить i8 к значению типа Option<i8>:

```rust
let x: i8 = 5;
let y: Option<i8> = Some(5);
let sum = x + y;
```

Запуск данного кода даст ошибку ниже: