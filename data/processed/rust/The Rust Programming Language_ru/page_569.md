---
source_image: page_569.png
page_number: 569
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 52.64
tokens: 11790
characters: 1873
timestamp: 2025-12-24T10:42:25.034051
finish_reason: stop
---

Продвинутые функции и замыкания

Наконец, мы рассмотрим некоторые дополнительные возможности, связанные с функциями и замыканиями, которые включают указатели на функции и возврат замыканий.

Указатели функций

Мы говорили о том, как передавать замыкания в функции; но вы также можете передавать обычные функции в функции! Эта техника полезна, когда вы хотите передать функцию, которую вы уже определили, а не объявлять новое замыкание. Указатель функции позволит использовать функции как аргументы к другим функциям. Функции приводятся (coerce) к типу fn (с нижним регистром f), не к путать с типажом замыкания Fn. Тип fn называется указателем функции. Синтаксис для указания того, что параметр является указателем функции, похож на замыкание как показано в листинге 19-27.

Файл: src/main.rs

```rust
fn add_one(x: i32) -> i32 {
    x + 1
}

fn do_twice(f: fn(i32) -> i32, arg: i32) -> i32 {
    f(arg) + f(arg)
}

fn main() {
    let answer = do_twice(add_one, 5);

    println!("The answer is: {}", answer);
}
```

Листинг 19-27: Использование типа fn для принятия указателя функции в качестве аргумента

Этот код печатает The answer is: 12. Мы указываем, что параметр вызова f для функции do_twice является fn, которая принимает один параметр типа i32 и возвращает тип i32. Затем мы можем вызвать f в теле функции do_twice. В main показано как можно передать имя функции add_one в качестве первого аргумента для функции do_twice.

В отличие от замыканий, fn является типом, а не типажом, поэтому мы указываем fn как параметр типа напрямую, а не объявляем параметр обобщённого типа с одним из типажей Fn в качестве ограничения типажа.

Указатели функций реализуют все три типажа замыканий (Fn, FnMut и FnOnce), поэтому вы всегда можете передать указатель функции в качестве аргумента функции ожидающей замыкание. Лучше всего объявлять функции, используя обобщённый тип и