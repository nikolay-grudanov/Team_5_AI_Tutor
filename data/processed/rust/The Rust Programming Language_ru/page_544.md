---
source_image: page_544.png
page_number: 544
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 70.36
tokens: 11945
characters: 2514
timestamp: 2025-12-24T10:41:37.961111
finish_reason: stop
---

Далее проверяем, что индекс `mid` находится в границах среза. Затем мы обращаемся к небезопасному коду: функция `slice::from_raw_parts_mut` принимает сырой указатель, длину и создаёт срез. Мы используем эту функцию для создания среза, начинающегося с `ptr` и имеющего длину в `mid` элементов. Затем мы вызываем метод `add` у `ptr` с `mid` в качестве аргумента, чтобы получить сырой указатель, который начинается с `mid`, и создаём срез, используя этот указатель и оставшееся количество элементов после `mid` в качестве длины.

Функция `slice::from_raw_parts_mut` небезопасна, потому что она принимает сырой указатель и должна верить, что этот указатель действителен. Метод `offset` для сырых указателях также небезопасен, поскольку он должен доверять, что местоположение после смещения также является допустимым указателем. Поэтому нам пришлось поместить `unsafe` блок вокруг вызовов `slice::from_raw_parts_mut` и `offset`, чтобы мы могли их вызвать. Посмотрев на код и добавив проверку, что `mid` должно быть меньше или равно `len`, мы можем быть уверены, что все сырые указатели, используемые в `unsafe` блоке будут действительно указателями на данные внутри среза. Это приемлемое и правильное использование `unsafe`.

Обратите внимание, что нам не нужно помечать результирующую функцию `split_at_mut` как `unsafe`, и мы можем вызвать эту функцию из безопасного Rust. Мы создали безопасную абстракцию для небезопасного кода с помощью реализации функции, которая использует код `unsafe` блока безопасным образом, поскольку она создаёт только допустимые указатели из данных, к которым эта функция имеет доступ.

Напротив, использование `slice::from_raw_parts_mut` в листинге 19-7 приведёт к вероятному сбою при использовании среза. Этот код использует произвольный адрес памяти и создаёт срез из 10000 элементов.

```rust
use std::slice;

let address = 0x01234usize;
let r = address as *mut i32;

let values: &[i32] = unsafe { slice::from_raw_parts_mut(r, 10000) };
```

Листинг 19-7: Создание среза из произвольного адреса памяти

Мы не владеем памятью в этом произвольном месте, и нет никаких гарантий что срез, создаваемый этим кодом, содержит допустимые значения `i32`. Попытка использовать переменную `slice` как будто это допустимый срез приводит к неопределенному поведению (UB - undefined behavior).

Использование `extern` функций для вызова внешнего кода

Иногда в вашем Rust коде может появиться необходимость взаимодействия с кодом, написанным на другом языке программирования. Для этой цели существует