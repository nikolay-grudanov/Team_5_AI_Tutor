---
source_image: page_617.png
page_number: 617
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 57.46
tokens: 11644
characters: 1670
timestamp: 2025-12-24T10:44:37.056723
finish_reason: stop
---

Файл: src/lib.rs

// --snip--

impl Worker {
    fn new(id: usize, receiver: Arc<Mutex<mpsc::Receiver<Job>>> ) -> Worker {
        let thread = thread::spawn(move || {
            while let Ok(job) = receiver.lock().unwrap().recv() {
                println!("Worker {id} got a job; executing.");

                job();
            }
        });
        Worker { id, thread }
    }
}

Листинг 20-22: Альтернативная реализация Worker::new с использованием while let

Этот код компилируется и запускается, но не приводит к желаемому поведению: медленный запрос всё равно приведёт к тому, что другие запросы будут ждать обработки. Причина здесь несколько тоньше: Mutex не имеет общедоступного unlock потому что право собственности на блокировку зависит от времени жизни MutexGuard<T> в LockResult<MutexGuard<T>> которое возвращает метод lock. Во время компиляции анализатор заимствований может затем применить правило, согласно которому к ресурсу, охраняемому Mutex нельзя получить доступ, если мы не удерживаем блокировку. Но эта реализация также может привести к тому, что блокировка будет удерживаться дольше, чем предполагалось, если мы не будем тщательно продумывать время жизни MutexGuard<T>.

Код в листинге 20-20, который использует let job = receiver.lock().unwrap().recv().unwrap(); работает, потому что с let любые временные значения, используемые в выражении справа от знака равенства, немедленно удаляются после завершения оператора let. Однако while let (и if let and match) не удаляет временные значения до конца связанного блока. В листинге 20-21 блокировка сохраняется на время вызова job(), что означает, что другие исполнители не могут получать задания.