---
source_image: page_354.png
page_number: 354
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 48.22
tokens: 11696
characters: 1657
timestamp: 2025-12-24T10:33:21.886813
finish_reason: stop
---

Листинг 13-5. Определение и вызов замыкания, захватывающего изменяемую ссылку

Этот код компилируется, запускается и печатает:

$ cargo run
Compiling closure-example v0.1.0 (file:///projects/closure-example)
Finished dev [unoptimized + debuginfo] target(s) in 0.43s
    Running `target/debug/closure-example`
Before defining closure: [1, 2, 3]
After calling closure: [1, 2, 3, 7]

Обратите внимание, что между определением и вызовом замыкания borrows_mutably больше нет println!: когда определяется borrows_mutably, оно захватывает мутабельную ссылку на list. После вызова замыкания мы больше не используем его, поэтому заимствование mutable заканчивается. Между определением замыкания и вызовом замыкания неизменяемое заимствование для печати недопустимо, потому что при наличии изменяемого заимствования никакие другие заимствования недопустимы. Попробуйте добавить туда println! и посмотрите, какое сообщение об ошибке вы получите!

Если вы хотите заставить замыкание взять владение значениями, которые оно использует в окружении, даже если тело замыкания не требует владения, вы можете использовать ключевое слово move перед списком параметров.

Эта техника в основном полезна при передаче замыкания новому потоку, чтобы переместить данные так, чтобы они принадлежали новому потоку. Мы подробно обсудим потоки и то, зачем их использовать, в главе 16, когда будем говорить о параллелизме, а пока давайте вкратце рассмотрим порождение нового потока с помощью замыкания, в котором используется ключевое слово move. В листинге 13-6 показан код из листинга 13-4, модифицированный для печати вектора в новом потоке, а не в основном потоке:

Файл : src/main.rs