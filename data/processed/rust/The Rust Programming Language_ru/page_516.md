---
source_image: page_516.png
page_number: 516
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 61.74
tokens: 11901
characters: 2468
timestamp: 2025-12-24T10:40:21.880682
finish_reason: stop
---

Возможность опровержения: может ли шаблон не совпадать

Шаблоны бывают двух форм: опровержимые и неопровержимые. Шаблоны, которые будут соответствовать любому возможному переданному значению, являются неопровержимыми (irrefutable). Примером может быть x в выражении let x = 5; , потому что x соответствует чему-либо и следовательно не может не совпадать.
Шаблоны, которые могут не соответствовать некоторому возможному значению, являются опровержимыми (refutable). Примером может быть Some(x) в выражении if let Some(x) = a_value , потому что если значение в переменной a_value равно None , а не Some , то шаблон Some(x) не будет совпадать.

Параметры функций, операторы let и for могут принимать только неопровержимые шаблоны, поскольку программа не может сделать ничего значимого, если значения не совпадают. А выражения if let и while let принимают опровержимые и неопровержимые шаблоны, но компилятор предостерегает от неопровержимых шаблонов, поскольку по определению они предназначены для обработки возможного сбоя: функциональность условного выражения заключается в его способности выполнять разный код в зависимости от успеха или неудачи.

В общем случае, вам не нужно беспокоиться о разнице между опровержимыми (refutable) и неопровержимыми (irrefutable) образцами; тем не менее, вам необходимо ознакомиться с концепцией возможности опровержения, чтобы вы могли отреагировать на неё, увидев в сообщении об ошибке. В таких случаях вам потребуется изменить либо шаблон, либо конструкцию с которой вы используете шаблон в зависимости от предполагаемого поведения кода.

Давайте посмотрим на пример того, что происходит, когда мы пытаемся использовать опровержимый (refutable) шаблон, где Rust требует неопровержимый шаблон и наоборот. В листинге 18-8 показан оператор let , но для образца мы указали Some(x) являющийся шаблоном, который можно опровергнуть. Как и следовало ожидать, этот код не будет компилироваться.

let Some(x) = some_option_value;

Листинг 18-8: Попытка использовать опровержимый шаблон вместе с let

Если some_option_value было бы значением None , то оно не соответствовало бы шаблону Some(x) , что означает, что шаблон является опровержимым. Тем не менее, оператор let может принимать только неопровержимый шаблон, потому что нет корректного кода, который может что-то сделать со значением None . Во время компиляции Rust будет жаловаться на то, что мы пытались использовать опровержимый шаблон для которого требуется неопровержимый шаблон: