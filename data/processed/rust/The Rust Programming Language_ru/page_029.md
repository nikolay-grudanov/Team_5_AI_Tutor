---
source_image: page_029.png
page_number: 29
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 64.70
tokens: 11797
characters: 2178
timestamp: 2025-12-24T10:20:09.853195
finish_reason: stop
---

означает, что операция не удалась, а `Err` содержит информацию о том, как и почему операция не удалась.

Значения типа `Result`, как и значения любого типа, имеют определённые для них методы. Экземпляр `Result` имеет `expect` метод, который можно вызвать. Если этот экземпляр `Result` является значением `Err`, `expect` вызовет сбой программы и отобразит сообщение, которое вы передали в качестве аргумента. Если метод `read_line` возвращает `Err`, это, скорее всего, результат ошибки базовой операционной системы. Если экземпляр `Result` является значением `Ok`, `expect` возьмёт возвращаемое значение, которое `Ok` удерживает, и вернёт вам только это значение, чтобы вы могли его использовать. В данном случае это значение представляет собой количество байтов, введённых пользователем.

Если не вызвать `expect`, программа скомпилируется, но будет получено предупреждение:

```sh
$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
warning: unused `Result` that must be used
 --> src/main.rs:10:5
10 |     io::stdin().read_line(&mut guess);
   |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
= note: `#[warn(unused_must_use)]` on by default
= note: this `Result` may be an `Err` variant, which should be handled

warning: `guessing_game` (bin "guessing_game") generated 1 warning
    Finished dev [unoptimized + debuginfo] target(s) in 0.59s
```

Rust предупреждает о не использовании значения `Result`, возвращаемого из `read_line`, показывая, что программа не учла возможность возникновения ошибки.

Правильный способ убрать предупреждение - это написать обработку ошибок, но в нашем случае мы просто хотим аварийно завершить программу при возникновении проблемы, поэтому используем `expect`. О способах восстановления после ошибок вы узнаете в главе 9.

Напечатать значений с помощью заполнителей `println!`

Кроме закрывающей фигурной скобки, в коде на данный момент есть ещё только одна строка для обсуждения:

```rust
println!("You guessed: {guess}");
```

Эта строка печатает строку, которая теперь содержит ввод пользователя. Набор фигурных скобок `{}` является заполнителем: думайте о `{}` как о маленьких крабовых