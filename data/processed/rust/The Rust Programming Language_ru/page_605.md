---
source_image: page_605.png
page_number: 605
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 55.23
tokens: 11730
characters: 1764
timestamp: 2025-12-24T10:44:04.089973
finish_reason: stop
---

Опять же, это самая простая реализация метода `execute`: она ничего не делает, мы только пытаемся сделать код компилируемым. Давайте проверим снова:

```sh
$ cargo check
    Checking hello v0.1.0 (file:///projects/hello)
    Finished dev [unoptimized + debuginfo] target(s) in 0.24s
```

Сейчас мы получаем только предупреждения, что означает, что код компилируется! Но обратите внимание, если вы попробуете `cargo run` и сделаете запрос в браузере, вы увидите ошибки в браузере, которые мы видели в начале главы. Наша библиотека на самом деле ещё не вызывает замыкание, переданное в `execute`!

Примечание: вы возможно слышали высказывание о языках со строгими компиляторами, таких как Haskell и Rust, которое звучит так: «Если код компилируется, то он работает». Но это высказывание не всегда верно. Наш проект компилируется, но абсолютно ничего не делает! Если бы мы создавали реальный, законченный проект, это был бы хороший момент начать писать модульные тесты, чтобы проверять, что код компилируется и имеет желаемое поведение.

Проверка количества потоков в `new`

Мы продолжим получать предупреждения, потому что мы ничего не делаем с параметрами для `new` и `execute`. Давайте реализуем тела этих функций в соответствии с желаемым поведением. Для начала давайте подумаем о `new`. Ранее мы выбирали без знаковый тип для параметра `size`, потому что пул с отрицательным числом потоков не имеет смысла. Тем не менее, пул с нулевым значением для потоков также не имеет смысла, но ноль является совершенно корректным для типа `usize`. Мы добавим код, чтобы проверить, что `size` больше нуля, перед возвращением экземпляра `ThreadPool` и будем паниковать, если программа получит ноль, используя макрос `assert!`, как показано в листинге 20-13.

Файл: src/lib.rs