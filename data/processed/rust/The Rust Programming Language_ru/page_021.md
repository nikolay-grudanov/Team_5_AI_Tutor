---
source_image: page_021.png
page_number: 21
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 81.67
tokens: 11822
characters: 2282
timestamp: 2025-12-24T10:19:37.346747
finish_reason: stop
---

Использование `cargo run` более удобно, чем необходимость помнить и запускать `cargo build`, а затем использовать весь путь к бинарному файлу, поэтому большинство разработчиков используют `cargo run`.

Обратите внимание, что на этот раз мы не видели вывода, указывающего на то, что Cargo компилирует `hello_cargo`. Cargo выяснил, что файлы не изменились, поэтому не стал пересобирать, а просто запустил бинарный файл. Если бы вы изменили свой исходный код, Cargo пересобирал бы проект перед его запуском, и вы бы увидели этот вывод:

```
$ cargo run
Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
Finished dev [unoptimized + debuginfo] target(s) in 0.33 secs
    Running `target/debug/hello_cargo`
Hello, world!
```

Cargo также предоставляет команду, называемую `cargo check`. Эта команда быстро проверяет ваш код, чтобы убедиться, что он компилируется, но не создаёт исполняемый файл:

```
$ cargo check
Checking hello_cargo v0.1.0 (file:///projects/hello_cargo)
Finished dev [unoptimized + debuginfo] target(s) in 0.32 secs
```

Почему вам не нужен исполняемый файл? Часто `cargo check` выполняется намного быстрее, чем `cargo build`, поскольку пропускает этап создания исполняемого файла. Если вы постоянно проверяете свою работу во время написания кода, использование `cargo check` ускорит процесс информирования вас о том, что ваш проект всё ещё компилируется! Таким образом, многие Rustacean периодически запускают `cargo check`, когда пишут свои программы, чтобы убедиться, что она компилируется. Затем они запускают `cargo build`, когда готовы использовать исполняемый файл.

Давайте подытожим, что мы уже узнали о Cargo:

• Мы можем создать проект с помощью `cargo new`.
• можно собирать проект, используя команду `cargo build`,
• можно одновременно собирать и запускать проект одной командой `cargo run`,
• можно собрать проект для проверки ошибок с помощью `cargo check`, не тратя время на кодогенерацию исполняемого файла,
• cargo сохраняет результаты сборки не в директорию с исходным кодом, а в отдельный каталог `target/debug`.

Дополнительным преимуществом использования Cargo является то, что его команды одинаковы для разных операционных систем. С этой точки зрения, мы больше не будем предоставлять отдельные инструкции для Linux, macOS или Windows.