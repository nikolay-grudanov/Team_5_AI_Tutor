---
source_image: page_409.png
page_number: 409
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 47.61
tokens: 11725
characters: 1734
timestamp: 2025-12-24T10:35:35.863963
finish_reason: stop
---

В данном предложении "перенаправление" означает, что вместо того, чтобы непосредственно хранить само значение, мы должны изменить структуру данных, так чтобы хранить его косвенно - хранить указатель на это значение.

Поскольку `Box<T>` является указателем, Rust всегда знает, сколько места нужно `Box<T>`: размер указателя не меняется в зависимости от объёма данных, на которые он указывает. Это означает, что мы можем поместить `Box<T>` внутрь экземпляра `Cons` вместо значения `List` напрямую. `Box<T>` будет указывать на значение очередного `List`, который будет находиться в куче, а не внутри экземпляра `Cons`. Концептуально у нас все ещё есть список, созданный из списков, содержащих другие списки, но эта реализация теперь больше похожа на размещение элементов рядом друг с другом, а не внутри друг друга.

Мы можем изменить определение перечисления `List` в листинге 15-2 и использование `List` в листинге 15-3 на код из листинга 15-5, который будет компилироваться:

Файл: src/main.rs

```rust
enum List {
    Cons(i32, Box<List>),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil))))));
}
```

Листинг 15-5: Определение `List`, которое использует `Box<T>` для того, чтобы иметь вычисляемый размер

`Cons` требуется объём `i32` плюс место для хранения данных указателя box. `Nil` не хранит никаких значений, поэтому ему нужно меньше места, чем `Cons`. Теперь мы знаем, что любое значение `List` займёт размер `i32` плюс размер данных указателя box. Используя box, мы разорвали бесконечную рекурсивную цепочку, поэтому компилятор может определить размер, необходимый для хранения значения `List`. На рисунке 15-2 показано, как теперь выглядит `Cons`.