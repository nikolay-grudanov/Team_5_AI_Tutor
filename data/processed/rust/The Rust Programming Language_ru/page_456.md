---
source_image: page_456.png
page_number: 456
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 56.70
tokens: 11726
characters: 1764
timestamp: 2025-12-24T10:37:47.283799
finish_reason: stop
---

Код в листинге 16-1 преждевременно останавливает порождённый поток в большинстве случаев, из-за завершения основного потока. Более того, так как порядок выполнения потоков чётко не определён, этот код не даёт гарантии, что порождённый поток вообще начнёт исполняться!

Мы можем исправить проблему, когда созданный поток не запускается или завершается преждевременно, сохранив возвращаемое значение `thread::spawn` в какой-либо переменной. Тип возвращаемого значения `thread::spawn` — `JoinHandle`. `JoinHandle` — это владеющее значение, которое, при вызове метода `join`, будет ждать завершения своего потока. Листинг 16-2 демонстрирует, как использовать `JoinHandle` потока, созданного в листинге 16-1, и вызывать функцию `join`, для того, чтобы убедиться, что порождённый поток завершится раньше, чем поток `main`:

Файл: src/main.rs

```rust
use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!("hi number {} from the spawned thread!", i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!("hi number {} from the main thread!", i);
        thread::sleep(Duration::from_millis(1));
    }

    handle.join().unwrap();
}
```

Листинг 16-2. Сохранение значения `JoinHandle` потока `thread::spawn`, гарантирующее, что поток выполнит всю необходимую работу, перед тем, как завершится

Вызов `join` у дескриптора блокирует текущий поток, пока поток, представленный дескриптором не завершится. Блокировка потока означает, что потоку запрещено выполнять работу или выходить из него. Поскольку мы поместили вызов `join` после цикла `for` основного потока, выполнение листинга 16-2 должно привести к выводу, подобному следующему: