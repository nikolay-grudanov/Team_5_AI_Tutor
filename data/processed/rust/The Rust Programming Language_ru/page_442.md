---
source_image: page_442.png
page_number: 442
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 51.04
tokens: 11731
characters: 1743
timestamp: 2025-12-24T10:37:06.107441
finish_reason: stop
---

Ссылочные зациклывания могут приводить к утечке памяти

Гарантии безопасности памяти в Rust затрудняют, но не делают невозможным случайное выделение памяти, которое никогда не очищается (известное как утечка памяти ). Полное предотвращение утечек памяти не является одной из гарантий Rust, а это означает, что утечки памяти безопасны в Rust. Мы видим, что Rust допускает утечку памяти с помощью `Rc<T>` и `RefCell<T>`: можно создавать ссылки, в которых элементы ссылаются друг на друга в цикле. Это создаёт утечки памяти, потому что счётчик ссылок каждого элемента в цикле никогда не достигнет 0, а значения никогда не будут удалены.

Создание ссылочного зациклывания

Давайте посмотрим, как может произойти ситуация ссылочного зациклывания и как её предотвратить, начиная с определения перечисления `List` и метода `tail` в листинге 15-25:

Файл : src/main.rs

```rust
use crate::List::{Cons, Nil};
use std::cell::RefCell;
use std::rc::Rc;

#[derive(Debug)]
enum List {
    Cons(i32, RefCell<Rc<List>>),
    Nil,
}

impl List {
    fn tail(&self) -> Option<&RefCell<Rc<List>>> {
        match self {
            Cons(_, item) => Some(item),
            Nil => None,
        }
    }
}

fn main() {}
```

Листинг 15-25: Объявление cons list, который содержит `RefCell<T>`, чтобы мы могли изменять то, на что ссылается экземпляр `Cons`

Мы используем другую вариацию определения `List` из листинга 15-5. Второй элемент в варианте `Cons` теперь `RefCell<Rc<List>>`, что означает, что вместо возможности менять значение `i32`, как мы делали в листинге 15-24, мы хотим менять значение `List`, на которое указывает вариант `Cons`. Мы также добавляем метод `tail`, чтобы нам было удобно обращаться ко второму элементу, если у нас есть вариант `Cons`.