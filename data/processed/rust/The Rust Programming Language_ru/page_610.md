---
source_image: page_610.png
page_number: 610
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 63.95
tokens: 11673
characters: 1675
timestamp: 2025-12-24T10:44:23.842491
finish_reason: stop
---

замыкание, которое мы получаем в методе `execute`. Давайте взглянем на то, как это сделать.

Отправка запросов в потоки через каналы

Теперь мы рассмотрим проблему, заключающуюся в том, что замыкания переданные в `thread::spawn` абсолютно ничего не делают. Вот мы получаем замыкание, которое хотим выполнить в методе `execute`. Но для запуска нам необходимо передать замыкание в метод `thread::spawn`, где на каждый `ThreadPool` создаётся один `Worker`.

Мы хотим, чтобы только что созданные структуры `Worker` извлекали код для запуска из очереди хранящейся в `ThreadPool` и отправляли этот код в свой поток для выполнения.

В главе 16 вы узнали о каналах (channels) - простом способе связи между двумя потоками, который идеально подойдёт для этого сценария. Мы будем использовать канал в качестве очереди заданий, а команда `execute` отправит задание из `ThreadPool` экземплярам `Worker`, который отправит задание в свой поток. Вот план:

1. `ThreadPool` создаст канал и будет удерживать его передающую сторону.
2. Каждый `Worker` будет удерживать принимающую сторону канала.
3. Мы создадим новую структуру `Job` которая будет содержать замыкания, которые мы хотим отправить в канал.
4. Метод `execute` отправит задание, которое он хочет выполнить, в отправляющую сторону канала.
5. В своём потоке `Worker` будет выполнять цикл с принимающей стороной канала и выполнит замыкание любого получаемого задания.

Давайте начнём с создания канала в `ThreadPool::new` и удержания отправляющей стороны в экземпляре `ThreadPool`, как показано в листинге 20-16. В структуре `Job` сейчас ничего не содержится, но это будет тип элемента который мы отправляем в канал.

Файл: src/lib.rs