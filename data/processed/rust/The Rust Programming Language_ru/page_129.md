---
source_image: page_129.png
page_number: 129
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 54.53
tokens: 11690
characters: 1713
timestamp: 2025-12-24T10:24:05.873054
finish_reason: stop
---

Вот как это работает: когда вы вызываете метод `object.something()`, Rust автоматически добавляет `&`, `&mut` или `*`, таким образом, чтобы `object` соответствовал сигнатуре метода. Другими словами, это то же самое:

```rust
p1.distance(&p2);
(&p1).distance(&p2);
```

Первый пример выглядит намного понятнее. Автоматический вывод ссылки работает потому, что методы имеют понятного получателя - тип `self`. Учитывая получателя и имя метода, Rust может точно определить, что в данном случае делает код: читает ли метод (`&self`), делает ли изменение (`&mut self`) или поглощает (`self`). Тот факт, что Rust делает заимствование неявным для принимающего метода, в значительной степени способствует тому, чтобы сделать владение эргономичным на практике.

Методы с несколькими параметрами

Давайте попрактикуемся в использовании методов, реализовав второй метод в структуре `Rectangle`. На этот раз мы хотим, чтобы экземпляр `Rectangle` брал другой экземпляр `Rectangle` и возвращал `true`, если второй `Rectangle` может полностью поместиться внутри `self` (первый `Rectangle`); в противном случае он должен вернуть `false`. То есть, как только мы определим метод `can_hold`, мы хотим иметь возможность написать программу, показанную в Листинге 5-14.

Файл: src/main.rs

```rust
fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };
    let rect2 = Rectangle {
        width: 10,
        height: 40,
    };
    let rect3 = Rectangle {
        width: 60,
        height: 45,
    };

    println!("Can rect1 hold rect2? {}", rect1.can_hold(&rect2));
    println!("Can rect1 hold rect3? {}", rect1.can_hold(&rect3));
}
```

Листинг 5-14: Использование ещё не написанного метода `can_hold`