---
source_image: page_567.png
page_number: 567
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 78.97
tokens: 11988
characters: 2773
timestamp: 2025-12-24T10:42:39.860241
finish_reason: stop
---

Динамические типы и Sized типаж

В связи с необходимостью Rust знать определённые детали, например, сколько места выделять для значения определённого типа, то существует краеугольный камень его системы типов, который может сбивать с толку. Это концепция динамических типов (dynamically sized types). Иногда она упоминается как DST или безразмерные типы (unsized types), эти типы позволяют писать код, используя значения, чей размер известен только во время выполнения.

Давайте углубимся в детали динамического типа str, который мы использовали на протяжении всей книги. Все верно, не типа &str, а типа str самого по себе, который является DST. Мы не можем знать, какой длины строка до момента времени выполнения, то есть мы не можем создать переменную типа str и не можем принять аргумент типа str. Рассмотрим следующий код, который не работает:

```rust
let s1: str = "Hello there!";
let s2: str = "How's it going?";
```

Rust должен знать, сколько памяти выделить для любого значения конкретного типа и все значения типа должны использовать одинаковый объем памяти. Если Rust позволил бы нам написать такой код, то эти два значения str должны были бы занимать одинаковое количество памяти. Но они имеют разную длину: s1 нужно 12 байтов памяти, а для s2 нужно 15. Вот почему невозможно создать переменную имеющую динамический тип.

Так что же нам делать? В этом случае вы уже знаете ответ: мы делаем типы s1 и s2 в виде типа &str, а не str. Напомним, что в разделе "Строковые срезы" главы 4, мы сказали, что структура данных срез хранит начальную позицию и длину среза.

Таким образом, хотя &T является единственным значением, которое хранит адрес памяти где находится тип T, тип &str является двумя значениями: адресом str и его длиной. Таким образом, мы можем знать размер значения &str во время компиляции: это двойная длина от типа usize. То есть мы всегда знаем размер &str, неважно какой длины является строка на которую она ссылается. В общем, это способ которым в Rust используются динамические типы: у них есть дополнительные метаданные в которых хранится размер динамической информации. Золотое правило динамических типов в том, что мы всегда должны ставить значения динамических типов позади некоторого указателя.

Можно комбинировать str со всеми видами указателей: например, Box<str> или Rc<str>. На самом деле, вы видели это раньше, но с другим динамическим типом: типажом. Каждый типаж является динамическим типом к которому можно обратиться используя имя типажа. В разделе "Использование объектов-типажей, которые разрешают использовать разные значения типов" главы 17, мы упоминали, что для использования типажей в качестве объектов-типажей мы должны поместить их за указателем, например &dyn Trait или Box<dyn Trait> (Rc<dyn Trait> тоже будет работать).