---
source_image: page_581.png
page_number: 581
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 57.02
tokens: 11807
characters: 2126
timestamp: 2025-12-24T10:43:03.812108
finish_reason: stop
---

Rust. Листинг 19-32 показывает соответствующие части структуры `DeriveInput`, которые мы получаем при разборе строки `struct Pancakes;`:

```rust
DeriveInput {
    // --snip--
    ident: Ident {
        ident: "Pancakes",
        span: #0 bytes(95..103)
    },
    data: Struct(
        DataStruct {
            struct_token: Struct,
            fields: Unit,
            semi_token: Some(
                Semi
            )
        }
    )
}
```

Листинг 19-32: Экземпляр `DeriveInput` получаемый, когда разбирается код имеющий атрибут макроса из Листинга 19-30

Поля этой структуры показывают, что код Rust, который мы разобрали, является блок структуры с `ident` (идентификатором, означающим имя) для `Pancakes`. Есть больше полей в этой структуре для описания всех видов кода Rust; проверьте документацию `syn` о структуре `DeriveInput` для получения дополнительной информации.

Вскоре мы определим функцию `impl_hello_macro`, в которой построим новый, дополнительный код Rust. Но прежде чем мы это сделаем, обратите внимание, что выводом для нашего выводимого (derive) макроса также является `TokenStream`. Возвращаемый `TokenStream` добавляется в код, написанный пользователями макроса, поэтому, когда они соберут свой крейт, они получат дополнительную функциональность, которую мы предоставляем в изменённом `TokenStream`.

Возможно, вы заметили, что мы вызываем `unwrap` чтобы выполнить панику в функции `hello_macro_derive`, если вызов функции `syn::parse` потерпит неудачу. Наш процедурный макрос должен паниковать при ошибках, потому что функции `proc_macro_derive` должны возвращать `TokenStream`, а не тип `Result` для соответствия API процедурного макроса. Мы упростили этот пример с помощью `unwrap`, но в рабочем коде вы должны предоставить более конкретные сообщения об ошибках, если что-то пошло не правильно, используя `panic!` или `expect`.

Теперь, когда у нас есть код для преобразования аннотированного Rust кода из `TokenStream` в экземпляр `DeriveInput`, давайте сгенерируем код реализующий типаж `HelloMacro` у аннотированного типа, как показано в листинге 19-33.

Файл: hello_macro_derive/src/lib.rs