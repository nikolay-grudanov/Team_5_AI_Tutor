---
source_image: page_573.png
page_number: 573
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 64.44
tokens: 11887
characters: 2381
timestamp: 2025-12-24T10:42:45.005240
finish_reason: stop
---

Макросы

Мы использовали макросы, такие как `println!` на протяжении всей этой книги, но мы не изучили полностью, что такое макрос и как он работает. Термин макрос относится к семейству возможностей в Rust. Это декларативные (declarative) макросы с помощью `macro_rules!` и три вида процедурных (procedural) макросов:

• Пользовательские (выводимые) #[derive] макросы, которые указывают код добавленный с помощью derive атрибута, используемые для структур и перечислений
• Макросы подобные атрибутам (attribute-like), которые определяют настраиваемые атрибуты, используемые для любого элемента языка
• Функционально подобные (function-like) макросы, которые выглядят как вызовы функций, но работают с TokenStream

Мы поговорим о каждом из них по очереди, но сначала давайте рассмотрим, зачем вообще нужны макросы, если есть функции.

Разница между макросами и функциями

По сути, макросы являются способом написания кода, который записывает другой код, что известно как мета программирование. В приложении C мы обсуждаем атрибут derive, который генерирует за вас реализацию различных типажей. Вы также использовали макросы `println!` и `vec!` в книге. Все эти макросы раскрываются для генерации большего количества кода, чем исходный код написанный вами вручную.

Мета программирование полезно для уменьшения объёма кода, который вы должны написать и поддерживать, что также является одним из предназначений функций. Однако макросы имеют некоторые дополнительные возможности, которых функции не имеют.

Сигнатура функции должна объявлять некоторое количество и тип этих параметров имеющихся у функции. Макросы, с другой стороны, могут принимать переменное число параметров: мы можем вызвать `println!("hello")` с одним аргументом или `println!("hello {}", name)` с двумя аргументами. Также макросы раскрываются до того как компилятор интерпретирует смысл кода, поэтому макрос может, например, реализовать типаж заданного типа. Функция этого не может, потому что она вызывается во время выполнения и типаж должен быть реализован во время компиляции.

Обратной стороной реализации макроса вместо функции является то, что определения макросов являются более сложными, чем определения функций, потому что вы создаёте Rust код, который записывает другой Rust код. Из-за этой косвенности, объявления макросов, как правило, труднее читать, понимать и поддерживать, чем объявления функций.