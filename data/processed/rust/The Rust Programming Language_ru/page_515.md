---
source_image: page_515.png
page_number: 515
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 49.93
tokens: 11684
characters: 1551
timestamp: 2025-12-24T10:40:01.257077
finish_reason: stop
---

решить проблему, сделав типы совпадающими, удалив некоторые переменные таким образом, чтобы число переменных равнялось числу элементов в кортеже.

Параметры функции

Параметры функции также могут быть образцами. Код в листинге 18-6 объявляет функцию с именем foo, которая принимает один параметр с именем x типа i32, к настоящему времени это должно выглядеть знакомым.

fn foo(x: i32) {
    // code goes here
}

Листинг 18-6: Сигнатура функции использует образцы в параметрах

x это часть шаблона! Как и в случае с let, мы можем сопоставить кортеж в аргументах функции с образцом. Листинг 18-7 разделяет значения в кортеже при его передачи в функцию.

Файл: src/main.rs

fn print_coordinates(&(x, y): &(i32, i32)) {
    println!("Current location: ({}, {})", x, y);
}

fn main() {
    let point = (3, 5);
    print_coordinates(&point);
}

Листинг 18-7: Функция с параметрами, которая разрушает кортеж

Этот код печатает текущие координаты: (3, 5). Значения & (3, 5) соответствуют образцу &(x, y), поэтому x - это значение 3, а y - это значение 5.

Добавляя к вышесказанному, мы можем использовать шаблоны в списках параметров замыкания таким же образом, как и в списках параметров функции, потому что, как обсуждалось в главе 13, замыкания похожи на функции.

На данный момент вы видели несколько способов использования шаблонов, но шаблоны работают не одинаково во всех местах, где их можно использовать. В некоторых местах шаблоны должны быть неопровержимыми; в других обстоятельствах они могут быть опровергнуты. Мы обсудим эти две концепции далее.