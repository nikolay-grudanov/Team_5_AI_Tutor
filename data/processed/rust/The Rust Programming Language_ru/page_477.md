---
source_image: page_477.png
page_number: 477
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 45.95
tokens: 11572
characters: 1305
timestamp: 2025-12-24T10:38:24.411659
finish_reason: stop
---

обеспечивает внутреннюю изменяемость, также как и семейство `Cell` типов. Мы использовали `RefCell<T>` в главе 15, чтобы получить возможность изменять содержимое внутри `Rc<T>`, теперь аналогичным образом мы используем `Mutex<T>` для изменения содержимого внутри `Arc<T>`.

Ещё одна деталь, на которую стоит обратить внимание: Rust не может защитить вас от всевозможных логических ошибок при использовании `Mutex<T>`. Вспомните в главе 15, что использование `Rc<T>` сопряжено с риском создания ссылочной зациклённости, где два значения `Rc<T>` ссылаются друг на друга, что приводит к утечкам памяти.
Аналогичным образом, `Mutex<T>` сопряжён с риском создания взаимных блокировок (deadlocks). Это происходит, когда операции необходимо заблокировать два ресурса и каждый из двух потоков получил одну из блокировок, заставляя оба потока ждать друг друга вечно. Если вам интересна тема взаимных блокировок, попробуйте создать программу Rust, которая её содержит; затем исследуйте стратегии устранения взаимных блокировок для мьютексов на любом языке и попробуйте реализовать их в Rust.
Документация стандартной библиотеки для `Mutex<T>` и `MutexGuard` предлагает полезную информацию.

Мы завершим эту главу, рассказав о типажах `Send` и `Sync` и о том, как мы можем использовать их с пользовательскими типами.