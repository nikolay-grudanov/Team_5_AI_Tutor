---
source_image: page_576.png
page_number: 576
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 62.35
tokens: 11892
characters: 2287
timestamp: 2025-12-24T10:42:50.597461
finish_reason: stop
---

Запятая, следующая за `$()` указывает на то, что буквенный символ-разделитель запятой может дополнительно появиться после кода, который соответствует коду в `$()`.
Звёздочка `*` указывает, что шаблон соответствует ноль или больше раз тому, что предшествует `*`.

Когда вызывается этот макрос с помощью `vec![1, 2, 3];` шаблон `$x` соответствует три раза всем трём выражениям `1`, `2` и `3`.

Теперь давайте посмотрим на шаблон в теле кода, связанного с этой ветвью:
`temp_vec.push()` внутри `$(())*` генерируется для каждой части, которая соответствует символу `$()` в шаблоне ноль или более раз в зависимости от того, сколько раз шаблон сопоставлен. Символ `$x` заменяется на каждое совпадающее выражение. Когда мы вызываем этот макрос с `vec![1, 2, 3];`, сгенерированный код, заменяющий этот вызов макроса будет следующим:

```rust
{
    let mut temp_vec = Vec::new();
    temp_vec.push(1);
    temp_vec.push(2);
    temp_vec.push(3);
    temp_vec
}
```

Мы определили макрос, который может принимать любое количество аргументов любого типа и может генерировать код для создания вектора, содержащего указанные элементы.

Есть несколько странных краевых случаев у макроса `macro_rules!`. В будущем у Rust будет второй вид декларативного макроса, который будет работать аналогичным образом, но поправит некоторые из этих краевых случаев. После этого обновления `macro_rules!` будет фактически устаревшим. Имея это в виду, а также тот факт, что большинство Rust программистов будут использовать макросы больше, чем сами писать макросы, мы далее не будем обсуждать `macro_rules!`. Чтобы узнать больше о том, как писать макросы, обратитесь к электронной документации или другим ресурсам, таким как “The Little Book of Rust Macros”.

Процедурные макросы для генерации кода из атрибутов

Вторая форма макросов - это процедурные макросы (procedural macros), которые действуют как функции (и являются типом процедуры). Процедурные макросы принимают некоторый код в качестве входных данных, работают над этим кодом и создают некоторый код в качестве вывода, а не выполняют сопоставления с шаблонами и замену кода другим кодом, как это делают декларативные макросы.

Все три вида процедурных макросов (пользовательские выводимые, похожие на атрибуты и похожие на функции) все работают аналогично.