---
source_image: page_052.png
page_number: 52
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 98.81
tokens: 12167
characters: 2624
timestamp: 2025-12-24T10:21:34.813288
finish_reason: stop
---

встроенные целочисленные типы в Rust. Мы можем использовать любой из этих вариантов для объявления типа целочисленного значения.

Таблица 3-1: целочисленные типы в Rust

<table>
  <tr>
    <th>Длина</th>
    <th>Со знаком</th>
    <th>Без знака</th>
  </tr>
  <tr>
    <td>8 бит</td>
    <td>i8</td>
    <td>u8</td>
  </tr>
  <tr>
    <td>16-bit</td>
    <td>i16</td>
    <td>u16</td>
  </tr>
  <tr>
    <td>32 бит</td>
    <td>i32</td>
    <td>u32</td>
  </tr>
  <tr>
    <td>64 бит</td>
    <td>i64</td>
    <td>u64</td>
  </tr>
  <tr>
    <td>128-bit</td>
    <td>i128</td>
    <td>u128</td>
  </tr>
  <tr>
    <td>arch</td>
    <td>isize</td>
    <td>usize</td>
  </tr>
</table>

Каждый вариант может быть как со знаком, так и без знака и имеет явный размер. Такая характеристика типа как знаковый и беззнаковый определяет возможность числа быть отрицательным. Другими словами, должно ли число иметь знак (знаковое) или оно всегда будет только положительным и, следовательно, может быть представлено без знака (беззнаковое). Это похоже на написание чисел на бумаге: когда знак имеет значение, число отображается со знаком плюс или со знаком минус; однако, когда можно с уверенностью предположить, что число положительное, оно отображается без знака. Числа со знаком хранятся с использованием дополнительного кода.

Каждый вариант со знаком может хранить числа от -(2^n - 1) до 2^n - 1 включительно, где n — количество битов, которые использует этот вариант. Таким образом, i8 может хранить числа от -(2^7) до 2^7 - 1, что равно значениям от -128 до 127. Варианты без знака могут хранить числа от 0 до 2^n - 1, поэтому u8 может хранить числа от 0 до 2^8 - 1, что равно значениям от 0 до 255.

Кроме того, isize и usize зависят от архитектуры компьютера, на котором запускается ваша программа, что отражено в таблице как «arch»: 64-битный, если вы используете 64-битную архитектуру, и 32-битный, если вы на 32-битной архитектуре.

Целочисленные литералы можно записывать в любой из форм, показанных в таблице 3-2. Обратите внимание, что числовые литералы, которые могут быть несколькими числовыми типами, позволяют использовать суффикс типа, например 57u8, для обозначения типа. Числовые литералы также могут использовать _ в качестве визуального разделителя, чтобы число было легче читать, например 1_000, которое будет иметь то же значение, как если бы вы указали 1000.

Таблица 3-2: Целочисленные литералы в Rust

<table>
  <tr>
    <th>Числовые литералы</th>
    <th>Пример</th>
  </tr>
  <tr>
    <td>Десятичный</td>
    <td>98_222</td>
  </tr>
  <tr>
    <td>Шестнадцатеричный</td>
    <td>0xff</td>
  </tr>
</table>