---
source_image: page_473.png
page_number: 473
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 75.72
tokens: 11931
characters: 2389
timestamp: 2025-12-24T10:38:44.971350
finish_reason: stop
---

Мы создаём переменную-счётчик `counter` для хранения `i32` значения внутри `Mutex<T>`, как мы это делали в листинге 16-12. Затем мы создаём 10 потоков, перебирая диапазон чисел. Мы используем `thread::spawn` и передаём всем этим потокам одинаковое замыкание, которое перемещает счётчик в поток, запрашивает блокировку на `Mutex<T>`, вызывая метод `lock`, а затем добавляет 1 к значению в мьютексе. Когда поток завершит выполнение своего замыкания, `num` выйдет из области видимости и освободит блокировку, чтобы её мог получить другой поток.

В основном потоке мы собираем все дескрипторы в переменную handles. Затем, как мы это делали в листинге 16-2, вызываем `join` для каждого дескриптора, чтобы убедиться в завершении всех потоков. В этот момент основной поток получит доступ к блокировке и тоже напечатает результат программы.

Компилятор намекнул, что этот пример не компилируется. Давайте выясним почему!

```sh
$ cargo run
Compiling shared-state v0.1.0 (file:///projects/shared-state)
error[E0382]: use of moved value: `counter`
 --> src/main.rs:9:36
  |
5 |     let counter = Mutex::new(0);
  |         ------ move occurs because `counter` has type `Mutex<i32>`, which does not implement the `Copy` trait
...
9 |     let handle = thread::spawn(move || {
  |                        ^^^^^^^^ value moved into closure here, in previous iteration of loop
10 |         let mut num = counter.lock().unwrap();
  |         ------ use occurs due to use in closure

For more information about this error, try `rustc --explain E0382`.
error: could not compile `shared-state` due to previous error
```

Сообщение об ошибке указывает, что значение `counter` было перемещено в замыкание на предыдущей итерации цикла. Rust говорит нам, что мы не можем передать во владение нескольким потокам. Давайте исправим ошибку компилятора с помощью метода множественного владения, который мы обсуждали в главе 15.

Множественное владение между множеством потоков

В главе 15 мы давали значение нескольким владельцам, используя умный указатель `Rc<T>` для создания значения подсчитанных ссылок. Давайте сделаем то же самое здесь и посмотрим, что произойдёт. Мы завернём `Mutex<T>` в `Rc<T>` в листинге 16-14 и клонируем `Rc<T>` перед передачей владения в поток. Теперь, когда мы увидели ошибки, мы также вернёмся к использованию цикла `for` и сохраним ключевое слово `move` у замыкания.

Файл: src/main.rs