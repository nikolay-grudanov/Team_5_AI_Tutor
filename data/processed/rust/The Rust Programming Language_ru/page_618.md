---
source_image: page_618.png
page_number: 618
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 66.32
tokens: 11793
characters: 2099
timestamp: 2025-12-24T10:44:46.001082
finish_reason: stop
---

Изящное завершение и освобождение ресурсов

Листинг 20-20 асинхронно отвечает на запросы с помощью использования пула потоков, как мы и хотели. Мы получаем некоторые предупреждения про workers, id и поля thread, которые мы не используем напрямую, что напоминает нам о том, что мы не освобождаем все ресурсы. Когда мы используем менее элегантный метод остановки основного потока клавишной комбинацией ctrl-c, все остальные потоки также немедленно останавливаются, даже если они находятся в середине обработки запроса.

Теперь мы будем реализовывать типаж Drop для вызова join у каждого потока в пуле, чтобы они могли завершить запросы над которыми они работают до закрытия. Затем мы реализуем способ сообщить потокам, что они должны перестать принимать новые запросы и завершить работу. Чтобы увидеть этот код в действии, мы изменим наш сервер так, чтобы он принимал только два запроса, прежде чем корректно завершить работу его пула потоков.

Реализация типажа Drop для ThreadPool

Давайте начнём с реализации Drop у нашего пула потоков. Когда пул удаляется, все наши потоки должны объединиться (join), чтобы убедиться, что они завершают свою работу. В листинге 20-22 показана первая попытка реализации Drop, код пока не будет работать.

Файл: src/lib.rs

```rust
impl Drop for ThreadPool {
    fn drop(&mut self) {
        for worker in &mut self.workers {
            println!("Shutting down worker {}", worker.id);
            worker.thread.join().unwrap();
        }
    }
}
```

Листинг 20-22: Присоединение (Joining) каждого потока, когда пул потоков выходит из области видимости

Во-первых, мы проходим циклом по каждому workers из пула потоков. Для этого мы используем &mut, потому что self является изменяемой ссылкой и нам также нужно иметь возможность изменять экземпляр worker. Для каждого "работника" мы печатаем сообщение о том, что этот конкретный "работник" завершается, затем вызываем join у потока этого "работника". Если вызов join происходит с ошибкой, мы используем unwrap, чтобы вызвать панику в Rust и завершить не совсем красиво.

Ошибка получаемая при компиляции этого кода: