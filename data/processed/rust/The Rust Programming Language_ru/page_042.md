---
source_image: page_042.png
page_number: 42
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 32.46
tokens: 11600
characters: 1510
timestamp: 2025-12-24T10:20:09.875681
finish_reason: stop
---

Листинг 2-5. Игнорирование предположения, отличного от числа, и запрос другого предположения вместо сбоя программы

Мы переключаем вызов expect на выражение match, чтобы перейти от аварийного завершения при ошибке к обработке ошибки. Помните, что parse возвращает тип Result, а Result - это перечисление, которое имеет варианты Ok и Err. Здесь мы используем выражение match, как и в случае с результатом Ordering метода cmp.

Если parse может успешно преобразовать строку в число, он вернёт значение ok, содержащее полученное число. Это значение ok будет соответствовать шаблону первой ветки, а выражение match просто вернёт значение num, созданное parse, и поместит его внутрь значения ok. Это число окажется именно там, где мы хотим, в новой переменной guess.

Если метод parse не способен превратить строку в число, он вернёт значение Err, которое содержит более подробную информацию об ошибке. Значение Err не совпадает с шаблоном Ok(num) в первой ветке match, но совпадает с шаблоном Err(_) второй ветки. Подчёркивание _ является всеохватывающим выражением. В этой ветке мы говорим, что хотим обработать совпадение всех значений Err, независимо от того, какая информация находится внутри Err. Поэтому программа выполнит код второй ветки, continue, который сообщает программе перейти к следующей итерации loop и запросить ещё одну догадку. В этом случае программа эффективно игнорирует все ошибки, с которыми может столкнуться parse!

Все в программе теперь должно работать как положено. Давайте попробуем: