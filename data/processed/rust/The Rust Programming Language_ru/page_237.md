---
source_image: page_237.png
page_number: 237
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 46.70
tokens: 11596
characters: 1300
timestamp: 2025-12-24T10:28:34.595735
finish_reason: stop
---

В подсказке упоминается `std::cmp::PartialOrd`, который является типажом. Мы поговорим про типажи в следующей секции. Сейчас, ошибка в функции `largest` указывает, что функция не будет работать для всех возможных типов `T`. Так как мы хотим сравнивать значения типа `T` в теле функции, то можно использовать только те типы, данные которых можно упорядочить: можем упорядочить, значит можем и сравнить. Для возможности сравнения, стандартная библиотека имеет типаж `std::cmp::PartialOrd`, который вы можете реализовать для типов (смотрите Дополнение С для большей информации про данный типаж). Вы узнаете, как потребовать чтобы обобщённый тип реализовывал определённый типаж в секции "Типажи как параметры", но сначала давайте рассмотрим другие варианты использования обобщённых типов.

В определении структур

Также можно определять структуры с использованием обобщённых типов в одном или нескольких полях структуры с помощью синтаксиса `<>`. Листинг 10-6 показывает как определить структуру `Point<T>`, чтобы хранить поля координат `x` и `y` любого типа данных.

Файл: src/main.rs

```rust
struct Point<T> {
    x: T,
    y: T,
}

fn main() {
    let integer = Point { x: 5, y: 10 };
    let float = Point { x: 1.0, y: 4.0 };
}
```

Листинг 10-6: структура `Point` содержащая поля `x` и `y` типа `T`