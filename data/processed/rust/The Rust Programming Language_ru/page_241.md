---
source_image: page_241.png
page_number: 241
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 55.64
tokens: 11743
characters: 1708
timestamp: 2025-12-24T10:28:51.615550
finish_reason: stop
---

Обратите внимание, что нужно объявить `T` сразу после `impl`, чтобы можно было использовать его для указания, что мы реализуем методы для типа `Point<T>`. Объявляя `T` как обобщённый тип после `impl`, Rust может определить, что тип в угловых скобках у `Point` - это обобщённый, а не конкретный тип.

Мы могли бы, например, реализовать методы только для экземпляров типа `Point<f32>` вместо остальных экземпляров `Point<T>` где используется какой-то другой обобщённый тип. В листинге 10-10 мы реализуем код для конкретного типа `f32`: здесь мы не объявляем иных блоков `impl` для других вариантов обобщённого типа после.

Файл: src/main.rs

```rust
impl Point<f32> {
    fn distance_from_origin(&self) -> f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}
```

Листинг 10-10: блок `impl` который применяется только к структуре с конкретным типом для параметра обобщённого типа `T`

Этот код означает, что тип `Point<f32>` будет иметь метод с именем `distance_from_origin`, а другие экземпляры `Point<T>` где `T` имеет тип отличный от `f32` не будут иметь этого метода. Метод измеряет, насколько далеко наша точка находится от точки с координатами (0,0, 0,0) и использует математические операции, доступные только для типов с плавающей запятой.

Обобщённые типы в определении структуры не всегда являются теми же, которые вы используете в сигнатаурах методов этой же структуры. Чтобы сделать пример более понятным, в листинге 10-11 используются обобщённые типы `X1` и `Y1` для структуры `Point` и `X2` `Y2` для метода `mixup`. Метод создаёт новый `Point` со значением `x` из `self Point` (типа `X1`) и значением `y` из другой `Point` (типа `Y2`), переданной в качестве параметра.

Файл: src/main.rs