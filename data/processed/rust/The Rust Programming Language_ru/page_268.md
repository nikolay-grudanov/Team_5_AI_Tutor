---
source_image: page_268.png
page_number: 268
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 60.60
tokens: 11859
characters: 2301
timestamp: 2025-12-24T10:30:05.537442
finish_reason: stop
---

Можно заметить, что второе правило здесь не применимо, так как в сигнатуре указано больше одного входного параметра времени жизни. Третье правило также не применимо, так как `longest` — функция, а не метод, следовательно, в ней нет параметра `self`. Итак, мы прошли все три правила, но так и не смогли вычислить время жизни выходного параметра. Поэтому мы и получили ошибку при попытке скомпилировать код листинга 10-20: компилятор работал по правилам неявного выводения времён жизни, но не мог выяснить все времена жизни ссылок в сигнатуре.

Так как третье правило применяется только к методам, далее мы рассмотрим времена жизни в этом контексте, чтобы понять, почему нам часто не требуется аннотировать времена жизни в сигнатурах методов.

**Аннотация времён жизни в определении методов**

Когда мы реализуем методы для структур с временами жизни, мы используем тот же синтаксис, который применялся для аннотаций обобщённых типов данных на листинге 10-11. Место, где мы объявляем и используем времена жизни, зависит от того, с чем они связаны — с полями структуры, либо с аргументами методов и возвращаемыми значениями.

Имена параметров времени жизни для полей структур всегда описываются после ключевого слова `impl` и затем используются после имени структуры, поскольку эти времена жизни являются частью типа структуры.

В сигнатаурах методов внутри блока `impl` ссылки могут быть привязаны ко времени жизни ссылок в полях структуры, либо могут быть независимыми. Вдобавок, правила неявного выводения времён жизни часто делают так, что аннотации переменных времён жизни являются необязательными в сигнатаурах методов. Рассмотрим несколько примеров, использующих структуру с названием `ImportantExcerpt`, которую мы определили в листинге 10-24.

Сначала, воспользуемся методом `level`, чей единственный параметр является ссылкой на `self`, а возвращаемое значение `i32`, не является ссылкой ни на что:

```rust
impl<'a> ImportantExcerpt<'a> {
    fn level(&self) -> i32 {
        3
    }
}
```

Объявление параметра времени жизни после `impl` и его использование после имени типа является обязательным, но нам не нужно аннотировать время жизни ссылки на `self`, благодаря первому правилу неявного выводения времён жизни.

Вот пример, где применяется третье правило неявного выводения времён жизни: