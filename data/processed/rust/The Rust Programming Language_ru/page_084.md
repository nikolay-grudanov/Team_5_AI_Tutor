---
source_image: page_084.png
page_number: 84
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 69.79
tokens: 11851
characters: 2357
timestamp: 2025-12-24T10:22:29.318461
finish_reason: stop
---

литералы более быстрые и эффективные, в их неизменяемости. К сожалению, нельзя поместить неопределённый кусок памяти в выполняемый файл для текста, размер которого неизвестен при компиляции и может меняться во время выполнения программы.

Чтобы поддерживать изменяемый, увеличивающийся текст типа `String`, необходимо выделять память в куче для всего содержимого, объем которого неизвестен во время компиляции. Это означает, что:

• Память должна запрашиваться у операционной системы во время выполнения программы,
• Необходим способ возврата этой памяти операционной системе, когда мы закончили в программе работу со `String`.

Первая часть выполняется нами: когда мы вызываем `String::from`, его реализация запрашивает необходимую память. Это работает довольно похоже во всех языках программирования.

Однако вторая часть отличается. В языках со сборщиком мусора (GC), память, которая больше не используется, отслеживается и очищается с его помощью — нам не нужно об этом думать. В большинстве языков без сборщика мусора мы обязаны сами определять, когда память больше не используется, и вызывать код для явного её освобождения, точно так же, как мы делали это для её запроса. Правильное выполнение этого процесса исторически было сложной проблемой программирования. Если мы забудем освободить память, она будет потеряна. Если мы сделаем это слишком рано, у нас будет недопустимая переменная. Сделать это дважды тоже будет ошибкой. Нам нужно соединить ровно один `allocate` ровно с одним `free`.

Rust выбирает другой путь: память автоматически возвращается, как только владеющая памятью переменная выходит из области видимости. Вот версия примера с областью видимости из листинга 4-1, в котором используется тип `String` вместо строкового литерала:

```rust
{
    let s = String::from("hello"); // s is valid from this point forward

    // do stuff with s
}
    // this scope is now over, and s is no longer valid
```

Существует естественный момент, когда мы можем вернуть память, необходимую нашему `String`, обратно распределителю — когда `s` выходит за пределы области видимости. Когда переменная выходит за пределы области видимости, Rust вызывает для нас специальную функцию. Эта функция называется `drop`, и именно здесь автор `String` может поместить код для возврата памяти. Rust автоматически вызывает `drop` после закрывающей фигурной скобки.