---
source_image: page_236.png
page_number: 236
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 46.79
tokens: 11661
characters: 1633
timestamp: 2025-12-24T10:28:31.422527
finish_reason: stop
---

Когда мы используем параметр в теле функции, мы должны объявить имя параметра в сигнатуре, так компилятор будет знать, что означает имя. Аналогично, когда мы используем имя параметра в сигнатуре функции, мы должны объявить имя параметра раньше, чем мы его используем. Чтобы определить обобщённую функцию largest, поместим объявление имён параметров в треугольные скобки, <> , между именем функции и списком параметров, как здесь:

fn largest<T>(list: &[T]) -> T {

Объявление читается так: функция largest является обобщённой по типу T . Эта функция имеет один параметр с именем list , который является срезом значений с типом данных T . Функция largest возвращает данные такого же типа T .

Листинг 10-5 показывает определение функции largest с использованием обобщённых типов данных в её сигнатурае. Листинг также показывает, как мы можем вызвать функцию со срезом данных типа i32 или char . Данный код пока не будет компилироваться, но мы исправим это к концу раздела.

Файл: src/main.rs

fn largest<T>(list: &[T]) -> &T {
    let mut largest = &list[0];

    for item in list {
        if item > largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&number_list);
    println!("The largest number is {}", result);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&char_list);
    println!("The largest char is {}", result);
}

Листинг 10-5: определение функции largest с использованием обобщённых типов, но код пока не компилируется

Если мы скомпилируем программу сейчас, мы получим следующую ошибку: