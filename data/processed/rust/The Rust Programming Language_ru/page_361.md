---
source_image: page_361.png
page_number: 361
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 67.78
tokens: 11835
characters: 2094
timestamp: 2025-12-24T10:34:01.552703
finish_reason: stop
---

Обработка группы элементов с помощью итераторов

Шаблон итератора позволяет выполнять некоторые задачи над последовательностью элементов. Итератор отвечает за логику итерации по каждому элементу и определяет, когда последовательность завершилась. Когда вы используете итераторы, вам не нужно переопределять эту логику самостоятельно.

В Rust итераторы являются lazy, то есть они не производят никакого эффекта, пока вы не вызовете методы, которые потребляют итератор, чтобы использовать его. Например, код в листинге 13-10 создаёт итератор элементов вектора v1, вызывая метод iter, определённый для Vec<T>. Сам по себе этот код не делает ничего полезного.

```rust
let v1 = vec![1, 2, 3];

let v1_iter = v1.iter();
```

Листинг 13-10: Создание итератора

Итератор хранится в переменной v1_iter. Создав итератор, мы можем использовать его различными способами. В листинге 3-5 главы 3 мы выполняли итерацию по массиву с помощью цикла for для выполнения какого-то кода над каждым из его элементов. Под капотом это невидно создавало, а затем потребляло итератор, но до сих пор мы не касались того, как именно это работает.

В примере в листинге 13-11 мы отделяем создание итератора от его использования в цикле for. Когда цикл for вызывается используя итератор v1_iter, то для каждого элемента итератора отводится одна итерация цикла, в ходе которой выводится каждое значение.

```rust
let v1 = vec![1, 2, 3];

let v1_iter = v1.iter();

for val in v1_iter {
    println!("Got: {}", val);
}
```

Листинг 13-11: Использование итератора в цикле for

В языках, которые не имеют итераторов в стандартной библиотеке, вы, вероятно, написали бы эту же функцию следующим образом: взять переменную со значением 0, использовать её для индексации вектора, чтобы получить значение, и увеличивать её значение в цикле, пока не будет достигнуто общее количество элементов в векторе.

Итераторы делают все эти шаги за вас, сокращая повторяющийся код, который вы потенциально могли бы испортить. Итераторы дают вам больше гибкости для использования одной и той же логики с различными типами последовательностей, а не