---
source_image: page_565.png
page_number: 565
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 55.60
tokens: 11719
characters: 1805
timestamp: 2025-12-24T10:42:15.519586
finish_reason: stop
---

pub trait Write {
    fn write(&mut self, buf: &[u8]) -> Result<usize>;
    fn flush(&mut self) -> Result<()>;
    fn write_all(&mut self, buf: &[u8]) -> Result<()>;
    fn write_fmt(&mut self, fmt: fmt::Arguments) -> Result<()>;
}

Псевдоним типа помогает двумя способами: он облегчает написание кода и даёт нам согласованный интерфейс для всего из std::io. Поскольку это псевдоним, то это просто ещё один тип Result<T, E>, что означает, что с ним мы можем использовать любые методы, которые работают с Result<T, E>, а также специальный синтаксис вроде ? оператора.

Тип Never, который никогда не возвращается

Rust имеет специальный тип с названием !, который известен в теории типов как пустой тип (empty type), потому что у него нет значений. Мы предпочитаем называть его тип никогда (never type), потому что он стоит на месте возвращаемого типа, такая функция никогда не возвращает управление. Вот пример:

fn bar() -> ! {
    // --snip--
}

Этот код читается как «функция bar никогда не возвращается». Функции, которые никогда не возвращаются называются расходящимися функциями (diverging functions). Нельзя создавать значения типа !, так как bar никогда не может вернуться.

Но для чего нужен тип, для которого вы никогда не сможете создать значения? Напомним код из листинга 2-5; мы воспроизвели его часть здесь в листинге 19-26.

let guess: u32 = match guess.trim().parse() {
    Ok(num) => num,
    Err(_) => continue,
};

Листинг 19-26: Сопоставление match с веткой, которая заканчивается continue

В то время мы опустили некоторые детали в этом коде. В главе 6 раздела "Оператор управления потоком match" мы обсуждали, что все ветви match должны возвращать одинаковый тип. Например, следующий код не работает:

let guess = match guess.trim().parse() {
    Ok(_) => 5,
    Err(_) => "hello",
};