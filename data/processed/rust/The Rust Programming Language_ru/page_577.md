---
source_image: page_577.png
page_number: 577
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 51.46
tokens: 11797
characters: 2092
timestamp: 2025-12-24T10:42:44.791274
finish_reason: stop
---

При создании процедурных макросов объявления должны находиться в собственном крейте специального типа. Это из-за сложных технических причин, которые мы надеемся будут устранены в будущем. Использование процедурных макросов выглядит как код в листинге 19-29, где `some_attribute` является заполнителем для использования специального макроса.

Файл: src/lib.rs

```rust
use proc_macro;

#[some_attribute]
pub fn some_name(input: TokenStream) -> TokenStream {
}
```

Листинг 19-29: Пример использования процедурного макроса

Функция, которая определяет процедурный макрос, принимает `TokenStream` в качестве входных данных и создаёт `TokenStream` в качестве вывода. Тип `TokenStream` объявлен крейтом `proc_macro`, включённым в Rust и представляет собой последовательность токенов. Это ядро макроса: исходный код над которым работает макрос, является входным `TokenStream`, а код создаваемый макросом является выходным `TokenStream`. К функции имеет также прикреплённый атрибут, определяющий какой тип процедурного макроса мы создаём. Можно иметь несколько видов процедурных макросов в одном и том же крейте.

Давайте посмотрим на различные виды процедурных макросов. Начнём с пользовательского, выводимого (derive) макроса и затем объясним небольшие различия, делающие другие формы отличающимися.

Как написать пользовательский derive макрос

Давайте создадим крейт с именем `hello_macro`, который определяет типаж с именем `HelloMacro` и имеет одну с ним ассоциированную функцию с именем `hello_macro`. Вместо того, чтобы пользователи нашего крейта самостоятельно реализовывали типаж `HelloMacro` для каждого из своих типов, мы предоставим им процедурный макрос, чтобы они могли аннотировать свой тип с помощью атрибута `#[diverve(HelloMacro)]` и получили реализацию по умолчанию для функции `hello_macro`. Реализация по умолчанию выведет `Hello, Macro! My name is TypeName!`, где `TypeName` - это имя типа, для которого был определён этот типаж. Другими словами, мы напишем крейт, использование которого позволит другому программисту писать код показанный в листинге 19-30.

Файл: src/main.rs