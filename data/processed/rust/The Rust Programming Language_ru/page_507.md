---
source_image: page_507.png
page_number: 507
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 68.28
tokens: 11839
characters: 2320
timestamp: 2025-12-24T10:40:05.297277
finish_reason: stop
---

экземпляра DraftPost, теперь мы закодировали процесс смены состояний записи блога с помощью системы типов.

Но мы также должны внести небольшие изменения в main. Методы request_review и approve возвращают новые экземпляры, а не изменяют структуру, к которой они обращаются, поэтому нам нужно добавить больше выражений let post = , затеняя присваивания для сохранения возвращаемых экземпляров. Мы также не можем использовать утверждения (assertions), что для черновика и записи, ожидающей проверки, содержимое должно быть пустой строкой, они нам больше не нужны: теперь мы не сможем скомпилировать код, который пытается использовать содержимое записей в этих состояниях. Обновлённый код main показан в листинге 17-21:

Файл: src/main.rs

use blog::Post;

fn main() {
    let mut post = Post::new();

    post.add_text("I ate a salad for lunch today");

    let post = post.request_review();

    let post = post.approve();

    assert_eq!("I ate a salad for lunch today", post.content());
}

Листинг 17-21: Изменения в main, использующие новую реализацию процесса подготовки записи блога

Изменения, которые нам нужно было внести в main, чтобы переназначить post означают, что эта реализация теперь не совсем соответствует объектно-ориентированному шаблону "Состояние": преобразования между состояниями больше не инкапсулированы внутри реализации Post полностью. Тем не менее, мы получили большую выгоду в том, что недопустимые состояния теперь невозможны из-за системы типов и проверки типов, которая происходит во время компиляции! У нас есть гарантия, что некоторые ошибки, такие как отображение содержимого неопубликованной публикации, будут обнаружены до того, как они дойдут до пользователей.

Попробуйте выполнить задачи, предложенные в начале этого раздела, в версии крейта blog, каким он стал после листинга 17-20, чтобы сформировать своё мнение о дизайне этой версии кода. Обратите внимание, что некоторые задачи в этом варианте могут быть уже выполнены.

Мы увидели, что хотя Rust и способен реализовывать объектно-ориентированные шаблоны проектирования, в нём также доступны и другие шаблоны, такие как кодирование состояния с помощью системы типов. Эти модели имеют различные компромиссы. Хотя вы, возможно, очень хорошо знакомы с объектно-ориентированными шаблонами, переосмысление проблем для использования