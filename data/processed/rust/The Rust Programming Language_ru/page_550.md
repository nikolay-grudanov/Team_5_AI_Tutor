---
source_image: page_550.png
page_number: 550
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 56.66
tokens: 11837
characters: 2231
timestamp: 2025-12-24T10:41:39.012024
finish_reason: stop
---

Продвинутые типажи

Сначала мы рассмотрели типажи в разделе "Типажи: Определение общего поведения" главы 10, но как и со временами жизни, мы не обсудили более сложные детали. Сейчас что вы знаете о Rust больше и мы можем двинуться дальше.

Указание заполнителей типов в определениях типажей с ассоциированными типами

Ассоциированные типы (Associated types) связывают заполнитель типа с типажом, таким образом что объявления методов типажа могут использовать эти заполнители типов в своих сигнатурах. Реализация типажа будет указывать конкретный, используемый тип на месте заполнителя типа, при конкретной реализации. Таким образом, мы можем определить типаж пока он не реализован, который использует какие-то типы без необходимости знать, какими точно типами они будут.

Мы описали большинство расширенных возможностей в этой главе, как редко необходимые. Ассоциированные типы находятся где-то посередине: они используются реже чем возможности описанные в остальной части книги, но чаще чем многие другие возможности обсуждаемые в этой главе.

Одним из примеров типажа с ассоциированным типом является типаж Iterator, который предоставляет стандартная библиотека. Ассоциированный тип называется Item и представляет тип для значений, которые перебирает тип реализующий типаж Iterator. В разделе "Типаж Iterator и метод next" главы 13, мы упоминали определение типажа Iterator показанное в листинге 19-12.

pub trait Iterator {
    type Item;
    fn next(&mut self) -> Option<Self::Item>;
}

Листинг 19-12: Определение типажа Iterator, который имеет ассоциированный тип Item

Тип Item является заполнителем и определение метода next показывает, что он будет возвращать значения типа Option<Self::Item>. Разработчики типажа Iterator определит конкретный тип для Item, а метод next вернёт Option содержащий значение этого конкретного типа.

Ассоциированные типы могли бы показаться концепцией похожей на обобщённые типы, в том смысле, что последние позволяют определить функцию, не указывая, какие типы она может обрабатывать. Так зачем использовать ассоциированные типы?

Давайте рассмотрим разницу между этими двумя понятиями на примере из главы 13, которая реализует типаж Iterator у структуры Counter. В листинге 13-21 мы указали,