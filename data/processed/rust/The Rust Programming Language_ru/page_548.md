---
source_image: page_548.png
page_number: 548
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 51.97
tokens: 11734
characters: 1965
timestamp: 2025-12-24T10:41:32.326571
finish_reason: stop
---

добавив ключевое слово unsafe перед trait, а также пометив реализацию типажа как unsafe, как показано в листинге 19-11.

unsafe trait Foo {
    // methods go here
}

unsafe impl Foo for i32 {
    // method implementations go here
}

fn main() {}

Листинг 19-11: Объявление и реализация небезопасного типажа

Используя unsafe impl, мы даём обещание поддерживать инварианты, которые компилятор не может проверить.

Для примера вспомним маркерные типажи Sync и Send, которые мы обсуждали в разделе "Расширяемый параллелизм с помощью типажей Sync и Send" главы 16: компилятор реализует эти типажи автоматически, если наши типы полностью состоят из типов Send и Sync. Если мы создадим тип, который содержит тип, не являющийся Send или Sync, такой, как сырой указатель, и мы хотим пометить этот тип как Send или Sync, мы должны использовать unsafe блок. Rust не может проверить, что наш тип поддерживает гарантии того, что он может быть безопасно передан между потоками или доступен из нескольких потоков; поэтому нам нужно добавить эти проверки вручную и указать это с помощью unsafe.

Доступ к полям объединений (union)

Последнее действие, которое работает только с unsafe, это доступ к полям объединений, union. union похож на struct, но только одно объявленное поле используется в конкретном экземпляре в один момент времени. Объединения в основном используются для взаимодействия с объединениями в коде С. Доступ к полям объединения небезопасен, потому что Rust не может гарантировать тип данных, хранящихся в данный момент в экземпляре объединения. Вы можете узнать больше об объединениях в справочнике.

Когда использовать небезопасный код

Использование unsafe для выполнения одного из пяти действий (супер способностей), которые только что обсуждались, не является ошибочным или не одобренным. Но получить корректный unsafe код сложнее, потому что компилятор не может помочь в обеспечении безопасности памяти. Если у вас есть причина использовать unsafe код, вы