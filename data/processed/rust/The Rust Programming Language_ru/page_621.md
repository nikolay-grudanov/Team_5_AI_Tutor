---
source_image: page_621.png
page_number: 621
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 65.77
tokens: 11784
characters: 2063
timestamp: 2025-12-24T10:44:46.029841
finish_reason: stop
---

```rust
impl Drop for ThreadPool {
    fn drop(&mut self) {
        for worker in &mut self.workers {
            println!("Shutting down worker {}", worker.id);

            if let Some(thread) = worker.thread.take() {
                thread.join().unwrap();
            }
        }
    }
}
```

Как уже говорилось в главе 17, метод `take` у типа `Option` забирает значение из варианта `Some` и оставляет вариант `None` в этом месте. Мы используем `if let`, чтобы деструктурировать `Some` и получить поток; затем вызываем `join` у потока. Если поток "работника" уже `None`, мы знаем, что этот "работник" уже очистил свой поток, поэтому в этом случае ничего не происходит.

**Сигнализация потокам прекратить прослушивание получения задач**

Теперь со всеми внесёнными нами изменениями код компилируется без каких-либо предупреждений. Но плохая новость в том, что этот код ещё не работает так, как мы этого хотим. Ключом является логика в замыканиях, запускаемых потоками экземпляров `Worker`. В данный момент мы вызываем `join`, но это не завершит потоки, потому что они работают в цикле `loop` бесконечно в поиске новой задачи (job). Если мы попытаемся удалить `ThreadPool` в текущей реализации `drop`, то основной поток навсегда заблокируется в ожидании завершения первого потока из пула.

Для решения этой проблемы, мы изменим потоки так, чтобы они прослушивали либо задачи `Job` для её выполнения, либо сигнал, что они должны прекратить прослушивание и выйти из бесконечного цикла. Вместо отправки экземпляров задач `Job`, наш канал отправит один из этих двух вариантов перечисления.

Файл: src/lib.rs

```rust
{{#rustdoc_include ../listings/ch20-web-server/no-listing-07-define-message-enum/src/lib.rs:here}}
```

Это перечисление `Message` будет либо вариантом `NewJob`, который внутри держит `Job` с потоком для выполнения, или это будет вариант `Terminate`, который сделает так, чтобы поток вышел из цикла и остановился.

Нам нужно настроить канал для использования значений типа `Message`, а не типа `Job` как показано в листинге 20-23.

Файл: src/lib.rs