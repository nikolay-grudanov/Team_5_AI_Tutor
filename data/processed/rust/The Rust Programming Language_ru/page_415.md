---
source_image: page_415.png
page_number: 415
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 77.49
tokens: 11967
characters: 2523
timestamp: 2025-12-24T10:36:20.823982
finish_reason: stop
---

Синтаксис `type Target = T;` определяет связанный тип для использования у типажа `Deref`. Связанные типы - это немного другой способ объявления обобщённого параметра, но пока вам не нужно о них беспокоиться; мы рассмотрим их более подробно в главе 19.

Мы заполним тело метода `deref` оператором `&self.0`, чтобы `deref` вернул ссылку на значение, к которому мы хотим получить доступ с помощью оператора `*`; вспомним из раздела "Using Tuple Structs without Named Fields to Create Different Types" главы 5, что `.0` получает доступ к первому значению в кортежной структуре. Функция `main` в листинге 15-9, которая вызывает `*` для значения `MyBox<T>`, теперь компилируется, и проверки проходят!

Без типажа `Deref` компилятор может только разыменовывать `&` ссылки. Метод `deref` даёт компилятору возможность принимать значение любого типа, реализующего `Deref` и вызывать метод `deref` чтобы получить ссылку `&`, которую он знает, как разыменовывать.

Когда мы ввели `*y` в листинге 15-9, Rust фактически выполнил за кулисами такой код:

```rust
*(y.deref())
```

Rust заменяет оператор `*` вызовом метода `deref` и затем простое разыменование, поэтому нам не нужно думать о том, нужно ли нам вызывать метод `deref`. Эта функция Rust позволяет писать код, который функционирует одинаково, независимо от того, есть ли у нас обычная ссылка или тип, реализующий типаж `Deref`.

Причина, по которой метод `deref` возвращает ссылку на значение, и что простое разыменование вне круглых скобок в `*(y.deref())` все ещё необходимо, связана с системой владения. Если бы метод `deref` возвращал значение напрямую, а не ссылку на него, значение переместилось бы из `self`. Мы не хотим передавать владение внутренним значением внутри `MyBox<T>` в этом случае и в большинстве случаев, когда мы используем оператор разыменования.

Обратите внимание, что оператор `*` заменён вызовом метода `deref`, а затем вызовом оператора `*` только один раз, каждый раз, когда мы используем `*` в коде. Поскольку замена оператора `*` не повторяется бесконечно, мы получаем данные типа `i32`, которые соответствуют `5` в `assert_eq!` листинга 15-9.

Неявные разыменованные приведения с функциями и методами

Разыменованное приведение преобразует ссылку на тип, который реализует признак `Deref`, в ссылку на другой тип. Например, `deref coercion` может преобразовать `&String` в `&str`, потому что `String` реализует признак `Deref`, который возвращает `&str`. `Deref coercion` - это удобный механизм, который Rust использует для аргументов функций и