---
source_image: page_608.png
page_number: 608
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 75.62
tokens: 11869
characters: 2319
timestamp: 2025-12-24T10:44:32.075101
finish_reason: stop
---

Структура Worker ответственная за отправку кода из ThreadPool в поток

Мы оставили комментарий относительно создания потоков в цикле for кода 20-14. Здесь мы рассмотрим, как мы на самом деле создаём потоки. Стандартная библиотека предоставляет thread::spawn как способ создания потоков, а thread::spawn ожидает получить некоторый код, который поток должен запустить как только поток создан. Однако в нашем случае мы хотим создать потоки и заставить их ждать код, который мы отправим им позже. Реализация потоков в стандартной библиотеке не имеет какого то способа это сделать, мы должны реализовать это вручную.

Мы будем реализовывать это поведение с помощью новой структуры данных между ThreadPool и потоками, которая будет управлять этим новым поведением. Мы назовём эту структуру данных Worker, что является общим термином в реализации пулов. Подумайте о людях, работающих на кухне в ресторане: рабочие ждут пока не поступят заказы от клиентов, а затем они несут ответственность за принятие этих заказов и их выполнение.

Вместо хранения вектора JoinHandle<()>, в пуле потоков, мы будем сохранять экземпляры структуры Worker. Каждый Worker будет хранить один экземпляр JoinHandle<()>. Затем мы реализуем метод у Worker, который берет код замыкания для запуска и отправляет его в уже запущенный поток для выполнения. Мы также назначим каждому работнику id, чтобы мы могли различать разных работников в пуле при ведении журнала или отладке.

Давайте внесём изменения в последовательность действий, которая выполняется при создании ThreadPool. Мы реализуем код, который отправляет замыкание в поток после того, как мы настроили Worker следующим образом:

1. Определим структуру Worker (работник), которая содержит id и JoinHandle<()>.
2. Изменим ThreadPool, чтобы он содержал вектор экземпляров Worker.
3. Определим функцию Worker::new, которая принимает номер id и возвращает экземпляр Worker, который содержит id и поток, порождённый пустым замыканием.
4. В ThreadPool::new используем счётчик цикла for для генерации id, создаём новый Worker с этим id и сохраняем экземпляр "работника" в вектор.

Если вы готовы принять вызов, попробуйте реализовать эти изменения самостоятельно, прежде чем смотреть код листинге 20-15.

Готовы? Вот листинг 20-15 с одним из способов сделать предыдущие модификации.

Файл: src/lib.rs