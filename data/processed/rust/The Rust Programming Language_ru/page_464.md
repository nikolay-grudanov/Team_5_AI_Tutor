---
source_image: page_464.png
page_number: 464
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 65.71
tokens: 11808
characters: 2140
timestamp: 2025-12-24T10:38:11.896593
finish_reason: stop
---

поэтому, если получатель уже удалён и отправить значение некуда, операция отправки вернёт ошибку. В этом примере мы вызываем `unwrap` для паники в случае ошибки. В реальном приложении мы обработали бы эту ситуацию более корректно: вернитесь к главе 9, если хотите ещё раз разобрать стратегии правильной обработки ошибок.

В листинге 16-8 мы получим значение от приёмника в основном потоке. Это похоже на извлечение резиновой уточки из воды в конце реки или получение сообщения в чате.

Файл: src/main.rs

```rust
use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from("hi");
        tx.send(val).unwrap();
    });

    let received = rx.recv().unwrap();
    println!("Got: {}", received);
}
```

Листинг 16-8. Получение значения «привет» в основном потоке и его печать

Метод `try_recv` неблокирующий, отличается тем, что немедленно вернёт тип `Result<T, E>` : где значение `Ok` содержащее сообщение, если оно доступно и значение `Err`, если в этот раз нет сообщений. Использование `try_recv` полезно, если текущий поток выполняет другую работу во время ожидания сообщений: мы могли бы написать цикл, довольно часто вызывающий метод `try_recv`, так чтобы обрабатывать сообщение, если оно доступно и в противном случае выполнять другую работу некоторое время до следующей проверки.

Метод `try_recv` не блокирует выполнение, вместо этого он немедленно возвращает `Result<T, E>` : значение `Ok`, содержащее сообщение, если оно доступно, и значение `Err`, если на этот раз сообщений нет. Использование `try_recv` полезно, если у потока есть другая работа во время ожидания сообщений: мы могли бы написать цикл, который время от времени вызывает `try_recv`, обрабатывает сообщение, если оно доступно, а в противном случае некоторое время выполняет другую работу, пока не проверит снова.

Мы использовали `recv` в этом примере для простоты; у нас нет никакой другой работы для основного потока, кроме как ждать сообщений, поэтому блокировка основного потока уместна.

При запуске кода листинга 16-8, мы увидим значение, напечатанное из основного потока: