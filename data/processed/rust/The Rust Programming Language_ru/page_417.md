---
source_image: page_417.png
page_number: 417
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 63.96
tokens: 11791
characters: 1999
timestamp: 2025-12-24T10:36:07.760523
finish_reason: stop
---

Если бы Rust не реализовал разыменованное приведение, мы должны были бы написать код в листинге 15-13 вместо кода в листинге 15-12 для вызова метода hello со значением типа &MyBox<String>.

Файл: src/main.rs

```rust
fn main() {
    let m = MyBox::new(String::from("Rust"));
    hello(&(*m)[..]);
}
```

Листинг 15-13: Код, который нам пришлось бы написать, если бы в Rust не было разыменованного приведения ссылок

(*m) разыменовывает MyBox<String> в String. Затем & и [...] принимают фрагмент строки String, равный полной строке для соответствия сигнатуре hello. Этот код без deref-согласований сложнее читать, писать и понимать, поскольку в нем задействованы все эти символы. Deref coercion позволяет Rust автоматически обрабатывать эти преобразования.

Когда типаж Deref определён для задействованных типов, Rust проанализирует типы и будет использовать Deref::deref столько раз, сколько необходимо, чтобы получить ссылку, соответствующую типу параметра. Количество раз, которое нужно вставить Deref::deref определяется во время компиляции, поэтому использование разыменованного приведения не имеет накладных расходов во время выполнения!

Как разыменованное приведение взаимодействует с изменяемостью

Подобно тому, как вы используете типаж Deref для переопределения оператора * у неизменяемых ссылок, вы можете использовать типаж DerefMut для переопределения оператора * у изменяемых ссылок.

Rust выполняет разыменованное приведение, когда находит типы и реализации типажей в трёх случаях:

• Из типа &T в тип &U когда верно T: Deref<Target=U>
• Из типа &mut T в тип &mut U когда верно T: DerefMut<Target=U>
• Из типа &mut T в тип &U когда верно T: Deref<Target=U>

Первые два случая идентичны друг другу, за исключением того, что второй реализует изменяемость. В первом случае говорится, что если у вас есть &T, а T реализует Deref для некоторого типа U, вы сможете прозрачно получить &U. Во втором случае говорится, что такое же разыменованное приведение происходит и для изменяемых ссылок.