---
source_image: page_242.png
page_number: 242
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 44.37
tokens: 11598
characters: 1322
timestamp: 2025-12-24T10:28:43.996191
finish_reason: stop
---

Листинг 10-11: метод, использующий разные обобщённые типы из определения структуры для которой он определён

В функции main, мы определили тип Point, который имеет i32 для x (со значением 5) и тип f64 для y (со значением 10.4). Переменная p2 является структурой Point которая имеет строковый срез для x (со значением "Hello") и char для y (со значением c ). Вызов mixup на p1 с аргументом p2 создаст для нас экземпляр структуры p3. Новый экземпляр p3 будет иметь для x тип i32 (потому что x взят из p1), а для y тип char (потому что y взят из p2). Вызов макроса println! выведет p3.x = 5, p3.y = c.

Цель этого примера продемонстрировать ситуацию, в которой одни обобщённые параметры объявлены в impl, а другие в определении метода. Здесь обобщённые параметры X1 и Y1 объявляются после impl, потому что они идут вместе с определением структуры. Обобщённые параметры типа X2 и Y2 объявляются после fn mixup, потому что они относятся только к методу.

Производительность кода использующего обобщённые типы

Вы могли бы задаться вопросом, появляются ли дополнительные вычисления во время выполнения кода использующего параметры обобщённого типа. Хорошей новостью является то, что Rust реализует обобщённые типы таким способом, что ваш код не работает медленнее при их использовании, чем если бы это было с конкретными типами.