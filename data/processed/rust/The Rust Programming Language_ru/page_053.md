---
source_image: page_053.png
page_number: 53
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 80.65
tokens: 12007
characters: 2582
timestamp: 2025-12-24T10:21:25.983889
finish_reason: stop
---

<table>
  <tr>
    <th>Числовые литералы</th>
    <th>Пример</th>
  </tr>
  <tr>
    <td>Восьмеричный</td>
    <td>0o77</td>
  </tr>
  <tr>
    <td>Двоичный</td>
    <td>0b1111_0000</td>
  </tr>
  <tr>
    <td>Байт (только <code>u8</code>)</td>
    <td>b'A'</td>
  </tr>
</table>

Как же узнать, какой тип целого числа использовать? Если вы не уверены, значения по умолчанию в Rust, как правило, подходят для начала: целочисленные типы по умолчанию <code>i32</code>. Основной случай, в котором вы должны использовать <code>isize</code> или <code>usize</code>, — это индексация какой-либо коллекции.

Переполнение целых чисел

Допустим, у вас есть переменная типа <code>u8</code>, которая может хранить значения от 0 до 255. Если вы попытаетесь присвоить переменной значение вне этого диапазона, например 256, произойдёт переполнение целого числа, что может привести к одному из двух вариантов поведения. Когда вы выполняете компиляцию в режиме отладки, Rust содержит проверки на переполнение целых чисел, которые заставят вашу программу паниковать во время выполнения, если такое произойдёт. Rust использует термин паника, когда программа завершается с ошибкой; мы обсудим панику более подробно в разделе "Непоправимые ошибки в случае panic!" в главе 9.

Когда вы выполняете компиляцию в режиме release с флагом <code>--release</code>, Rust не включает проверки на переполнение целых чисел, которые вызывают панику. Вместо этого, если происходит переполнение, Rust выполняет свёртку с двойным дополнением. Короче говоря, значения, превышающие максимальное значение, которое может хранить тип, "сворачиваются" к минимальному из значений, которые может хранить тип. В случае <code>u8</code>, значение 256 становится 0, значение 257 становится 1 и так далее. Программа не запаникует, но переменная будет иметь значение, которое, вероятно, не соответствует вашим ожиданиям. Полагаться на поведение свёртки при переполнении целых чисел считается ошибкой.

Чтобы явно обработать возможность переполнения, вы можете использовать следующие группы методов, предоставляемые стандартной библиотекой для примитивных числовых типов:

• Обёртывание во всех режимах с помощью методов <code>wrapping_*</code>, например <code>wrapping_add</code>
• Верните значение <code>None</code>, если произошло переполнение при использовании методов <code>checked_*</code>
• Верните число и логическое значение, указывающее, имело ли место переполнение с помощью методов <code>overflowing_*</code>
• Считать корректным установку минимального или максимального значения, используя метод <code>saturating_*</code>