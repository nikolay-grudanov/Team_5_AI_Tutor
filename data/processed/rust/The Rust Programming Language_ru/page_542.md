---
source_image: page_542.png
page_number: 542
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 43.85
tokens: 11672
characters: 1381
timestamp: 2025-12-24T10:41:10.921196
finish_reason: stop
---

```rust
let mut v = vec![1, 2, 3, 4, 5, 6];

let r = &mut v[..];

let (a, b) = r.split_at_mut(3);

assert_eq!(a, &mut [1, 2, 3]);
assert_eq!(b, &mut [4, 5, 6]);
```

Листинг 19-4: Использование безопасной функции `split_at_mut`

Эту функцию нельзя реализовать, используя только безопасный Rust. Попытка реализации могла бы выглядеть примерно как в листинге 19-5, который не компилируется. Для простоты мы реализуем `split_at_mut` как функцию, а не как метод, и только для значений типа `i32`, а не обобщённого типа `T`.

```rust
fn split_at_mut(values: &mut [i32], mid: usize) -> (&mut [i32], &mut [i32]) {
    let len = values.len();

    assert!(mid <= len);

    (&mut values[..mid], &mut values[mid..])
}
```

Листинг 19-5: Попытка реализации функции `split_at_mut` используя только безопасный Rust

Эта функция сначала получает общую длину среза. Затем она проверяет(assert), что индекс, переданный в качестве параметра, находится в границах среза, сравнивая его с длиной. Assert означает, что если мы передадим индекс, который больше, чем длина среза, функция запаникует ещё до попытки использования этого индекса.

Затем мы возвращаем два изменяемых фрагмента в кортеже: один от начала исходного фрагмента до `mid` индекса (не включая сам `mid`), а другой - от `mid` (включая сам `mid`) до конца фрагмента.

При попытке скомпилировать код в листинге 19-5, мы получим ошибку.