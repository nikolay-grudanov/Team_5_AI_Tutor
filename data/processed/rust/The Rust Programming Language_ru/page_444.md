---
source_image: page_444.png
page_number: 444
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 45.05
tokens: 11627
characters: 1280
timestamp: 2025-12-24T10:37:05.357859
finish_reason: stop
---

Количество ссылок на экземпляры `Rc<List>` как в `a`, так и в `b` равно 2 после того, как мы заменили список в `a` на ссылку на `b`. В конце `main` Rust уничтожает переменную `b`, что уменьшает количество ссылок на `Rc<List>` из `b` с 2 до 1. Память, которую `Rc<List>` занимает в куче, не будет освобождена в этот момент, потому что количество ссылок на неё равно 1, а не 0. Затем Rust удаляет `a`, что уменьшает количество ссылок экземпляра `Rc<List>` в `a` с 2 до 1. Память этого экземпляра также не может быть освобождена, поскольку другой экземпляр `Rc<List>` по-прежнему ссылается на него. Таким образом, память, выделенная для списка не будет освобождена никогда. Чтобы наглядно представить этот цикл ссылок, мы создали диаграмму на рисунке 15-4.

![Ссылочный цикл списков a и b, указывающих друг на друга](https://i.imgur.com/3Q5z5QG.png)

Рисунок 15-4: Ссылочный цикл списков a и b, указывающих друг на друга

Если вы удалите последний комментарий с `println!` и запустите программу, Rust будет пытаться печатать зациклённость в `a`, указывающей на `b`, указывающей на `a` и так далее, пока не переполнится стек.

По сравнению с реальной программой, последствия создания цикла ссылок в этом примере не так страшны: сразу после создания цикла ссылок программа завершается.