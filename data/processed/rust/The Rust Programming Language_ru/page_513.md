---
source_image: page_513.png
page_number: 513
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 56.88
tokens: 11753
characters: 1761
timestamp: 2025-12-24T10:40:07.755701
finish_reason: stop
---

листинге 18-3 показано, как использовать шаблон в цикле for , чтобы деструктурировать или разбить кортеж как часть цикла for .

```rust
let v = vec!['a', 'b', 'c'];

for (index, value) in v.iter().enumerate() {
    println!("{} is at index {}", value, index);
}
```

Листинг 18-3: Использование шаблона в цикле for для деструктурирования кортежа

Код в листинге 18-3 выведет следующее:

```
$ cargo run
Compiling patterns v0.1.0 (file:///projects/patterns)
Finished dev [unoptimized + debuginfo] target(s) in 0.52s
    Running `target/debug/patterns`
a is at index 0
b is at index 1
c is at index 2
```

Мы адаптируем итератор с помощью метода enumerate, чтобы он генерировал кортеж, состоящий из значения и индекса этого значения. Первым сгенерированным значением будет кортеж (0, 'a'). Когда это значение сопоставляется с шаблоном (index, value), index будет равен 0, а value будет равно 'a' и будет напечатана первая строка выходных данных.

Оператор let

До этой главы мы подробно обсуждали только использование шаблонов с match и if let, но на самом деле, мы использовали шаблоны и в других местах, в том числе в операторах let. Например, рассмотрим следующее простое назначение переменной с помощью let:

```rust
let x = 5;
```

Каждый раз, когда вы использовали подобным образом оператор let, вы использовали шаблоны, хотя могли и не осознавать этого! Более формально оператор let выглядит так:

```rust
let PATTERN = EXPRESSION;
```

В выражениях типа let x = 5; с именем переменной в слоте PATTERN, имя переменной является просто отдельной, простой формой шаблона. Rust сравнивает выражение с шаблоном и присваивает любые имена, которые он находит. Так что в примере let x = 5; , x - это шаблон, который означает "привязать то, что соответствует здесь,