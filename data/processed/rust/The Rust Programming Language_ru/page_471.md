---
source_image: page_471.png
page_number: 471
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 59.00
tokens: 11733
characters: 1911
timestamp: 2025-12-24T10:38:27.501700
finish_reason: stop
---

дискуссии забудет освободить микрофон, когда закончит с ним, то никто больше не сможет говорить. Если управление общим микрофоном идёт не правильно, то конференция не будет работать как было запланировано!

Правильное управление мьютексами может быть невероятно сложным и именно поэтому многие люди с энтузиазмом относятся к каналам. Однако, благодаря системе типов и правилам владения в Rust, вы не можете использовать блокировку и разблокировку неправильным образом.

Mutex<T> API

Давайте рассмотрим пример использования мьютекса в листинге 16-12 без использования нескольких потоков:

Файл: src/main.rs

use std::sync::Mutex;

fn main() {
    let m = Mutex::new(5);

    {
        let mut num = m.lock().unwrap();
        *num = 6;
    }

    println!("m = {:?}", m);
}

Листинг 16-12: Изучение API Mutex<T> для простоты в однопоточном контексте.

Как и во многих типах, мы создаём Mutex<T> используя ассоциированную функцию new. Чтобы получить доступ к данным внутри мьютекса, мы используем метод lock для получения блокировки. Этот вызов блокирует текущий поток, поэтому он не может выполнять какую-либо другую работу, пока не наступит наша очередь получить блокировку.

Вызов lock завершится неудачей, если запаникует другой поток, удерживающий блокировку. В этом случае никто никогда не сможет получить блокировку, поэтому мы решили вызвать unwrap и вызвать панику, если окажемся в такой ситуации.

После того как мы получили блокировку, мы можем рассматривать возвращаемое значение, в данном случае с именем num, как изменяемую ссылку на данные внутри. Система типов гарантирует, что мы получим блокировку перед использованием значения из m. Переменная m имеет тип Mutex<i32>, а не просто i32, поэтому мы должны вызвать функцию lock, чтобы иметь возможность использовать значение типа i32. Мы не можем забыть об этом; без этого система типов не позволит нам получить доступ ко внутреннему i32 значению.