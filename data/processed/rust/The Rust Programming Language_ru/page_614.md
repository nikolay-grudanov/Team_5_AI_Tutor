---
source_image: page_614.png
page_number: 614
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 64.94
tokens: 11719
characters: 1819
timestamp: 2025-12-24T10:44:37.357504
finish_reason: stop
---

Листинг 20-18: Совместное использование принимающей стороны канала среди "работников" используя Arc и Mutex

В ThreadPool::new мы помещаем принимающую сторону канала внутрь Arc и Mutex. Для каждого нового "работника" мы клонируем Arc, чтобы увеличить счётчик ссылок так, что "работники" могут разделять владение принимающей стороны канала.

С этими изменениями код компилируется! Мы подбираемся к цели!

Реализация метода execute

Давайте реализуем метод execute у структуры ThreadPool. Мы также изменим тип Job со структуры на псевдоним типа для типаж-объекта, который содержит тип замыкания принимаемый методом execute. Как описано в разделе "Создание синонимов типа с помощью псевдонимов типа" главы 19, псевдонимы типов позволяют делать длинные типы короче. Посмотрите в листинг 20-19.

Файл: src/lib.rs

// --snip--

type Job = Box<dyn FnOnce() + Send + 'static>;

impl ThreadPool {
    // --snip--

    pub fn execute<F>(&self, f: F)
    where
        F: FnOnce() + Send + 'static,
    {
        let job = Box::new(f);
        self.sender.send(job).unwrap();
    }
}

// --snip--

Листинг 20-19: Создание псевдонима типа Job для Box, содержащего каждое замыкание и затем отправляющее задание (job) в канал

После создания нового экземпляра Job с помощью замыкания, получаемого в метод execute, мы отправляем это задание в отправляющую часть канала. Мы вызываем unwrap для send в случае неудачной отправки. Это может произойти, если например, мы остановим выполнение всех наших потоков, что означает, что принимающая сторона прекратила получение новых сообщений. На данный момент мы не можем остановить выполнение наших потоков: наши потоки продолжают выполняться, пока существует пул. Причина, по которой мы используем unwrap, заключается в том, что мы знаем, что сбой не произойдёт, но компилятор этого не знает.