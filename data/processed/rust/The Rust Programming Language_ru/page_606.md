---
source_image: page_606.png
page_number: 606
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 44.88
tokens: 11644
characters: 1529
timestamp: 2025-12-24T10:43:54.311130
finish_reason: stop
---

**Листинг 20-13: Реализация ThreadPool::new с паникой, если size равен нулю**

Мы добавили документации в ThreadPool с помощью комментариев. Обратите внимание, мы следовали хорошим практикам документирования, добавив раздел, в котором указывается ситуация при которой функция может паниковать как обсуждалось в главе 14. Попробуйте запустить cargo doc --open и кликнуть структуру ThreadPool, чтобы увидеть как выглядит сгенерированная документация для new!

Вместо добавления макроса assert!, как мы здесь сделали, мы могли бы описать у new возвращать Result как мы делали в Config::new проекта ввода/вывода в коде 12-9. Но сейчас мы решили, что попытка создания пула потоков без любого указания количества потоков должно быть не восстанавливаемой ошибкой. Если вы чувствуете себя честолюбивым, попробуйте написать версию new со следующей сигнатурой, чтобы сравнить обе версии:

pub fn new(size: usize) -> Result<ThreadPool, PoolCreationError> {

Создание места для хранения потоков

Теперь у нас есть способ узнать, что задано допустимое число потоков для хранения в пуле и мы можем создать эти потоки и сохранить их в структуре ThreadPool перед её возвратом. Но как мы "храним" поток? Давайте ещё раз посмотрим на сигнатуру thread::spawn:

pub fn spawn<F, T>(f: F) -> JoinHandle<T>
    where
        F: FnOnce() -> T,
        F: Send + 'static,
        T: Send + 'static,

Функция spawn возвращает тип JoinHandle<T>, где T является типом, который возвращает замыкание. Давайте попробуем использовать JoinHandle и посмотрим, что