---
source_image: page_345.png
page_number: 345
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 55.73
tokens: 11665
characters: 1693
timestamp: 2025-12-24T10:33:09.235056
finish_reason: stop
---

ошибок, поэтому в файл попадают только данные из успешного запуска. Мы поменяем это.

Печать ошибок в поток ошибок

Мы будем использовать код в листинге 12-24, чтобы изменить способ вывода сообщений об ошибках. Из-за рефакторинга, который мы делали ранее в этой главе, весь код, который печатает сообщения об ошибках, находится в одной функции: main.
Стандартная библиотека предоставляет макрос eprintln! который печатает в стандартный поток ошибок, поэтому давайте изменим два места, где мы вызывали println! для печати ошибок, чтобы использовать eprintln! вместо этого.

Файл: src/main.rs

```rust
fn main() {
    let args: Vec<String> = env::args().collect();

    let config = Config::build(&args).unwrap_or_else(|err| {
        eprintln!("Problem parsing arguments: {err}");
        process::exit(1);
    });

    if let Err(e) = minigrep::run(config) {
        eprintln!("Application error: {e}");
        process::exit(1);
    }
}
```

Листинг 12-24. Запись сообщений об ошибках в стандартный поток ошибок вместо потока стандартного вывода используя макрос eprintln!

После изменения println! на eprintln!, давайте снова запустим программу без каких-либо аргументов и перенаправим стандартный вывод с помощью >:

```sh
$ cargo run > output.txt
Problem parsing arguments: not enough arguments
```

Теперь мы видим ошибку на экране и output.txt не содержит ничего, что мы ожидали от программы командной строки.

Давайте снова запустим программу с аргументами, которые не вызывают ошибку, но все же перенаправляют стандартный вывод в файл, например так:

```sh
$ cargo run to poem.txt > output.txt
```

Мы не увидим никакого вывода в терминал, а output.txt будет содержать наши результаты: