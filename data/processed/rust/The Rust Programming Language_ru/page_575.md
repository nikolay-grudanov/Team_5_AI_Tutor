---
source_image: page_575.png
page_number: 575
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 62.17
tokens: 11874
characters: 2137
timestamp: 2025-12-24T10:42:50.013763
finish_reason: stop
---

```rust
#[macro_export]
macro_rules! vec {
    ( $( $x:expr ),* ) => {
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($x);
            )*
            temp_vec
        }
    };
}
```

Листинг 19-28: Упрощённая версия определения макроса `vec!`

Примечание: фактическое определение макроса `vec!` в стандартной библиотеке включает сначала код для предварительного выделения правильного объёма памяти. Этот код является оптимизацией, которую мы здесь не включаем, чтобы сделать пример проще.

Аннотация `#[macro_export]` указывает, что данный макрос должен быть доступен всякий раз, когда крейт с объявленным макросом, добавлен в область видимости. Без этой аннотации макрос нельзя добавить в область видимости.

Затем мы начинаем объявление макроса с помощью `macro_rules!` и имени макроса, который объявляется без восклицательного знака. Название, в данном случае `vec`, после которого следуют фигурные скобки, указывающие тело определения макроса.

Структура в теле макроса `vec!` похожа на структуру `match` выражения. Здесь у нас есть одна ветвь с шаблоном `( $( $x:expr ),* )`, затем следует ветвь `=>` и блок кода, связанный с этим шаблоном. Если шаблон сопоставлен успешно, то соответствующий блок кода будет сгенерирован. Учитывая, что данный код является единственным шаблоном в этом макросе, существует только один действительный способ сопоставления, любой другой шаблон приведёт к ошибке. Более сложные макросы будут иметь более чем одна ветвь.

Допустимый синтаксис шаблона в определениях макросов отличается от синтаксиса шаблона рассмотренного в главе 18, потому что шаблоны макроса сопоставляются со структурами кода Rust, а не со значениями. Давайте пройдёмся по тому, какие части шаблона в листинге 19-28 что означают; полный синтаксис макроса см. в ссылке.

Во-первых, набор скобок охватывает весь шаблон. Далее идёт знак доллара ( `$` ), затем следует набор скобок, который захватывает значения, соответствующие шаблону в скобках для использования в коде замены. Внутри `$( )` находится `$x:expr`, который соответствует любому выражению Rust и даёт выражению имя `$x`.