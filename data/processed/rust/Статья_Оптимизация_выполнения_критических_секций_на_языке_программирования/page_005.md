---
source_image: page_005.png
page_number: 5
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 16.36
tokens: 12100
characters: 2842
timestamp: 2025-12-23T22:46:59.175859
finish_reason: stop
---

proc lock_acquire_write (tid)
    while owner_field != 0 {}
    owner_field := tid
    if is_reader(tid) = true
        lock_release_read(tid)
    endif
    while lock_readers > 0 {}
    return
endproc

Рис. 3. Упрощенная логика захвата байтлока на запись

Рассмотрим ряд основных функций, необходимых при работе с байтлоком. В случае попытки захвата байтлока для записи поток-писатель использует операцию сравнения с обменом, чтобы выставить свой идентификатор в поле владельца. Далее в цикле производится проверка счетчика чтений и массива байтов — ожидание, пока все потоки, читающие данную область памяти, не прекратят чтение. Если сам поток-писатель является еще и читателем, он также прекращает чтение: в случае, если поток является сегментированным, это определяется по состоянию соответствующего элемента в байтовом массиве; в противном же случае декрементируется счетчик чтений несегментированных потоков (рис. 3). Для освобождения участка памяти поток-писатель просто выставляет поле владельца в значение «0».

При попытке захвата байтлока для чтения могут быть рассмотрены три случая. В первом случае «сегментированный» читатель уже является владельцем байтлока, тогда поток просто освобождает его, выставляя нулевое значение в поле владельца, после чего выставляет байт «1» в свою ячейку массива байтов. Если читатель несегментирован, он пытается увеличить на единицу значение счетчика читателей, после чего проверяет, не производит ли кто-либо запись в область памяти, защищаемую байтлоком. Если запись производится, читатель декрементирует счетчик и ожидает освобождения байтлока писателем, после чего повторяет попытку захвата на чтение. Если поток-читатель сегментирован, процедура захвата для него аналогична описанной выше, только вместо инкрементирования и декрементирования счетчика читателей производятся операции с ячейкой потока в байтовом массиве.

Стоит заметить, что алгоритм TLRW подразумевает превышение лимита времени в случае слишком большого числа попыток захватить байтлок. В этом случае транзакция отменяется и возвращается соответствующее уведомление. Таким образом, алгоритм TLRW можно разделить на три основных стадии: выполнение кода транзакции, возможный откат транзакции из-за превышения лимита времени и успешное завершение транзакции. В случае, если транзакция завершилась успешно, необходимо освободить сначала блокировки записи, а затем блокировки чтения.

Для хранения байтлока выделяется объем памяти в 64 байта — стандартная длина кеш-линии в микроархитектурах Intel, Sun и AMD. Допускается расширение размера байтлока за счет использования дополнительных кеш-линий, что, однако, приводит к замедлению процесса доступа к структуре.

Как уже упоминалось выше, применение программной транзакционной памяти на базе алгоритма TLRW дает высокий уровень производительности при превалировании операций с