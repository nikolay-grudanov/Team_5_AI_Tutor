---
source_image: page_002.png
page_number: 2
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 20.48
tokens: 12069
characters: 3196
timestamp: 2025-12-23T22:46:47.620123
finish_reason: stop
---

точных приложений встает задача поиска компромисса, который совмещал бы в себе высокую производительность многопоточной программы, приемлемый уровень надежности и простоту разработки.

Язык программирования Rust разрабатывается как инструмент, решающий задачи безопасности работы с данными практически с нулевыми накладными расходами во время выполнения. Высокий уровень производительности достигается при помощи эффективных механизмов ограничения и собственной концепции владения данными.

Проектирование эффективных и надежных программ на ВС с общей памятью требует от разработчика учета множества аспектов, одним из которых является предотвращение состояния гонки данных (data race) на стадии выполнения многопоточной программы. В текущей версии Rust для решения этой проблемы используются методы синхронизации, основанные на механизмах блокировки. Альтернативным подходом является использование программной транзакционной памяти (transactional memory) [2]. Данная работа концентрируется на реализации программной транзакционной памяти (software transactional memory, STM) для языка программирования Rust. В качестве реализуемого метода был выбран предложенный в 2009 году алгоритм TLRW [3], отличающийся от других реализаций простотой использования и высоким уровнем производительности благодаря эффективному использованию кеш-памяти процессора вычислительного ресурса.

1. Описание предметной области

1.1. Язык программирования Rust
С 2010 года компанией Mozilla Research разрабатывается системный мультипарадигмальный язык программирования Rust. Направление развития этого языка сосредоточено вокруг трех основных понятий: безопасность, скорость и параллелизм. Синтаксис Rust схож с таковыми в C или C++, однако семантически эти языки значительно различаются. Одной из отличительных особенностей Rust следует назвать отказ от использования сборщика мусора (garbage collector), который применяется, например, в Java, JavaScript или SmallTalk. Rust объединяет в себе высокую производительность и гарантированную безопасность собственной модели памяти. Модель памяти, предлагаемая Rust [7], основана на эффективных механизмах ограничения, которые не допускают использования нулевых (null pointers) и висячих (dangling pointers) указателей. При этом накладные расходы, возникающие во время выполнения многопоточных программ, сводятся к минимуму. В Rust каждый объект имеет свою область владения (owning scope). Перемещение или возврат объекта означает его передачу в новую область владения, при этом окончание какой-либо области подразумевает уничтожение всех объектов, ей принадлежащих (рис. 1).

Еще одной ключевой особенностью данного языка, отличающей его от многих других недавно появившихся языков программирования, следует назвать низкоуровневое управление памятью. Разработчик способен явно управлять, например, процессами выделения и освобождения памяти в программе. В этом плане Rust схож с C или C++. Продолжая проводить параллели с C++, можно отметить наличие в Rust «умных» указателей (smart pointers). Здесь стоит упомянуть следующие аспекты: во-первых, перед выходом из области видимости (области владения) переменной память освобождается автоматически, этот этап предусматрива-