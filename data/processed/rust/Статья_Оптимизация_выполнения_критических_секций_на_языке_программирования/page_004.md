---
source_image: page_004.png
page_number: 4
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 21.09
tokens: 12116
characters: 2881
timestamp: 2025-12-23T22:46:48.234930
finish_reason: stop
---

Рис. 2. Структура байтлока: поле владельца, занимаемое потоком-писателем, массив байтов для сегментированных потоков, счетчик чтений для несегментированных потоков

Под транзакцией в данном контексте понимается выполняемая потоком конечная последовательность инструкций, реализующая операции транзакционных чтения и записи. В общем случае, отдельно взятая транзакция выполняется либо полностью и успешно, либо не выполняется вообще, если возникает конфликт по данным.

Несомненным достоинством транзакционной памяти по сравнению с традиционным подходом на основе операции сравнения с обменом является простота использования. Также алгоритмы на основе транзакционной памяти свободны от блокировок и обеспечивают прирост ускорения за счет единовременного выполнения транзакций. К недостаткам данной методики следует отнести сложность отладки программ, ограниченную область применения, а также падение производительности при некорректном использовании. Стоит отметить, что текущие реализации транзакционной памяти характеризуются высокими накладными расходами на создание и управление транзакциями.

Существующие реализации транзакционной памяти включают в себя как программно- [4, 5, 6], так и аппаратно-реализуемые алгоритмы. Также следует упомянуть реализации, сочетающие в себе аппаратные и программные средства. Одним из перспективных подходов к реализации программной транзакционной памяти является алгоритм TLRW.

1.3. Алгоритм TLRW
Алгоритм программной транзакционной памяти TLRW был разработан Д. Дайсом и Н. Шавитом (D. Dice, N. Shavit) в 2009 г. и представлен в 2010 г. на 22-м «Симпозиуме по параллелизму в алгоритмах и архитектурах» (Symposium on Parallelism in Algorithms and Architectures, SPAA). Ключевая идея данного алгоритма базируется на использовании блокировок чтения-записи (read-write lock) и подразумевает использование специализированных структур данных, называемых байтлоками (byte-lock).

Принцип их работы заключается в том, что каждому потоку в программе ставится в соответствие структура размером в 64 байта, разделенная на три области — поле владельца (owner field), байтовый массив (byte array) и счетчик читателей (reader counter) (рис. 2). В поле владельца записывается идентификатор потока-писателя, захватившего байтлок. Если же байтлок свободен, в поле выставляется нулевое значение. Байтовый массив, как правило, состоит из \( k = 48 \) элементов, каждый из которых ставится в соответствие одному потоку-читателю. Эти потоки в количестве \( k \) выбираются по принципу наименьшего идентификатора (thread identifier) и называются сегментированными (slotted). Оставшиеся \(( n - k )\) потоков, где \( n \) — общее число потоков в системе, называются несегментированными (unslotted threads), их количество хранится в 32-битном счетчике чтений. Представленный алгоритм показывает высокий уровень эффективности для сегментированных потоков-читателей.