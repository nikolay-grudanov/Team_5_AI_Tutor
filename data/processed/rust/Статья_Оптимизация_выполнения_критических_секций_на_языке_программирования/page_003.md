---
source_image: page_003.png
page_number: 3
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 15.59
tokens: 11944
characters: 2563
timestamp: 2025-12-23T22:46:42.726404
finish_reason: stop
---

fn foo() {
    let mut stuff = Vec::new();

    /* Вектор 'stuff' создан,
     * владелец — функция foo.
     */

    stuff.push(0);
    stuff.push(1);

    /* Окончание области владения,
     * dealлокация вектора
     */
}

Рис. 1. Подход к реализации области владения в языке

ется компилятором; во-вторых, в Rust в принципе невозможно выделение памяти без ее инициализации, что обозначено объединением этих двух операций в одном выражении языка.

Как упоминалось выше, внимание разработчиков Rust сосредоточено вокруг безопасности, скорости и параллелизма. Эти свойства достигаются за счет так называемых «абстракций с нулевой стоимостью» (zero-cost abstractions). Одна из таких абстракций — уже описанная выше реализация области владения. Также стоит рассмотреть и другие такие абстракции, например, семантику перемещения (move semantics).

На этапе компиляции кода Rust должен убедиться в том, что на каждый из ресурсов в программе в один и тот же момент времени существует только одна привязка (binding). Такое поведение компилятора исключает возможные утечки памяти и ошибки сегментации, а также возникновение состояния гонки данных в случае, если программа является многопоточной.

Еще одной из основных «абстракций с нулевой стоимостью» в Rust следует назвать принцип заимствования. Заимствование производится при помощи ссылок. Ссылка на тот или иной объект может быть изменяемой (mutable), или же неизменяемой (immutable). Каждый объект в Rust может иметь или одну изменяемую ссылку, или одну/несколько неизменяемых. Иная логика в программе приведет к ошибке на этапе компиляции, что вновь исключает возможные состояния гонки за данными.

Высокая надежность выполнения кода в многопоточных приложениях на Rust достигается также за счет особого подхода к примитивам синхронизации. Мьютекс в Rust является ресурсом, который обязательно содержит в себе защищаемое им значение, то есть, каждый мьютекс привязывается к конкретным данным. Однако, данный метод ориентирован на защиту участка кода программы, а не области памяти. В качестве альтернативного решения предлагается использовать транзакционную память, примитив синхронизации, ориентированный на защиту области памяти, а не участка кода.

1.2. Транзакционная память
Одним из перспективных решений для задачи организации доступа параллельных потоков к разделяемым данным, а также альтернативой алгоритмам, основанным на механизме блокировки, является транзакционная память. Транзакционная память предполагает выделение групп инструкций в атомарные транзакции, аналогичные транзакциям в базах данных.