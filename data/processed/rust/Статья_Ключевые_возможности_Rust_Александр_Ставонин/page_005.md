---
source_image: page_005.png
page_number: 5
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 18.23
tokens: 12724
characters: 5419
timestamp: 2025-12-23T22:42:47.528344
finish_reason: stop
---

Ключевые возможности Rust

Совместное использование потока
Хотя поток является однонаправленным механизмом передачи данных, это не приводит к необходимости создавать новый поток для каждого из желающих отправить данные, так как существует механизм, обеспечивающий работу в режиме «один-получатель-много-отправителей».

enum command {
    print_hello(uint),
    stop
}

...

let (server_chan, server_port) = stream(); // (2)
let (client_chan, client_port) = stream(); // (3)

do task::spawn { // (4)
    let mut hello_count = 0;
    let mut done = false;
    while !done {
        let req: command = server_chan.recv(); // (5)
        match req {
            print_hello(client_id) => {
                io::println(
                    fmt!("Hello from client #%u", client_id));
                hello_count += 1;
            }
            stop => {
                io::println("Stop command received");
                done = true;
            }
        }
    }
    client_port.send(hello_count); // (6)
}

let server_port = comm::SharedChan(server_port); // (7)
for uint::range(0, 5) |i| {
    let server_port = server_port.clone(); // (8)
    do task::spawn {
        server_port.send(print_hello(i)); // (9)
    }
}
server_port.send(stop);
io::println(fmt!("Result: %?", client_chan.recv()));

Для этого, как и для схемы «один-чтатель-один-писатель», необходимо создать серверный (2) и клиентский (3) потоки и запустить серверную задачу (3). Логика серверной задачи предельно проста: считать (5) данные из серверного канала, переданные клиентом (9), вывести сообщение о получении запроса на экран и отправить результирующее количество полученных запросов print_hello (5) в клиентский поток. Так как писателей несколько, то необходимо внести изменения в тип серверного порта, преобразовав (7) его к SharedChan вместо Chan, и для каждого из писателей создать уникальную копию порта (8) посредствам метода clone(). Дальнейшая работа с портом ничем не отличается от предыдущего примера: метод send() используется для отправки данных серверу (9) с той лишь разницей, что теперь данные отправляются из нескольких задач одновременно.

Кроме иллюстрации метода совместной работы с потоком, данный пример показывает способ отправки нескольких разных типов сообщений при помощи одного потока. Так как тип передаваемых потоком данных задается на этапе компиляции, для передачи данных разных типов необходимо либо воспользоваться сериализацией с последующей передачей бинарных данных (данный метод описан ниже в разделе «Пересылка объектов»), либо передавать перечисление (1). По своим свойствам перечисления в Rust похожи на объединения из языка С или тип Variant, в той или иной форме присутствующий почти во всех высокоуровневых языках программирования.

Пересылка объектов
В тех случаях, когда необходимость пересылать значения, адресуемые исключительно уникальными указателями, становится проблемой, на помощь приходит модуль flatpipes. Данный модуль позволяет отправлять и принимать любые бинарные данные в виде массива или объекты, поддерживающие сериализацию.

#[auto_encode] // (1)
#[auto_decode] // (2)
struct EncTest { val1: uint, val2: @str, val3: ~str }
...
let (server_chan, server_port) =
    flatpipes::serial::pipe_stream(); // (3)

do task::spawn {
    let val = server_chan.recv(); // (4)
    io::println(fmt!("Value: %?", val));
}

let value = @EncTest{val1: 1u, val2: @"test string 1",
    val3: ~"test string 2"};
server_port.send(value); // (5)

Как видно из примера, работать с flatpipes предельно просто. Структура, объекты которой будут передаваться посредством flatpipes, должна быть объявлена сериализуемой (1) и десериализуемой (2). Создание flatpipes (3) технически ничем не отличается от создания обычных потоков, так же как прием (4) и отправка (5) сообщений при помощи канала и порта. Главным же отличием flatpipes от потока является создание глубокой копии объекта на отправляющей стороне и построение нового объекта на принимающей стороне. Благодаря такому подходу, накладные расходы при работе с flatpipes, по сравнению с обычными потоками, возрастают, но возможности по пересылке данных между задачами увеличиваются.

Высокоуровневая абстракция обмена сообщениями
В большинстве приведенных выше примеров создаются два потока: один для отправки данных на сервер, второй для получения данных с сервера. Подобный подход не привносит какой-то ощутимой пользы да и просто замусоривает код. В связи с этим был создан модуль extra::comm, являющийся высокоуровневой абстракцией над std::comm и содержащий в себе DuplexStream, позволяющий организовать двунаправленное общение в рамках одного потока. Само собой, если заглянуть в исходный код DuplexStream, станет ясно, что это не более чем удобная надстройка над парой стандартных потоков.

let value = ~[1, 2, 3, 4, 5];
let (server, client) = DuplexStream(); // (1)

do task::spawn {
    let val: ~[uint] = server.recv(); // (2)
    io::println(fmt!("Value: %?", val));
    let res = val.map(|v| {v+1});
    server.send(res) // (3)
}

client.send(value); // (4)
io::println(fmt!("Result: %?", client.recv())); // (5)

При работе с DuplexStream создается (1) единственная пара из двух двунаправленных потоков, оба из которых могут использоваться как для отправки, так и для получения сообщений. Объект server захватывается контекстом задачи и используется для получения (2) и отправки (3) сообщений в задаче сервера, а объект client — в задаче клиента