---
source_image: page_002.png
page_number: 2
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 24.06
tokens: 12644
characters: 4825
timestamp: 2025-12-23T22:42:34.709645
finish_reason: stop
---

Ключевые возможности Rust

Рисунок 1

не совсем очевидных особенностей будет описана по мере необходимости, в процессе разбора основных возможностей Rust. В итоге статья посвящена описанию двух из трех основных возможностей языка: безопасной работе с памятью и написанию параллельных приложений. К сожалению, на момент написания статьи сетевая подсистема находилась в активной разработке, что делало включение описания работы с ней в статью совершенно бессмысленным.

Терминология
По большому счету, это одна из первых доступных статей, посвященных Rust, на русском языке, поэтому какой-либо устоявшейся русской терминологии нет и мне приходится брать наиболее подходящие эквиваленты, уже знакомые по другим языкам программирования. Для удобства дальнейшего чтения документации и статей на английском языке при первом появлении русскоязычного термина в скобках приводится английский эквивалент.
Наибольшее количество проблем вызвали термины Box и Pointer. По своим свойствам что Box, что Pointer больше всего напоминают умные указатели из C++, поэтому я решил использовать термин «указатели». Таким образом, Owned boxes превратились в Уникальные указатели, а Borrowed pointers во Временные указатели.

Работа с памятью
Принципы работы с памятью — это первая из ключевых возможностей Rust, которая выгодно отличает этот язык как от языков с полным доступом к памяти (типа C++), так и от языков с полным контролем за памятью со стороны GC (типа Java). Дело в том, что, с одной стороны, Rust предоставляет разработчику возможность контролировать, где размещать данные, вводя разделение по типам указателей и обеспечивая контроль за их использованием на этапе компиляции. С другой стороны, механизм подсчета ссылок, который в окончательной версии языка будет заменен полноценным GC, обеспечивает автоматическое управление ресурсами.
В Rust существует несколько типов указателей, адресующих объекты, размещенные в разных типах памяти, и подчиняющихся разным правилам:
• Разделяемые указатели (Managed boxes). Указывают на данные, размещенные в локальной куче (local heap) задачи; несколько разделяемых указателей могут адресовать один и тот же объект.
• Уникальные указатели (Owned boxes). Указывают на данные, размещенные в куче обмена (exchange heap), общей для всех задач; в одну единицу времени доступ к объекту может адресовать только один указатель (см. исключения из правила в разделе «Модуль ARC»).
• Временные указатели (Borrowed pointers). Универсальные указатели, имеющие возможность указывать на любой тип объекта: стековый, размещенный в локальной или обменной куче. В основном используются для написания универсального кода, работающего с данными в функциях, когда тип размещения объекта не важен.
• Немного сбоку находятся объекты, размещенные на стеке. Для их адресации не существует какого-либо выделенного типа указателя.
Схематически модель памяти Rust представлена на рисунке 1.

Использование стека
let x = Point {x: 1f, y: 1f}; // (1)
let y = x; // (2)
Так, код (1) разместит объект типа Point на стеке задачи, в которой будет вызван. При копировании подобного объекта (2) будет скопирован не указатель на объект x, а вся структура типа Point.
Для информации: переменные
Как можно увидеть из примера выше, ключевое слово let используется в Rust для создания переменных. По умолчанию все переменные константные и для создания изменяемой переменной необходимо добавлять ключевое слово mut. Таким образом, создание изменяемой переменной типа Point могло бы выглядеть следующим образом let mut x = Point {x: 1f, y: 1f};
Крайне важно помнить при работе с переменными, что константными оказываются именно данные, и за попытками изменить их «обманом» пристально следит компилятор.
let x = Point {x:1, y:2};
let y = Point {x:2, y:3};
let mut px = &x; // (1)
let py = &y;
px.x = 42; // (2)
px = py; // (3)
Так, вполне можно (1) создать изменяемую переменную, указывающую на константные данные, но вот попытка (2) изменить сами данные закончится ошибкой на этапе компиляции. А вот изменение значения переменной, хранящей адрес константного объекта Point и созданной ранее, является допустимым (3).
error: assigning to immutable field
px.x = 42;
~~~~~

Разделяемые указатели
Разделяемые указатели используются в качестве указателей на объекты, располагающиеся в локальной куче задачи. У каждой задачи есть собственная локальная куча, и указатели на расположенные в ней объекты никогда не могут быть переданы за ее пределы. Для создания разделяемых указателей используется унарный оператор @
let x = @Point {x: 1f, y: 1f};
В отличие от стековых объектов, при копировании копируется исключительно указатель, а не данные. Именно из этого свойства и пошло название данного типа указателей, так как поведение их очень похоже на shared_ptr из языка C++.
let y = x; // теперь x и y указывают на один и тот же объект типа Point