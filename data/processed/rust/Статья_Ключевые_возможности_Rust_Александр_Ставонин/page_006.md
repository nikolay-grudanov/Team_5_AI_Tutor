---
source_image: page_006.png
page_number: 6
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 16.90
tokens: 12845
characters: 5631
timestamp: 2025-12-23T22:42:51.705183
finish_reason: stop
---

(4,5). Принцип работы с DuplexStream ничем не отличается от работы с обычными потоками, но позволяет сократить количество вспомогательных объектов.

Модуль ARC
Несмотря на все прелести отправки сообщений, рано или поздно возникает вопрос: «А что делать с большой структурой данных, доступ к которой нужен из нескольких задач одновременно?» Конечно, ее можно пересылать в виде уникального указателя между потоками, но такой подход сильно затруднит разработку приложения, а его сопровождение превратится в настоящий кошмар. Именно для таких случаев и был создан модуль ARC, позволяющий организовать совместный доступ из нескольких задач к одному и тому же объекту.

Совместное использование уникальных указателей с доступом только на чтение
Сначала стоит разобраться с самым простым случаем — совместным доступом к неизменяемым данным из нескольких задач. Для решения подобной задачи необходимо воспользоваться модулем ARC, который реализует механизм автоматического подсчета ссылок (Atomically Reference-Counter) на разделяемый объект. В прототипе функции создания ARC-объекта fn ARC<T: Const + Owned>(data: T) -> ARC<T> стоит обратить внимание на налагаемые на тип T ограничения. Теперь объект должен относиться не только к классу Owned, как это было в случае с потоком, но еще и к классу Const, что гарантирует отсутствие каких бы то ни было изменяемых полей или указателей на изменяемые поля внутри объекта T (такие объекты в Rust носят название deeply immutable objects).

let data = arc::ARC([1, 2, 3, 4, 5]); // (1)
let shared_data = arc::clone(&data); // (2)
do task::spawn {
    let val = arc::get(&shared_data); // (3)
    io::println(fmt!("Value: %?", val[1]));
}
io::println(fmt!("Value: %?", *arc::get(&data))); // (4)

Пусть в данном примере нет работы с потоками, но он вполне достаточен для иллюстрации работы с ARC, так как наглядно демонстрирует основной функционал этого модуля — возможность одновременно обращаться к одним и тем же данным из разных задач. Так, для совместного использования одного и того же массива, обернутого в ARC (1), надо создать клон ARC обертки (2), что сделает возможным обращение к данным как из новой (3), так и из основной (4) задач.

R/W доступ к уникальным указателям
Модуль RWARC вызывает у меня двоякие эмоции. С одной стороны, благодаря RWARC можно реализовать широко распространенную и хорошо известную большинству разработчиков концепцию “много читателей один писатель”, что, наверное, хорошо, так как концепция широко известна. С другой стороны, совместный доступ к памяти, причем не RO доступ, который был описан чуть ранее, а RW доступ, чреват проблемами с взаимоблокировками, от которых Rust как раз и должен защитить разработчиков. Лично для себя я пришел к следующему выводу: о модуле знать надо, но использовать его без крайней необходимости не стоит.

let data = arc::RWARC([1, 2, 3, 4, 5]); // (1)
for 5.times {
    let reader = data.clone(); // (2)
    do task::spawn {
        do reader.read() |data| {
            io::println(fmt!("Value: %?", data)); // (3)
        }
    }
}
do spawn {
    do data.write() |data| {
        for data.each_mut |x| { *x = *x * 2 } // (6)
    }
}

В приведенном выше примере создается (1) массив, обернутый в RWARC, благодаря чему к нему можно обращаться как на чтение (4), так и на запись (6). Кардинальное отличие примера работы с RWARC от всех предыдущих примеров — использование замыканий в функциях read() (3) и write() (5) в качестве аргумента. Чтение и запись данных, обернутых в RWARC, можно производить только в этих функциях. И, как обычно, необходимо создать копию (2) объекта для доступа к нему из замыкания, так как в противном случае оригиналь станет недоступным.

Как такое вообще возможно?
Да, именно такой вопрос возникает после того, как узнаешь о том, что модули ARC и RWARC присутствуют в Rust. На первый взгляд они противоречат концепции работы с памятью в Rust в целом, и принципам работы уникальных указателей в частности. Не являясь создателем или разработчиком данного языка, я могу только лишь рассказать о том, благодаря чему подобное поведение возможно. В составе языка Rust имеется ключевое слово unsafe, позволяющее писать код, работающий с памятью напрямую, вызывать такие небезопасные с точки зрения управления памятью функции, как malloc, free, и использовать адресную арифметику. Именно эта возможность используется для обхода встроенной в Rust защиты памяти и обеспечения совместного доступа к одному и тому же объекту. Весь код, относящийся к данной функциональности, помечен как «COMPLETELY UNSAFE» и не должен использоваться конечными пользователями напрямую.

pipes
В составе библиотеки std появился новый модуль pipes. На момент написания статьи модуль производит ощущение очень сырого, которому еще предстоит претерпеть немало преобразований. Описание работы с ним я оставлю на потом, когда появится уверенность в стабильности интерфейсов.

Вместо заключения
Хотя прямо сейчас язык Rust не пригоден для промышленного использования, на мой взгляд, он обладает большим потенциалом. Очень может быть, что через несколько лет Rust сможет составить конкуренцию таким замечательным языкам-динозаврам, как C и C++, как минимум в областях, связанных с написанием сетевых и параллельных приложений. В крайнем случае, я очень на это надеюсь.
Что касается статьи, то считать ее законченной, скорее всего, нельзя: во-первых, синтаксис языка наверняка претерпит еще ряд изменений, а, во-вторых, должна завершиться работа над третей из ключевых возможностей языка — поддержкой сетевых взаимодействий. Как только эта функциональность придет в более или менее завершенное состояние, я обязательно о ней напишу.