---
source_image: page_004.png
page_number: 4
model: model-run-olm-ocr
prompt_type: olmocr_technical
processing_time: 27.97
tokens: 12849
characters: 5812
timestamp: 2025-12-23T22:42:38.590617
finish_reason: stop
---

указатель, который необходимо разыменовать (2) для доступа к данным:
do each([1, 2, 3]) |n| {
    io::println(int::to_str(*n));    // (2)
}
Так как do-синтаксис является синтаксическим сахаром, то запись ниже эквивалентна записи с использованием do-синтаксиса.
each([1, 2, 3], |n| {
    io::println(int::to_str(*n));
});

Запуск задачи на выполнение
Создать и выполнить задачу в Rust очень просто. Код, относящийся к работе с задачами, сосредоточен в модуле std::task, а простейшим способом создания и старта задачи является вызов функции spawn из этого модуля.
use std::task;
fn print_message() { println(fmt!("Task 1: %?", task::get_task())); }
fn main() {
    spawn(print_message);                // (1)
    spawn(|| println(
        fmt!("Task 2: %?", task::get_task())));   // (2)

    do spawn {
        println(fmt!("Task 3: %?", task::get_task()));   // (3)
    }
}

Функция spawn принимает замыкание в качестве аргумента и запускает его на выполнение в виде задачи (не стоит забывать о том, что задачи в Rust реализованы поверх зеленых потоков). Для того чтобы получить текущую задачу, в рамках которой выполняется код, можно воспользоваться методом get_task() из модуля task. С учетом того, что в рамках задачи выполняются замыкания, не сложно предложить 3 способа запустить задачу на выполнение: передав адрес функции (1), создав замыкание «на месте» (2) или, что более верно с точки зрения идеологии языка, воспользовавшись do-синтаксисом (3).

Взаимодействие между задачами
Модель памяти Rust, в общем случае, не допускает совместного обращения к одной и той же памяти из разных задач (shared memory model), предлагая вместо этого обмен сообщениями между задачами (mailbox model). При этом для нескольких задач существует возможность работать с общей памятью в режимах «только для чтения» и «один писатель много читателей». Для организации взаимодействия между задачами Rust предлагает следующие способы:
• Низкоуровневые каналы и порты из модуля std::comm;
• Высокоуровневая абстракция над каналами и портами extra::comm;
• Каналы, предназначенные для передачи бинарных данных из extra::flatpipes;
• Новая инфраструктура для обмена сообщениями std::pipes.

Обмен сообщениями на низком уровне
Самым широко используемым на данный момент способом взаимодействия между задачами является модуль std::comm. Код из std::comm хорошо отлажен, неплохо за- документирован и довольно прост в использовании. Основой механизма обмена сообщениями std::comm являются потоки, манипуляция с которыми происходит посредством каналов и портов. Поток представляет собой однонаправленный механизм связи, в котором порт используется для отправки сообщения, а канал — для приема отправленной информации. Простейший пример использования потока выглядит следующим образом:
let (chan, port) = stream();      // (1)
port.send("data");                 // (2)
// port.send(1);                    // (3)
io::println(chan.recv());          // (4)

В данном примере создается пара (1), состоящая из канала и порта, которые используются для отправки (2) строкового типа данных. Отдельное внимание стоит уделить прототипу функции stream(), который выглядит следующим образом: fn stream<T: Owned>() -> (Port<T>, Chan<T>). Как видно из прототипа, канал и порт являются шаблонными типами, что, на первый взгляд, неочевидно из кода, приведенного выше. В данном случае тип передаваемых данных выводится автоматически, основываясь на первом использовании. Так, если раскомментировать строку, отправляющую в поток единицу (3), компилятор выдаст сообщение об ошибке:
error: mismatched types: expected '&static str' but found '<VIO>'
(expected &'static str but found integral variable

Отдельного внимания заслуживает класс шаблонного параметра Owned, который означает возможность передачи при помощи потока только объектов, адресуемых при помощи уникальных указателей.

Для получения данных из потока можно воспользоваться функцией recv(), которая либо вернет данные, либо заблокирует задачу до их появления. Глядя на пример, приведенный выше, закрадывается подозрение, что он совершенно бесполезен, так как какого-то практического смысла в отправке сообщений при помощи потоков в рамках одной задачи нет. Так что стоит перейти к более практичным вещам, таким как использование потоков для передачи информации между задачами.
let value = vec::from_fn(5, |x| x + 1);      // (1)
let (server_chan, server_port) = stream();   // (2)
let (client_chan, client_port) = stream();   // (3)

do task::spawn {
    let val: ~[uint] = server_chan.recv();     // (4)
    let res = val.map(|v| {v+1});
    client_port.send(res)                      // (5)
}

server_port.send(value);                     // (6)
io::println(fmt!("Result: %?", client_chan.recv())); // (7)

Первое, на что стоит обратить внимание при работе с потоками, это необходимость передавать значения, адресуемые уникальными указателями, а функция from_fn() (1) как раз создает такой массив. Так как поток является однонаправленным, то для передачи запроса (2) и получения ответа (3) понадобятся два потока. При помощи функции recv() данныечитываются из потока (4), а при отсутствии таковых поток заблокирует задачу до их появления. Для отправки результата клиенту используется функция send() (5), принадлежащая не серверному, а клиентскому потоку; аналогичным образом необходимо поступить с данными для отправки серверной задаче: они записываются (6) при помощи функции send(), относящейся к серверному порту. В самом конце результат, переданный серверной задачей, считывается (7) из клиентского потока.

Таким образом, для отправки сообщений серверу и приема сообщений на стороне сервера используется поток server_chan, server_port. В силу однонаправленности потока, для получения результата вычислений сервера был создан клиентский поток, состоящий из пары client_chan, client_port.