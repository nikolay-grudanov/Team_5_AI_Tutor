# OCR Результаты: Книга_Python_К_вершинам_мастерства_Рамальо_Лучано

Модель: HunyuanOCR
Дата: 2025-12-20 05:53:11
================================================================================


────────────────────────────────────────────────────────────────────────────────
СТРАНИЦА 1
Файл: page_001.png
Время: 67.24с
Символов: 1469
────────────────────────────────────────────────────────────────────────────────

# ГЛАВА 10. Рубим, перемешиваем и нарезаем последовательности

Не проверяйте, утка ли это; проверяйте, что оно крякает, как утка, хо-дит, как утка и т. д. и т. п. – в зависимости от того, какая часть поведе-ния утки важна в ваших языковых игрищах (comp.lang.python, 26 июля 2000).

— Алекс Мартелли

В этой главе мы напишем класс vector для представления многомерного векто-ра – заметный шаг вперед по сравнению с классом двумерного вектора Vector2d из главы 9. Класс vector будет вести себя, как стандартная плоская неизменяемая последовательность в Python. Ее элементами будут числа с плавающей точкой, и окончательная версия будет поддерживать следующие возможности:

• базовый протокол последовательности: методы __len__ и __getitem__;

• безопасное представление экземпляров со многими элементами;

• поддержка операции среза, в результате которой получается новый экзем-пляр Vector;

• хэширование агрегата с учетом значений всех содержащихся в нем элемен-тов;

• расширение языка форматирования.

Мы также реализуем доступ к динамическим атрибутам с помощью метода __getattr__ – как замену доступных только для чтения свойств в классе Vector2d, – хотя для типов последовательностей такая функциональность нетипична.

Демонстрация кода будет прерываться обсуждением самой идеи протокола как неформального интерфейса. Мы поговорим о связи протоколов и динамической типизации, а также о ее практических следствиях для создания пользовательских типов.

Итак, начнем.


────────────────────────────────────────────────────────────────────────────────
СТРАНИЦА 2
Файл: page_002.png
Время: 25.12с
Символов: 2138
────────────────────────────────────────────────────────────────────────────────

306

Глава 10. Рубим, перемешиваем и нарезаем последовательности

---

## Где применяются векторы размерности выше 3

Кому нужен вектор с 1000 измерений? Подсказка: не 3D-дизайнерам! Тем не менее, *n*-мерные векторы (с большим значением *n*) широко используются в информационном поиске, где документы и тексты запро-сов представляются в виде векторов, по одному измерению на каждое слово. Это называется векторной моделью (*http://en.wikipedia.org/wiki/Vector_space_model*). В векторной модели в качестве основной меры ре-левантности используется коэффициент Отпан (косинус угла между вектором запроса и вектором документа). При уменьшении угла его косинусу стремится к максимальному значению 1, а вместе с ним и реле-вантность документа запроса.

Однако в этой главе класс *Vector* приведен только в педагогических целях, так что математики почти не будет. У нас более узкая задача – продемонстрировать специальные методы Python в контексте последо-вательностей.

Для выполнения серьезных математических операций над вектора-ми надобятся библиотеки NumPy и SciPy. В пакете gemsim (*https://pypi.python.org/pypi/gensim*) Радима Рехурека (Radim Rehurek) реали-зована векторная модель для обработки естественных языков и инфор-мационного поиска с использованием NumPy и SciPy.

## Vector: пользовательский тип последовательности

При реализации класса *vector* мы будем пользоваться не пасследованием, а компо-зицией. Компоненты вектора будут храниться в массиве *array* чисел с плавающей точкой, и мы напишем методы, необходимые для того, чтобы *Vector* вел себя, как неизменяемая плоская последовательность.

Но перед тем как приступать к методам последовательностей, разработаем ба-зовую реализацию класса *vector*, которая будет совместима с написанным ранее классом *Vector2d* – за исключением случаев, где говорить о совместимости не име-ет смысла.

## Vector, попытка № 1: совместимость с Vector2d

Первая версия *Vector* должна быть по возможности совместима с классом *Vector2d*.

Однако же конструктор *Vector* мы не станем делать совместимым. Можно было бы добиться работоспособности выражений *vector*(3, 4) и *Vector*(3, 4, 5),


────────────────────────────────────────────────────────────────────────────────
СТРАНИЦА 3
Файл: page_003.png
Время: 20.08с
Символов: 1741
────────────────────────────────────────────────────────────────────────────────

Vector, попытка № 1: совместимость с Vector2d

307

---

разрешив задавать произвольное число аргументов с помощью конструкции *args в методе __init__, но обычно конструктор последовательности принимает данные в виде итерируемого объекта – как все встроенные типы последовательностей. В примере 10.1 показано несколько способов создания объектов класса Vector.

Пример 10.1. Тесты методов Vector.__init__ и Vector.__repr__

>>> Vector([3.1, 4.2])
Vector([3.1, 4.2])
>>> Vector((3, 4, 5))
Vector([3.0, 4.0, 5.0])
>>> Vector(range(10))
Vector([0.0, 1.0, 2.0, 3.0, 4.0, ...])

Помимо сигнатуры конструктора, я включил тесты, которые проходили для Vector2d (например, Vector2d(3, 4)). Они должны проходить и для Vector и давать такие же результаты.

Если у вектора больше шести компонент, то вместо окончания строки, порожденной методом repr(), выводится ..., как в по-следней строке примера 10.1. Это существенно для любого типа коллекции, в котором может быть много элементов, потому что repr применяется для отладки (и вряд ли вам понравится, когда один объект занимает тысячи строк на консоли или в журнале). Для создания укороченных представлений используйте модуль reprlib, как в примере 10.2.

В Python 2 модуль reprlib называется repr. Программа 2to3 автоматически подменяет предложения импорта repr.

В примере 10.2 приведена реализация первой версии класса Vector (она основана на коде из примеров 9.2 и 9.3).

Пример 10.2. vector_v1.py: основана на vector2d_v1.py

from array import array
import reprlib
import math

class Vector:
    typecode = 'd'

    def __init__(self, components):
        self._components = array(self.typecode, components)

    def __iter__(self):
        return iter(self._components)

    def __repr__(self):


────────────────────────────────────────────────────────────────────────────────
СТРАНИЦА 4
Файл: page_004.png
Время: 70.19с
Символов: 1995
────────────────────────────────────────────────────────────────────────────────

308 Глава 10. Рубим, перемешиваем и нарезаем последовательности

---

components = reprlib.repr(self._components) ❶
components = components[components.find('['):-1] ❷
return 'Vector({})'.format(components)

def __str__(self):
    return str(tuple(self))

def __bytes__(self):
    return (bytes([ord(self.typecode)]) + bytes(self._components)) ❸

def __eq__(self, other):
    return tuple(self) == tuple(other)

def __abs__(self):
    return math.sqrt(sum(x * x for x in self)) ❹

def __bool__(self):
    return bool(abs(self))

@classmethod
def frombytes(cls, octets):
    typecode = chr(octets[0])
    memv = memoryview(octets[1:]).cast(typecode)
    return cls(memv) ❺

❶ В «защищенном» атрибуте экземпляра self._components хранится массив
array компонент Vector.

❷ Чтобы было возможно итерирование, возвращаем итератор, построенный
по self._components.¹

❸ Используем reprlib.repr() для получения представления self._compo-
nents ограниченной длины (например, array('d', [0.0, 1.0, 2.0, 3.0,
4.0, ...])).

❹ Удаляем префикс array('d' и закрывающую скобку ), перед тем как под-
ставить строку в вызов конструктора Vector.

❺ Строим объект bytes из self._components.

❻ Метод hypot больше не применим, поэтому вычисляем сумму квадратов
компонент и извлекаем из нее квадратный корень.

❼ Единственное отличие от написанного ранее метода frombytes – последняя
строка: мы передаем объект memoryview напрямую конструктору, не распа-
ковывая его с помощью *, как раньше.

То, как я использовал функцию reprlib.repr, заслуживает пояснения. Эта
функция порождает безопасное представление длинной или рекурсивной струк-
туры путем ограничения длины выходной строк с заменой отброшенного окон-
чания многоточиме '...'. Я хотел, чтобы repr-представление Vector имело вид
Vector([3.0, 4.0, 5.0]), а не Vector(array('d', [3.0, 4.0, 5.0])), потому что
присутствие array внутри Vector – деталь реализации. Поскольку оба вызова кон-

---
¹ Функция iter() рассматривается в главе 14 наряду с методом __iter__.


────────────────────────────────────────────────────────────────────────────────
СТРАНИЦА 5
Файл: page_005.png
Время: 28.20с
Символов: 2487
────────────────────────────────────────────────────────────────────────────────

структора возвращают одинаковые объекты Vector, я предпочел более простой синтаксис с использованием аргумента типа list.

При написании метода __repr__ я мог бы вывести упрощенное отображение components с помощью такого выражения: reprlib.repr(list(self.__components)). Но это было бы расчитательно, поскольку пришлось бы копировать каждый элемент self.__components в list только для того, чтобы использовать list repr. Вместо этого я решил применить reprlib.repr непосредственно к массиву self.__components, а затем отбросить все символы, оказавшиеся вне квадратных скобок []. Для этого и предназначена вторая строка метода __repr__ в примере 10.2.

Поскольку метод repr() вызывается во время отладки, он никогда не должен возбуждать исключение. Если в __repr__ происходит какая-то ошибка, вы должны обработать ее сами и сделать все возможное, чтобы показать пользователю нечто разумное, позволяющее идентифицировать объект.

Отметим, что методы __str__, __eq__ и __bool__ остались такими же, как в классе Vector2d, а в методе frombytes изменился только один символ (удален символ * в последней строке). Это воздаяние за то, что класс Vector2d изначально был сделан итерируемым.

Кстати, я мог бы сделать Vector подклассом Vector2d, но не стал по двум причинам. Во-первых, при наличии несовместимых конструкторов создавать подклассы не рекомендуется. Эту трудность можно было бы обойти за счет хитроумной обработки параметров в __init__, но есть и вторая, более важная, причина: я хочу, чтобы Vector был не зависящим от других классов примером реализации протокола последовательности. Этим мы и займемся далее, предварительно обсудив сам термином *протокол*.

# Протоколы и динамическая типизация

Еще в главе 1 мы видели, что для создания полнофункционального типа последовательности в Python необязательно последовать какому-то специальному классу; нужно лишь реализовать методы, удовлетворяющие протоколу последовательности. Но что это за протокол такой?

В объектно-ориентированном программировании протоколом называется неформальный интерфейс, определенный только в документации, но не в коде. Например, протокол последовательности в Python подразумевает только на-личие методов __len__ и __getitem__. Любой класс spam, в котором есть такие методы со стандартной сигнатурой и семантикой, можно использовать всюду, где ожидается последовательность. Является spam подклассом какого-то дру-гого класса или нет, роли не играет. Мы видели это в примере 1.1, который воспроизведен ниже.

