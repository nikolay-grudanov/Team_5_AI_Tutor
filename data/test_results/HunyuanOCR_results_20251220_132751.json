[
  {
    "model_name": "HunyuanOCR",
    "folder_name": "o-predelnom-mnogomernom-raspredelenii",
    "filename": "page_001.png",
    "page_number": 1,
    "text": "",
    "tokens": 0,
    "processing_time": 1.2515699863433838,
    "text_length": 0,
    "timestamp": "2025-12-20T13:24:20.144095",
    "error": "Error code: 400 - {'error': {'message': 'The decoder prompt (length 2121) is longer than the maximum model length of 2048. Make sure that `max_model_len` is no smaller than the number of text tokens plus multimodal tokens. For image inputs, the number of image tokens depends on the number of images, and possibly their aspect ratios as well.', 'type': 'BadRequestError', 'param': None, 'code': 400}}"
  },
  {
    "model_name": "HunyuanOCR",
    "folder_name": "o-predelnom-mnogomernom-raspredelenii",
    "filename": "page_002.png",
    "page_number": 2,
    "text": "",
    "tokens": 0,
    "processing_time": 0.11594152450561523,
    "text_length": 0,
    "timestamp": "2025-12-20T13:24:20.261194",
    "error": "Error code: 400 - {'error': {'message': 'The decoder prompt (length 2121) is longer than the maximum model length of 2048. Make sure that `max_model_len` is no smaller than the number of text tokens plus multimodal tokens. For image inputs, the number of image tokens depends on the number of images, and possibly their aspect ratios as well.', 'type': 'BadRequestError', 'param': None, 'code': 400}}"
  },
  {
    "model_name": "HunyuanOCR",
    "folder_name": "o-predelnom-mnogomernom-raspredelenii",
    "filename": "page_003.png",
    "page_number": 3,
    "text": "",
    "tokens": 0,
    "processing_time": 0.11529827117919922,
    "text_length": 0,
    "timestamp": "2025-12-20T13:24:20.377033",
    "error": "Error code: 400 - {'error': {'message': 'The decoder prompt (length 2121) is longer than the maximum model length of 2048. Make sure that `max_model_len` is no smaller than the number of text tokens plus multimodal tokens. For image inputs, the number of image tokens depends on the number of images, and possibly their aspect ratios as well.', 'type': 'BadRequestError', 'param': None, 'code': 400}}"
  },
  {
    "model_name": "HunyuanOCR",
    "folder_name": "o-predelnom-mnogomernom-raspredelenii",
    "filename": "page_004.png",
    "page_number": 4,
    "text": "",
    "tokens": 0,
    "processing_time": 0.12935566902160645,
    "text_length": 0,
    "timestamp": "2025-12-20T13:24:20.506649",
    "error": "Error code: 400 - {'error': {'message': 'The decoder prompt (length 2121) is longer than the maximum model length of 2048. Make sure that `max_model_len` is no smaller than the number of text tokens plus multimodal tokens. For image inputs, the number of image tokens depends on the number of images, and possibly their aspect ratios as well.', 'type': 'BadRequestError', 'param': None, 'code': 400}}"
  },
  {
    "model_name": "HunyuanOCR",
    "folder_name": "standartizatsiya-i-kachestvo-zhizni",
    "filename": "page_001.png",
    "page_number": 1,
    "text": "",
    "tokens": 0,
    "processing_time": 0.13147425651550293,
    "text_length": 0,
    "timestamp": "2025-12-20T13:24:20.638478",
    "error": "Error code: 400 - {'error': {'message': 'The decoder prompt (length 2215) is longer than the maximum model length of 2048. Make sure that `max_model_len` is no smaller than the number of text tokens plus multimodal tokens. For image inputs, the number of image tokens depends on the number of images, and possibly their aspect ratios as well.', 'type': 'BadRequestError', 'param': None, 'code': 400}}"
  },
  {
    "model_name": "HunyuanOCR",
    "folder_name": "standartizatsiya-i-kachestvo-zhizni",
    "filename": "page_002.png",
    "page_number": 2,
    "text": "",
    "tokens": 0,
    "processing_time": 0.12130069732666016,
    "text_length": 0,
    "timestamp": "2025-12-20T13:24:20.760308",
    "error": "Error code: 400 - {'error': {'message': 'The decoder prompt (length 2215) is longer than the maximum model length of 2048. Make sure that `max_model_len` is no smaller than the number of text tokens plus multimodal tokens. For image inputs, the number of image tokens depends on the number of images, and possibly their aspect ratios as well.', 'type': 'BadRequestError', 'param': None, 'code': 400}}"
  },
  {
    "model_name": "HunyuanOCR",
    "folder_name": "standartizatsiya-i-kachestvo-zhizni",
    "filename": "page_003.png",
    "page_number": 3,
    "text": "",
    "tokens": 0,
    "processing_time": 0.11747550964355469,
    "text_length": 0,
    "timestamp": "2025-12-20T13:24:20.878041",
    "error": "Error code: 400 - {'error': {'message': 'The decoder prompt (length 2215) is longer than the maximum model length of 2048. Make sure that `max_model_len` is no smaller than the number of text tokens plus multimodal tokens. For image inputs, the number of image tokens depends on the number of images, and possibly their aspect ratios as well.', 'type': 'BadRequestError', 'param': None, 'code': 400}}"
  },
  {
    "model_name": "HunyuanOCR",
    "folder_name": "Книга_Python_К_вершинам_мастерства_Рамальо_Лучано",
    "filename": "page_001.png",
    "page_number": 1,
    "text": "# ГЛАВА 10. Рубим, перемешиваем и нарезаем последовательности\n\nНе проверяйте, утка ли это; проверяйте, что оно крякает, как утка, хо-дит, как утка и т. д. и т. п. – в зависимости от того, какая часть поведе-ния утки важна в ваших языковых игрищах (comp.lang.python, 26 июля 2000).\n\n— Алекс Мартелли\n\nВ этой главе мы напишем класс vector для представления многомерного векто-ра – заметный шаг вперед по сравнению с классом двумерного вектора Vector2d из главы 9. Класс vector будет вести себя, как стандартная плоская неизменяемая последовательность в Python. Ее элементами будут числа с плавающей точкой, и окончательная версия будет поддерживать следующие возможности:\n\n• базовый протокол последовательности: методы __len__ и __getitem__;\n\n• безопасное представление экземпляров со многими элементами;\n\n• поддержка операции среза, в результате которой получается новый экзем-пляр Vector;\n\n• хэширование агрегата с учетом значений всех содержащихся в нем элемен-тов;\n\n• расширение языка форматирования.\n\nМы также реализуем доступ к динамическим атрибутам с помощью метода __getattr__ – как замену доступных только для чтения свойств в классе Vector2d, – хотя для типов последовательностей такая функциональность нетипична.\n\nДемонстрация кода будет прерываться обсуждением самой идеи протокола как неформального интерфейса. Мы поговорим о связи протоколов и динамической типизации, а также о ее практических следствиях для создания пользовательских типов.\n\nИтак, начнем.",
    "tokens": 1437,
    "processing_time": 67.3247332572937,
    "text_length": 1469,
    "timestamp": "2025-12-20T13:25:28.202816",
    "error": null
  },
  {
    "model_name": "HunyuanOCR",
    "folder_name": "Книга_Python_К_вершинам_мастерства_Рамальо_Лучано",
    "filename": "page_002.png",
    "page_number": 2,
    "text": "306\n\nГлава 10. Рубим, перемешиваем и нарезаем последовательности\n\n---\n\n## Где применяются векторы размерности выше 3\n\nКому нужен вектор с 1000 измерений? Подсказка: не 3D-дизайнерам! Тем не менее, *n*-мерные векторы (с большим значением *n*) широко используются в информационном поиске, где документы и тексты запро-сов представляются в виде векторов, по одному измерению на каждое слово. Это называется векторной моделью (*http://en.wikipedia.org/wiki/Vector_space_model*). В векторной модели в качестве основной меры ре-левантности используется коэффициент Отпан (косинус угла между вектором запроса и вектором документа). При уменьшении угла его косинусу стремится к максимальному значению 1, а вместе с ним и реле-вантность документа запроса.\n\nОднако в этой главе класс *Vector* приведен только в педагогических целях, так что математики почти не будет. У нас более узкая задача – продемонстрировать специальные методы Python в контексте последо-вательностей.\n\nДля выполнения серьезных математических операций над вектора-ми надобятся библиотеки NumPy и SciPy. В пакете gemsim (*https://pypi.python.org/pypi/gensim*) Радима Рехурека (Radim Rehurek) реали-зована векторная модель для обработки естественных языков и инфор-мационного поиска с использованием NumPy и SciPy.\n\n## Vector: пользовательский тип последовательности\n\nПри реализации класса *vector* мы будем пользоваться не пасследованием, а компо-зицией. Компоненты вектора будут храниться в массиве *array* чисел с плавающей точкой, и мы напишем методы, необходимые для того, чтобы *Vector* вел себя, как неизменяемая плоская последовательность.\n\nНо перед тем как приступать к методам последовательностей, разработаем ба-зовую реализацию класса *vector*, которая будет совместима с написанным ранее классом *Vector2d* – за исключением случаев, где говорить о совместимости не име-ет смысла.\n\n## Vector, попытка № 1: совместимость с Vector2d\n\nПервая версия *Vector* должна быть по возможности совместима с классом *Vector2d*.\n\nОднако же конструктор *Vector* мы не станем делать совместимым. Можно было бы добиться работоспособности выражений *vector*(3, 4) и *Vector*(3, 4, 5),",
    "tokens": 1683,
    "processing_time": 25.410834550857544,
    "text_length": 2138,
    "timestamp": "2025-12-20T13:25:53.613681",
    "error": null
  },
  {
    "model_name": "HunyuanOCR",
    "folder_name": "Книга_Python_К_вершинам_мастерства_Рамальо_Лучано",
    "filename": "page_003.png",
    "page_number": 3,
    "text": "Vector, попытка № 1: совместимость с Vector2d\n\n307\n\n---\n\nразрешив задавать произвольное число аргументов с помощью конструкции *args в методе __init__, но обычно конструктор последовательности принимает данные в виде итерируемого объекта – как все встроенные типы последовательностей. В примере 10.1 показано несколько способов создания объектов класса Vector.\n\nПример 10.1. Тесты методов Vector.__init__ и Vector.__repr__\n\n>>> Vector([3.1, 4.2])\nVector([3.1, 4.2])\n>>> Vector((3, 4, 5))\nVector([3.0, 4.0, 5.0])\n>>> Vector(range(10))\nVector([0.0, 1.0, 2.0, 3.0, 4.0, ...])\n\nПомимо сигнатуры конструктора, я включил тесты, которые проходили для Vector2d (например, Vector2d(3, 4)). Они должны проходить и для Vector и давать такие же результаты.\n\nЕсли у вектора больше шести компонент, то вместо окончания строки, порожденной методом repr(), выводится ..., как в по-следней строке примера 10.1. Это существенно для любого типа коллекции, в котором может быть много элементов, потому что repr применяется для отладки (и вряд ли вам понравится, когда один объект занимает тысячи строк на консоли или в журнале). Для создания укороченных представлений используйте модуль reprlib, как в примере 10.2.\n\nВ Python 2 модуль reprlib называется repr. Программа 2to3 автоматически подменяет предложения импорта repr.\n\nВ примере 10.2 приведена реализация первой версии класса Vector (она основана на коде из примеров 9.2 и 9.3).\n\nПример 10.2. vector_v1.py: основана на vector2d_v1.py\n\nfrom array import array\nimport reprlib\nimport math\n\nclass Vector:\n    typecode = 'd'\n\n    def __init__(self, components):\n        self._components = array(self.typecode, components)\n\n    def __iter__(self):\n        return iter(self._components)\n\n    def __repr__(self):",
    "tokens": 1525,
    "processing_time": 19.756669521331787,
    "text_length": 1741,
    "timestamp": "2025-12-20T13:26:13.370379",
    "error": null
  },
  {
    "model_name": "HunyuanOCR",
    "folder_name": "Книга_Python_К_вершинам_мастерства_Рамальо_Лучано",
    "filename": "page_004.png",
    "page_number": 4,
    "text": "308 Глава 10. Рубим, перемешиваем и нарезаем последовательности\n\n---\n\ncomponents = reprlib.repr(self._components) ❶\ncomponents = components[components.find('['):-1] ❷\nreturn 'Vector({})'.format(components)\n\ndef __str__(self):\n    return str(tuple(self))\n\ndef __bytes__(self):\n    return (bytes([ord(self.typecode)]) + bytes(self._components)) ❸\n\ndef __eq__(self, other):\n    return tuple(self) == tuple(other)\n\ndef __abs__(self):\n    return math.sqrt(sum(x * x for x in self)) ❹\n\ndef __bool__(self):\n    return bool(abs(self))\n\n@classmethod\ndef frombytes(cls, octets):\n    typecode = chr(octets[0])\n    memv = memoryview(octets[1:]).cast(typecode)\n    return cls(memv) ❺\n\n❶ В «защищенном» атрибуте экземпляра self._components хранится массив\narray компонент Vector.\n\n❷ Чтобы было возможно итерирование, возвращаем итератор, построенный\nпо self._components.¹\n\n❸ Используем reprlib.repr() для получения представления self._compo-\nnents ограниченной длины (например, array('d', [0.0, 1.0, 2.0, 3.0,\n4.0, ...])).\n\n❹ Удаляем префикс array('d' и закрывающую скобку ), перед тем как под-\nставить строку в вызов конструктора Vector.\n\n❺ Строим объект bytes из self._components.\n\n❻ Метод hypot больше не применим, поэтому вычисляем сумму квадратов\nкомпонент и извлекаем из нее квадратный корень.\n\n❼ Единственное отличие от написанного ранее метода frombytes – последняя\nстрока: мы передаем объект memoryview напрямую конструктору, не распа-\nковывая его с помощью *, как раньше.\n\nТо, как я использовал функцию reprlib.repr, заслуживает пояснения. Эта\nфункция порождает безопасное представление длинной или рекурсивной струк-\nтуры путем ограничения длины выходной строк с заменой отброшенного окон-\nчания многоточиме '...'. Я хотел, чтобы repr-представление Vector имело вид\nVector([3.0, 4.0, 5.0]), а не Vector(array('d', [3.0, 4.0, 5.0])), потому что\nприсутствие array внутри Vector – деталь реализации. Поскольку оба вызова кон-\n\n---\n¹ Функция iter() рассматривается в главе 14 наряду с методом __iter__.",
    "tokens": 1609,
    "processing_time": 69.89312958717346,
    "text_length": 1995,
    "timestamp": "2025-12-20T13:27:23.263540",
    "error": null
  },
  {
    "model_name": "HunyuanOCR",
    "folder_name": "Книга_Python_К_вершинам_мастерства_Рамальо_Лучано",
    "filename": "page_005.png",
    "page_number": 5,
    "text": "структора возвращают одинаковые объекты Vector, я предпочел более простой синтаксис с использованием аргумента типа list.\n\nПри написании метода __repr__ я мог бы вывести упрощенное отображение components с помощью такого выражения: reprlib.repr(list(self.__components)). Но это было бы расчитательно, поскольку пришлось бы копировать каждый элемент self.__components в list только для того, чтобы использовать list repr. Вместо этого я решил применить reprlib.repr непосредственно к массиву self.__components, а затем отбросить все символы, оказавшиеся вне квадратных скобок []. Для этого и предназначена вторая строка метода __repr__ в примере 10.2.\n\nПоскольку метод repr() вызывается во время отладки, он никогда не должен возбуждать исключение. Если в __repr__ происходит какая-то ошибка, вы должны обработать ее сами и сделать все возможное, чтобы показать пользователю нечто разумное, позволяющее идентифицировать объект.\n\nОтметим, что методы __str__, __eq__ и __bool__ остались такими же, как в классе Vector2d, а в методе frombytes изменился только один символ (удален символ * в последней строке). Это воздаяние за то, что класс Vector2d изначально был сделан итерируемым.\n\nКстати, я мог бы сделать Vector подклассом Vector2d, но не стал по двум причинам. Во-первых, при наличии несовместимых конструкторов создавать подклассы не рекомендуется. Эту трудность можно было бы обойти за счет хитроумной обработки параметров в __init__, но есть и вторая, более важная, причина: я хочу, чтобы Vector был не зависящим от других классов примером реализации протокола последовательности. Этим мы и займемся далее, предварительно обсудив сам термином *протокол*.\n\n# Протоколы и динамическая типизация\n\nЕще в главе 1 мы видели, что для создания полнофункционального типа последовательности в Python необязательно последовать какому-то специальному классу; нужно лишь реализовать методы, удовлетворяющие протоколу последовательности. Но что это за протокол такой?\n\nВ объектно-ориентированном программировании протоколом называется неформальный интерфейс, определенный только в документации, но не в коде. Например, протокол последовательности в Python подразумевает только на-личие методов __len__ и __getitem__. Любой класс spam, в котором есть такие методы со стандартной сигнатурой и семантикой, можно использовать всюду, где ожидается последовательность. Является spam подклассом какого-то дру-гого класса или нет, роли не играет. Мы видели это в примере 1.1, который воспроизведен ниже.",
    "tokens": 1750,
    "processing_time": 28.013123989105225,
    "text_length": 2487,
    "timestamp": "2025-12-20T13:27:51.276698",
    "error": null
  }
]